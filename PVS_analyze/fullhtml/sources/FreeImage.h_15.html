
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250" />
  <title>FreeImage.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// ==========================================================</a>
<a name="ln2">// FreeImage 3</a>
<a name="ln3">//</a>
<a name="ln4">// Design and implementation by</a>
<a name="ln5">// - Floris van den Berg (flvdberg@wxs.nl)</a>
<a name="ln6">// - Hervé Drolon (drolon@infonie.fr)</a>
<a name="ln7">//</a>
<a name="ln8">// Contributors:</a>
<a name="ln9">// - see changes log named 'Whatsnew.txt', see header of each .h and .cpp file</a>
<a name="ln10">//</a>
<a name="ln11">// This file is part of FreeImage 3</a>
<a name="ln12">//</a>
<a name="ln13">// COVERED CODE IS PROVIDED UNDER THIS LICENSE ON AN &quot;AS IS&quot; BASIS, WITHOUT WARRANTY</a>
<a name="ln14">// OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, WITHOUT LIMITATION, WARRANTIES</a>
<a name="ln15">// THAT THE COVERED CODE IS FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE</a>
<a name="ln16">// OR NON-INFRINGING. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE COVERED</a>
<a name="ln17">// CODE IS WITH YOU. SHOULD ANY COVERED CODE PROVE DEFECTIVE IN ANY RESPECT, YOU (NOT</a>
<a name="ln18">// THE INITIAL DEVELOPER OR ANY OTHER CONTRIBUTOR) ASSUME THE COST OF ANY NECESSARY</a>
<a name="ln19">// SERVICING, REPAIR OR CORRECTION. THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL</a>
<a name="ln20">// PART OF THIS LICENSE. NO USE OF ANY COVERED CODE IS AUTHORIZED HEREUNDER EXCEPT UNDER</a>
<a name="ln21">// THIS DISCLAIMER.</a>
<a name="ln22">//</a>
<a name="ln23">// Use at your own risk!</a>
<a name="ln24">// ==========================================================</a>
<a name="ln25"> </a>
<a name="ln26">#ifndef FREEIMAGE_H</a>
<a name="ln27">#define FREEIMAGE_H</a>
<a name="ln28"> </a>
<a name="ln29">// Version information ------------------------------------------------------</a>
<a name="ln30"> </a>
<a name="ln31">#define FREEIMAGE_MAJOR_VERSION   3</a>
<a name="ln32">#define FREEIMAGE_MINOR_VERSION   17</a>
<a name="ln33">#define FREEIMAGE_RELEASE_SERIAL  0</a>
<a name="ln34"> </a>
<a name="ln35">// Compiler options ---------------------------------------------------------</a>
<a name="ln36"> </a>
<a name="ln37">#include &lt;wchar.h&gt;	// needed for UNICODE functions</a>
<a name="ln38"> </a>
<a name="ln39">#if defined(FREEIMAGE_LIB)</a>
<a name="ln40">	#define DLL_API</a>
<a name="ln41">	#define DLL_CALLCONV</a>
<a name="ln42">#else</a>
<a name="ln43">	#if defined(_WIN32) || defined(__WIN32__)</a>
<a name="ln44">		#define DLL_CALLCONV __stdcall</a>
<a name="ln45">		// The following ifdef block is the standard way of creating macros which make exporting </a>
<a name="ln46">		// from a DLL simpler. All files within this DLL are compiled with the FREEIMAGE_EXPORTS</a>
<a name="ln47">		// symbol defined on the command line. this symbol should not be defined on any project</a>
<a name="ln48">		// that uses this DLL. This way any other project whose source files include this file see </a>
<a name="ln49">		// DLL_API functions as being imported from a DLL, wheras this DLL sees symbols</a>
<a name="ln50">		// defined with this macro as being exported.</a>
<a name="ln51">		#ifdef FREEIMAGE_EXPORTS</a>
<a name="ln52">			#define DLL_API __declspec(dllexport)</a>
<a name="ln53">		#else</a>
<a name="ln54">			#define DLL_API __declspec(dllimport)</a>
<a name="ln55">		#endif // FREEIMAGE_EXPORTS</a>
<a name="ln56">	#else </a>
<a name="ln57">		// try the gcc visibility support (see http://gcc.gnu.org/wiki/Visibility)</a>
<a name="ln58">		#if defined(__GNUC__) &amp;&amp; ((__GNUC__ &gt;= 4) || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 4))</a>
<a name="ln59">			#ifndef GCC_HASCLASSVISIBILITY</a>
<a name="ln60">				#define GCC_HASCLASSVISIBILITY</a>
<a name="ln61">			#endif</a>
<a name="ln62">		#endif // __GNUC__</a>
<a name="ln63">		#define DLL_CALLCONV</a>
<a name="ln64">		#if defined(GCC_HASCLASSVISIBILITY)</a>
<a name="ln65">			#define DLL_API __attribute__ ((visibility(&quot;default&quot;)))</a>
<a name="ln66">		#else</a>
<a name="ln67">			#define DLL_API</a>
<a name="ln68">		#endif		</a>
<a name="ln69">	#endif // WIN32 / !WIN32</a>
<a name="ln70">#endif // FREEIMAGE_LIB</a>
<a name="ln71"> </a>
<a name="ln72">// Endianness:</a>
<a name="ln73">// Some versions of gcc may have BYTE_ORDER or __BYTE_ORDER defined.</a>
<a name="ln74">// If your big endian system isn't being detected, add an OS specific check</a>
<a name="ln75">// or define any of FREEIMAGE_BIGENDIAN and FREEIMAGE_LITTLEENDIAN directly</a>
<a name="ln76">// to specify the desired endianness.</a>
<a name="ln77">#if (!defined(FREEIMAGE_BIGENDIAN) &amp;&amp; !defined(FREEIMAGE_LITTLEENDIAN))</a>
<a name="ln78">	#if (defined(BYTE_ORDER) &amp;&amp; BYTE_ORDER==BIG_ENDIAN) || (defined(__BYTE_ORDER) &amp;&amp; __BYTE_ORDER==__BIG_ENDIAN) || defined(__BIG_ENDIAN__)</a>
<a name="ln79">		#define FREEIMAGE_BIGENDIAN</a>
<a name="ln80">	#endif // BYTE_ORDER</a>
<a name="ln81">#endif // !FREEIMAGE_[BIG|LITTLE]ENDIAN</a>
<a name="ln82"> </a>
<a name="ln83">// Color-Order:</a>
<a name="ln84">// The specified order of color components red, green and blue affects 24-</a>
<a name="ln85">// and 32-bit images of type FIT_BITMAP as well as the colors that are part</a>
<a name="ln86">// of a color palette. All other images always use RGB order. By default,</a>
<a name="ln87">// color order is coupled to endianness:</a>
<a name="ln88">// little-endian -&gt; BGR</a>
<a name="ln89">// big-endian    -&gt; RGB</a>
<a name="ln90">// However, you can always define FREEIMAGE_COLORORDER to any of the known</a>
<a name="ln91">// orders FREEIMAGE_COLORORDER_BGR (0) and FREEIMAGE_COLORORDER_RGB (1) to</a>
<a name="ln92">// specify your preferred color order.</a>
<a name="ln93">#define FREEIMAGE_COLORORDER_BGR    0</a>
<a name="ln94">#define FREEIMAGE_COLORORDER_RGB    1</a>
<a name="ln95">#if (!defined(FREEIMAGE_COLORORDER)) || ((FREEIMAGE_COLORORDER != FREEIMAGE_COLORORDER_BGR) &amp;&amp; (FREEIMAGE_COLORORDER != FREEIMAGE_COLORORDER_RGB))</a>
<a name="ln96">	#if defined(FREEIMAGE_BIGENDIAN)</a>
<a name="ln97">		#define FREEIMAGE_COLORORDER FREEIMAGE_COLORORDER_RGB</a>
<a name="ln98">	#else</a>
<a name="ln99">		#define FREEIMAGE_COLORORDER FREEIMAGE_COLORORDER_BGR</a>
<a name="ln100">	#endif // FREEIMAGE_BIGENDIAN</a>
<a name="ln101">#endif // FREEIMAGE_COLORORDER</a>
<a name="ln102"> </a>
<a name="ln103">// Ensure 4-byte enums if we're using Borland C++ compilers</a>
<a name="ln104">#if defined(__BORLANDC__)</a>
<a name="ln105">#pragma option push -b</a>
<a name="ln106">#endif</a>
<a name="ln107"> </a>
<a name="ln108">// For C compatibility --------------------------------------------------------</a>
<a name="ln109"> </a>
<a name="ln110">#ifdef __cplusplus</a>
<a name="ln111">#define FI_DEFAULT(x)	= x</a>
<a name="ln112">#define FI_ENUM(x)      enum x</a>
<a name="ln113">#define FI_STRUCT(x)	struct x</a>
<a name="ln114">#else</a>
<a name="ln115">#define FI_DEFAULT(x)</a>
<a name="ln116">#define FI_ENUM(x)      typedef int x; enum x</a>
<a name="ln117">#define FI_STRUCT(x)	typedef struct x x; struct x</a>
<a name="ln118">#endif</a>
<a name="ln119"> </a>
<a name="ln120">// Bitmap types -------------------------------------------------------------</a>
<a name="ln121"> </a>
<a name="ln122">FI_STRUCT (FIBITMAP) { void *data; };</a>
<a name="ln123">FI_STRUCT (FIMULTIBITMAP) { void *data; };</a>
<a name="ln124"> </a>
<a name="ln125">// Types used in the library (directly copied from Windows) -----------------</a>
<a name="ln126"> </a>
<a name="ln127">#if defined(__MINGW32__) &amp;&amp; defined(_WINDOWS_H)</a>
<a name="ln128">#define _WINDOWS_	// prevent a bug in MinGW32</a>
<a name="ln129">#endif // __MINGW32__</a>
<a name="ln130"> </a>
<a name="ln131">#ifndef _WINDOWS_</a>
<a name="ln132">#define _WINDOWS_</a>
<a name="ln133"> </a>
<a name="ln134">#ifndef FALSE</a>
<a name="ln135">#define FALSE 0</a>
<a name="ln136">#endif</a>
<a name="ln137">#ifndef TRUE</a>
<a name="ln138">#define TRUE 1</a>
<a name="ln139">#endif</a>
<a name="ln140">#ifndef NULL</a>
<a name="ln141">#define NULL 0</a>
<a name="ln142">#endif</a>
<a name="ln143"> </a>
<a name="ln144">#ifndef SEEK_SET</a>
<a name="ln145">#define SEEK_SET  0</a>
<a name="ln146">#define SEEK_CUR  1</a>
<a name="ln147">#define SEEK_END  2</a>
<a name="ln148">#endif</a>
<a name="ln149"> </a>
<a name="ln150">#ifndef _MSC_VER</a>
<a name="ln151">// define portable types for 32-bit / 64-bit OS</a>
<a name="ln152">#include &lt;inttypes.h&gt;</a>
<a name="ln153">typedef int32_t BOOL;</a>
<a name="ln154">typedef uint8_t BYTE;</a>
<a name="ln155">typedef uint16_t WORD;</a>
<a name="ln156">typedef uint32_t DWORD;</a>
<a name="ln157">typedef int32_t LONG;</a>
<a name="ln158">typedef int64_t INT64;</a>
<a name="ln159">typedef uint64_t UINT64;</a>
<a name="ln160">#else</a>
<a name="ln161">// MS is not C99 ISO compliant</a>
<a name="ln162">typedef long BOOL;</a>
<a name="ln163">typedef unsigned char BYTE;</a>
<a name="ln164">typedef unsigned short WORD;</a>
<a name="ln165">typedef unsigned long DWORD;</a>
<a name="ln166">typedef long LONG;</a>
<a name="ln167">typedef signed __int64 INT64;</a>
<a name="ln168">typedef unsigned __int64 UINT64;</a>
<a name="ln169">#endif // _MSC_VER</a>
<a name="ln170"> </a>
<a name="ln171">#if (defined(_WIN32) || defined(__WIN32__))</a>
<a name="ln172">#pragma pack(push, 1)</a>
<a name="ln173">#else</a>
<a name="ln174">#pragma pack(1)</a>
<a name="ln175">#endif // WIN32</a>
<a name="ln176"> </a>
<a name="ln177">typedef struct tagRGBQUAD {</a>
<a name="ln178">#if FREEIMAGE_COLORORDER == FREEIMAGE_COLORORDER_BGR</a>
<a name="ln179">  BYTE rgbBlue;</a>
<a name="ln180">  BYTE rgbGreen;</a>
<a name="ln181">  BYTE rgbRed;</a>
<a name="ln182">#else</a>
<a name="ln183">  BYTE rgbRed;</a>
<a name="ln184">  BYTE rgbGreen;</a>
<a name="ln185">  BYTE rgbBlue;</a>
<a name="ln186">#endif // FREEIMAGE_COLORORDER</a>
<a name="ln187">  BYTE rgbReserved;</a>
<a name="ln188">} RGBQUAD;</a>
<a name="ln189"> </a>
<a name="ln190">typedef struct tagRGBTRIPLE {</a>
<a name="ln191">#if FREEIMAGE_COLORORDER == FREEIMAGE_COLORORDER_BGR</a>
<a name="ln192">  BYTE rgbtBlue;</a>
<a name="ln193">  BYTE rgbtGreen;</a>
<a name="ln194">  BYTE rgbtRed;</a>
<a name="ln195">#else</a>
<a name="ln196">  BYTE rgbtRed;</a>
<a name="ln197">  BYTE rgbtGreen;</a>
<a name="ln198">  BYTE rgbtBlue;</a>
<a name="ln199">#endif // FREEIMAGE_COLORORDER</a>
<a name="ln200">} RGBTRIPLE;</a>
<a name="ln201"> </a>
<a name="ln202">#if (defined(_WIN32) || defined(__WIN32__))</a>
<a name="ln203">#pragma pack(pop)</a>
<a name="ln204">#else</a>
<a name="ln205">#pragma pack()</a>
<a name="ln206">#endif // WIN32</a>
<a name="ln207"> </a>
<a name="ln208">typedef struct tagBITMAPINFOHEADER{</a>
<a name="ln209">  DWORD biSize;</a>
<a name="ln210">  LONG  biWidth; </a>
<a name="ln211">  LONG  biHeight; </a>
<a name="ln212">  WORD  biPlanes; </a>
<a name="ln213">  WORD  biBitCount;</a>
<a name="ln214">  DWORD biCompression; </a>
<a name="ln215">  DWORD biSizeImage; </a>
<a name="ln216">  LONG  biXPelsPerMeter; </a>
<a name="ln217">  LONG  biYPelsPerMeter; </a>
<a name="ln218">  DWORD biClrUsed; </a>
<a name="ln219">  DWORD biClrImportant;</a>
<a name="ln220">} BITMAPINFOHEADER, *PBITMAPINFOHEADER; </a>
<a name="ln221"> </a>
<a name="ln222">typedef struct tagBITMAPINFO { </a>
<a name="ln223">  BITMAPINFOHEADER bmiHeader; </a>
<a name="ln224">  RGBQUAD          bmiColors[1];</a>
<a name="ln225">} BITMAPINFO, *PBITMAPINFO;</a>
<a name="ln226"> </a>
<a name="ln227">#endif // _WINDOWS_</a>
<a name="ln228"> </a>
<a name="ln229">// Types used in the library (specific to FreeImage) ------------------------</a>
<a name="ln230"> </a>
<a name="ln231">#if (defined(_WIN32) || defined(__WIN32__))</a>
<a name="ln232">#pragma pack(push, 1)</a>
<a name="ln233">#else</a>
<a name="ln234">#pragma pack(1)</a>
<a name="ln235">#endif // WIN32</a>
<a name="ln236"> </a>
<a name="ln237">/** 48-bit RGB </a>
<a name="ln238">*/</a>
<a name="ln239">typedef struct tagFIRGB16 {</a>
<a name="ln240">	WORD red;</a>
<a name="ln241">	WORD green;</a>
<a name="ln242">	WORD blue;</a>
<a name="ln243">} FIRGB16;</a>
<a name="ln244"> </a>
<a name="ln245">/** 64-bit RGBA</a>
<a name="ln246">*/</a>
<a name="ln247">typedef struct tagFIRGBA16 {</a>
<a name="ln248">	WORD red;</a>
<a name="ln249">	WORD green;</a>
<a name="ln250">	WORD blue;</a>
<a name="ln251">	WORD alpha;</a>
<a name="ln252">} FIRGBA16;</a>
<a name="ln253"> </a>
<a name="ln254">/** 96-bit RGB Float</a>
<a name="ln255">*/</a>
<a name="ln256">typedef struct tagFIRGBF {</a>
<a name="ln257">	float red;</a>
<a name="ln258">	float green;</a>
<a name="ln259">	float blue;</a>
<a name="ln260">} FIRGBF;</a>
<a name="ln261"> </a>
<a name="ln262">/** 128-bit RGBA Float</a>
<a name="ln263">*/</a>
<a name="ln264">typedef struct tagFIRGBAF {</a>
<a name="ln265">	float red;</a>
<a name="ln266">	float green;</a>
<a name="ln267">	float blue;</a>
<a name="ln268">	float alpha;</a>
<a name="ln269">} FIRGBAF;</a>
<a name="ln270"> </a>
<a name="ln271">/** Data structure for COMPLEX type (complex number)</a>
<a name="ln272">*/</a>
<a name="ln273">typedef struct tagFICOMPLEX {</a>
<a name="ln274">    /// real part</a>
<a name="ln275">	double r;</a>
<a name="ln276">	/// imaginary part</a>
<a name="ln277">    double i;</a>
<a name="ln278">} FICOMPLEX;</a>
<a name="ln279"> </a>
<a name="ln280">#if (defined(_WIN32) || defined(__WIN32__))</a>
<a name="ln281">#pragma pack(pop)</a>
<a name="ln282">#else</a>
<a name="ln283">#pragma pack()</a>
<a name="ln284">#endif // WIN32</a>
<a name="ln285"> </a>
<a name="ln286">// Indexes for byte arrays, masks and shifts for treating pixels as words ---</a>
<a name="ln287">// These coincide with the order of RGBQUAD and RGBTRIPLE -------------------</a>
<a name="ln288"> </a>
<a name="ln289">#ifndef FREEIMAGE_BIGENDIAN</a>
<a name="ln290">#if FREEIMAGE_COLORORDER == FREEIMAGE_COLORORDER_BGR</a>
<a name="ln291">// Little Endian (x86 / MS Windows, Linux) : BGR(A) order</a>
<a name="ln292">#define FI_RGBA_RED				2</a>
<a name="ln293">#define FI_RGBA_GREEN			1</a>
<a name="ln294">#define FI_RGBA_BLUE			0</a>
<a name="ln295">#define FI_RGBA_ALPHA			3</a>
<a name="ln296">#define FI_RGBA_RED_MASK		0x00FF0000</a>
<a name="ln297">#define FI_RGBA_GREEN_MASK		0x0000FF00</a>
<a name="ln298">#define FI_RGBA_BLUE_MASK		0x000000FF</a>
<a name="ln299">#define FI_RGBA_ALPHA_MASK		0xFF000000</a>
<a name="ln300">#define FI_RGBA_RED_SHIFT		16</a>
<a name="ln301">#define FI_RGBA_GREEN_SHIFT		8</a>
<a name="ln302">#define FI_RGBA_BLUE_SHIFT		0</a>
<a name="ln303">#define FI_RGBA_ALPHA_SHIFT		24</a>
<a name="ln304">#else</a>
<a name="ln305">// Little Endian (x86 / MaxOSX) : RGB(A) order</a>
<a name="ln306">#define FI_RGBA_RED				0</a>
<a name="ln307">#define FI_RGBA_GREEN			1</a>
<a name="ln308">#define FI_RGBA_BLUE			2</a>
<a name="ln309">#define FI_RGBA_ALPHA			3</a>
<a name="ln310">#define FI_RGBA_RED_MASK		0x000000FF</a>
<a name="ln311">#define FI_RGBA_GREEN_MASK		0x0000FF00</a>
<a name="ln312">#define FI_RGBA_BLUE_MASK		0x00FF0000</a>
<a name="ln313">#define FI_RGBA_ALPHA_MASK		0xFF000000</a>
<a name="ln314">#define FI_RGBA_RED_SHIFT		0</a>
<a name="ln315">#define FI_RGBA_GREEN_SHIFT		8</a>
<a name="ln316">#define FI_RGBA_BLUE_SHIFT		16</a>
<a name="ln317">#define FI_RGBA_ALPHA_SHIFT		24</a>
<a name="ln318">#endif // FREEIMAGE_COLORORDER</a>
<a name="ln319">#else</a>
<a name="ln320">#if FREEIMAGE_COLORORDER == FREEIMAGE_COLORORDER_BGR</a>
<a name="ln321">// Big Endian (PPC / none) : BGR(A) order</a>
<a name="ln322">#define FI_RGBA_RED				2</a>
<a name="ln323">#define FI_RGBA_GREEN			1</a>
<a name="ln324">#define FI_RGBA_BLUE			0</a>
<a name="ln325">#define FI_RGBA_ALPHA			3</a>
<a name="ln326">#define FI_RGBA_RED_MASK		0x0000FF00</a>
<a name="ln327">#define FI_RGBA_GREEN_MASK		0x00FF0000</a>
<a name="ln328">#define FI_RGBA_BLUE_MASK		0xFF000000</a>
<a name="ln329">#define FI_RGBA_ALPHA_MASK		0x000000FF</a>
<a name="ln330">#define FI_RGBA_RED_SHIFT		8</a>
<a name="ln331">#define FI_RGBA_GREEN_SHIFT		16</a>
<a name="ln332">#define FI_RGBA_BLUE_SHIFT		24</a>
<a name="ln333">#define FI_RGBA_ALPHA_SHIFT		0</a>
<a name="ln334">#else</a>
<a name="ln335">// Big Endian (PPC / Linux, MaxOSX) : RGB(A) order</a>
<a name="ln336">#define FI_RGBA_RED				0</a>
<a name="ln337">#define FI_RGBA_GREEN			1</a>
<a name="ln338">#define FI_RGBA_BLUE			2</a>
<a name="ln339">#define FI_RGBA_ALPHA			3</a>
<a name="ln340">#define FI_RGBA_RED_MASK		0xFF000000</a>
<a name="ln341">#define FI_RGBA_GREEN_MASK		0x00FF0000</a>
<a name="ln342">#define FI_RGBA_BLUE_MASK		0x0000FF00</a>
<a name="ln343">#define FI_RGBA_ALPHA_MASK		0x000000FF</a>
<a name="ln344">#define FI_RGBA_RED_SHIFT		24</a>
<a name="ln345">#define FI_RGBA_GREEN_SHIFT		16</a>
<a name="ln346">#define FI_RGBA_BLUE_SHIFT		8</a>
<a name="ln347">#define FI_RGBA_ALPHA_SHIFT		0</a>
<a name="ln348">#endif // FREEIMAGE_COLORORDER</a>
<a name="ln349">#endif // FREEIMAGE_BIGENDIAN</a>
<a name="ln350"> </a>
<a name="ln351">#define FI_RGBA_RGB_MASK		(FI_RGBA_RED_MASK|FI_RGBA_GREEN_MASK|FI_RGBA_BLUE_MASK)</a>
<a name="ln352"> </a>
<a name="ln353">// The 16bit macros only include masks and shifts, since each color element is not byte aligned</a>
<a name="ln354"> </a>
<a name="ln355">#define FI16_555_RED_MASK		0x7C00</a>
<a name="ln356">#define FI16_555_GREEN_MASK		0x03E0</a>
<a name="ln357">#define FI16_555_BLUE_MASK		0x001F</a>
<a name="ln358">#define FI16_555_RED_SHIFT		10</a>
<a name="ln359">#define FI16_555_GREEN_SHIFT	5</a>
<a name="ln360">#define FI16_555_BLUE_SHIFT		0</a>
<a name="ln361">#define FI16_565_RED_MASK		0xF800</a>
<a name="ln362">#define FI16_565_GREEN_MASK		0x07E0</a>
<a name="ln363">#define FI16_565_BLUE_MASK		0x001F</a>
<a name="ln364">#define FI16_565_RED_SHIFT		11</a>
<a name="ln365">#define FI16_565_GREEN_SHIFT	5</a>
<a name="ln366">#define FI16_565_BLUE_SHIFT		0</a>
<a name="ln367"> </a>
<a name="ln368">// ICC profile support ------------------------------------------------------</a>
<a name="ln369"> </a>
<a name="ln370">#define FIICC_DEFAULT			0x00</a>
<a name="ln371">#define FIICC_COLOR_IS_CMYK		0x01</a>
<a name="ln372"> </a>
<a name="ln373">FI_STRUCT (FIICCPROFILE) { </a>
<a name="ln374">	WORD    flags;	//! info flag</a>
<a name="ln375">	DWORD	size;	//! profile's size measured in bytes</a>
<a name="ln376">	void   *data;	//! points to a block of contiguous memory containing the profile</a>
<a name="ln377">};</a>
<a name="ln378"> </a>
<a name="ln379">// Important enums ----------------------------------------------------------</a>
<a name="ln380"> </a>
<a name="ln381">/** I/O image format identifiers.</a>
<a name="ln382">*/</a>
<a name="ln383">FI_ENUM(FREE_IMAGE_FORMAT) {</a>
<a name="ln384">	FIF_UNKNOWN = -1,</a>
<a name="ln385">	FIF_BMP		= 0,</a>
<a name="ln386">	FIF_ICO		= 1,</a>
<a name="ln387">	FIF_JPEG	= 2,</a>
<a name="ln388">	FIF_JNG		= 3,</a>
<a name="ln389">	FIF_KOALA	= 4,</a>
<a name="ln390">	FIF_LBM		= 5,</a>
<a name="ln391">	FIF_IFF = FIF_LBM,</a>
<a name="ln392">	FIF_MNG		= 6,</a>
<a name="ln393">	FIF_PBM		= 7,</a>
<a name="ln394">	FIF_PBMRAW	= 8,</a>
<a name="ln395">	FIF_PCD		= 9,</a>
<a name="ln396">	FIF_PCX		= 10,</a>
<a name="ln397">	FIF_PGM		= 11,</a>
<a name="ln398">	FIF_PGMRAW	= 12,</a>
<a name="ln399">	FIF_PNG		= 13,</a>
<a name="ln400">	FIF_PPM		= 14,</a>
<a name="ln401">	FIF_PPMRAW	= 15,</a>
<a name="ln402">	FIF_RAS		= 16,</a>
<a name="ln403">	FIF_TARGA	= 17,</a>
<a name="ln404">	FIF_TIFF	= 18,</a>
<a name="ln405">	FIF_WBMP	= 19,</a>
<a name="ln406">	FIF_PSD		= 20,</a>
<a name="ln407">	FIF_CUT		= 21,</a>
<a name="ln408">	FIF_XBM		= 22,</a>
<a name="ln409">	FIF_XPM		= 23,</a>
<a name="ln410">	FIF_DDS		= 24,</a>
<a name="ln411">	FIF_GIF     = 25,</a>
<a name="ln412">	FIF_HDR		= 26,</a>
<a name="ln413">	FIF_FAXG3	= 27,</a>
<a name="ln414">	FIF_SGI		= 28,</a>
<a name="ln415">	FIF_EXR		= 29,</a>
<a name="ln416">	FIF_J2K		= 30,</a>
<a name="ln417">	FIF_JP2		= 31,</a>
<a name="ln418">	FIF_PFM		= 32,</a>
<a name="ln419">	FIF_PICT	= 33,</a>
<a name="ln420">	FIF_RAW		= 34,</a>
<a name="ln421">	FIF_WEBP	= 35,</a>
<a name="ln422">	FIF_JXR		= 36</a>
<a name="ln423">};</a>
<a name="ln424"> </a>
<a name="ln425">/** Image type used in FreeImage.</a>
<a name="ln426">*/</a>
<a name="ln427">FI_ENUM(FREE_IMAGE_TYPE) {</a>
<a name="ln428">	FIT_UNKNOWN = 0,	//! unknown type</a>
<a name="ln429">	FIT_BITMAP  = 1,	//! standard image			: 1-, 4-, 8-, 16-, 24-, 32-bit</a>
<a name="ln430">	FIT_UINT16	= 2,	//! array of unsigned short	: unsigned 16-bit</a>
<a name="ln431">	FIT_INT16	= 3,	//! array of short			: signed 16-bit</a>
<a name="ln432">	FIT_UINT32	= 4,	//! array of unsigned long	: unsigned 32-bit</a>
<a name="ln433">	FIT_INT32	= 5,	//! array of long			: signed 32-bit</a>
<a name="ln434">	FIT_FLOAT	= 6,	//! array of float			: 32-bit IEEE floating point</a>
<a name="ln435">	FIT_DOUBLE	= 7,	//! array of double			: 64-bit IEEE floating point</a>
<a name="ln436">	FIT_COMPLEX	= 8,	//! array of FICOMPLEX		: 2 x 64-bit IEEE floating point</a>
<a name="ln437">	FIT_RGB16	= 9,	//! 48-bit RGB image			: 3 x 16-bit</a>
<a name="ln438">	FIT_RGBA16	= 10,	//! 64-bit RGBA image		: 4 x 16-bit</a>
<a name="ln439">	FIT_RGBF	= 11,	//! 96-bit RGB float image	: 3 x 32-bit IEEE floating point</a>
<a name="ln440">	FIT_RGBAF	= 12	//! 128-bit RGBA float image	: 4 x 32-bit IEEE floating point</a>
<a name="ln441">};</a>
<a name="ln442"> </a>
<a name="ln443">/** Image color type used in FreeImage.</a>
<a name="ln444">*/</a>
<a name="ln445">FI_ENUM(FREE_IMAGE_COLOR_TYPE) {</a>
<a name="ln446">	FIC_MINISWHITE = 0,		//! min value is white</a>
<a name="ln447">    FIC_MINISBLACK = 1,		//! min value is black</a>
<a name="ln448">    FIC_RGB        = 2,		//! RGB color model</a>
<a name="ln449">    FIC_PALETTE    = 3,		//! color map indexed</a>
<a name="ln450">	FIC_RGBALPHA   = 4,		//! RGB color model with alpha channel</a>
<a name="ln451">	FIC_CMYK       = 5		//! CMYK color model</a>
<a name="ln452">};</a>
<a name="ln453"> </a>
<a name="ln454">/** Color quantization algorithms.</a>
<a name="ln455">Constants used in FreeImage_ColorQuantize.</a>
<a name="ln456">*/</a>
<a name="ln457">FI_ENUM(FREE_IMAGE_QUANTIZE) {</a>
<a name="ln458">    FIQ_WUQUANT = 0,		//! Xiaolin Wu color quantization algorithm</a>
<a name="ln459">    FIQ_NNQUANT = 1,		//! NeuQuant neural-net quantization algorithm by Anthony Dekker</a>
<a name="ln460">	FIQ_LFPQUANT = 2		//! Lossless Fast Pseudo-Quantization Algorithm by Carsten Klein</a>
<a name="ln461">};</a>
<a name="ln462"> </a>
<a name="ln463">/** Dithering algorithms.</a>
<a name="ln464">Constants used in FreeImage_Dither.</a>
<a name="ln465">*/</a>
<a name="ln466">FI_ENUM(FREE_IMAGE_DITHER) {</a>
<a name="ln467">    FID_FS			= 0,	//! Floyd &amp; Steinberg error diffusion</a>
<a name="ln468">	FID_BAYER4x4	= 1,	//! Bayer ordered dispersed dot dithering (order 2 dithering matrix)</a>
<a name="ln469">	FID_BAYER8x8	= 2,	//! Bayer ordered dispersed dot dithering (order 3 dithering matrix)</a>
<a name="ln470">	FID_CLUSTER6x6	= 3,	//! Ordered clustered dot dithering (order 3 - 6x6 matrix)</a>
<a name="ln471">	FID_CLUSTER8x8	= 4,	//! Ordered clustered dot dithering (order 4 - 8x8 matrix)</a>
<a name="ln472">	FID_CLUSTER16x16= 5,	//! Ordered clustered dot dithering (order 8 - 16x16 matrix)</a>
<a name="ln473">	FID_BAYER16x16	= 6		//! Bayer ordered dispersed dot dithering (order 4 dithering matrix)</a>
<a name="ln474">};</a>
<a name="ln475"> </a>
<a name="ln476">/** Lossless JPEG transformations</a>
<a name="ln477">Constants used in FreeImage_JPEGTransform</a>
<a name="ln478">*/</a>
<a name="ln479">FI_ENUM(FREE_IMAGE_JPEG_OPERATION) {</a>
<a name="ln480">	FIJPEG_OP_NONE			= 0,	//! no transformation</a>
<a name="ln481">	FIJPEG_OP_FLIP_H		= 1,	//! horizontal flip</a>
<a name="ln482">	FIJPEG_OP_FLIP_V		= 2,	//! vertical flip</a>
<a name="ln483">	FIJPEG_OP_TRANSPOSE		= 3,	//! transpose across UL-to-LR axis</a>
<a name="ln484">	FIJPEG_OP_TRANSVERSE	= 4,	//! transpose across UR-to-LL axis</a>
<a name="ln485">	FIJPEG_OP_ROTATE_90		= 5,	//! 90-degree clockwise rotation</a>
<a name="ln486">	FIJPEG_OP_ROTATE_180	= 6,	//! 180-degree rotation</a>
<a name="ln487">	FIJPEG_OP_ROTATE_270	= 7		//! 270-degree clockwise (or 90 ccw)</a>
<a name="ln488">};</a>
<a name="ln489"> </a>
<a name="ln490">/** Tone mapping operators.</a>
<a name="ln491">Constants used in FreeImage_ToneMapping.</a>
<a name="ln492">*/</a>
<a name="ln493">FI_ENUM(FREE_IMAGE_TMO) {</a>
<a name="ln494">    FITMO_DRAGO03	 = 0,	//! Adaptive logarithmic mapping (F. Drago, 2003)</a>
<a name="ln495">	FITMO_REINHARD05 = 1,	//! Dynamic range reduction inspired by photoreceptor physiology (E. Reinhard, 2005)</a>
<a name="ln496">	FITMO_FATTAL02	 = 2	//! Gradient domain high dynamic range compression (R. Fattal, 2002)</a>
<a name="ln497">};</a>
<a name="ln498"> </a>
<a name="ln499">/** Upsampling / downsampling filters. </a>
<a name="ln500">Constants used in FreeImage_Rescale.</a>
<a name="ln501">*/</a>
<a name="ln502">FI_ENUM(FREE_IMAGE_FILTER) {</a>
<a name="ln503">	FILTER_BOX		  = 0,	//! Box, pulse, Fourier window, 1st order (constant) b-spline</a>
<a name="ln504">	FILTER_BICUBIC	  = 1,	//! Mitchell &amp; Netravali's two-param cubic filter</a>
<a name="ln505">	FILTER_BILINEAR   = 2,	//! Bilinear filter</a>
<a name="ln506">	FILTER_BSPLINE	  = 3,	//! 4th order (cubic) b-spline</a>
<a name="ln507">	FILTER_CATMULLROM = 4,	//! Catmull-Rom spline, Overhauser spline</a>
<a name="ln508">	FILTER_LANCZOS3	  = 5	//! Lanczos3 filter</a>
<a name="ln509">};</a>
<a name="ln510"> </a>
<a name="ln511">/** Color channels.</a>
<a name="ln512">Constants used in color manipulation routines.</a>
<a name="ln513">*/</a>
<a name="ln514">FI_ENUM(FREE_IMAGE_COLOR_CHANNEL) {</a>
<a name="ln515">	FICC_RGB	= 0,	//! Use red, green and blue channels</a>
<a name="ln516">	FICC_RED	= 1,	//! Use red channel</a>
<a name="ln517">	FICC_GREEN	= 2,	//! Use green channel</a>
<a name="ln518">	FICC_BLUE	= 3,	//! Use blue channel</a>
<a name="ln519">	FICC_ALPHA	= 4,	//! Use alpha channel</a>
<a name="ln520">	FICC_BLACK	= 5,	//! Use black channel</a>
<a name="ln521">	FICC_REAL	= 6,	//! Complex images: use real part</a>
<a name="ln522">	FICC_IMAG	= 7,	//! Complex images: use imaginary part</a>
<a name="ln523">	FICC_MAG	= 8,	//! Complex images: use magnitude</a>
<a name="ln524">	FICC_PHASE	= 9		//! Complex images: use phase</a>
<a name="ln525">};</a>
<a name="ln526"> </a>
<a name="ln527">// Metadata support ---------------------------------------------------------</a>
<a name="ln528"> </a>
<a name="ln529">/**</a>
<a name="ln530">  Tag data type information (based on TIFF specifications)</a>
<a name="ln531"> </a>
<a name="ln532">  Note: RATIONALs are the ratio of two 32-bit integer values.</a>
<a name="ln533">*/</a>
<a name="ln534">FI_ENUM(FREE_IMAGE_MDTYPE) {</a>
<a name="ln535">	FIDT_NOTYPE		= 0,	//! placeholder </a>
<a name="ln536">	FIDT_BYTE		= 1,	//! 8-bit unsigned integer </a>
<a name="ln537">	FIDT_ASCII		= 2,	//! 8-bit bytes w/ last byte null </a>
<a name="ln538">	FIDT_SHORT		= 3,	//! 16-bit unsigned integer </a>
<a name="ln539">	FIDT_LONG		= 4,	//! 32-bit unsigned integer </a>
<a name="ln540">	FIDT_RATIONAL	= 5,	//! 64-bit unsigned fraction </a>
<a name="ln541">	FIDT_SBYTE		= 6,	//! 8-bit signed integer </a>
<a name="ln542">	FIDT_UNDEFINED	= 7,	//! 8-bit untyped data </a>
<a name="ln543">	FIDT_SSHORT		= 8,	//! 16-bit signed integer </a>
<a name="ln544">	FIDT_SLONG		= 9,	//! 32-bit signed integer </a>
<a name="ln545">	FIDT_SRATIONAL	= 10,	//! 64-bit signed fraction </a>
<a name="ln546">	FIDT_FLOAT		= 11,	//! 32-bit IEEE floating point </a>
<a name="ln547">	FIDT_DOUBLE		= 12,	//! 64-bit IEEE floating point </a>
<a name="ln548">	FIDT_IFD		= 13,	//! 32-bit unsigned integer (offset) </a>
<a name="ln549">	FIDT_PALETTE	= 14,	//! 32-bit RGBQUAD </a>
<a name="ln550">	FIDT_LONG8		= 16,	//! 64-bit unsigned integer </a>
<a name="ln551">	FIDT_SLONG8		= 17,	//! 64-bit signed integer</a>
<a name="ln552">	FIDT_IFD8		= 18	//! 64-bit unsigned integer (offset)</a>
<a name="ln553">};</a>
<a name="ln554"> </a>
<a name="ln555">/**</a>
<a name="ln556">  Metadata models supported by FreeImage</a>
<a name="ln557">*/</a>
<a name="ln558">FI_ENUM(FREE_IMAGE_MDMODEL) {</a>
<a name="ln559">	FIMD_NODATA			= -1,</a>
<a name="ln560">	FIMD_COMMENTS		= 0,	//! single comment or keywords</a>
<a name="ln561">	FIMD_EXIF_MAIN		= 1,	//! Exif-TIFF metadata</a>
<a name="ln562">	FIMD_EXIF_EXIF		= 2,	//! Exif-specific metadata</a>
<a name="ln563">	FIMD_EXIF_GPS		= 3,	//! Exif GPS metadata</a>
<a name="ln564">	FIMD_EXIF_MAKERNOTE = 4,	//! Exif maker note metadata</a>
<a name="ln565">	FIMD_EXIF_INTEROP	= 5,	//! Exif interoperability metadata</a>
<a name="ln566">	FIMD_IPTC			= 6,	//! IPTC/NAA metadata</a>
<a name="ln567">	FIMD_XMP			= 7,	//! Abobe XMP metadata</a>
<a name="ln568">	FIMD_GEOTIFF		= 8,	//! GeoTIFF metadata</a>
<a name="ln569">	FIMD_ANIMATION		= 9,	//! Animation metadata</a>
<a name="ln570">	FIMD_CUSTOM			= 10,	//! Used to attach other metadata types to a dib</a>
<a name="ln571">	FIMD_EXIF_RAW		= 11	//! Exif metadata as a raw buffer</a>
<a name="ln572">};</a>
<a name="ln573"> </a>
<a name="ln574">/**</a>
<a name="ln575">  Handle to a metadata model</a>
<a name="ln576">*/</a>
<a name="ln577">FI_STRUCT (FIMETADATA) { void *data; };</a>
<a name="ln578"> </a>
<a name="ln579">/**</a>
<a name="ln580">  Handle to a FreeImage tag</a>
<a name="ln581">*/</a>
<a name="ln582">FI_STRUCT (FITAG) { void *data; };</a>
<a name="ln583"> </a>
<a name="ln584">// File IO routines ---------------------------------------------------------</a>
<a name="ln585"> </a>
<a name="ln586">#ifndef FREEIMAGE_IO</a>
<a name="ln587">#define FREEIMAGE_IO</a>
<a name="ln588"> </a>
<a name="ln589">typedef void* fi_handle;</a>
<a name="ln590">typedef unsigned (DLL_CALLCONV *FI_ReadProc) (void *buffer, unsigned size, unsigned count, fi_handle handle);</a>
<a name="ln591">typedef unsigned (DLL_CALLCONV *FI_WriteProc) (void *buffer, unsigned size, unsigned count, fi_handle handle);</a>
<a name="ln592">typedef int (DLL_CALLCONV *FI_SeekProc) (fi_handle handle, long offset, int origin);</a>
<a name="ln593">typedef long (DLL_CALLCONV *FI_TellProc) (fi_handle handle);</a>
<a name="ln594"> </a>
<a name="ln595">#if (defined(_WIN32) || defined(__WIN32__))</a>
<a name="ln596">#pragma pack(push, 1)</a>
<a name="ln597">#else</a>
<a name="ln598">#pragma pack(1)</a>
<a name="ln599">#endif // WIN32</a>
<a name="ln600"> </a>
<a name="ln601">FI_STRUCT(FreeImageIO) {</a>
<a name="ln602">	FI_ReadProc  read_proc;     //! pointer to the function used to read data</a>
<a name="ln603">    FI_WriteProc write_proc;    //! pointer to the function used to write data</a>
<a name="ln604">    FI_SeekProc  seek_proc;     //! pointer to the function used to seek</a>
<a name="ln605">    FI_TellProc  tell_proc;     //! pointer to the function used to aquire the current position</a>
<a name="ln606">};</a>
<a name="ln607"> </a>
<a name="ln608">#if (defined(_WIN32) || defined(__WIN32__))</a>
<a name="ln609">#pragma pack(pop)</a>
<a name="ln610">#else</a>
<a name="ln611">#pragma pack()</a>
<a name="ln612">#endif // WIN32</a>
<a name="ln613"> </a>
<a name="ln614">/**</a>
<a name="ln615">Handle to a memory I/O stream</a>
<a name="ln616">*/</a>
<a name="ln617">FI_STRUCT (FIMEMORY) { void *data; };</a>
<a name="ln618"> </a>
<a name="ln619">#endif // FREEIMAGE_IO</a>
<a name="ln620"> </a>
<a name="ln621">// Plugin routines ----------------------------------------------------------</a>
<a name="ln622"> </a>
<a name="ln623">#ifndef PLUGINS</a>
<a name="ln624">#define PLUGINS</a>
<a name="ln625"> </a>
<a name="ln626">typedef const char *(DLL_CALLCONV *FI_FormatProc)(void);</a>
<a name="ln627">typedef const char *(DLL_CALLCONV *FI_DescriptionProc)(void);</a>
<a name="ln628">typedef const char *(DLL_CALLCONV *FI_ExtensionListProc)(void);</a>
<a name="ln629">typedef const char *(DLL_CALLCONV *FI_RegExprProc)(void);</a>
<a name="ln630">typedef void *(DLL_CALLCONV *FI_OpenProc)(FreeImageIO *io, fi_handle handle, BOOL read);</a>
<a name="ln631">typedef void (DLL_CALLCONV *FI_CloseProc)(FreeImageIO *io, fi_handle handle, void *data);</a>
<a name="ln632">typedef int (DLL_CALLCONV *FI_PageCountProc)(FreeImageIO *io, fi_handle handle, void *data);</a>
<a name="ln633">typedef int (DLL_CALLCONV *FI_PageCapabilityProc)(FreeImageIO *io, fi_handle handle, void *data);</a>
<a name="ln634">typedef FIBITMAP *(DLL_CALLCONV *FI_LoadProc)(FreeImageIO *io, fi_handle handle, int page, int flags, void *data);</a>
<a name="ln635">typedef BOOL (DLL_CALLCONV *FI_SaveProc)(FreeImageIO *io, FIBITMAP *dib, fi_handle handle, int page, int flags, void *data);</a>
<a name="ln636">typedef BOOL (DLL_CALLCONV *FI_ValidateProc)(FreeImageIO *io, fi_handle handle);</a>
<a name="ln637">typedef const char *(DLL_CALLCONV *FI_MimeProc)(void);</a>
<a name="ln638">typedef BOOL (DLL_CALLCONV *FI_SupportsExportBPPProc)(int bpp);</a>
<a name="ln639">typedef BOOL (DLL_CALLCONV *FI_SupportsExportTypeProc)(FREE_IMAGE_TYPE type);</a>
<a name="ln640">typedef BOOL (DLL_CALLCONV *FI_SupportsICCProfilesProc)(void);</a>
<a name="ln641">typedef BOOL (DLL_CALLCONV *FI_SupportsNoPixelsProc)(void);</a>
<a name="ln642"> </a>
<a name="ln643">FI_STRUCT (Plugin) {</a>
<a name="ln644">	FI_FormatProc format_proc;</a>
<a name="ln645">	FI_DescriptionProc description_proc;</a>
<a name="ln646">	FI_ExtensionListProc extension_proc;</a>
<a name="ln647">	FI_RegExprProc regexpr_proc;</a>
<a name="ln648">	FI_OpenProc open_proc;</a>
<a name="ln649">	FI_CloseProc close_proc;</a>
<a name="ln650">	FI_PageCountProc pagecount_proc;</a>
<a name="ln651">	FI_PageCapabilityProc pagecapability_proc;</a>
<a name="ln652">	FI_LoadProc load_proc;</a>
<a name="ln653">	FI_SaveProc save_proc;</a>
<a name="ln654">	FI_ValidateProc validate_proc;</a>
<a name="ln655">	FI_MimeProc mime_proc;</a>
<a name="ln656">	FI_SupportsExportBPPProc supports_export_bpp_proc;</a>
<a name="ln657">	FI_SupportsExportTypeProc supports_export_type_proc;</a>
<a name="ln658">	FI_SupportsICCProfilesProc supports_icc_profiles_proc;</a>
<a name="ln659">	FI_SupportsNoPixelsProc supports_no_pixels_proc;</a>
<a name="ln660">};</a>
<a name="ln661"> </a>
<a name="ln662">typedef void (DLL_CALLCONV *FI_InitProc)(Plugin *plugin, int format_id);</a>
<a name="ln663"> </a>
<a name="ln664">#endif // PLUGINS</a>
<a name="ln665"> </a>
<a name="ln666"> </a>
<a name="ln667">// Load / Save flag constants -----------------------------------------------</a>
<a name="ln668"> </a>
<a name="ln669">#define FIF_LOAD_NOPIXELS 0x8000	//! loading: load the image header only (not supported by all plugins, default to full loading)</a>
<a name="ln670"> </a>
<a name="ln671">#define BMP_DEFAULT         0</a>
<a name="ln672">#define BMP_SAVE_RLE        1</a>
<a name="ln673">#define CUT_DEFAULT         0</a>
<a name="ln674">#define DDS_DEFAULT			0</a>
<a name="ln675">#define EXR_DEFAULT			0		//! save data as half with piz-based wavelet compression</a>
<a name="ln676">#define EXR_FLOAT			0x0001	//! save data as float instead of as half (not recommended)</a>
<a name="ln677">#define EXR_NONE			0x0002	//! save with no compression</a>
<a name="ln678">#define EXR_ZIP				0x0004	//! save with zlib compression, in blocks of 16 scan lines</a>
<a name="ln679">#define EXR_PIZ				0x0008	//! save with piz-based wavelet compression</a>
<a name="ln680">#define EXR_PXR24			0x0010	//! save with lossy 24-bit float compression</a>
<a name="ln681">#define EXR_B44				0x0020	//! save with lossy 44% float compression - goes to 22% when combined with EXR_LC</a>
<a name="ln682">#define EXR_LC				0x0040	//! save images with one luminance and two chroma channels, rather than as RGB (lossy compression)</a>
<a name="ln683">#define FAXG3_DEFAULT		0</a>
<a name="ln684">#define GIF_DEFAULT			0</a>
<a name="ln685">#define GIF_LOAD256			1		//! load the image as a 256 color image with ununsed palette entries, if it's 16 or 2 color</a>
<a name="ln686">#define GIF_PLAYBACK		2		//! 'Play' the GIF to generate each frame (as 32bpp) instead of returning raw frame data when loading</a>
<a name="ln687">#define HDR_DEFAULT			0</a>
<a name="ln688">#define ICO_DEFAULT         0</a>
<a name="ln689">#define ICO_MAKEALPHA		1		//! convert to 32bpp and create an alpha channel from the AND-mask when loading</a>
<a name="ln690">#define IFF_DEFAULT         0</a>
<a name="ln691">#define J2K_DEFAULT			0		//! save with a 16:1 rate</a>
<a name="ln692">#define JP2_DEFAULT			0		//! save with a 16:1 rate</a>
<a name="ln693">#define JPEG_DEFAULT        0		//! loading (see JPEG_FAST); saving (see JPEG_QUALITYGOOD|JPEG_SUBSAMPLING_420)</a>
<a name="ln694">#define JPEG_FAST           0x0001	//! load the file as fast as possible, sacrificing some quality</a>
<a name="ln695">#define JPEG_ACCURATE       0x0002	//! load the file with the best quality, sacrificing some speed</a>
<a name="ln696">#define JPEG_CMYK			0x0004	//! load separated CMYK &quot;as is&quot; (use | to combine with other load flags)</a>
<a name="ln697">#define JPEG_EXIFROTATE		0x0008	//! load and rotate according to Exif 'Orientation' tag if available</a>
<a name="ln698">#define JPEG_GREYSCALE		0x0010	//! load and convert to a 8-bit greyscale image</a>
<a name="ln699">#define JPEG_QUALITYSUPERB  0x80	//! save with superb quality (100:1)</a>
<a name="ln700">#define JPEG_QUALITYGOOD    0x0100	//! save with good quality (75:1)</a>
<a name="ln701">#define JPEG_QUALITYNORMAL  0x0200	//! save with normal quality (50:1)</a>
<a name="ln702">#define JPEG_QUALITYAVERAGE 0x0400	//! save with average quality (25:1)</a>
<a name="ln703">#define JPEG_QUALITYBAD     0x0800	//! save with bad quality (10:1)</a>
<a name="ln704">#define JPEG_PROGRESSIVE	0x2000	//! save as a progressive-JPEG (use | to combine with other save flags)</a>
<a name="ln705">#define JPEG_SUBSAMPLING_411 0x1000		//! save with high 4x1 chroma subsampling (4:1:1) </a>
<a name="ln706">#define JPEG_SUBSAMPLING_420 0x4000		//! save with medium 2x2 medium chroma subsampling (4:2:0) - default value</a>
<a name="ln707">#define JPEG_SUBSAMPLING_422 0x8000		//! save with low 2x1 chroma subsampling (4:2:2) </a>
<a name="ln708">#define JPEG_SUBSAMPLING_444 0x10000	//! save with no chroma subsampling (4:4:4)</a>
<a name="ln709">#define JPEG_OPTIMIZE		0x20000		//! on saving, compute optimal Huffman coding tables (can reduce a few percent of file size)</a>
<a name="ln710">#define JPEG_BASELINE		0x40000		//! save basic JPEG, without metadata or any markers</a>
<a name="ln711">#define KOALA_DEFAULT       0</a>
<a name="ln712">#define LBM_DEFAULT         0</a>
<a name="ln713">#define MNG_DEFAULT         0</a>
<a name="ln714">#define PCD_DEFAULT         0</a>
<a name="ln715">#define PCD_BASE            1		//! load the bitmap sized 768 x 512</a>
<a name="ln716">#define PCD_BASEDIV4        2		//! load the bitmap sized 384 x 256</a>
<a name="ln717">#define PCD_BASEDIV16       3		//! load the bitmap sized 192 x 128</a>
<a name="ln718">#define PCX_DEFAULT         0</a>
<a name="ln719">#define PFM_DEFAULT         0</a>
<a name="ln720">#define PICT_DEFAULT        0</a>
<a name="ln721">#define PNG_DEFAULT         0</a>
<a name="ln722">#define PNG_IGNOREGAMMA		1		//! loading: avoid gamma correction</a>
<a name="ln723">#define PNG_Z_BEST_SPEED			0x0001	//! save using ZLib level 1 compression flag (default value is 6)</a>
<a name="ln724">#define PNG_Z_DEFAULT_COMPRESSION	0x0006	//! save using ZLib level 6 compression flag (default recommended value)</a>
<a name="ln725">#define PNG_Z_BEST_COMPRESSION		0x0009	//! save using ZLib level 9 compression flag (default value is 6)</a>
<a name="ln726">#define PNG_Z_NO_COMPRESSION		0x0100	//! save without ZLib compression</a>
<a name="ln727">#define PNG_INTERLACED				0x0200	//! save using Adam7 interlacing (use | to combine with other save flags)</a>
<a name="ln728">#define PNM_DEFAULT         0</a>
<a name="ln729">#define PNM_SAVE_RAW        0       //! if set the writer saves in RAW format (i.e. P4, P5 or P6)</a>
<a name="ln730">#define PNM_SAVE_ASCII      1       //! if set the writer saves in ASCII format (i.e. P1, P2 or P3)</a>
<a name="ln731">#define PSD_DEFAULT         0</a>
<a name="ln732">#define PSD_CMYK			1		//! reads tags for separated CMYK (default is conversion to RGB)</a>
<a name="ln733">#define PSD_LAB				2		//! reads tags for CIELab (default is conversion to RGB)</a>
<a name="ln734">#define RAS_DEFAULT         0</a>
<a name="ln735">#define RAW_DEFAULT         0		//! load the file as linear RGB 48-bit</a>
<a name="ln736">#define RAW_PREVIEW			1		//! try to load the embedded JPEG preview with included Exif Data or default to RGB 24-bit</a>
<a name="ln737">#define RAW_DISPLAY			2		//! load the file as RGB 24-bit</a>
<a name="ln738">#define RAW_HALFSIZE		4		//! output a half-size color image</a>
<a name="ln739">#define RAW_UNPROCESSED		8		//! output a FIT_UINT16 raw Bayer image</a>
<a name="ln740">#define SGI_DEFAULT			0</a>
<a name="ln741">#define TARGA_DEFAULT       0</a>
<a name="ln742">#define TARGA_LOAD_RGB888   1       //! if set the loader converts RGB555 and ARGB8888 -&gt; RGB888.</a>
<a name="ln743">#define TARGA_SAVE_RLE		2		//! if set, the writer saves with RLE compression</a>
<a name="ln744">#define TIFF_DEFAULT        0</a>
<a name="ln745">#define TIFF_CMYK			0x0001	//! reads/stores tags for separated CMYK (use | to combine with compression flags)</a>
<a name="ln746">#define TIFF_PACKBITS       0x0100  //! save using PACKBITS compression</a>
<a name="ln747">#define TIFF_DEFLATE        0x0200  //! save using DEFLATE compression (a.k.a. ZLIB compression)</a>
<a name="ln748">#define TIFF_ADOBE_DEFLATE  0x0400  //! save using ADOBE DEFLATE compression</a>
<a name="ln749">#define TIFF_NONE           0x0800  //! save without any compression</a>
<a name="ln750">#define TIFF_CCITTFAX3		0x1000  //! save using CCITT Group 3 fax encoding</a>
<a name="ln751">#define TIFF_CCITTFAX4		0x2000  //! save using CCITT Group 4 fax encoding</a>
<a name="ln752">#define TIFF_LZW			0x4000	//! save using LZW compression</a>
<a name="ln753">#define TIFF_JPEG			0x8000	//! save using JPEG compression</a>
<a name="ln754">#define TIFF_LOGLUV			0x10000	//! save using LogLuv compression</a>
<a name="ln755">#define WBMP_DEFAULT        0</a>
<a name="ln756">#define XBM_DEFAULT			0</a>
<a name="ln757">#define XPM_DEFAULT			0</a>
<a name="ln758">#define WEBP_DEFAULT		0		//! save with good quality (75:1)</a>
<a name="ln759">#define WEBP_LOSSLESS		0x100	//! save in lossless mode</a>
<a name="ln760">#define JXR_DEFAULT			0		//! save with quality 80 and no chroma subsampling (4:4:4)</a>
<a name="ln761">#define JXR_LOSSLESS		0x0064	//! save lossless</a>
<a name="ln762">#define JXR_PROGRESSIVE		0x2000	//! save as a progressive-JXR (use | to combine with other save flags)</a>
<a name="ln763"> </a>
<a name="ln764">// Background filling options ---------------------------------------------------------</a>
<a name="ln765">// Constants used in FreeImage_FillBackground and FreeImage_EnlargeCanvas</a>
<a name="ln766"> </a>
<a name="ln767">#define FI_COLOR_IS_RGB_COLOR			0x00	//! RGBQUAD color is a RGB color (contains no valid alpha channel)</a>
<a name="ln768">#define FI_COLOR_IS_RGBA_COLOR			0x01	//! RGBQUAD color is a RGBA color (contains a valid alpha channel)</a>
<a name="ln769">#define FI_COLOR_FIND_EQUAL_COLOR		0x02	//! For palettized images: lookup equal RGB color from palette</a>
<a name="ln770">#define FI_COLOR_ALPHA_IS_INDEX			0x04	//! The color's rgbReserved member (alpha) contains the palette index to be used</a>
<a name="ln771">#define FI_COLOR_PALETTE_SEARCH_MASK	(FI_COLOR_FIND_EQUAL_COLOR | FI_COLOR_ALPHA_IS_INDEX)	// No color lookup is performed</a>
<a name="ln772"> </a>
<a name="ln773">// RescaleEx options ---------------------------------------------------------</a>
<a name="ln774">// Constants used in FreeImage_RescaleEx</a>
<a name="ln775"> </a>
<a name="ln776">#define FI_RESCALE_DEFAULT			0x00    //! default options; none of the following other options apply</a>
<a name="ln777">#define FI_RESCALE_TRUE_COLOR		0x01	//! for non-transparent greyscale images, convert to 24-bit if src bitdepth &lt;= 8 (default is a 8-bit greyscale image). </a>
<a name="ln778">#define FI_RESCALE_OMIT_METADATA	0x02	//! do not copy metadata to the rescaled image</a>
<a name="ln779"> </a>
<a name="ln780"> </a>
<a name="ln781">#ifdef __cplusplus</a>
<a name="ln782">extern &quot;C&quot; {</a>
<a name="ln783">#endif</a>
<a name="ln784"> </a>
<a name="ln785">// Init / Error routines ----------------------------------------------------</a>
<a name="ln786"> </a>
<a name="ln787">DLL_API void DLL_CALLCONV FreeImage_Initialise(BOOL load_local_plugins_only FI_DEFAULT(FALSE));</a>
<a name="ln788">DLL_API void DLL_CALLCONV FreeImage_DeInitialise(void);</a>
<a name="ln789"> </a>
<a name="ln790">// Version routines ---------------------------------------------------------</a>
<a name="ln791"> </a>
<a name="ln792">DLL_API const char *DLL_CALLCONV FreeImage_GetVersion(void);</a>
<a name="ln793">DLL_API const char *DLL_CALLCONV FreeImage_GetCopyrightMessage(void);</a>
<a name="ln794"> </a>
<a name="ln795">// Message output functions -------------------------------------------------</a>
<a name="ln796"> </a>
<a name="ln797">typedef void (*FreeImage_OutputMessageFunction)(FREE_IMAGE_FORMAT fif, const char *msg);</a>
<a name="ln798">typedef void (DLL_CALLCONV *FreeImage_OutputMessageFunctionStdCall)(FREE_IMAGE_FORMAT fif, const char *msg); </a>
<a name="ln799"> </a>
<a name="ln800">DLL_API void DLL_CALLCONV FreeImage_SetOutputMessageStdCall(FreeImage_OutputMessageFunctionStdCall omf); </a>
<a name="ln801">DLL_API void DLL_CALLCONV FreeImage_SetOutputMessage(FreeImage_OutputMessageFunction omf);</a>
<a name="ln802">DLL_API void DLL_CALLCONV FreeImage_OutputMessageProc(int fif, const char *fmt, ...);</a>
<a name="ln803"> </a>
<a name="ln804">// Allocate / Clone / Unload routines ---------------------------------------</a>
<a name="ln805"> </a>
<a name="ln806">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_Allocate(int width, int height, int bpp, unsigned red_mask FI_DEFAULT(0), unsigned green_mask FI_DEFAULT(0), unsigned blue_mask FI_DEFAULT(0));</a>
<a name="ln807">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_AllocateT(FREE_IMAGE_TYPE type, int width, int height, int bpp FI_DEFAULT(8), unsigned red_mask FI_DEFAULT(0), unsigned green_mask FI_DEFAULT(0), unsigned blue_mask FI_DEFAULT(0));</a>
<a name="ln808">DLL_API FIBITMAP * DLL_CALLCONV FreeImage_Clone(FIBITMAP *dib);</a>
<a name="ln809">DLL_API void DLL_CALLCONV FreeImage_Unload(FIBITMAP *dib);</a>
<a name="ln810"> </a>
<a name="ln811">// Header loading routines</a>
<a name="ln812">DLL_API BOOL DLL_CALLCONV FreeImage_HasPixels(FIBITMAP *dib);</a>
<a name="ln813"> </a>
<a name="ln814">// Load / Save routines -----------------------------------------------------</a>
<a name="ln815"> </a>
<a name="ln816">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_Load(FREE_IMAGE_FORMAT fif, const char *filename, int flags FI_DEFAULT(0));</a>
<a name="ln817">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_LoadU(FREE_IMAGE_FORMAT fif, const wchar_t *filename, int flags FI_DEFAULT(0));</a>
<a name="ln818">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_LoadFromHandle(FREE_IMAGE_FORMAT fif, FreeImageIO *io, fi_handle handle, int flags FI_DEFAULT(0));</a>
<a name="ln819">DLL_API BOOL DLL_CALLCONV FreeImage_Save(FREE_IMAGE_FORMAT fif, FIBITMAP *dib, const char *filename, int flags FI_DEFAULT(0));</a>
<a name="ln820">DLL_API BOOL DLL_CALLCONV FreeImage_SaveU(FREE_IMAGE_FORMAT fif, FIBITMAP *dib, const wchar_t *filename, int flags FI_DEFAULT(0));</a>
<a name="ln821">DLL_API BOOL DLL_CALLCONV FreeImage_SaveToHandle(FREE_IMAGE_FORMAT fif, FIBITMAP *dib, FreeImageIO *io, fi_handle handle, int flags FI_DEFAULT(0));</a>
<a name="ln822"> </a>
<a name="ln823">// Memory I/O stream routines -----------------------------------------------</a>
<a name="ln824"> </a>
<a name="ln825">DLL_API FIMEMORY *DLL_CALLCONV FreeImage_OpenMemory(BYTE *data FI_DEFAULT(0), DWORD size_in_bytes FI_DEFAULT(0));</a>
<a name="ln826">DLL_API void DLL_CALLCONV FreeImage_CloseMemory(FIMEMORY *stream);</a>
<a name="ln827">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_LoadFromMemory(FREE_IMAGE_FORMAT fif, FIMEMORY *stream, int flags FI_DEFAULT(0));</a>
<a name="ln828">DLL_API BOOL DLL_CALLCONV FreeImage_SaveToMemory(FREE_IMAGE_FORMAT fif, FIBITMAP *dib, FIMEMORY *stream, int flags FI_DEFAULT(0));</a>
<a name="ln829">DLL_API long DLL_CALLCONV FreeImage_TellMemory(FIMEMORY *stream);</a>
<a name="ln830">DLL_API BOOL DLL_CALLCONV FreeImage_SeekMemory(FIMEMORY *stream, long offset, int origin);</a>
<a name="ln831">DLL_API BOOL DLL_CALLCONV FreeImage_AcquireMemory(FIMEMORY *stream, BYTE **data, DWORD *size_in_bytes);</a>
<a name="ln832">DLL_API unsigned DLL_CALLCONV FreeImage_ReadMemory(void *buffer, unsigned size, unsigned count, FIMEMORY *stream);</a>
<a name="ln833">DLL_API unsigned DLL_CALLCONV FreeImage_WriteMemory(const void *buffer, unsigned size, unsigned count, FIMEMORY *stream);</a>
<a name="ln834"> </a>
<a name="ln835">DLL_API FIMULTIBITMAP *DLL_CALLCONV FreeImage_LoadMultiBitmapFromMemory(FREE_IMAGE_FORMAT fif, FIMEMORY *stream, int flags FI_DEFAULT(0));</a>
<a name="ln836">DLL_API BOOL DLL_CALLCONV FreeImage_SaveMultiBitmapToMemory(FREE_IMAGE_FORMAT fif, FIMULTIBITMAP *bitmap, FIMEMORY *stream, int flags);</a>
<a name="ln837"> </a>
<a name="ln838">// Plugin Interface ---------------------------------------------------------</a>
<a name="ln839"> </a>
<a name="ln840">DLL_API FREE_IMAGE_FORMAT DLL_CALLCONV FreeImage_RegisterLocalPlugin(FI_InitProc proc_address, const char *format FI_DEFAULT(0), const char *description FI_DEFAULT(0), const char *extension FI_DEFAULT(0), const char *regexpr FI_DEFAULT(0));</a>
<a name="ln841">DLL_API FREE_IMAGE_FORMAT DLL_CALLCONV FreeImage_RegisterExternalPlugin(const char *path, const char *format FI_DEFAULT(0), const char *description FI_DEFAULT(0), const char *extension FI_DEFAULT(0), const char *regexpr FI_DEFAULT(0));</a>
<a name="ln842">DLL_API int DLL_CALLCONV FreeImage_GetFIFCount(void);</a>
<a name="ln843">DLL_API int DLL_CALLCONV FreeImage_SetPluginEnabled(FREE_IMAGE_FORMAT fif, BOOL enable);</a>
<a name="ln844">DLL_API int DLL_CALLCONV FreeImage_IsPluginEnabled(FREE_IMAGE_FORMAT fif);</a>
<a name="ln845">DLL_API FREE_IMAGE_FORMAT DLL_CALLCONV FreeImage_GetFIFFromFormat(const char *format);</a>
<a name="ln846">DLL_API FREE_IMAGE_FORMAT DLL_CALLCONV FreeImage_GetFIFFromMime(const char *mime);</a>
<a name="ln847">DLL_API const char *DLL_CALLCONV FreeImage_GetFormatFromFIF(FREE_IMAGE_FORMAT fif);</a>
<a name="ln848">DLL_API const char *DLL_CALLCONV FreeImage_GetFIFExtensionList(FREE_IMAGE_FORMAT fif);</a>
<a name="ln849">DLL_API const char *DLL_CALLCONV FreeImage_GetFIFDescription(FREE_IMAGE_FORMAT fif);</a>
<a name="ln850">DLL_API const char *DLL_CALLCONV FreeImage_GetFIFRegExpr(FREE_IMAGE_FORMAT fif);</a>
<a name="ln851">DLL_API const char *DLL_CALLCONV FreeImage_GetFIFMimeType(FREE_IMAGE_FORMAT fif);</a>
<a name="ln852">DLL_API FREE_IMAGE_FORMAT DLL_CALLCONV FreeImage_GetFIFFromFilename(const char *filename);</a>
<a name="ln853">DLL_API FREE_IMAGE_FORMAT DLL_CALLCONV FreeImage_GetFIFFromFilenameU(const wchar_t *filename);</a>
<a name="ln854">DLL_API BOOL DLL_CALLCONV FreeImage_FIFSupportsReading(FREE_IMAGE_FORMAT fif);</a>
<a name="ln855">DLL_API BOOL DLL_CALLCONV FreeImage_FIFSupportsWriting(FREE_IMAGE_FORMAT fif);</a>
<a name="ln856">DLL_API BOOL DLL_CALLCONV FreeImage_FIFSupportsExportBPP(FREE_IMAGE_FORMAT fif, int bpp);</a>
<a name="ln857">DLL_API BOOL DLL_CALLCONV FreeImage_FIFSupportsExportType(FREE_IMAGE_FORMAT fif, FREE_IMAGE_TYPE type);</a>
<a name="ln858">DLL_API BOOL DLL_CALLCONV FreeImage_FIFSupportsICCProfiles(FREE_IMAGE_FORMAT fif);</a>
<a name="ln859">DLL_API BOOL DLL_CALLCONV FreeImage_FIFSupportsNoPixels(FREE_IMAGE_FORMAT fif);</a>
<a name="ln860"> </a>
<a name="ln861">// Multipaging interface ----------------------------------------------------</a>
<a name="ln862"> </a>
<a name="ln863">DLL_API FIMULTIBITMAP * DLL_CALLCONV FreeImage_OpenMultiBitmap(FREE_IMAGE_FORMAT fif, const char *filename, BOOL create_new, BOOL read_only, BOOL keep_cache_in_memory FI_DEFAULT(FALSE), int flags FI_DEFAULT(0));</a>
<a name="ln864">DLL_API FIMULTIBITMAP * DLL_CALLCONV FreeImage_OpenMultiBitmapFromHandle(FREE_IMAGE_FORMAT fif, FreeImageIO *io, fi_handle handle, int flags FI_DEFAULT(0));</a>
<a name="ln865">DLL_API BOOL DLL_CALLCONV FreeImage_SaveMultiBitmapToHandle(FREE_IMAGE_FORMAT fif, FIMULTIBITMAP *bitmap, FreeImageIO *io, fi_handle handle, int flags FI_DEFAULT(0));</a>
<a name="ln866">DLL_API BOOL DLL_CALLCONV FreeImage_CloseMultiBitmap(FIMULTIBITMAP *bitmap, int flags FI_DEFAULT(0));</a>
<a name="ln867">DLL_API int DLL_CALLCONV FreeImage_GetPageCount(FIMULTIBITMAP *bitmap);</a>
<a name="ln868">DLL_API void DLL_CALLCONV FreeImage_AppendPage(FIMULTIBITMAP *bitmap, FIBITMAP *data);</a>
<a name="ln869">DLL_API void DLL_CALLCONV FreeImage_InsertPage(FIMULTIBITMAP *bitmap, int page, FIBITMAP *data);</a>
<a name="ln870">DLL_API void DLL_CALLCONV FreeImage_DeletePage(FIMULTIBITMAP *bitmap, int page);</a>
<a name="ln871">DLL_API FIBITMAP * DLL_CALLCONV FreeImage_LockPage(FIMULTIBITMAP *bitmap, int page);</a>
<a name="ln872">DLL_API void DLL_CALLCONV FreeImage_UnlockPage(FIMULTIBITMAP *bitmap, FIBITMAP *data, BOOL changed);</a>
<a name="ln873">DLL_API BOOL DLL_CALLCONV FreeImage_MovePage(FIMULTIBITMAP *bitmap, int target, int source);</a>
<a name="ln874">DLL_API BOOL DLL_CALLCONV FreeImage_GetLockedPageNumbers(FIMULTIBITMAP *bitmap, int *pages, int *count);</a>
<a name="ln875"> </a>
<a name="ln876">// Filetype request routines ------------------------------------------------</a>
<a name="ln877"> </a>
<a name="ln878">DLL_API FREE_IMAGE_FORMAT DLL_CALLCONV FreeImage_GetFileType(const char *filename, int size FI_DEFAULT(0));</a>
<a name="ln879">DLL_API FREE_IMAGE_FORMAT DLL_CALLCONV FreeImage_GetFileTypeU(const wchar_t *filename, int size FI_DEFAULT(0));</a>
<a name="ln880">DLL_API FREE_IMAGE_FORMAT DLL_CALLCONV FreeImage_GetFileTypeFromHandle(FreeImageIO *io, fi_handle handle, int size FI_DEFAULT(0));</a>
<a name="ln881">DLL_API FREE_IMAGE_FORMAT DLL_CALLCONV FreeImage_GetFileTypeFromMemory(FIMEMORY *stream, int size FI_DEFAULT(0));</a>
<a name="ln882"> </a>
<a name="ln883">// Image type request routine -----------------------------------------------</a>
<a name="ln884"> </a>
<a name="ln885">DLL_API FREE_IMAGE_TYPE DLL_CALLCONV FreeImage_GetImageType(FIBITMAP *dib);</a>
<a name="ln886"> </a>
<a name="ln887">// FreeImage helper routines ------------------------------------------------</a>
<a name="ln888"> </a>
<a name="ln889">DLL_API BOOL DLL_CALLCONV FreeImage_IsLittleEndian(void);</a>
<a name="ln890">DLL_API BOOL DLL_CALLCONV FreeImage_LookupX11Color(const char *szColor, BYTE *nRed, BYTE *nGreen, BYTE *nBlue);</a>
<a name="ln891">DLL_API BOOL DLL_CALLCONV FreeImage_LookupSVGColor(const char *szColor, BYTE *nRed, BYTE *nGreen, BYTE *nBlue);</a>
<a name="ln892"> </a>
<a name="ln893">// Pixel access routines ----------------------------------------------------</a>
<a name="ln894"> </a>
<a name="ln895">DLL_API BYTE *DLL_CALLCONV FreeImage_GetBits(FIBITMAP *dib);</a>
<a name="ln896">DLL_API BYTE *DLL_CALLCONV FreeImage_GetScanLine(FIBITMAP *dib, int scanline);</a>
<a name="ln897"> </a>
<a name="ln898">DLL_API BOOL DLL_CALLCONV FreeImage_GetPixelIndex(FIBITMAP *dib, unsigned x, unsigned y, BYTE *value);</a>
<a name="ln899">DLL_API BOOL DLL_CALLCONV FreeImage_GetPixelColor(FIBITMAP *dib, unsigned x, unsigned y, RGBQUAD *value);</a>
<a name="ln900">DLL_API BOOL DLL_CALLCONV FreeImage_SetPixelIndex(FIBITMAP *dib, unsigned x, unsigned y, BYTE *value);</a>
<a name="ln901">DLL_API BOOL DLL_CALLCONV FreeImage_SetPixelColor(FIBITMAP *dib, unsigned x, unsigned y, RGBQUAD *value);</a>
<a name="ln902"> </a>
<a name="ln903">// DIB info routines --------------------------------------------------------</a>
<a name="ln904"> </a>
<a name="ln905">DLL_API unsigned DLL_CALLCONV FreeImage_GetColorsUsed(FIBITMAP *dib);</a>
<a name="ln906">DLL_API unsigned DLL_CALLCONV FreeImage_GetBPP(FIBITMAP *dib);</a>
<a name="ln907">DLL_API unsigned DLL_CALLCONV FreeImage_GetWidth(FIBITMAP *dib);</a>
<a name="ln908">DLL_API unsigned DLL_CALLCONV FreeImage_GetHeight(FIBITMAP *dib);</a>
<a name="ln909">DLL_API unsigned DLL_CALLCONV FreeImage_GetLine(FIBITMAP *dib);</a>
<a name="ln910">DLL_API unsigned DLL_CALLCONV FreeImage_GetPitch(FIBITMAP *dib);</a>
<a name="ln911">DLL_API unsigned DLL_CALLCONV FreeImage_GetDIBSize(FIBITMAP *dib);</a>
<a name="ln912">DLL_API unsigned DLL_CALLCONV FreeImage_GetMemorySize(FIBITMAP *dib);</a>
<a name="ln913">DLL_API RGBQUAD *DLL_CALLCONV FreeImage_GetPalette(FIBITMAP *dib);</a>
<a name="ln914"> </a>
<a name="ln915">DLL_API unsigned DLL_CALLCONV FreeImage_GetDotsPerMeterX(FIBITMAP *dib);</a>
<a name="ln916">DLL_API unsigned DLL_CALLCONV FreeImage_GetDotsPerMeterY(FIBITMAP *dib);</a>
<a name="ln917">DLL_API void DLL_CALLCONV FreeImage_SetDotsPerMeterX(FIBITMAP *dib, unsigned res);</a>
<a name="ln918">DLL_API void DLL_CALLCONV FreeImage_SetDotsPerMeterY(FIBITMAP *dib, unsigned res);</a>
<a name="ln919"> </a>
<a name="ln920">DLL_API BITMAPINFOHEADER *DLL_CALLCONV FreeImage_GetInfoHeader(FIBITMAP *dib);</a>
<a name="ln921">DLL_API BITMAPINFO *DLL_CALLCONV FreeImage_GetInfo(FIBITMAP *dib);</a>
<a name="ln922">DLL_API FREE_IMAGE_COLOR_TYPE DLL_CALLCONV FreeImage_GetColorType(FIBITMAP *dib);</a>
<a name="ln923"> </a>
<a name="ln924">DLL_API unsigned DLL_CALLCONV FreeImage_GetRedMask(FIBITMAP *dib);</a>
<a name="ln925">DLL_API unsigned DLL_CALLCONV FreeImage_GetGreenMask(FIBITMAP *dib);</a>
<a name="ln926">DLL_API unsigned DLL_CALLCONV FreeImage_GetBlueMask(FIBITMAP *dib);</a>
<a name="ln927"> </a>
<a name="ln928">DLL_API unsigned DLL_CALLCONV FreeImage_GetTransparencyCount(FIBITMAP *dib);</a>
<a name="ln929">DLL_API BYTE * DLL_CALLCONV FreeImage_GetTransparencyTable(FIBITMAP *dib);</a>
<a name="ln930">DLL_API void DLL_CALLCONV FreeImage_SetTransparent(FIBITMAP *dib, BOOL enabled);</a>
<a name="ln931">DLL_API void DLL_CALLCONV FreeImage_SetTransparencyTable(FIBITMAP *dib, BYTE *table, int count);</a>
<a name="ln932">DLL_API BOOL DLL_CALLCONV FreeImage_IsTransparent(FIBITMAP *dib);</a>
<a name="ln933">DLL_API void DLL_CALLCONV FreeImage_SetTransparentIndex(FIBITMAP *dib, int index);</a>
<a name="ln934">DLL_API int DLL_CALLCONV FreeImage_GetTransparentIndex(FIBITMAP *dib);</a>
<a name="ln935"> </a>
<a name="ln936">DLL_API BOOL DLL_CALLCONV FreeImage_HasBackgroundColor(FIBITMAP *dib);</a>
<a name="ln937">DLL_API BOOL DLL_CALLCONV FreeImage_GetBackgroundColor(FIBITMAP *dib, RGBQUAD *bkcolor);</a>
<a name="ln938">DLL_API BOOL DLL_CALLCONV FreeImage_SetBackgroundColor(FIBITMAP *dib, RGBQUAD *bkcolor);</a>
<a name="ln939"> </a>
<a name="ln940">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_GetThumbnail(FIBITMAP *dib);</a>
<a name="ln941">DLL_API BOOL DLL_CALLCONV FreeImage_SetThumbnail(FIBITMAP *dib, FIBITMAP *thumbnail);</a>
<a name="ln942"> </a>
<a name="ln943">// ICC profile routines -----------------------------------------------------</a>
<a name="ln944"> </a>
<a name="ln945">DLL_API FIICCPROFILE *DLL_CALLCONV FreeImage_GetICCProfile(FIBITMAP *dib);</a>
<a name="ln946">DLL_API FIICCPROFILE *DLL_CALLCONV FreeImage_CreateICCProfile(FIBITMAP *dib, void *data, long size);</a>
<a name="ln947">DLL_API void DLL_CALLCONV FreeImage_DestroyICCProfile(FIBITMAP *dib);</a>
<a name="ln948"> </a>
<a name="ln949">// Line conversion routines -------------------------------------------------</a>
<a name="ln950"> </a>
<a name="ln951">DLL_API void DLL_CALLCONV FreeImage_ConvertLine1To4(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln952">DLL_API void DLL_CALLCONV FreeImage_ConvertLine8To4(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);</a>
<a name="ln953">DLL_API void DLL_CALLCONV FreeImage_ConvertLine16To4_555(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln954">DLL_API void DLL_CALLCONV FreeImage_ConvertLine16To4_565(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln955">DLL_API void DLL_CALLCONV FreeImage_ConvertLine24To4(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln956">DLL_API void DLL_CALLCONV FreeImage_ConvertLine32To4(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln957">DLL_API void DLL_CALLCONV FreeImage_ConvertLine1To8(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln958">DLL_API void DLL_CALLCONV FreeImage_ConvertLine4To8(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln959">DLL_API void DLL_CALLCONV FreeImage_ConvertLine16To8_555(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln960">DLL_API void DLL_CALLCONV FreeImage_ConvertLine16To8_565(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln961">DLL_API void DLL_CALLCONV FreeImage_ConvertLine24To8(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln962">DLL_API void DLL_CALLCONV FreeImage_ConvertLine32To8(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln963">DLL_API void DLL_CALLCONV FreeImage_ConvertLine1To16_555(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);</a>
<a name="ln964">DLL_API void DLL_CALLCONV FreeImage_ConvertLine4To16_555(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);</a>
<a name="ln965">DLL_API void DLL_CALLCONV FreeImage_ConvertLine8To16_555(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);</a>
<a name="ln966">DLL_API void DLL_CALLCONV FreeImage_ConvertLine16_565_To16_555(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln967">DLL_API void DLL_CALLCONV FreeImage_ConvertLine24To16_555(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln968">DLL_API void DLL_CALLCONV FreeImage_ConvertLine32To16_555(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln969">DLL_API void DLL_CALLCONV FreeImage_ConvertLine1To16_565(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);</a>
<a name="ln970">DLL_API void DLL_CALLCONV FreeImage_ConvertLine4To16_565(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);</a>
<a name="ln971">DLL_API void DLL_CALLCONV FreeImage_ConvertLine8To16_565(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);</a>
<a name="ln972">DLL_API void DLL_CALLCONV FreeImage_ConvertLine16_555_To16_565(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln973">DLL_API void DLL_CALLCONV FreeImage_ConvertLine24To16_565(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln974">DLL_API void DLL_CALLCONV FreeImage_ConvertLine32To16_565(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln975">DLL_API void DLL_CALLCONV FreeImage_ConvertLine1To24(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);</a>
<a name="ln976">DLL_API void DLL_CALLCONV FreeImage_ConvertLine4To24(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);</a>
<a name="ln977">DLL_API void DLL_CALLCONV FreeImage_ConvertLine8To24(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);</a>
<a name="ln978">DLL_API void DLL_CALLCONV FreeImage_ConvertLine16To24_555(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln979">DLL_API void DLL_CALLCONV FreeImage_ConvertLine16To24_565(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln980">DLL_API void DLL_CALLCONV FreeImage_ConvertLine32To24(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln981">DLL_API void DLL_CALLCONV FreeImage_ConvertLine1To32(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);</a>
<a name="ln982">DLL_API void DLL_CALLCONV FreeImage_ConvertLine4To32(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);</a>
<a name="ln983">DLL_API void DLL_CALLCONV FreeImage_ConvertLine8To32(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);</a>
<a name="ln984">DLL_API void DLL_CALLCONV FreeImage_ConvertLine16To32_555(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln985">DLL_API void DLL_CALLCONV FreeImage_ConvertLine16To32_565(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln986">DLL_API void DLL_CALLCONV FreeImage_ConvertLine24To32(BYTE *target, BYTE *source, int width_in_pixels);</a>
<a name="ln987"> </a>
<a name="ln988">// Smart conversion routines ------------------------------------------------</a>
<a name="ln989"> </a>
<a name="ln990">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_ConvertTo4Bits(FIBITMAP *dib);</a>
<a name="ln991">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_ConvertTo8Bits(FIBITMAP *dib);</a>
<a name="ln992">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_ConvertToGreyscale(FIBITMAP *dib);</a>
<a name="ln993">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_ConvertTo16Bits555(FIBITMAP *dib);</a>
<a name="ln994">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_ConvertTo16Bits565(FIBITMAP *dib);</a>
<a name="ln995">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_ConvertTo24Bits(FIBITMAP *dib);</a>
<a name="ln996">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_ConvertTo32Bits(FIBITMAP *dib);</a>
<a name="ln997">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_ColorQuantize(FIBITMAP *dib, FREE_IMAGE_QUANTIZE quantize);</a>
<a name="ln998">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_ColorQuantizeEx(FIBITMAP *dib, FREE_IMAGE_QUANTIZE quantize FI_DEFAULT(FIQ_WUQUANT), int PaletteSize FI_DEFAULT(256), int ReserveSize FI_DEFAULT(0), RGBQUAD *ReservePalette FI_DEFAULT(NULL));</a>
<a name="ln999">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_Threshold(FIBITMAP *dib, BYTE T);</a>
<a name="ln1000">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_Dither(FIBITMAP *dib, FREE_IMAGE_DITHER algorithm);</a>
<a name="ln1001"> </a>
<a name="ln1002">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_ConvertFromRawBits(BYTE *bits, int width, int height, int pitch, unsigned bpp, unsigned red_mask, unsigned green_mask, unsigned blue_mask, BOOL topdown FI_DEFAULT(FALSE));</a>
<a name="ln1003">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_ConvertFromRawBitsEx(BOOL copySource, BYTE *bits, FREE_IMAGE_TYPE type, int width, int height, int pitch, unsigned bpp, unsigned red_mask, unsigned green_mask, unsigned blue_mask, BOOL topdown FI_DEFAULT(FALSE));</a>
<a name="ln1004">DLL_API void DLL_CALLCONV FreeImage_ConvertToRawBits(BYTE *bits, FIBITMAP *dib, int pitch, unsigned bpp, unsigned red_mask, unsigned green_mask, unsigned blue_mask, BOOL topdown FI_DEFAULT(FALSE));</a>
<a name="ln1005"> </a>
<a name="ln1006">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_ConvertToFloat(FIBITMAP *dib);</a>
<a name="ln1007">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_ConvertToRGBF(FIBITMAP *dib);</a>
<a name="ln1008">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_ConvertToRGBAF(FIBITMAP *dib);</a>
<a name="ln1009">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_ConvertToUINT16(FIBITMAP *dib);</a>
<a name="ln1010">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_ConvertToRGB16(FIBITMAP *dib);</a>
<a name="ln1011">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_ConvertToRGBA16(FIBITMAP *dib);</a>
<a name="ln1012"> </a>
<a name="ln1013">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_ConvertToStandardType(FIBITMAP *src, BOOL scale_linear FI_DEFAULT(TRUE));</a>
<a name="ln1014">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_ConvertToType(FIBITMAP *src, FREE_IMAGE_TYPE dst_type, BOOL scale_linear FI_DEFAULT(TRUE));</a>
<a name="ln1015"> </a>
<a name="ln1016">// Tone mapping operators ---------------------------------------------------</a>
<a name="ln1017"> </a>
<a name="ln1018">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_ToneMapping(FIBITMAP *dib, FREE_IMAGE_TMO tmo, double first_param FI_DEFAULT(0), double second_param FI_DEFAULT(0));</a>
<a name="ln1019">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_TmoDrago03(FIBITMAP *src, double gamma FI_DEFAULT(2.2), double exposure FI_DEFAULT(0));</a>
<a name="ln1020">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_TmoReinhard05(FIBITMAP *src, double intensity FI_DEFAULT(0), double contrast FI_DEFAULT(0));</a>
<a name="ln1021">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_TmoReinhard05Ex(FIBITMAP *src, double intensity FI_DEFAULT(0), double contrast FI_DEFAULT(0), double adaptation FI_DEFAULT(1), double color_correction FI_DEFAULT(0));</a>
<a name="ln1022"> </a>
<a name="ln1023">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_TmoFattal02(FIBITMAP *src, double color_saturation FI_DEFAULT(0.5), double attenuation FI_DEFAULT(0.85));</a>
<a name="ln1024"> </a>
<a name="ln1025">// ZLib interface -----------------------------------------------------------</a>
<a name="ln1026"> </a>
<a name="ln1027">DLL_API DWORD DLL_CALLCONV FreeImage_ZLibCompress(BYTE *target, DWORD target_size, BYTE *source, DWORD source_size);</a>
<a name="ln1028">DLL_API DWORD DLL_CALLCONV FreeImage_ZLibUncompress(BYTE *target, DWORD target_size, BYTE *source, DWORD source_size);</a>
<a name="ln1029">DLL_API DWORD DLL_CALLCONV FreeImage_ZLibGZip(BYTE *target, DWORD target_size, BYTE *source, DWORD source_size);</a>
<a name="ln1030">DLL_API DWORD DLL_CALLCONV FreeImage_ZLibGUnzip(BYTE *target, DWORD target_size, BYTE *source, DWORD source_size);</a>
<a name="ln1031">DLL_API DWORD DLL_CALLCONV FreeImage_ZLibCRC32(DWORD crc, BYTE *source, DWORD source_size);</a>
<a name="ln1032"> </a>
<a name="ln1033">// --------------------------------------------------------------------------</a>
<a name="ln1034">// Metadata routines</a>
<a name="ln1035">// --------------------------------------------------------------------------</a>
<a name="ln1036"> </a>
<a name="ln1037">// tag creation / destruction</a>
<a name="ln1038">DLL_API FITAG *DLL_CALLCONV FreeImage_CreateTag(void);</a>
<a name="ln1039">DLL_API void DLL_CALLCONV FreeImage_DeleteTag(FITAG *tag);</a>
<a name="ln1040">DLL_API FITAG *DLL_CALLCONV FreeImage_CloneTag(FITAG *tag);</a>
<a name="ln1041"> </a>
<a name="ln1042">// tag getters and setters</a>
<a name="ln1043">DLL_API const char *DLL_CALLCONV FreeImage_GetTagKey(FITAG *tag);</a>
<a name="ln1044">DLL_API const char *DLL_CALLCONV FreeImage_GetTagDescription(FITAG *tag);</a>
<a name="ln1045">DLL_API WORD DLL_CALLCONV FreeImage_GetTagID(FITAG *tag);</a>
<a name="ln1046">DLL_API FREE_IMAGE_MDTYPE DLL_CALLCONV FreeImage_GetTagType(FITAG *tag);</a>
<a name="ln1047">DLL_API DWORD DLL_CALLCONV FreeImage_GetTagCount(FITAG *tag);</a>
<a name="ln1048">DLL_API DWORD DLL_CALLCONV FreeImage_GetTagLength(FITAG *tag);</a>
<a name="ln1049">DLL_API const void *DLL_CALLCONV FreeImage_GetTagValue(FITAG *tag);</a>
<a name="ln1050"> </a>
<a name="ln1051">DLL_API BOOL DLL_CALLCONV FreeImage_SetTagKey(FITAG *tag, const char *key);</a>
<a name="ln1052">DLL_API BOOL DLL_CALLCONV FreeImage_SetTagDescription(FITAG *tag, const char *description);</a>
<a name="ln1053">DLL_API BOOL DLL_CALLCONV FreeImage_SetTagID(FITAG *tag, WORD id);</a>
<a name="ln1054">DLL_API BOOL DLL_CALLCONV FreeImage_SetTagType(FITAG *tag, FREE_IMAGE_MDTYPE type);</a>
<a name="ln1055">DLL_API BOOL DLL_CALLCONV FreeImage_SetTagCount(FITAG *tag, DWORD count);</a>
<a name="ln1056">DLL_API BOOL DLL_CALLCONV FreeImage_SetTagLength(FITAG *tag, DWORD length);</a>
<a name="ln1057">DLL_API BOOL DLL_CALLCONV FreeImage_SetTagValue(FITAG *tag, const void *value);</a>
<a name="ln1058"> </a>
<a name="ln1059">// iterator</a>
<a name="ln1060">DLL_API FIMETADATA *DLL_CALLCONV FreeImage_FindFirstMetadata(FREE_IMAGE_MDMODEL model, FIBITMAP *dib, FITAG **tag);</a>
<a name="ln1061">DLL_API BOOL DLL_CALLCONV FreeImage_FindNextMetadata(FIMETADATA *mdhandle, FITAG **tag);</a>
<a name="ln1062">DLL_API void DLL_CALLCONV FreeImage_FindCloseMetadata(FIMETADATA *mdhandle);</a>
<a name="ln1063"> </a>
<a name="ln1064">// metadata setter and getter</a>
<a name="ln1065">DLL_API BOOL DLL_CALLCONV FreeImage_SetMetadata(FREE_IMAGE_MDMODEL model, FIBITMAP *dib, const char *key, FITAG *tag);</a>
<a name="ln1066">DLL_API BOOL DLL_CALLCONV FreeImage_GetMetadata(FREE_IMAGE_MDMODEL model, FIBITMAP *dib, const char *key, FITAG **tag);</a>
<a name="ln1067">DLL_API BOOL DLL_CALLCONV FreeImage_SetMetadataKeyValue(FREE_IMAGE_MDMODEL model, FIBITMAP *dib, const char *key, const char *value);</a>
<a name="ln1068"> </a>
<a name="ln1069">// helpers</a>
<a name="ln1070">DLL_API unsigned DLL_CALLCONV FreeImage_GetMetadataCount(FREE_IMAGE_MDMODEL model, FIBITMAP *dib);</a>
<a name="ln1071">DLL_API BOOL DLL_CALLCONV FreeImage_CloneMetadata(FIBITMAP *dst, FIBITMAP *src);</a>
<a name="ln1072"> </a>
<a name="ln1073">// tag to C string conversion</a>
<a name="ln1074">DLL_API const char* DLL_CALLCONV FreeImage_TagToString(FREE_IMAGE_MDMODEL model, FITAG *tag, char *Make FI_DEFAULT(NULL));</a>
<a name="ln1075"> </a>
<a name="ln1076">// --------------------------------------------------------------------------</a>
<a name="ln1077">// JPEG lossless transformation routines</a>
<a name="ln1078">// --------------------------------------------------------------------------</a>
<a name="ln1079"> </a>
<a name="ln1080">DLL_API BOOL DLL_CALLCONV FreeImage_JPEGTransform(const char *src_file, const char *dst_file, FREE_IMAGE_JPEG_OPERATION operation, BOOL perfect FI_DEFAULT(TRUE));</a>
<a name="ln1081">DLL_API BOOL DLL_CALLCONV FreeImage_JPEGTransformU(const wchar_t *src_file, const wchar_t *dst_file, FREE_IMAGE_JPEG_OPERATION operation, BOOL perfect FI_DEFAULT(TRUE));</a>
<a name="ln1082">DLL_API BOOL DLL_CALLCONV FreeImage_JPEGCrop(const char *src_file, const char *dst_file, int left, int top, int right, int bottom);</a>
<a name="ln1083">DLL_API BOOL DLL_CALLCONV FreeImage_JPEGCropU(const wchar_t *src_file, const wchar_t *dst_file, int left, int top, int right, int bottom);</a>
<a name="ln1084">DLL_API BOOL DLL_CALLCONV FreeImage_JPEGTransformFromHandle(FreeImageIO* src_io, fi_handle src_handle, FreeImageIO* dst_io, fi_handle dst_handle, FREE_IMAGE_JPEG_OPERATION operation, int* left, int* top, int* right, int* bottom, BOOL perfect FI_DEFAULT(TRUE));</a>
<a name="ln1085">DLL_API BOOL DLL_CALLCONV FreeImage_JPEGTransformCombined(const char *src_file, const char *dst_file, FREE_IMAGE_JPEG_OPERATION operation, int* left, int* top, int* right, int* bottom, BOOL perfect FI_DEFAULT(TRUE));</a>
<a name="ln1086">DLL_API BOOL DLL_CALLCONV FreeImage_JPEGTransformCombinedU(const wchar_t *src_file, const wchar_t *dst_file, FREE_IMAGE_JPEG_OPERATION operation, int* left, int* top, int* right, int* bottom, BOOL perfect FI_DEFAULT(TRUE));</a>
<a name="ln1087">DLL_API BOOL DLL_CALLCONV FreeImage_JPEGTransformCombinedFromMemory(FIMEMORY* src_stream, FIMEMORY* dst_stream, FREE_IMAGE_JPEG_OPERATION operation, int* left, int* top, int* right, int* bottom, BOOL perfect FI_DEFAULT(TRUE));</a>
<a name="ln1088"> </a>
<a name="ln1089"> </a>
<a name="ln1090">// --------------------------------------------------------------------------</a>
<a name="ln1091">// Image manipulation toolkit</a>
<a name="ln1092">// --------------------------------------------------------------------------</a>
<a name="ln1093"> </a>
<a name="ln1094">// rotation and flipping</a>
<a name="ln1095">/// @deprecated see FreeImage_Rotate</a>
<a name="ln1096">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_RotateClassic(FIBITMAP *dib, double angle);</a>
<a name="ln1097">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_Rotate(FIBITMAP *dib, double angle, const void *bkcolor FI_DEFAULT(NULL));</a>
<a name="ln1098">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_RotateEx(FIBITMAP *dib, double angle, double x_shift, double y_shift, double x_origin, double y_origin, BOOL use_mask);</a>
<a name="ln1099">DLL_API BOOL DLL_CALLCONV FreeImage_FlipHorizontal(FIBITMAP *dib);</a>
<a name="ln1100">DLL_API BOOL DLL_CALLCONV FreeImage_FlipVertical(FIBITMAP *dib);</a>
<a name="ln1101"> </a>
<a name="ln1102">// upsampling / downsampling</a>
<a name="ln1103">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_Rescale(FIBITMAP *dib, int dst_width, int dst_height, FREE_IMAGE_FILTER filter FI_DEFAULT(FILTER_CATMULLROM));</a>
<a name="ln1104">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_MakeThumbnail(FIBITMAP *dib, int max_pixel_size, BOOL convert FI_DEFAULT(TRUE));</a>
<a name="ln1105">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_RescaleRect(FIBITMAP *dib, int dst_width, int dst_height, int left, int top, int right, int bottom, FREE_IMAGE_FILTER filter FI_DEFAULT(FILTER_CATMULLROM), unsigned flags FI_DEFAULT(0));</a>
<a name="ln1106"> </a>
<a name="ln1107">// color manipulation routines (point operations)</a>
<a name="ln1108">DLL_API BOOL DLL_CALLCONV FreeImage_AdjustCurve(FIBITMAP *dib, BYTE *LUT, FREE_IMAGE_COLOR_CHANNEL channel);</a>
<a name="ln1109">DLL_API BOOL DLL_CALLCONV FreeImage_AdjustGamma(FIBITMAP *dib, double gamma);</a>
<a name="ln1110">DLL_API BOOL DLL_CALLCONV FreeImage_AdjustBrightness(FIBITMAP *dib, double percentage);</a>
<a name="ln1111">DLL_API BOOL DLL_CALLCONV FreeImage_AdjustContrast(FIBITMAP *dib, double percentage);</a>
<a name="ln1112">DLL_API BOOL DLL_CALLCONV FreeImage_Invert(FIBITMAP *dib);</a>
<a name="ln1113">DLL_API BOOL DLL_CALLCONV FreeImage_GetHistogram(FIBITMAP *dib, DWORD *histo, FREE_IMAGE_COLOR_CHANNEL channel FI_DEFAULT(FICC_BLACK));</a>
<a name="ln1114">DLL_API int DLL_CALLCONV FreeImage_GetAdjustColorsLookupTable(BYTE *LUT, double brightness, double contrast, double gamma, BOOL invert);</a>
<a name="ln1115">DLL_API BOOL DLL_CALLCONV FreeImage_AdjustColors(FIBITMAP *dib, double brightness, double contrast, double gamma, BOOL invert FI_DEFAULT(FALSE));</a>
<a name="ln1116">DLL_API unsigned DLL_CALLCONV FreeImage_ApplyColorMapping(FIBITMAP *dib, RGBQUAD *srccolors, RGBQUAD *dstcolors, unsigned count, BOOL ignore_alpha, BOOL swap);</a>
<a name="ln1117">DLL_API unsigned DLL_CALLCONV FreeImage_SwapColors(FIBITMAP *dib, RGBQUAD *color_a, RGBQUAD *color_b, BOOL ignore_alpha);</a>
<a name="ln1118">DLL_API unsigned DLL_CALLCONV FreeImage_ApplyPaletteIndexMapping(FIBITMAP *dib, BYTE *srcindices,	BYTE *dstindices, unsigned count, BOOL swap);</a>
<a name="ln1119">DLL_API unsigned DLL_CALLCONV FreeImage_SwapPaletteIndices(FIBITMAP *dib, BYTE *index_a, BYTE *index_b);</a>
<a name="ln1120"> </a>
<a name="ln1121">// channel processing routines</a>
<a name="ln1122">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_GetChannel(FIBITMAP *dib, FREE_IMAGE_COLOR_CHANNEL channel);</a>
<a name="ln1123">DLL_API BOOL DLL_CALLCONV FreeImage_SetChannel(FIBITMAP *dst, FIBITMAP *src, FREE_IMAGE_COLOR_CHANNEL channel);</a>
<a name="ln1124">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_GetComplexChannel(FIBITMAP *src, FREE_IMAGE_COLOR_CHANNEL channel);</a>
<a name="ln1125">DLL_API BOOL DLL_CALLCONV FreeImage_SetComplexChannel(FIBITMAP *dst, FIBITMAP *src, FREE_IMAGE_COLOR_CHANNEL channel);</a>
<a name="ln1126"> </a>
<a name="ln1127">// copy / paste / composite routines</a>
<a name="ln1128">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_Copy(FIBITMAP *dib, int left, int top, int right, int bottom);</a>
<a name="ln1129">DLL_API BOOL DLL_CALLCONV FreeImage_Paste(FIBITMAP *dst, FIBITMAP *src, int left, int top, int alpha);</a>
<a name="ln1130">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_CreateView(FIBITMAP *dib, unsigned left, unsigned top, unsigned right, unsigned bottom);</a>
<a name="ln1131"> </a>
<a name="ln1132">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_Composite(FIBITMAP *fg, BOOL useFileBkg FI_DEFAULT(FALSE), RGBQUAD *appBkColor FI_DEFAULT(NULL), FIBITMAP *bg FI_DEFAULT(NULL));</a>
<a name="ln1133">DLL_API BOOL DLL_CALLCONV FreeImage_PreMultiplyWithAlpha(FIBITMAP *dib);</a>
<a name="ln1134"> </a>
<a name="ln1135">// background filling routines</a>
<a name="ln1136">DLL_API BOOL DLL_CALLCONV FreeImage_FillBackground(FIBITMAP *dib, const void *color, int options FI_DEFAULT(0));</a>
<a name="ln1137">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_EnlargeCanvas(FIBITMAP *src, int left, int top, int right, int bottom, const void *color, int options FI_DEFAULT(0));</a>
<a name="ln1138">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_AllocateEx(int width, int height, int bpp, const RGBQUAD *color, int options FI_DEFAULT(0), const RGBQUAD *palette FI_DEFAULT(NULL), unsigned red_mask FI_DEFAULT(0), unsigned green_mask FI_DEFAULT(0), unsigned blue_mask FI_DEFAULT(0));</a>
<a name="ln1139">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_AllocateExT(FREE_IMAGE_TYPE type, int width, int height, int bpp, const void *color, int options FI_DEFAULT(0), const RGBQUAD *palette FI_DEFAULT(NULL), unsigned red_mask FI_DEFAULT(0), unsigned green_mask FI_DEFAULT(0), unsigned blue_mask FI_DEFAULT(0));</a>
<a name="ln1140"> </a>
<a name="ln1141">// miscellaneous algorithms</a>
<a name="ln1142">DLL_API FIBITMAP *DLL_CALLCONV FreeImage_MultigridPoissonSolver(FIBITMAP *Laplacian, int ncycle FI_DEFAULT(3));</a>
<a name="ln1143"> </a>
<a name="ln1144">// restore the borland-specific enum size option</a>
<a name="ln1145">#if defined(__BORLANDC__)</a>
<a name="ln1146">#pragma option pop</a>
<a name="ln1147">#endif</a>
<a name="ln1148"> </a>
<a name="ln1149">#ifdef __cplusplus</a>
<a name="ln1150">}</a>
<a name="ln1151">#endif</a>
<a name="ln1152"> </a>
<a name="ln1153">#endif // FREEIMAGE_H</a>

</code></pre>
<div class="balloon" rel="168"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v677/" target="_blank">V677</a> Custom declaration of a standard 'UINT64' type. The system header file should be used: #include <BaseTsd.h>.</p></div>
<div class="balloon" rel="166"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v677/" target="_blank">V677</a> Custom declaration of a standard 'LONG' type. The system header file should be used: #include <WinNT.h>.</p></div>
<div class="balloon" rel="165"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v677/" target="_blank">V677</a> Custom declaration of a standard 'DWORD' type. The system header file should be used: #include <WinDef.h>.</p></div>
<div class="balloon" rel="167"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v677/" target="_blank">V677</a> Custom declaration of a standard 'INT64' type. The system header file should be used: #include <BaseTsd.h>.</p></div>
<div class="balloon" rel="163"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v677/" target="_blank">V677</a> Custom declaration of a standard 'BYTE' type. The system header file should be used: #include <WinDef.h>.</p></div>
<div class="balloon" rel="162"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v677/" target="_blank">V677</a> Custom declaration of a standard 'BOOL' type. The system header file should be used: #include <WinDef.h>.</p></div>
<div class="balloon" rel="164"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v677/" target="_blank">V677</a> Custom declaration of a standard 'WORD' type. The system header file should be used: #include <WinDef.h>.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
