
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>HRMeshCommon.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#include &quot;HydraInternal.h&quot;</a>
<a name="ln2">#include &quot;HydraObjectManager.h&quot;</a>
<a name="ln3"> </a>
<a name="ln4">#include &quot;HydraVSGFExport.h&quot;</a>
<a name="ln5">#include &quot;HydraVSGFCompress.h&quot;</a>
<a name="ln6">#include &quot;HydraXMLHelpers.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;sstream&gt;</a>
<a name="ln10">#include &lt;fstream&gt;</a>
<a name="ln11">#include &lt;unordered_set&gt;</a>
<a name="ln12">#include &lt;unordered_map&gt;</a>
<a name="ln13">#include &lt;algorithm&gt;</a>
<a name="ln14"> </a>
<a name="ln15">extern HRObjectManager g_objManager;</a>
<a name="ln16"> </a>
<a name="ln17">#ifdef WIN32</a>
<a name="ln18">#undef min</a>
<a name="ln19">#undef max</a>
<a name="ln20">#endif</a>
<a name="ln21"> </a>
<a name="ln22"> </a>
<a name="ln23"> </a>
<a name="ln24">std::vector&lt; HydraLiteMath::float4&gt; getVerticesFromBBox(const BBox &amp;a_bbox)</a>
<a name="ln25">{</a>
<a name="ln26">  std::vector&lt; HydraLiteMath::float4&gt; verts;</a>
<a name="ln27"> </a>
<a name="ln28">  verts.emplace_back(HydraLiteMath::float4(a_bbox.x_min, a_bbox.y_min, a_bbox.z_min, 1.0f));</a>
<a name="ln29">  verts.emplace_back(HydraLiteMath::float4(a_bbox.x_min, a_bbox.y_min, a_bbox.z_max, 1.0f));</a>
<a name="ln30">  verts.emplace_back(HydraLiteMath::float4(a_bbox.x_min, a_bbox.y_max, a_bbox.z_max, 1.0f));</a>
<a name="ln31">  verts.emplace_back(HydraLiteMath::float4(a_bbox.x_min, a_bbox.y_max, a_bbox.z_min, 1.0f));</a>
<a name="ln32"> </a>
<a name="ln33">  verts.emplace_back(HydraLiteMath::float4(a_bbox.x_max, a_bbox.y_min, a_bbox.z_min, 1.0f));</a>
<a name="ln34">  verts.emplace_back(HydraLiteMath::float4(a_bbox.x_max, a_bbox.y_min, a_bbox.z_max, 1.0f));</a>
<a name="ln35">  verts.emplace_back(HydraLiteMath::float4(a_bbox.x_max, a_bbox.y_max, a_bbox.z_max, 1.0f));</a>
<a name="ln36">  verts.emplace_back(HydraLiteMath::float4(a_bbox.x_max, a_bbox.y_max, a_bbox.z_min, 1.0f));</a>
<a name="ln37"> </a>
<a name="ln38">  return verts;</a>
<a name="ln39">}</a>
<a name="ln40"> </a>
<a name="ln41">BBox createBBoxFromFloat4V(const std::vector&lt;HydraLiteMath::float4&gt; &amp;a_verts)</a>
<a name="ln42">{</a>
<a name="ln43">  BBox box;</a>
<a name="ln44"> </a>
<a name="ln45">  box.x_min = a_verts[0].x;</a>
<a name="ln46">  box.x_max = a_verts[0].x;</a>
<a name="ln47">  box.y_min = a_verts[0].y;</a>
<a name="ln48">  box.y_max = a_verts[0].y;</a>
<a name="ln49">  box.z_min = a_verts[0].z;</a>
<a name="ln50">  box.z_max = a_verts[0].z;</a>
<a name="ln51"> </a>
<a name="ln52">  for (int i = 1; i &lt; a_verts.size(); ++i)</a>
<a name="ln53">  {</a>
<a name="ln54">    float x = a_verts[i].x;</a>
<a name="ln55">    float y = a_verts[i].y;</a>
<a name="ln56">    float z = a_verts[i].z;</a>
<a name="ln57"> </a>
<a name="ln58">    box.x_min = x &lt; box.x_min ? x : box.x_min;</a>
<a name="ln59">    box.x_max = x &gt; box.x_max ? x : box.x_max;</a>
<a name="ln60"> </a>
<a name="ln61">    box.y_min = y &lt; box.y_min ? y : box.y_min;</a>
<a name="ln62">    box.y_max = y &gt; box.y_max ? y : box.y_max;</a>
<a name="ln63"> </a>
<a name="ln64">    box.z_min = z &lt; box.z_min ? z : box.z_min;</a>
<a name="ln65">    box.z_max = z &gt; box.z_max ? z : box.z_max;</a>
<a name="ln66">  }</a>
<a name="ln67"> </a>
<a name="ln68">  return box;</a>
<a name="ln69">}</a>
<a name="ln70"> </a>
<a name="ln71">BBox createBBoxFromFloatV(const std::vector&lt;float&gt; &amp;a_verts, int stride)</a>
<a name="ln72">{</a>
<a name="ln73">  BBox box;</a>
<a name="ln74"> </a>
<a name="ln75">  box.x_min = a_verts[0];</a>
<a name="ln76">  box.x_max = a_verts[0];</a>
<a name="ln77">  box.y_min = a_verts[1];</a>
<a name="ln78">  box.y_max = a_verts[1];</a>
<a name="ln79">  box.z_min = a_verts[2];</a>
<a name="ln80">  box.z_max = a_verts[2];</a>
<a name="ln81"> </a>
<a name="ln82">  for (int i = 4; i &lt; a_verts.size(); i += stride)</a>
<a name="ln83">  {</a>
<a name="ln84">    float x = a_verts[i + 0];</a>
<a name="ln85">    float y = a_verts[i + 1];</a>
<a name="ln86">    float z = a_verts[i + 2];</a>
<a name="ln87"> </a>
<a name="ln88">    box.x_min = x &lt; box.x_min ? x : box.x_min;</a>
<a name="ln89">    box.x_max = x &gt; box.x_max ? x : box.x_max;</a>
<a name="ln90"> </a>
<a name="ln91">    box.y_min = y &lt; box.y_min ? y : box.y_min;</a>
<a name="ln92">    box.y_max = y &gt; box.y_max ? y : box.y_max;</a>
<a name="ln93"> </a>
<a name="ln94">    box.z_min = z &lt; box.z_min ? z : box.z_min;</a>
<a name="ln95">    box.z_max = z &gt; box.z_max ? z : box.z_max;</a>
<a name="ln96">  }</a>
<a name="ln97"> </a>
<a name="ln98">  return box;</a>
<a name="ln99">}</a>
<a name="ln100"> </a>
<a name="ln101">BBox HRUtils::transformBBox(const BBox &amp;a_bbox, const float m[16])</a>
<a name="ln102">{</a>
<a name="ln103">  HydraLiteMath::float4x4 mat(m);</a>
<a name="ln104"> </a>
<a name="ln105">  return ::transformBBox(a_bbox, mat);</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">BBox transformBBox(const BBox &amp;a_bbox, const HydraLiteMath::float4x4 &amp;m)</a>
<a name="ln109">{</a>
<a name="ln110">  auto verts = getVerticesFromBBox(a_bbox);</a>
<a name="ln111"> </a>
<a name="ln112">  for(auto&amp; v : verts)</a>
<a name="ln113">    v = HydraLiteMath::mul(m, v);</a>
<a name="ln114"> </a>
<a name="ln115"> </a>
<a name="ln116">  return createBBoxFromFloat4V(verts);</a>
<a name="ln117">}</a>
<a name="ln118"> </a>
<a name="ln119">BBox mergeBBoxes(const BBox &amp;A, const BBox &amp;B)</a>
<a name="ln120">{</a>
<a name="ln121">  BBox C;</a>
<a name="ln122">  </a>
<a name="ln123">  C.x_min = A.x_min &lt; B.x_min ? A.x_min : B.x_min;</a>
<a name="ln124">  C.x_max = A.x_max &gt; B.x_max ? A.x_max : B.x_max;</a>
<a name="ln125"> </a>
<a name="ln126">  C.y_min = A.y_min &lt; B.y_min ? A.y_min : B.y_min;</a>
<a name="ln127">  C.y_max = A.y_max &gt; B.y_max ? A.y_max : B.y_max;</a>
<a name="ln128"> </a>
<a name="ln129">  C.z_min = A.z_min &lt; B.z_min ? A.z_min : B.z_min;</a>
<a name="ln130">  C.z_max = A.z_max &gt; B.z_max ? A.z_max : B.z_max;</a>
<a name="ln131"> </a>
<a name="ln132">  return C;</a>
<a name="ln133">}</a>
<a name="ln134"> </a>
<a name="ln135">std::string  ws2s(const std::wstring&amp; s);</a>
<a name="ln136"> </a>
<a name="ln137">struct MeshVSGF : public IHRMesh</a>
<a name="ln138">{</a>
<a name="ln139">  MeshVSGF(){}</a>
<a name="ln140">  MeshVSGF(size_t a_sz, size_t a_chId) : m_sizeInBytes(a_sz), m_chunkId(a_chId), m_vertNum(0),</a>
<a name="ln141">                                         m_indNum(0), m_bbox(BBox()), m_hasTangentOnLoad(true), m_hasNormalsOnLoad(true) { m_matDrawList.reserve(100); }</a>
<a name="ln142"> </a>
<a name="ln143">  uint64_t chunkId() const override { return uint64_t(m_chunkId); }</a>
<a name="ln144">  uint64_t offset (const wchar_t* a_arrayname) const override;</a>
<a name="ln145"> </a>
<a name="ln146">  uint64_t vertNum() const override { return m_vertNum; }</a>
<a name="ln147">  uint64_t indNum()  const override { return m_indNum;  }</a>
<a name="ln148"> </a>
<a name="ln149">  size_t DataSizeInBytes() const override { return m_sizeInBytes; }</a>
<a name="ln150">  size_t EstimatedDataSizeInBytes() const override</a>
<a name="ln151">  {</a>
<a name="ln152">    return m_vertNum*(sizeof(float)*4*3 + sizeof(float)*2) +</a>
<a name="ln153">           m_indNum*sizeof(int) + (m_indNum*sizeof(int))/3 +</a>
<a name="ln154">           sizeof(HydraGeomData::Header) + 1024;</a>
<a name="ln155">  }</a>
<a name="ln156">  </a>
<a name="ln157">  const void* GetData() const override</a>
<a name="ln158">  {</a>
<a name="ln159">    auto chunk = g_objManager.scnData.m_vbCache.chunk_at(m_chunkId);</a>
<a name="ln160"> </a>
<a name="ln161">    if(chunk.InMemory())</a>
<a name="ln162">    {</a>
<a name="ln163">      return chunk.GetMemoryNow();</a>
<a name="ln164">    }</a>
<a name="ln165">    else</a>
<a name="ln166">    {</a>
<a name="ln167">      const std::wstring location = ChunkName(chunk);</a>
<a name="ln168">      std::ifstream fin;</a>
<a name="ln169">      hr_ifstream_open(fin, location.c_str());</a>
<a name="ln170">      g_objManager.m_tempBuffer.resize(DataSizeInBytes()/sizeof(int) + 10); // #TODO: add lock flags for global buffer ... ?? may be ...</a>
<a name="ln171">      fin.read((char*)g_objManager.m_tempBuffer.data(), DataSizeInBytes());</a>
<a name="ln172">      fin.close();</a>
<a name="ln173">      return g_objManager.m_tempBuffer.data();</a>
<a name="ln174">    }</a>
<a name="ln175">  }</a>
<a name="ln176"> </a>
<a name="ln177">  BBox getBBox() const override { return m_bbox;}</a>
<a name="ln178">  </a>
<a name="ln179">  const std::vector&lt;HRBatchInfo&gt;&amp; MList() const override { return m_matDrawList; }</a>
<a name="ln180">  std::vector&lt;HRBatchInfo&gt;&amp;       MList() override { return m_matDrawList; }</a>
<a name="ln181">  </a>
<a name="ln182">  std::string MaterialNamesList() override</a>
<a name="ln183">  {</a>
<a name="ln184">    auto batchList = MList();</a>
<a name="ln185">    </a>
<a name="ln186">    std::stringstream strOut;</a>
<a name="ln187">    for(size_t i=0;i&lt;batchList.size();i++)</a>
<a name="ln188">    {</a>
<a name="ln189">      int matId = batchList[i].matId;</a>
<a name="ln190">    </a>
<a name="ln191">      if(matId &lt; 0)</a>
<a name="ln192">      {</a>
<a name="ln193">        strOut &lt;&lt; &quot;undefined;&quot;;</a>
<a name="ln194">        continue;</a>
<a name="ln195">      }</a>
<a name="ln196">    </a>
<a name="ln197">      HRMaterialRef matRef;</a>
<a name="ln198">      matRef.id = matId;</a>
<a name="ln199">    </a>
<a name="ln200">      auto* pMaterial = g_objManager.PtrById(matRef);</a>
<a name="ln201">      if(pMaterial == nullptr)</a>
<a name="ln202">      {</a>
<a name="ln203">        strOut &lt;&lt; &quot;undefined;&quot;;</a>
<a name="ln204">        continue;</a>
<a name="ln205">      }</a>
<a name="ln206">    </a>
<a name="ln207">      std::string matName = ws2s(pMaterial-&gt;name);</a>
<a name="ln208">      strOut &lt;&lt; matName.c_str() &lt;&lt; &quot;;&quot;;</a>
<a name="ln209">    }</a>
<a name="ln210">    return strOut.str();</a>
<a name="ln211">  }</a>
<a name="ln212">  </a>
<a name="ln213">  const std::unordered_map&lt;std::wstring, std::tuple&lt;std::wstring, size_t, size_t, int&gt; &gt;&amp; GetOffsAndSizeForAttrs() const override { return m_custAttrOffsAndSize; }</a>
<a name="ln214"> </a>
<a name="ln215">  size_t   m_sizeInBytes;</a>
<a name="ln216">  size_t   m_chunkId;</a>
<a name="ln217"> </a>
<a name="ln218">  size_t   m_vertNum;</a>
<a name="ln219">  size_t   m_indNum;</a>
<a name="ln220"> </a>
<a name="ln221">  std::vector&lt;HRBatchInfo&gt; m_matDrawList;</a>
<a name="ln222">  BBox m_bbox;</a>
<a name="ln223"> </a>
<a name="ln224">  bool m_hasTangentOnLoad;</a>
<a name="ln225">  bool m_hasNormalsOnLoad;</a>
<a name="ln226"> </a>
<a name="ln227">  std::unordered_map&lt;std::wstring, std::tuple&lt;std::wstring, size_t, size_t, int&gt; &gt; m_custAttrOffsAndSize;</a>
<a name="ln228">};</a>
<a name="ln229"> </a>
<a name="ln230"> </a>
<a name="ln231">uint64_t MeshVSGF::offset(const wchar_t* a_arrayname) const </a>
<a name="ln232">{</a>
<a name="ln233"> </a>
<a name="ln234">  const VSGFOffsets offsets = CalcOffsets(m_vertNum, m_indNum, m_hasTangentOnLoad, m_hasNormalsOnLoad);</a>
<a name="ln235">  </a>
<a name="ln236">  if (std::wstring(a_arrayname) == L&quot;pos&quot;)</a>
<a name="ln237">  {</a>
<a name="ln238">    return offsets.offsetPos;</a>
<a name="ln239">  }</a>
<a name="ln240">  else if (std::wstring(a_arrayname) == L&quot;norm&quot;)</a>
<a name="ln241">  {</a>
<a name="ln242">    return offsets.offsetNorm;</a>
<a name="ln243">  }</a>
<a name="ln244">  else if (std::wstring(a_arrayname) == L&quot;tan&quot;)</a>
<a name="ln245">  {</a>
<a name="ln246">    return offsets.offsetTang;</a>
<a name="ln247">  }</a>
<a name="ln248">  else if (std::wstring(a_arrayname) == L&quot;texc&quot;)</a>
<a name="ln249">  {</a>
<a name="ln250">    return offsets.offsetTexc;</a>
<a name="ln251">  }</a>
<a name="ln252">  else if (std::wstring(a_arrayname) == L&quot;ind&quot;)</a>
<a name="ln253">  {</a>
<a name="ln254">    return offsets.offsetInd;</a>
<a name="ln255">  }</a>
<a name="ln256">  else if (std::wstring(a_arrayname) == L&quot;mind&quot;)</a>
<a name="ln257">  {</a>
<a name="ln258">    return offsets.offsetMind;</a>
<a name="ln259">  }</a>
<a name="ln260">  else</a>
<a name="ln261">  {</a>
<a name="ln262">    return uint64_t (-1);</a>
<a name="ln263">  }</a>
<a name="ln264"> </a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">std::vector&lt;HRBatchInfo&gt; FormMatDrawListRLE(const std::vector&lt;uint32_t&gt;&amp; matIndices);</a>
<a name="ln268"> </a>
<a name="ln269">void HR_LoadVSGFCompressedBothHeaders(std::ifstream&amp; fin,</a>
<a name="ln270">                                      std::vector&lt;HRBatchInfo&gt;&amp; a_outBatchList, HydraGeomData::Header&amp; h1, HydraHeaderC&amp; h2);</a>
<a name="ln271"> </a>
<a name="ln272">struct MeshVSGFProxy : public MeshVSGF</a>
<a name="ln273">{</a>
<a name="ln274">  MeshVSGFProxy() : m_loaded(false) {}</a>
<a name="ln275">  MeshVSGFProxy(const wchar_t* a_vsgfPath)</a>
<a name="ln276">  {</a>
<a name="ln277">    m_loaded = ReadVSGFHeader(a_vsgfPath);</a>
<a name="ln278">  }</a>
<a name="ln279">  </a>
<a name="ln280">  std::string MaterialNamesList() override { return matNames; }</a>
<a name="ln281">  std::string matNames;</a>
<a name="ln282"> </a>
<a name="ln283">  bool m_loaded;</a>
<a name="ln284">  </a>
<a name="ln285">protected:</a>
<a name="ln286"> </a>
<a name="ln287">  bool ReadVSGFHeader(const wchar_t* a_fileName)</a>
<a name="ln288">  {</a>
<a name="ln289">    std::ifstream fin;</a>
<a name="ln290">    hr_ifstream_open(fin, a_fileName);</a>
<a name="ln291">    </a>
<a name="ln292">    if(!fin.is_open())</a>
<a name="ln293">    {</a>
<a name="ln294">      HrPrint(HR_SEVERITY_ERROR, L&quot;MeshVSGFProxy::ReadVSGFHeader, can't open file: &quot;, a_fileName);</a>
<a name="ln295">      return false;</a>
<a name="ln296">    }</a>
<a name="ln297">    </a>
<a name="ln298">    std::wstring fileName(a_fileName);</a>
<a name="ln299">    std::wstring ext = str_tail(fileName, 6);</a>
<a name="ln300"> </a>
<a name="ln301">    HydraGeomData::Header header;</a>
<a name="ln302"> </a>
<a name="ln303">    if(ext == L&quot;.vsgfc&quot;)</a>
<a name="ln304">    {</a>
<a name="ln305">      HydraHeaderC h2;</a>
<a name="ln306">      HR_LoadVSGFCompressedBothHeaders(fin,</a>
<a name="ln307">                                       m_matDrawList, header, h2);</a>
<a name="ln308">      m_vertNum     = header.verticesNum;</a>
<a name="ln309">      m_indNum      = header.indicesNum;</a>
<a name="ln310">      m_sizeInBytes = header.fileSizeInBytes;</a>
<a name="ln311">      m_chunkId     = size_t(-1);</a>
<a name="ln312"> </a>
<a name="ln313">      //#TODO: read file names list;</a>
<a name="ln314">      //</a>
<a name="ln315">      matNames.resize(h2.customDataSize);</a>
<a name="ln316">      fin.seekg(h2.customDataOffset, std::ios_base::beg);</a>
<a name="ln317">      fin.read ((char*)matNames.c_str(), h2.customDataSize);</a>
<a name="ln318">      fin.close();</a>
<a name="ln319">      </a>
<a name="ln320">      m_bbox.x_min = h2.boxMin[0];</a>
<a name="ln321">      m_bbox.y_min = h2.boxMin[1];</a>
<a name="ln322">      m_bbox.z_min = h2.boxMin[2];</a>
<a name="ln323">  </a>
<a name="ln324">      m_bbox.x_max = h2.boxMax[0];</a>
<a name="ln325">      m_bbox.y_max = h2.boxMax[1];</a>
<a name="ln326">      m_bbox.z_max = h2.boxMax[2];</a>
<a name="ln327">    }</a>
<a name="ln328">    else</a>
<a name="ln329">    {</a>
<a name="ln330">      fin.read((char*)&amp;header, sizeof(HydraGeomData::Header));</a>
<a name="ln331"> </a>
<a name="ln332">      m_vertNum     = header.verticesNum;</a>
<a name="ln333">      m_indNum      = header.indicesNum;</a>
<a name="ln334">      m_sizeInBytes = header.fileSizeInBytes;</a>
<a name="ln335">      m_chunkId     = size_t(-1);</a>
<a name="ln336"> </a>
<a name="ln337">      const bool hasNormalsOnLoad = ((header.flags &amp; HydraGeomData::HAS_NO_NORMALS) == 0);</a>
<a name="ln338">      const bool hasTangentOnLoad = ((header.flags &amp; HydraGeomData::HAS_TANGENT)    != 0);</a>
<a name="ln339">      const auto allOffsets       = CalcOffsets(header.verticesNum, header.indicesNum, hasTangentOnLoad, hasNormalsOnLoad);</a>
<a name="ln340">      const auto matIndOffset     = allOffsets.offsetMind;</a>
<a name="ln341"> </a>
<a name="ln342">      std::vector&lt;uint32_t&gt; matIndixes(m_indNum/3);</a>
<a name="ln343">      fin.seekg (matIndOffset);</a>
<a name="ln344">      fin.read((char*)matIndixes.data(), matIndixes.size()*sizeof(int));</a>
<a name="ln345">      fin.close();</a>
<a name="ln346"> </a>
<a name="ln347">      m_matDrawList = FormMatDrawListRLE(matIndixes);</a>
<a name="ln348">      //m_bbox;        // don't evaluate this for Proxy Object due to this is long operation</a>
<a name="ln349">    }</a>
<a name="ln350"> </a>
<a name="ln351">    m_hasNormalsOnLoad = ((header.flags &amp; HydraGeomData::HAS_NO_NORMALS) == 0);</a>
<a name="ln352">    m_hasTangentOnLoad = ((header.flags &amp; HydraGeomData::HAS_TANGENT)    != 0);</a>
<a name="ln353">    </a>
<a name="ln354">    return true;</a>
<a name="ln355">  }</a>
<a name="ln356"> </a>
<a name="ln357">  const void* GetData() const override  // yes, don;t try to get data of MeshVSGFProxy. Find another option.</a>
<a name="ln358">  {</a>
<a name="ln359">    return nullptr;</a>
<a name="ln360">  }</a>
<a name="ln361"> </a>
<a name="ln362">};</a>
<a name="ln363"> </a>
<a name="ln364">std::vector&lt;HRBatchInfo&gt; FormMatDrawListRLE(const std::vector&lt;uint32_t&gt;&amp; matIndices)</a>
<a name="ln365">{</a>
<a name="ln366">  std::vector&lt;HRBatchInfo&gt; matDrawList;</a>
<a name="ln367"> </a>
<a name="ln368">  if (matIndices.empty())</a>
<a name="ln369">    return matDrawList;</a>
<a name="ln370"> </a>
<a name="ln371">  matDrawList.reserve(matIndices.size() / 4);</a>
<a name="ln372"> </a>
<a name="ln373">  uint32_t tBegin = 0;</a>
<a name="ln374">  int32_t  tMatId = matIndices[0];</a>
<a name="ln375"> </a>
<a name="ln376">  for (size_t i = 0; i &lt; matIndices.size(); i++)</a>
<a name="ln377">  {</a>
<a name="ln378">    uint32_t mid = matIndices[i];</a>
<a name="ln379"> </a>
<a name="ln380">    if (matIndices[tBegin] != mid || (i == matIndices.size() - 1))</a>
<a name="ln381">    {</a>
<a name="ln382">      // append current tri sequence withe the same material id</a>
<a name="ln383">      //</a>
<a name="ln384">      HRBatchInfo elem = {0,0,0};</a>
<a name="ln385">      elem.matId    = tMatId;</a>
<a name="ln386">      elem.triBegin = tBegin;</a>
<a name="ln387">      elem.triEnd   = uint32_t(i);</a>
<a name="ln388"> </a>
<a name="ln389">      if (i == matIndices.size() - 1)</a>
<a name="ln390">        elem.triEnd = uint32_t(matIndices.size());</a>
<a name="ln391"> </a>
<a name="ln392">      matDrawList.push_back(elem);</a>
<a name="ln393"> </a>
<a name="ln394">      // save begin and material id for next  tri sequence withe the same material id</a>
<a name="ln395">      //</a>
<a name="ln396">      tBegin = elem.triEnd;</a>
<a name="ln397">      tMatId = mid;</a>
<a name="ln398">    }</a>
<a name="ln399">  }</a>
<a name="ln400"> </a>
<a name="ln401">  ////////////////////////////////////////////////////////////////////////////////// fix for last tringle</a>
<a name="ln402">  size_t last    = matIndices.size() - 1;</a>
<a name="ln403">  size_t preLast = matIndices.size() - 2;</a>
<a name="ln404"> </a>
<a name="ln405">  if(matIndices.size() == 1 &amp;&amp; matDrawList.size() == 0)</a>
<a name="ln406">  {</a>
<a name="ln407">    HRBatchInfo elem = {0,0,0};</a>
<a name="ln408">    elem.matId    = matIndices[0];</a>
<a name="ln409">    elem.triBegin = 0;</a>
<a name="ln410">    elem.triEnd   = 1;</a>
<a name="ln411">    matDrawList.push_back(elem);</a>
<a name="ln412">  }</a>
<a name="ln413">  else if (matIndices.size() &gt; 1 &amp;&amp; matIndices[last] != matIndices[preLast])</a>
<a name="ln414">  {</a>
<a name="ln415">    HRBatchInfo elem = {0,0,0};</a>
<a name="ln416">    elem.matId    = matIndices[last];</a>
<a name="ln417">    elem.triBegin = last;</a>
<a name="ln418">    elem.triEnd   = matIndices.size();</a>
<a name="ln419">    matDrawList.push_back(elem);</a>
<a name="ln420">  }</a>
<a name="ln421">  ////////////////////////////////////////////////////////////////////////////////// fix for last tringle</a>
<a name="ln422"> </a>
<a name="ln423">  return matDrawList;</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">std::shared_ptr&lt;IHRMesh&gt; HydraFactoryCommon::CreateVSGFFromSimpleInputMesh(HRMesh* pSysObj, bool a_saveCompressed)</a>
<a name="ln427">{</a>
<a name="ln428">  const auto&amp; input = pSysObj-&gt;m_input;</a>
<a name="ln429"> </a>
<a name="ln430">  if (input.matIndices.empty())</a>
<a name="ln431">  {</a>
<a name="ln432">    HrError(L&quot;CreateVSGFFromSimpleInputMesh: input.matIndices.size() == 0&quot;);</a>
<a name="ln433">    return nullptr;</a>
<a name="ln434">  }</a>
<a name="ln435"> </a>
<a name="ln436">  // put this all to linear memory chunk</a>
<a name="ln437">  //</a>
<a name="ln438">  HydraGeomData data;</a>
<a name="ln439"> </a>
<a name="ln440">  const size_t totalVertNumber     = input.verticesPos.size() / 4;</a>
<a name="ln441">  const size_t totalMeshTriIndices = input.triIndices.size();</a>
<a name="ln442"> </a>
<a name="ln443">  // sorting triIndices by matIndices</a>
<a name="ln444">  </a>
<a name="ln445">  const uint32_t* triIndices = input.triIndices.data();</a>
<a name="ln446">  const uint32_t* matIndices = input.matIndices.data();</a>
<a name="ln447"> </a>
<a name="ln448">  std::vector&lt;uint32_t&gt; sortedTriIndices;</a>
<a name="ln449">  std::vector&lt;uint32_t&gt; sortedMatIndices;</a>
<a name="ln450"> </a>
<a name="ln451">  if (g_objManager.m_sortTriIndices)</a>
<a name="ln452">  {</a>
<a name="ln453">    std::vector&lt;std::size_t&gt; tmp_vec;</a>
<a name="ln454">    for (std::size_t i = 0; i != input.matIndices.size(); ++i) { tmp_vec.push_back(i); }</a>
<a name="ln455"> </a>
<a name="ln456">    std::sort(</a>
<a name="ln457">      tmp_vec.begin(), tmp_vec.end(),</a>
<a name="ln458">      [&amp;](std::size_t a, std::size_t b) { return input.matIndices[a] &lt; input.matIndices[b]; });</a>
<a name="ln459"> </a>
<a name="ln460">    sortedTriIndices.resize(input.triIndices.size());</a>
<a name="ln461">    sortedMatIndices.resize(input.matIndices.size());</a>
<a name="ln462"> </a>
<a name="ln463">    for (int i = 0; i &lt; tmp_vec.size(); ++i)</a>
<a name="ln464">    {</a>
<a name="ln465">      sortedTriIndices.at(i * 3 + 0) = input.triIndices.at(tmp_vec.at(i) * 3 + 0);</a>
<a name="ln466">      sortedTriIndices.at(i * 3 + 1) = input.triIndices.at(tmp_vec.at(i) * 3 + 1);</a>
<a name="ln467">      sortedTriIndices.at(i * 3 + 2) = input.triIndices.at(tmp_vec.at(i) * 3 + 2);</a>
<a name="ln468"> </a>
<a name="ln469">      sortedMatIndices.at(i) = input.matIndices.at(tmp_vec.at(i));</a>
<a name="ln470">    }</a>
<a name="ln471">    triIndices = &amp;sortedTriIndices[0];</a>
<a name="ln472">    matIndices = &amp;sortedMatIndices[0];</a>
<a name="ln473">  }</a>
<a name="ln474"> </a>
<a name="ln475"> </a>
<a name="ln476">  // (1) common mesh attributes</a>
<a name="ln477">  //</a>
<a name="ln478">  data.setData(uint32_t(totalVertNumber), input.verticesPos.data(), input.verticesNorm.data(), input.verticesTangent.data(), input.verticesTexCoord.data(),</a>
<a name="ln479">               uint32_t(totalMeshTriIndices), triIndices, matIndices);</a>
<a name="ln480"> </a>
<a name="ln481">  const size_t totalByteSizeCommon = data.sizeInBytes();</a>
<a name="ln482"> </a>
<a name="ln483">  // (2) custom mesh attributes</a>
<a name="ln484">  //</a>
<a name="ln485">  size_t totalByteSizeCustom = 0;</a>
<a name="ln486"> </a>
<a name="ln487">  for (auto&amp; arr : pSysObj-&gt;m_input.customArrays)</a>
<a name="ln488">  {</a>
<a name="ln489">    if (!arr.fdata.empty())</a>
<a name="ln490">      totalByteSizeCustom += arr.fdata.size() * sizeof(float);</a>
<a name="ln491">    else</a>
<a name="ln492">      totalByteSizeCustom += arr.idata.size() * sizeof(int);</a>
<a name="ln493">  }</a>
<a name="ln494"> </a>
<a name="ln495">  const size_t totalByteSize = totalByteSizeCommon + totalByteSizeCustom;</a>
<a name="ln496">  const size_t chunkId       = g_objManager.scnData.m_vbCache.AllocChunk(totalByteSize, pSysObj-&gt;id);</a>
<a name="ln497">   </a>
<a name="ln498">  if (chunkId == size_t(-1))</a>
<a name="ln499">  {</a>
<a name="ln500">    HrError(L&quot;HydraFactoryCommon::CreateVSGFFromSimpleInputMesh, out of memory, failed to allocate large chunk&quot;);</a>
<a name="ln501">    return nullptr;</a>
<a name="ln502">  }</a>
<a name="ln503"> </a>
<a name="ln504">  auto&amp; chunk          = g_objManager.scnData.m_vbCache.chunk_at(chunkId);</a>
<a name="ln505">  chunk.type           = CHUNK_TYPE_VSGF;</a>
<a name="ln506">  chunk.saveCompressed = a_saveCompressed;  // we need to remember this info inside chunk to enable compressed mesh save</a>
<a name="ln507">  chunk.sysObjectId    = pSysObj-&gt;id;       // and plug xml description inside a file also;</a>
<a name="ln508">  </a>
<a name="ln509">  char* memory = (char*)chunk.GetMemoryNow();</a>
<a name="ln510"> </a>
<a name="ln511">  if (memory == nullptr)</a>
<a name="ln512">  {</a>
<a name="ln513">    HrError(L&quot;HydraFactoryCommon::CreateVSGFFromSimpleInputMesh, out of memory, unknown error&quot;);</a>
<a name="ln514">    return nullptr;</a>
<a name="ln515">  }</a>
<a name="ln516">  </a>
<a name="ln517">  std::shared_ptr&lt;MeshVSGF&gt; pMeshImpl = std::make_shared&lt;MeshVSGF&gt;(totalByteSize, chunkId);</a>
<a name="ln518"> </a>
<a name="ln519">  // (1) common mesh attributes</a>
<a name="ln520">  //</a>
<a name="ln521">  data.writeToMemory(memory);</a>
<a name="ln522"> </a>
<a name="ln523">  // (2) custom mesh attributes</a>
<a name="ln524">  //</a>
<a name="ln525">  size_t currOffset = totalByteSizeCommon;</a>
<a name="ln526">  for (const auto&amp; arr : pSysObj-&gt;m_input.customArrays)</a>
<a name="ln527">  {</a>
<a name="ln528">    std::wstring type = L&quot;&quot;;</a>
<a name="ln529"> </a>
<a name="ln530">    size_t currSize = 0;</a>
<a name="ln531">    if (!arr.fdata.empty())</a>
<a name="ln532">    {</a>
<a name="ln533">      currSize = arr.fdata.size() * sizeof(float);</a>
<a name="ln534">      memcpy(memory + currOffset, &amp;arr.fdata[0], currSize);</a>
<a name="ln535"> </a>
<a name="ln536">      if (arr.depth == 4)</a>
<a name="ln537">        type = L&quot;array4f&quot;;</a>
<a name="ln538">      else if(arr.depth == 2)</a>
<a name="ln539">        type = L&quot;array2f&quot;;</a>
<a name="ln540">      else</a>
<a name="ln541">        type = L&quot;array1f&quot;;</a>
<a name="ln542">    }</a>
<a name="ln543">    else</a>
<a name="ln544">    {</a>
<a name="ln545">      currSize = arr.idata.size() * sizeof(int);</a>
<a name="ln546">      memcpy(memory + currOffset, &amp;arr.idata[0], currSize);</a>
<a name="ln547"> </a>
<a name="ln548">      if (arr.depth == 4)</a>
<a name="ln549">        type = L&quot;array4i&quot;;</a>
<a name="ln550">      else if (arr.depth == 2)</a>
<a name="ln551">        type = L&quot;array2i&quot;;</a>
<a name="ln552">      else</a>
<a name="ln553">        type = L&quot;array1i&quot;;</a>
<a name="ln554">    }</a>
<a name="ln555"> </a>
<a name="ln556">    pMeshImpl-&gt;m_custAttrOffsAndSize[arr.name] = std::tuple&lt;std::wstring, size_t, size_t, int&gt;(type, currOffset, currSize, arr.apply);</a>
<a name="ln557">    currOffset += currSize;</a>
<a name="ln558">  }</a>
<a name="ln559"> </a>
<a name="ln560">  pMeshImpl-&gt;m_vertNum = totalVertNumber;</a>
<a name="ln561">  pMeshImpl-&gt;m_indNum  = totalMeshTriIndices;</a>
<a name="ln562"> </a>
<a name="ln563">  //compute bbox</a>
<a name="ln564">  if (g_objManager.m_computeBBoxes)</a>
<a name="ln565">  {</a>
<a name="ln566">    BBox box;</a>
<a name="ln567">    box.x_min = std::numeric_limits&lt;float&gt;::max();</a>
<a name="ln568">    box.x_max = std::numeric_limits&lt;float&gt;::lowest();</a>
<a name="ln569">    box.y_min = std::numeric_limits&lt;float&gt;::max();</a>
<a name="ln570">    box.y_max = std::numeric_limits&lt;float&gt;::lowest();</a>
<a name="ln571">    box.z_min = std::numeric_limits&lt;float&gt;::max();</a>
<a name="ln572">    box.z_max = std::numeric_limits&lt;float&gt;::lowest();</a>
<a name="ln573">    for (int i = 0; i &lt; input.verticesPos.size(); i += 4)</a>
<a name="ln574">    {</a>
<a name="ln575">      float x = input.verticesPos[i + 0];</a>
<a name="ln576">      float y = input.verticesPos[i + 1];</a>
<a name="ln577">      float z = input.verticesPos[i + 2];</a>
<a name="ln578"> </a>
<a name="ln579">      box.x_min = x &lt; box.x_min ? x : box.x_min;</a>
<a name="ln580">      box.x_max = x &gt; box.x_max ? x : box.x_max;</a>
<a name="ln581"> </a>
<a name="ln582">      box.y_min = y &lt; box.y_min ? y : box.y_min;</a>
<a name="ln583">      box.y_max = y &gt; box.y_max ? y : box.y_max;</a>
<a name="ln584"> </a>
<a name="ln585">      box.z_min = z &lt; box.z_min ? z : box.z_min;</a>
<a name="ln586">      box.z_max = z &gt; box.z_max ? z : box.z_max;</a>
<a name="ln587">    }</a>
<a name="ln588">    pMeshImpl-&gt;m_bbox = box;</a>
<a name="ln589">  }</a>
<a name="ln590"> </a>
<a name="ln591"> </a>
<a name="ln592">  if (g_objManager.m_sortTriIndices)</a>
<a name="ln593">    pMeshImpl-&gt;m_matDrawList = FormMatDrawListRLE(sortedMatIndices);</a>
<a name="ln594">  else</a>
<a name="ln595">    pMeshImpl-&gt;m_matDrawList = FormMatDrawListRLE(input.matIndices);</a>
<a name="ln596"> </a>
<a name="ln597">  return pMeshImpl;</a>
<a name="ln598">}</a>
<a name="ln599"> </a>
<a name="ln600">std::shared_ptr&lt;IHRMesh&gt; HydraFactoryCommon::CreateVSGFFromFile(HRMesh* pSysObj, const std::wstring&amp; a_fileName, pugi::xml_node a_node)</a>
<a name="ln601">{</a>
<a name="ln602">  const int64_t totalByteSize = a_node.attribute(L&quot;bytesize&quot;).as_llong();</a>
<a name="ln603"> </a>
<a name="ln604">  if(totalByteSize &lt;= 0)</a>
<a name="ln605">    return nullptr;</a>
<a name="ln606"> </a>
<a name="ln607">  std::shared_ptr&lt;MeshVSGF&gt; pMeshImpl = std::make_shared&lt;MeshVSGF&gt;(totalByteSize, -1);</a>
<a name="ln608">  pMeshImpl-&gt;m_vertNum     = a_node.attribute(L&quot;vertNum&quot;).as_int();</a>
<a name="ln609">  pMeshImpl-&gt;m_indNum      = a_node.attribute(L&quot;triNum&quot;).as_int()*3;</a>
<a name="ln610">  pMeshImpl-&gt;m_chunkId     = ChunkIdFromFileName(a_fileName.c_str());</a>
<a name="ln611">  </a>
<a name="ln612">  pugi::xml_node mindicesNode = a_node.child(L&quot;matindices&quot;);</a>
<a name="ln613">  if(mindicesNode == nullptr)</a>
<a name="ln614">    mindicesNode = a_node.child(L&quot;mindices&quot;);</a>
<a name="ln615"> </a>
<a name="ln616">  const int64_t moffset = mindicesNode.attribute(L&quot;offset&quot;).as_llong();</a>
<a name="ln617">  const int64_t msize   = mindicesNode.attribute(L&quot;bytesize&quot;).as_llong();</a>
<a name="ln618"> </a>
<a name="ln619">  std::vector&lt;uint32_t&gt; mindices(a_node.attribute(L&quot;triNum&quot;).as_int());</a>
<a name="ln620"> </a>
<a name="ln621">  size_t totalChunks = g_objManager.scnData.m_vbCache.size();</a>
<a name="ln622">  </a>
<a name="ln623">  ChunkPointer chunk;</a>
<a name="ln624">  if(g_objManager.m_attachMode &amp;&amp; pMeshImpl-&gt;m_chunkId &gt;= 0 &amp;&amp; pMeshImpl-&gt;m_chunkId &lt; totalChunks)</a>
<a name="ln625">    chunk = g_objManager.scnData.m_vbCache.chunk_at(pMeshImpl-&gt;m_chunkId);</a>
<a name="ln626">  </a>
<a name="ln627">  if(chunk.InMemory())</a>
<a name="ln628">  {</a>
<a name="ln629">    const char* data = (const char*)chunk.GetMemoryNow();</a>
<a name="ln630">    memcpy(mindices.data(), data + moffset, msize);</a>
<a name="ln631">  }</a>
<a name="ln632">  else</a>
<a name="ln633">  {</a>
<a name="ln634">  #ifdef WIN32</a>
<a name="ln635">    std::ifstream fin(a_fileName.c_str(), std::ios::binary);</a>
<a name="ln636">  #else</a>
<a name="ln637">    std::string fileIn(a_fileName.begin(), a_fileName.end());</a>
<a name="ln638">    std::ifstream fin(fileIn.c_str(), std::ios::binary);</a>
<a name="ln639">  #endif</a>
<a name="ln640">    fin.seekg(moffset);</a>
<a name="ln641">    fin.read((char*)mindices.data(), msize);</a>
<a name="ln642">    fin.close();</a>
<a name="ln643">  }</a>
<a name="ln644">  </a>
<a name="ln645">  pMeshImpl-&gt;m_matDrawList = FormMatDrawListRLE(mindices);</a>
<a name="ln646"> </a>
<a name="ln647">  BBox bbox;</a>
<a name="ln648">  HydraXMLHelpers::ReadBBox(a_node, bbox);</a>
<a name="ln649">  pMeshImpl-&gt;m_bbox = bbox;</a>
<a name="ln650"> </a>
<a name="ln651">  return pMeshImpl;</a>
<a name="ln652">}</a>
<a name="ln653"> </a>
<a name="ln654">std::shared_ptr&lt;IHRMesh&gt; HydraFactoryCommon::CreateVSGFProxy(const wchar_t* a_fileName)</a>
<a name="ln655">{</a>
<a name="ln656">  std::shared_ptr&lt;MeshVSGFProxy&gt; pImpl = std::make_shared&lt;MeshVSGFProxy&gt;(a_fileName);</a>
<a name="ln657">  if(!pImpl-&gt;m_loaded)</a>
<a name="ln658">    return nullptr;</a>
<a name="ln659">  return pImpl;</a>
<a name="ln660">}</a>

</code></pre>
<div class="balloon" rel="139"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: m_sizeInBytes, m_chunkId, m_vertNum, m_indNum, m_hasTangentOnLoad, m_hasNormalsOnLoad.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
