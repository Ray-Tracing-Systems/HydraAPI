
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>HRTextureCommon.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#include &quot;HydraInternal.h&quot;</a>
<a name="ln2">#include &quot;HydraObjectManager.h&quot;</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;fstream&gt;</a>
<a name="ln5"> </a>
<a name="ln6">///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln7">///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;cstdio&gt;</a>
<a name="ln10">#include &lt;cwchar&gt;</a>
<a name="ln11"> </a>
<a name="ln12">#pragma warning(disable:4996)</a>
<a name="ln13"> </a>
<a name="ln14">#if defined(WIN32)</a>
<a name="ln15">  #include &quot;FreeImage.h&quot;</a>
<a name="ln16">  #pragma comment(lib, &quot;FreeImage.lib&quot;)</a>
<a name="ln17">#else</a>
<a name="ln18">  #include &lt;FreeImage.h&gt;</a>
<a name="ln19">#endif</a>
<a name="ln20"> </a>
<a name="ln21">extern HRObjectManager g_objManager;</a>
<a name="ln22"> </a>
<a name="ln23">size_t IHRTextureNode::DataSizeInBytes() const</a>
<a name="ln24">{</a>
<a name="ln25">  return size_t(width()*height())*size_t(bpp());</a>
<a name="ln26">}</a>
<a name="ln27"> </a>
<a name="ln28">bool IHRTextureNode::ReadDataFromChunkTo(std::vector&lt;int&gt;&amp; a_dataConteiner)</a>
<a name="ln29">{</a>
<a name="ln30">  auto chunk = g_objManager.scnData.m_vbCache.chunk_at(chunkId());</a>
<a name="ln31"> </a>
<a name="ln32">  auto sizeInInts = DataSizeInBytes() / sizeof(int) + 1;</a>
<a name="ln33">  if (a_dataConteiner.size() &lt; sizeInInts)</a>
<a name="ln34">    a_dataConteiner.resize(sizeInInts);</a>
<a name="ln35"> </a>
<a name="ln36">  // copy from memory</a>
<a name="ln37">  //</a>
<a name="ln38">  if (chunk.InMemory())</a>
<a name="ln39">  {</a>
<a name="ln40">    char* data = (char*)chunk.GetMemoryNow();</a>
<a name="ln41">    if (data != nullptr)</a>
<a name="ln42">    {</a>
<a name="ln43">      memcpy(a_dataConteiner.data(), data + sizeof(int)*2, DataSizeInBytes());</a>
<a name="ln44">      return true;</a>
<a name="ln45">    }</a>
<a name="ln46">  }</a>
<a name="ln47"> </a>
<a name="ln48">  // if fail then try to load from file</a>
<a name="ln49">  //</a>
<a name="ln50">  std::wstring locPath = g_objManager.scnData.m_path + std::wstring(L&quot;/&quot;) + ChunkName(chunk);</a>
<a name="ln51"> </a>
<a name="ln52">  InternalImageTool chunkLoader;</a>
<a name="ln53"> </a>
<a name="ln54">  int w, h, bpp;</a>
<a name="ln55">  return chunkLoader.LoadImageFromFile(locPath.c_str(), </a>
<a name="ln56">                                       w, h, bpp, a_dataConteiner);</a>
<a name="ln57">}</a>
<a name="ln58"> </a>
<a name="ln59">const void* IHRTextureNode::GetData() const</a>
<a name="ln60">{</a>
<a name="ln61">  if(chunkId() &gt;= g_objManager.scnData.m_vbCache.size())</a>
<a name="ln62">    return nullptr;</a>
<a name="ln63">  </a>
<a name="ln64">  auto chunk = g_objManager.scnData.m_vbCache.chunk_at(chunkId());</a>
<a name="ln65">  if (!chunk.InMemory())</a>
<a name="ln66">    return nullptr;</a>
<a name="ln67"> </a>
<a name="ln68">  const char* ptr = (const char*)chunk.GetMemoryNow();</a>
<a name="ln69">  if (ptr == nullptr)</a>
<a name="ln70">    return nullptr;</a>
<a name="ln71"> </a>
<a name="ln72">  return (ptr + 2 * sizeof(int));</a>
<a name="ln73">}</a>
<a name="ln74"> </a>
<a name="ln75">///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln76">///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln77"> </a>
<a name="ln78">struct BitmapLDRNode : public IHRTextureNode</a>
<a name="ln79">{</a>
<a name="ln80">  BitmapLDRNode(uint32_t w, uint32_t h, size_t a_sz, size_t a_chId) : m_width(w), m_height(h), m_sizeInBytes(a_sz), m_chunkId(a_chId) {}</a>
<a name="ln81"> </a>
<a name="ln82">  uint64_t chunkId() const override { return uint64_t(m_chunkId); }</a>
<a name="ln83">  uint32_t width()   const override { return m_width; }</a>
<a name="ln84">  uint32_t height()  const override { return m_height; }</a>
<a name="ln85">  uint32_t bpp()     const override { return 4; }</a>
<a name="ln86"> </a>
<a name="ln87">  uint32_t m_width;</a>
<a name="ln88">  uint32_t m_height;</a>
<a name="ln89">  size_t   m_sizeInBytes;</a>
<a name="ln90">  size_t   m_chunkId;</a>
<a name="ln91">};</a>
<a name="ln92"> </a>
<a name="ln93">struct BitmapHDRNode : public IHRTextureNode</a>
<a name="ln94">{</a>
<a name="ln95">  BitmapHDRNode(uint32_t w, uint32_t h, size_t a_sz, size_t a_chId) : m_width(w), m_height(h), m_sizeInBytes(a_sz), m_chunkId(a_chId) {}</a>
<a name="ln96"> </a>
<a name="ln97">  uint64_t chunkId() const override { return uint64_t(m_chunkId); }</a>
<a name="ln98">  uint32_t width()   const override { return m_width; }</a>
<a name="ln99">  uint32_t height()  const override { return m_height; }</a>
<a name="ln100">  uint32_t bpp()     const override { return 16; }</a>
<a name="ln101"> </a>
<a name="ln102">  uint32_t m_width;</a>
<a name="ln103">  uint32_t m_height;</a>
<a name="ln104">  size_t   m_sizeInBytes;</a>
<a name="ln105">  size_t   m_chunkId;</a>
<a name="ln106">};</a>
<a name="ln107"> </a>
<a name="ln108">struct BitmapProxy : public IHRTextureNode</a>
<a name="ln109">{</a>
<a name="ln110">  BitmapProxy(uint32_t w, uint32_t h, size_t a_sz, size_t a_chId) : m_width(w), m_height(h), m_sizeInBytes(a_sz), m_chunkId(a_chId), m_bytesPerPixel(4) {}</a>
<a name="ln111"> </a>
<a name="ln112">  uint64_t chunkId() const override { return uint64_t(m_chunkId); }</a>
<a name="ln113">  uint32_t width()   const override { return m_width; }</a>
<a name="ln114">  uint32_t height()  const override { return m_height; }</a>
<a name="ln115">  uint32_t bpp()     const override { return 4; }</a>
<a name="ln116"> </a>
<a name="ln117">  uint32_t     m_width;</a>
<a name="ln118">  uint32_t     m_height;</a>
<a name="ln119">  size_t       m_sizeInBytes;</a>
<a name="ln120">  size_t       m_chunkId;</a>
<a name="ln121">  int          m_bytesPerPixel;</a>
<a name="ln122">  std::wstring fileName;</a>
<a name="ln123">};</a>
<a name="ln124"> </a>
<a name="ln125">///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln126">///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln127"> </a>
<a name="ln128">std::shared_ptr&lt;IHRTextureNode&gt; HydraFactoryCommon::CreateTexture2DFromMemory(HRTextureNode* pSysObj, int width, int height, int bpp, const void* a_data)</a>
<a name="ln129">{</a>
<a name="ln130">  const size_t textureSizeInBytes     = size_t(width)*size_t(height)*size_t(bpp);</a>
<a name="ln131">  const size_t totalByteSizeOfTexture = textureSizeInBytes + size_t(2 * sizeof(unsigned int));</a>
<a name="ln132">  </a>
<a name="ln133">  const size_t chunkId                = g_objManager.scnData.m_vbCache.AllocChunk(totalByteSizeOfTexture, pSysObj-&gt;id);</a>
<a name="ln134"> </a>
<a name="ln135">  if (chunkId == size_t(-1))</a>
<a name="ln136">  {</a>
<a name="ln137">    HrError(L&quot;HydraFactoryCommon::CreateTexture2DFromMemory, out of memory, failed to allocate large chunk&quot;);</a>
<a name="ln138">    return nullptr;</a>
<a name="ln139">  }</a>
<a name="ln140"> </a>
<a name="ln141">  auto&amp; chunk         = g_objManager.scnData.m_vbCache.chunk_at(chunkId);</a>
<a name="ln142">  chunk.type          = (bpp &lt;= 4) ? CHUNK_TYPE_IMAGE4UB : CHUNK_TYPE_IMAGE4F;</a>
<a name="ln143">  unsigned char* data = (unsigned char*)chunk.GetMemoryNow();</a>
<a name="ln144"> </a>
<a name="ln145">  if (data == nullptr)</a>
<a name="ln146">  {</a>
<a name="ln147">    HrError(L&quot;HydraFactoryCommon::CreateTexture2DFromMemory, out of memory unknown error&quot;);</a>
<a name="ln148">    return nullptr;</a>
<a name="ln149">  }</a>
<a name="ln150"> </a>
<a name="ln151">  unsigned int* pW = (unsigned int*)data;</a>
<a name="ln152">  unsigned int* pH = pW+1;</a>
<a name="ln153"> </a>
<a name="ln154">  (*pW) = width;</a>
<a name="ln155">  (*pH) = height;</a>
<a name="ln156"> </a>
<a name="ln157">  data += 2*sizeof(unsigned int);</a>
<a name="ln158"> </a>
<a name="ln159">  memcpy(data, a_data, textureSizeInBytes);</a>
<a name="ln160"> </a>
<a name="ln161">  std::shared_ptr&lt;BitmapLDRNode&gt; p1 = std::make_shared&lt;BitmapLDRNode&gt;(width, height, totalByteSizeOfTexture, chunkId);</a>
<a name="ln162">  std::shared_ptr&lt;BitmapHDRNode&gt; p2 = std::make_shared&lt;BitmapHDRNode&gt;(width, height, totalByteSizeOfTexture, chunkId);</a>
<a name="ln163"> </a>
<a name="ln164">  std::shared_ptr&lt;IHRTextureNode&gt; p11 = p1;</a>
<a name="ln165">  std::shared_ptr&lt;IHRTextureNode&gt; p22 = p2;</a>
<a name="ln166"> </a>
<a name="ln167">  return (bpp &lt;= 4) ? p11 : p22;</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln171">///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln172"> </a>
<a name="ln173">std::shared_ptr&lt;IHRTextureNode&gt; CreateTexture2D_WithImageTool(HRTextureNode* pSysObj, const std::wstring&amp; a_fileName)</a>
<a name="ln174">{</a>
<a name="ln175">  // load image from file</a>
<a name="ln176">  //</a>
<a name="ln177">  const wchar_t* filename = a_fileName.c_str();</a>
<a name="ln178"> </a>
<a name="ln179">  int width, height, bpp;</a>
<a name="ln180">  bool loaded = g_objManager.m_pImgTool-&gt;LoadImageFromFile(filename, </a>
<a name="ln181">                                                           width, height, bpp, g_objManager.m_tempBuffer);</a>
<a name="ln182">  </a>
<a name="ln183">  if (!loaded)</a>
<a name="ln184">    return nullptr;</a>
<a name="ln185"> </a>
<a name="ln186">  const size_t totalByteSizeOfTexture = size_t(width*height)*size_t(bpp) + size_t(2)*sizeof(unsigned int);</a>
<a name="ln187"> </a>
<a name="ln188">  // now put image data directly to cache ... </a>
<a name="ln189">  //</a>
<a name="ln190">  size_t chunkId = g_objManager.scnData.m_vbCache.AllocChunk(totalByteSizeOfTexture, pSysObj-&gt;id);</a>
<a name="ln191">  auto&amp; chunk    = g_objManager.scnData.m_vbCache.chunk_at(chunkId);</a>
<a name="ln192">  chunk.type     = (bpp &lt;= 4) ? CHUNK_TYPE_IMAGE4UB : CHUNK_TYPE_IMAGE4F;</a>
<a name="ln193"> </a>
<a name="ln194">  //unsigned char* data = new unsigned char[size];</a>
<a name="ln195">  char* data = (char*)chunk.GetMemoryNow();</a>
<a name="ln196">  if (data == nullptr)</a>
<a name="ln197">  {</a>
<a name="ln198">    std::shared_ptr&lt;BitmapProxy&gt; p = std::make_shared&lt;BitmapProxy&gt;(width, height, totalByteSizeOfTexture, chunkId); //#TODO: return nullptr here?</a>
<a name="ln199">    p-&gt;fileName        = a_fileName;</a>
<a name="ln200">    p-&gt;m_bytesPerPixel = bpp;</a>
<a name="ln201">    return p;</a>
<a name="ln202">  }</a>
<a name="ln203"> </a>
<a name="ln204">  unsigned int* pW = (unsigned int*)data;</a>
<a name="ln205">  unsigned int* pH = pW + 1;</a>
<a name="ln206">  data += 2 * sizeof(unsigned int);</a>
<a name="ln207"> </a>
<a name="ln208">  memcpy(data, g_objManager.m_tempBuffer.data(), size_t(width*height)*size_t(bpp));</a>
<a name="ln209"> </a>
<a name="ln210">  if (g_objManager.m_tempBuffer.size() &gt; TEMP_BUFFER_MAX_SIZE_DONT_FREE)</a>
<a name="ln211">    g_objManager.m_tempBuffer = g_objManager.EmptyBuffer();</a>
<a name="ln212"> </a>
<a name="ln213">  (*pW) = width;</a>
<a name="ln214">  (*pH) = height;</a>
<a name="ln215"> </a>
<a name="ln216">  // return resulting object</a>
<a name="ln217">  //</a>
<a name="ln218">  std::shared_ptr&lt;BitmapLDRNode&gt; p1 = std::make_shared&lt;BitmapLDRNode&gt;(width, height, totalByteSizeOfTexture, chunkId);</a>
<a name="ln219">  std::shared_ptr&lt;BitmapHDRNode&gt; p2 = std::make_shared&lt;BitmapHDRNode&gt;(width, height, totalByteSizeOfTexture, chunkId);</a>
<a name="ln220"> </a>
<a name="ln221">  std::shared_ptr&lt;IHRTextureNode&gt; p11 = p1;</a>
<a name="ln222">  std::shared_ptr&lt;IHRTextureNode&gt; p22 = p2;</a>
<a name="ln223"> </a>
<a name="ln224">  return (bpp == 4) ? p11 : p22;</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227">std::shared_ptr&lt;IHRTextureNode&gt; CreateTexture2DImage4UB(HRTextureNode* pSysObj, const std::wstring&amp; a_fileName)</a>
<a name="ln228">{</a>
<a name="ln229">  std::string m_fileName(a_fileName.begin(), a_fileName.end());</a>
<a name="ln230">  std::ifstream fin(m_fileName.c_str(), std::ios::binary);</a>
<a name="ln231"> </a>
<a name="ln232">  if (!fin.is_open())</a>
<a name="ln233">    return nullptr;</a>
<a name="ln234"> </a>
<a name="ln235">  unsigned int width = 0;</a>
<a name="ln236">  unsigned int height = 0;</a>
<a name="ln237"> </a>
<a name="ln238">  fin.read((char*)&amp;width, sizeof(unsigned int));</a>
<a name="ln239">  fin.read((char*)&amp;height, sizeof(unsigned int));</a>
<a name="ln240"> </a>
<a name="ln241">  size_t totalByteSizeOfTexture = size_t(width)*size_t(height)*size_t(sizeof(char)*4);</a>
<a name="ln242">  totalByteSizeOfTexture += size_t(2 * sizeof(unsigned int));</a>
<a name="ln243"> </a>
<a name="ln244">  size_t chunkId = g_objManager.scnData.m_vbCache.AllocChunk(totalByteSizeOfTexture, pSysObj-&gt;id);</a>
<a name="ln245">  auto&amp; chunk    = g_objManager.scnData.m_vbCache.chunk_at(chunkId);</a>
<a name="ln246">  chunk.type     = CHUNK_TYPE_IMAGE4UB;</a>
<a name="ln247"> </a>
<a name="ln248">  char* data = (char*)chunk.GetMemoryNow();</a>
<a name="ln249">  if (data == nullptr)</a>
<a name="ln250">  {</a>
<a name="ln251"> </a>
<a name="ln252">    std::shared_ptr&lt;BitmapProxy&gt; p = std::make_shared&lt;BitmapProxy&gt;(width, height, totalByteSizeOfTexture, chunkId); //#TODO: return nullptr here?</a>
<a name="ln253">    p-&gt;fileName        = a_fileName;</a>
<a name="ln254">    p-&gt;m_bytesPerPixel = 4;</a>
<a name="ln255">    return p;</a>
<a name="ln256">  }</a>
<a name="ln257"> </a>
<a name="ln258">  unsigned int* pW = (unsigned int*)data;</a>
<a name="ln259">  unsigned int* pH = pW + 1;</a>
<a name="ln260">  data += 2 * sizeof(unsigned int);</a>
<a name="ln261"> </a>
<a name="ln262">  (*pW) = width;</a>
<a name="ln263">  (*pH) = height;</a>
<a name="ln264"> </a>
<a name="ln265">  fin.read(data, size_t(width)*size_t(height)*size_t(sizeof(char)*4));</a>
<a name="ln266"> </a>
<a name="ln267">  fin.close();</a>
<a name="ln268"> </a>
<a name="ln269">  std::shared_ptr&lt;BitmapLDRNode&gt; p1 = std::make_shared&lt;BitmapLDRNode&gt;(width, height, totalByteSizeOfTexture, chunkId);</a>
<a name="ln270"> </a>
<a name="ln271">  std::shared_ptr&lt;IHRTextureNode&gt; p11 = p1;</a>
<a name="ln272"> </a>
<a name="ln273">  return p11;</a>
<a name="ln274">}</a>
<a name="ln275"> </a>
<a name="ln276">std::shared_ptr&lt;IHRTextureNode&gt; CreateTexture2DImage4F(HRTextureNode* pSysObj, const std::wstring&amp; a_fileName)</a>
<a name="ln277">{</a>
<a name="ln278">  std::string m_fileName(a_fileName.begin(), a_fileName.end());</a>
<a name="ln279">  std::ifstream fin(m_fileName.c_str(), std::ios::binary);</a>
<a name="ln280"> </a>
<a name="ln281">  if (!fin.is_open())</a>
<a name="ln282">    return nullptr;</a>
<a name="ln283"> </a>
<a name="ln284">  unsigned int width = 0;</a>
<a name="ln285">  unsigned int height = 0;</a>
<a name="ln286"> </a>
<a name="ln287">  fin.read((char*)&amp;width, sizeof(unsigned int));</a>
<a name="ln288">  fin.read((char*)&amp;height, sizeof(unsigned int));</a>
<a name="ln289"> </a>
<a name="ln290">  size_t totalByteSizeOfTexture = size_t(width)*size_t(height)*size_t(sizeof(float) * 4);</a>
<a name="ln291">  totalByteSizeOfTexture += size_t(2 * sizeof(unsigned int));</a>
<a name="ln292"> </a>
<a name="ln293">  size_t chunkId = g_objManager.scnData.m_vbCache.AllocChunk(totalByteSizeOfTexture, pSysObj-&gt;id);</a>
<a name="ln294">  auto&amp; chunk    = g_objManager.scnData.m_vbCache.chunk_at(chunkId);</a>
<a name="ln295">  chunk.type     = CHUNK_TYPE_IMAGE4F;</a>
<a name="ln296"> </a>
<a name="ln297">  char* data = (char*)chunk.GetMemoryNow();</a>
<a name="ln298">  if (data == nullptr)</a>
<a name="ln299">  {</a>
<a name="ln300"> </a>
<a name="ln301">    std::shared_ptr&lt;BitmapProxy&gt; p = std::make_shared&lt;BitmapProxy&gt;(width, height, totalByteSizeOfTexture, chunkId); //#TODO: return nullptr here?</a>
<a name="ln302">    p-&gt;fileName        = a_fileName;</a>
<a name="ln303">    p-&gt;m_bytesPerPixel = 16;</a>
<a name="ln304">    return p;</a>
<a name="ln305">  }</a>
<a name="ln306"> </a>
<a name="ln307">  unsigned int* pW = (unsigned int*)data;</a>
<a name="ln308">  unsigned int* pH = pW + 1;</a>
<a name="ln309">  data += 2 * sizeof(unsigned int);</a>
<a name="ln310"> </a>
<a name="ln311">  (*pW) = width;</a>
<a name="ln312">  (*pH) = height;</a>
<a name="ln313"> </a>
<a name="ln314">  fin.read(data, size_t(width)*size_t(height)*size_t(sizeof(float)*4));</a>
<a name="ln315"> </a>
<a name="ln316">  fin.close();</a>
<a name="ln317"> </a>
<a name="ln318">  std::shared_ptr&lt;BitmapLDRNode&gt; p1 = std::make_shared&lt;BitmapLDRNode&gt;(width, height, totalByteSizeOfTexture, chunkId);</a>
<a name="ln319"> </a>
<a name="ln320">  std::shared_ptr&lt;IHRTextureNode&gt; p11 = p1;</a>
<a name="ln321"> </a>
<a name="ln322">  return p11;</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325">std::shared_ptr&lt;IHRTextureNode&gt; HydraFactoryCommon::CreateTexture2DFromFile(HRTextureNode* pSysObj, const std::wstring&amp; a_fileName)</a>
<a name="ln326">{</a>
<a name="ln327">  if(a_fileName.find(L&quot;.image4ub&quot;) != std::wstring::npos)</a>
<a name="ln328">  {</a>
<a name="ln329">    return CreateTexture2DImage4UB(pSysObj, a_fileName);</a>
<a name="ln330">  }</a>
<a name="ln331">  else if(a_fileName.find(L&quot;.image4f&quot;) != std::wstring::npos)</a>
<a name="ln332">  {</a>
<a name="ln333">    return CreateTexture2DImage4F(pSysObj, a_fileName);</a>
<a name="ln334">  }</a>
<a name="ln335">  else</a>
<a name="ln336">  {</a>
<a name="ln337">    return CreateTexture2D_WithImageTool(pSysObj, a_fileName);</a>
<a name="ln338">  }</a>
<a name="ln339">}</a>
<a name="ln340"> </a>
<a name="ln341">int32_t ChunkIdFromFileName(const wchar_t* a_chunkFileName)</a>
<a name="ln342">{</a>
<a name="ln343">  std::wstring fileName(a_chunkFileName);</a>
<a name="ln344">  </a>
<a name="ln345">  auto posBeg = fileName.find(L&quot;chunk_&quot;) + 6;</a>
<a name="ln346">  auto posEnd = fileName.find_last_of(L&quot;.&quot;);</a>
<a name="ln347">  </a>
<a name="ln348">  if(posBeg == std::wstring::npos || posEnd == std::wstring::npos)</a>
<a name="ln349">    return -1;</a>
<a name="ln350">  </a>
<a name="ln351">  auto strid  = fileName.substr(posBeg, posEnd - posBeg);</a>
<a name="ln352">  std::wstringstream strIn(strid);</a>
<a name="ln353">  int res = 0;</a>
<a name="ln354">  strIn &gt;&gt; res;</a>
<a name="ln355">  return res; //wcstol(strid.c_str(), NULL, 0);</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">std::shared_ptr&lt;IHRTextureNode&gt; HydraFactoryCommon::CreateTextureInfoFromChunkFile(HRTextureNode* pSysObj, const wchar_t* a_chunkFileName, pugi::xml_node a_node)</a>
<a name="ln359">{</a>
<a name="ln360">  // width=&quot;64&quot; height=&quot;64&quot; bytesize=&quot;16384&quot;</a>
<a name="ln361">  int wh[2];</a>
<a name="ln362">  wh[0] = a_node.attribute(L&quot;width&quot;).as_int();</a>
<a name="ln363">  wh[1] = a_node.attribute(L&quot;height&quot;).as_int();</a>
<a name="ln364"> </a>
<a name="ln365">  auto id = a_node.attribute(L&quot;id&quot;).as_int();</a>
<a name="ln366">  </a>
<a name="ln367">  if(std::wstring(a_node.attribute(L&quot;type&quot;).as_string()) == L&quot;proc&quot;)</a>
<a name="ln368">    return nullptr;</a>
<a name="ln369">  </a>
<a name="ln370">  if(wh[0] == 0 || wh[1] == 0)</a>
<a name="ln371">  {</a>
<a name="ln372">    HrError(L&quot;HydraFactoryCommon::CreateTextureInfoFromChunkFile, unknown image resolution is not allowed! TexId = &quot;, id);</a>
<a name="ln373">    return nullptr;</a>
<a name="ln374">  }</a>
<a name="ln375"> </a>
<a name="ln376">  const size_t bytesize = size_t(a_node.attribute(L&quot;bytesize&quot;).as_llong());</a>
<a name="ln377">  const int bpp         = int( bytesize/(wh[0]*wh[1]) );</a>
<a name="ln378"> </a>
<a name="ln379">  // now put all this to a custom implementations of IHRTextureNode</a>
<a name="ln380">  //</a>
<a name="ln381">  struct BitmapInfo : public IHRTextureNode</a>
<a name="ln382">  {</a>
<a name="ln383"> </a>
<a name="ln384">    BitmapInfo() : m_chunkId(uint64_t(-1)), m_width(0), m_height(0), m_bpp(0) {}</a>
<a name="ln385"> </a>
<a name="ln386">    uint64_t chunkId() const override { return m_chunkId; }</a>
<a name="ln387">    uint32_t width()   const override { return m_width;   }</a>
<a name="ln388">    uint32_t height()  const override { return m_height;  }</a>
<a name="ln389">    uint32_t bpp()     const override { return m_bpp;     }</a>
<a name="ln390"> </a>
<a name="ln391">    uint64_t m_chunkId;</a>
<a name="ln392">    uint32_t m_width;</a>
<a name="ln393">    uint32_t m_height;</a>
<a name="ln394">    uint32_t m_bpp;</a>
<a name="ln395">  };</a>
<a name="ln396"> </a>
<a name="ln397">  std::shared_ptr&lt;BitmapInfo&gt; pBitMapIndo = std::make_shared&lt;BitmapInfo&gt;();</a>
<a name="ln398"> </a>
<a name="ln399">  pBitMapIndo-&gt;m_chunkId = ChunkIdFromFileName(a_chunkFileName);</a>
<a name="ln400">  pBitMapIndo-&gt;m_width   = uint32_t(wh[0]);</a>
<a name="ln401">  pBitMapIndo-&gt;m_height  = uint32_t(wh[1]);</a>
<a name="ln402">  pBitMapIndo-&gt;m_bpp     = uint32_t(bpp);</a>
<a name="ln403"> </a>
<a name="ln404">  return pBitMapIndo;</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407"> </a>
<a name="ln408">void GetTextureFileInfo(const wchar_t* a_fileName, int32_t* pW, int32_t* pH, size_t* pByteSize)</a>
<a name="ln409">{</a>
<a name="ln410">  FREE_IMAGE_FORMAT fif = FIF_UNKNOWN;</a>
<a name="ln411"> </a>
<a name="ln412">#if defined WIN32</a>
<a name="ln413">  fif = FreeImage_GetFileTypeU(a_fileName, 0);</a>
<a name="ln414">#else</a>
<a name="ln415">  char filename_s[256];</a>
<a name="ln416">  wcstombs(filename_s, a_fileName, sizeof(filename_s));</a>
<a name="ln417">  fif = FreeImage_GetFileType(filename_s, 0);</a>
<a name="ln418">#endif</a>
<a name="ln419"> </a>
<a name="ln420">  if (fif == FIF_UNKNOWN)</a>
<a name="ln421">#if defined WIN32</a>
<a name="ln422">    fif = FreeImage_GetFIFFromFilenameU(a_fileName);</a>
<a name="ln423">#else</a>
<a name="ln424">    fif = FreeImage_GetFIFFromFilename(filename_s);</a>
<a name="ln425">#endif</a>
<a name="ln426">  if (fif == FIF_UNKNOWN)</a>
<a name="ln427">  {</a>
<a name="ln428">    (*pW)        = 0;</a>
<a name="ln429">    (*pH)        = 0;</a>
<a name="ln430">    (*pByteSize) = 0;</a>
<a name="ln431">    return;</a>
<a name="ln432">  }</a>
<a name="ln433"> </a>
<a name="ln434">  //check that the plugin has reading capabilities and load the file</a>
<a name="ln435">  //</a>
<a name="ln436"> </a>
<a name="ln437">  FIBITMAP* dib = nullptr;</a>
<a name="ln438"> </a>
<a name="ln439">  if (FreeImage_FIFSupportsReading(fif))</a>
<a name="ln440">#if defined WIN32</a>
<a name="ln441">    dib = FreeImage_LoadU(fif, a_fileName);</a>
<a name="ln442">#else</a>
<a name="ln443">    dib = FreeImage_Load(fif, filename_s);</a>
<a name="ln444">#endif</a>
<a name="ln445">  else</a>
<a name="ln446">  {</a>
<a name="ln447">    (*pW) = 0;</a>
<a name="ln448">    (*pH) = 0;</a>
<a name="ln449">    (*pByteSize) = 0;</a>
<a name="ln450">    return;</a>
<a name="ln451">  }</a>
<a name="ln452"> </a>
<a name="ln453">  if(dib == nullptr)</a>
<a name="ln454">  {</a>
<a name="ln455">    (*pW) = 0;</a>
<a name="ln456">    (*pH) = 0;</a>
<a name="ln457">    (*pByteSize) = 0;</a>
<a name="ln458">    return;</a>
<a name="ln459">  }</a>
<a name="ln460"> </a>
<a name="ln461">  auto width  = FreeImage_GetWidth(dib);</a>
<a name="ln462">  auto height = FreeImage_GetHeight(dib);</a>
<a name="ln463">  auto bpp    = FreeImage_GetBPP(dib);</a>
<a name="ln464">  if (bpp &lt;= 24) </a>
<a name="ln465">    bpp = 32;</a>
<a name="ln466">  else if (bpp &lt; 128) </a>
<a name="ln467">    bpp = 128;</a>
<a name="ln468"> </a>
<a name="ln469">  FreeImage_Unload(dib);</a>
<a name="ln470"> </a>
<a name="ln471">  (*pW)        = width;</a>
<a name="ln472">  (*pH)        = height;</a>
<a name="ln473">  (*pByteSize) = bpp/8;</a>
<a name="ln474">}</a>

</code></pre>
<div class="balloon" rel="25"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'width() * height()' operator to the 'size_t' type, not the result.</p></div>
<div class="balloon" rel="186"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'width * height' operator to the 'size_t' type, not the result.</p></div>
<div class="balloon" rel="208"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'width * height' operator to the 'size_t' type, not the result.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
