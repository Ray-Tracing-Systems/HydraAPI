
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>HR_AccumImageWin.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#pragma once</a>
<a name="ln2"> </a>
<a name="ln3">#include &lt;vector&gt;</a>
<a name="ln4">#include &lt;string&gt;</a>
<a name="ln5">#include &lt;cstdint&gt;</a>
<a name="ln6"> </a>
<a name="ln7">#if _MSC_VER &gt;= 1400</a>
<a name="ln8">#include &lt;intrin.h&gt;</a>
<a name="ln9">#else</a>
<a name="ln10">#include &lt;xmmintrin.h&gt;</a>
<a name="ln11">#endif</a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;cstring&gt;</a>
<a name="ln14">#include &quot;HydraInternal.h&quot;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;windows.h&gt;</a>
<a name="ln17"> </a>
<a name="ln18">struct SharedAccumImageWin32 : public IHRSharedAccumImage</a>
<a name="ln19">{</a>
<a name="ln20">  SharedAccumImageWin32();</a>
<a name="ln21">  ~SharedAccumImageWin32();</a>
<a name="ln22"> </a>
<a name="ln23">  bool   Create(int w, int h, int d, const char* name, char errMsg[256]) override;</a>
<a name="ln24">  bool   Attach(const char* name, char errMsg[256]) override;</a>
<a name="ln25"> </a>
<a name="ln26">  void Clear() override;</a>
<a name="ln27"> </a>
<a name="ln28">  bool   Lock(int a_miliseconds) override;</a>
<a name="ln29">  void   Unlock() override;</a>
<a name="ln30">  </a>
<a name="ln31">  HRSharedBufferHeader* Header() override;</a>
<a name="ln32">  char*   MessageSendData() override;</a>
<a name="ln33">  char*   MessageRcvData() override;</a>
<a name="ln34">  float*  ImageData(int layerNum) override;</a>
<a name="ln35"> </a>
<a name="ln36">private:</a>
<a name="ln37"> </a>
<a name="ln38">  void Free();</a>
<a name="ln39">  void AttachTo(char* memory);</a>
<a name="ln40"> </a>
<a name="ln41">  HANDLE m_buffHandle;</a>
<a name="ln42">  HANDLE m_mutex;</a>
<a name="ln43">  char*  m_memory;</a>
<a name="ln44"> </a>
<a name="ln45">  char*  m_msgSend;</a>
<a name="ln46">  char*  m_msgRcv;</a>
<a name="ln47">  float* m_images;</a>
<a name="ln48"> </a>
<a name="ln49">  std::string m_shmemName;</a>
<a name="ln50">};</a>
<a name="ln51"> </a>
<a name="ln52">SharedAccumImageWin32::SharedAccumImageWin32() : m_buffHandle(NULL), m_mutex(NULL), m_memory(nullptr), m_msgSend(nullptr), m_msgRcv(nullptr), m_images(nullptr)</a>
<a name="ln53">{</a>
<a name="ln54"> </a>
<a name="ln55">}</a>
<a name="ln56"> </a>
<a name="ln57">SharedAccumImageWin32::~SharedAccumImageWin32()</a>
<a name="ln58">{</a>
<a name="ln59">  Free();</a>
<a name="ln60">}</a>
<a name="ln61"> </a>
<a name="ln62">void SharedAccumImageWin32::Free()</a>
<a name="ln63">{</a>
<a name="ln64">  if (m_mutex != INVALID_HANDLE_VALUE &amp;&amp; m_mutex != NULL)</a>
<a name="ln65">    CloseHandle(m_mutex);</a>
<a name="ln66">  m_mutex = NULL;</a>
<a name="ln67"> </a>
<a name="ln68">  if (m_memory != nullptr)</a>
<a name="ln69">    UnmapViewOfFile(m_memory);</a>
<a name="ln70">  m_memory = nullptr;</a>
<a name="ln71"> </a>
<a name="ln72">  if (m_buffHandle != INVALID_HANDLE_VALUE &amp;&amp; m_buffHandle != NULL)</a>
<a name="ln73">    CloseHandle(m_buffHandle);</a>
<a name="ln74">  m_buffHandle = NULL;</a>
<a name="ln75"> </a>
<a name="ln76">  m_msgSend = nullptr;</a>
<a name="ln77">  m_msgRcv  = nullptr;</a>
<a name="ln78">  m_images  = nullptr;</a>
<a name="ln79">}</a>
<a name="ln80"> </a>
<a name="ln81"> </a>
<a name="ln82">bool SharedAccumImageWin32::Create(int a_width, int a_height, int a_depth, const char* a_name, char a_errMsg[256])</a>
<a name="ln83">{</a>
<a name="ln84">  memset(a_errMsg, 0, 256);</a>
<a name="ln85"> </a>
<a name="ln86">  if (a_width == 0 || a_height == 0 || a_depth == 0)</a>
<a name="ln87">  {</a>
<a name="ln88">    Free();</a>
<a name="ln89">    if(a_errMsg != nullptr)</a>
<a name="ln90">      strcpy(a_errMsg, &quot;&quot;);</a>
<a name="ln91">    return true;</a>
<a name="ln92">  }</a>
<a name="ln93">  else // #TODO: if new width != old width ... </a>
<a name="ln94">  {</a>
<a name="ln95">    if (m_memory != nullptr)</a>
<a name="ln96">    {</a>
<a name="ln97">      auto* pHeader = Header();</a>
<a name="ln98">      if (pHeader-&gt;width == a_width &amp;&amp; pHeader-&gt;height == a_height &amp;&amp; pHeader-&gt;depth == a_depth &amp;&amp; m_shmemName == a_name)</a>
<a name="ln99">        return true;</a>
<a name="ln100">    }</a>
<a name="ln101"> </a>
<a name="ln102">    Free();</a>
<a name="ln103">    m_shmemName = a_name;</a>
<a name="ln104">    </a>
<a name="ln105">    const int64_t totalSize     = int64_t(sizeof(HRSharedBufferHeader)) + int64_t(MESSAGE_SIZE * 2) + int64_t(a_width*a_height)*int64_t(a_depth*sizeof(float)*4) + int64_t(1024);</a>
<a name="ln106">    const std::string mutexName = std::string(a_name) + &quot;_mutex&quot;;</a>
<a name="ln107"> </a>
<a name="ln108">    m_mutex = CreateMutexA(NULL, FALSE, mutexName.c_str());</a>
<a name="ln109"> </a>
<a name="ln110">    if (m_mutex == NULL || m_mutex == INVALID_HANDLE_VALUE)</a>
<a name="ln111">    {</a>
<a name="ln112">      strcpy(a_errMsg, &quot;FAILED to create mutex (CreateMutexA)&quot;);</a>
<a name="ln113">      return false;</a>
<a name="ln114">    }</a>
<a name="ln115"> </a>
<a name="ln116">    DWORD high = (DWORD)(totalSize &gt;&gt; 32);</a>
<a name="ln117">    DWORD low  = (DWORD)(totalSize &amp; 0x00000000FFFFFFFF);</a>
<a name="ln118"> </a>
<a name="ln119">    m_buffHandle = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, high, low, a_name);</a>
<a name="ln120"> </a>
<a name="ln121">    if (m_buffHandle == NULL || m_buffHandle == INVALID_HANDLE_VALUE)</a>
<a name="ln122">    {</a>
<a name="ln123">      strcpy(a_errMsg, &quot;FAILED to alloc shared memory (CreateFileMappingA)&quot;);</a>
<a name="ln124">      Free();</a>
<a name="ln125">      return false;</a>
<a name="ln126">    }</a>
<a name="ln127"> </a>
<a name="ln128">    m_memory = (char*)MapViewOfFile(m_buffHandle, FILE_MAP_WRITE | FILE_MAP_READ, 0, 0, 0);</a>
<a name="ln129">    if(m_memory == nullptr)</a>
<a name="ln130">    {</a>
<a name="ln131">      strcpy(a_errMsg, &quot;FAILED to map shared memory (MapViewOfFile)&quot;);</a>
<a name="ln132">      Free();</a>
<a name="ln133">      return false;</a>
<a name="ln134">    }</a>
<a name="ln135"> </a>
<a name="ln136">    //const int totalSize2 = totalSize / 4;</a>
<a name="ln137">    //int* memi            = (int*)m_memory;</a>
<a name="ln138">    //#pragma omp parallel for</a>
<a name="ln139">    //for (int64_t i = 0; i &lt; totalSize2; i++)</a>
<a name="ln140">    //  memi[i] = 0;</a>
<a name="ln141"> </a>
<a name="ln142">    memset(m_memory, 0, size_t(totalSize));</a>
<a name="ln143"> </a>
<a name="ln144">    auto* pHeader = Header();</a>
<a name="ln145"> </a>
<a name="ln146">    pHeader-&gt;width      = a_width;</a>
<a name="ln147">    pHeader-&gt;height     = a_height;</a>
<a name="ln148">    pHeader-&gt;depth      = a_depth;</a>
<a name="ln149">    pHeader-&gt;spp        = 0.0f;</a>
<a name="ln150">    pHeader-&gt;counterRcv = 0;</a>
<a name="ln151">    pHeader-&gt;counterSnd = 0;</a>
<a name="ln152"> </a>
<a name="ln153">    pHeader-&gt;totalByteSize      = totalSize;</a>
<a name="ln154">    pHeader-&gt;messageSendOffset  = sizeof(HRSharedBufferHeader);</a>
<a name="ln155">    pHeader-&gt;messageRcvOffset   = pHeader-&gt;messageSendOffset + MESSAGE_SIZE;</a>
<a name="ln156">    pHeader-&gt;imageDataOffset    = pHeader-&gt;messageSendOffset + MESSAGE_SIZE*2;</a>
<a name="ln157"> </a>
<a name="ln158">    // now find offset for imageDataOffset to make resulting pointer is aligned(16) !!!</a>
<a name="ln159">    //</a>
<a name="ln160">    char* pData = m_memory + pHeader-&gt;imageDataOffset;</a>
<a name="ln161">    auto intptr = reinterpret_cast&lt;std::uintptr_t&gt;(pData);</a>
<a name="ln162"> </a>
<a name="ln163">    while (intptr % 16 != 0)</a>
<a name="ln164">    {</a>
<a name="ln165">      pData++;</a>
<a name="ln166">      intptr = reinterpret_cast&lt;std::uintptr_t&gt;(pData);</a>
<a name="ln167">    };</a>
<a name="ln168"> </a>
<a name="ln169">    pHeader-&gt;imageDataOffset = int32_t(pData - m_memory);</a>
<a name="ln170">    //</a>
<a name="ln171">    // \\</a>
<a name="ln172"> </a>
<a name="ln173">    AttachTo(m_memory);</a>
<a name="ln174">  }</a>
<a name="ln175"> </a>
<a name="ln176">  strcpy(a_errMsg, &quot;&quot;);</a>
<a name="ln177">  return true;</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">bool SharedAccumImageWin32::Attach(const char* name, char errMsg[256])</a>
<a name="ln181">{</a>
<a name="ln182">  memset(errMsg, 0, 256);</a>
<a name="ln183">  Free();</a>
<a name="ln184"> </a>
<a name="ln185">  const std::string mutexName = std::string(name) + &quot;_mutex&quot;;</a>
<a name="ln186">  </a>
<a name="ln187">  m_mutex = OpenMutexA(MUTEX_ALL_ACCESS, FALSE, mutexName.c_str());</a>
<a name="ln188">  if (m_mutex == NULL || m_mutex == INVALID_HANDLE_VALUE)</a>
<a name="ln189">  {</a>
<a name="ln190">    strcpy(errMsg, &quot;FAILED to attach mutex (OpenMutexA)&quot;);</a>
<a name="ln191">    return false;</a>
<a name="ln192">  }</a>
<a name="ln193"> </a>
<a name="ln194">  m_buffHandle = OpenFileMappingA(FILE_MAP_READ | FILE_MAP_WRITE, 0, name);</a>
<a name="ln195"> </a>
<a name="ln196">  if (m_buffHandle == NULL || m_buffHandle == INVALID_HANDLE_VALUE)</a>
<a name="ln197">  {</a>
<a name="ln198">    strcpy(errMsg, &quot;FAILED to attach shmem (OpenFileMappingA)&quot;);</a>
<a name="ln199">    Free();</a>
<a name="ln200">    return false;</a>
<a name="ln201">  }</a>
<a name="ln202"> </a>
<a name="ln203">  m_memory = (char*)MapViewOfFile(m_buffHandle, FILE_MAP_WRITE | FILE_MAP_READ, 0, 0, 0);</a>
<a name="ln204">  if (m_memory == nullptr)</a>
<a name="ln205">  {</a>
<a name="ln206">    strcpy(errMsg, &quot;FAILED to map shared memory (MapViewOfFile)&quot;);</a>
<a name="ln207">    Free();</a>
<a name="ln208">    return false;</a>
<a name="ln209">  }</a>
<a name="ln210"> </a>
<a name="ln211">  AttachTo(m_memory);</a>
<a name="ln212"> </a>
<a name="ln213">  strcpy(errMsg, &quot;&quot;);</a>
<a name="ln214">  return true;</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217"> </a>
<a name="ln218">void SharedAccumImageWin32::Clear()</a>
<a name="ln219">{</a>
<a name="ln220">  auto* pHeader = Header();</a>
<a name="ln221">  pHeader-&gt;spp = 0.0f;</a>
<a name="ln222">  pHeader-&gt;counterRcv = 0;</a>
<a name="ln223">  pHeader-&gt;counterSnd = 0;</a>
<a name="ln224"> </a>
<a name="ln225">  auto pImg = ImageData(0);</a>
<a name="ln226">  memset(pImg, 0, size_t(pHeader-&gt;width*pHeader-&gt;height)*size_t(sizeof(float)*4));</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229"> </a>
<a name="ln230">void SharedAccumImageWin32::AttachTo(char* a_memory)</a>
<a name="ln231">{</a>
<a name="ln232">  HRSharedBufferHeader* pHeader = (HRSharedBufferHeader*)m_memory;</a>
<a name="ln233"> </a>
<a name="ln234">  m_msgSend = m_memory + pHeader-&gt;messageSendOffset;</a>
<a name="ln235">  m_msgRcv  = m_memory + pHeader-&gt;messageRcvOffset;</a>
<a name="ln236">  m_images  = (float*)(m_memory + pHeader-&gt;imageDataOffset);</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">bool SharedAccumImageWin32::Lock(int a_miliseconds)</a>
<a name="ln240">{</a>
<a name="ln241">  const DWORD res = WaitForSingleObject(m_mutex, a_miliseconds);</a>
<a name="ln242"> </a>
<a name="ln243">  if (res == WAIT_TIMEOUT || res == WAIT_FAILED)</a>
<a name="ln244">    return false;</a>
<a name="ln245">  else</a>
<a name="ln246">    return true;</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249">void SharedAccumImageWin32::Unlock()</a>
<a name="ln250">{</a>
<a name="ln251">  ReleaseMutex(m_mutex);</a>
<a name="ln252">}</a>
<a name="ln253"> </a>
<a name="ln254">float* SharedAccumImageWin32::ImageData(int layerId)</a>
<a name="ln255">{</a>
<a name="ln256">  HRSharedBufferHeader* pHeader = (HRSharedBufferHeader*)m_memory;</a>
<a name="ln257">  return m_images + int64_t(pHeader-&gt;width*pHeader-&gt;height)*int64_t(layerId*4);</a>
<a name="ln258">}</a>
<a name="ln259"> </a>
<a name="ln260">char* SharedAccumImageWin32::MessageSendData()</a>
<a name="ln261">{</a>
<a name="ln262">  return m_msgSend;</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265">char* SharedAccumImageWin32::MessageRcvData()</a>
<a name="ln266">{</a>
<a name="ln267">  return m_msgRcv;</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270">HRSharedBufferHeader* SharedAccumImageWin32::Header()</a>
<a name="ln271">{</a>
<a name="ln272">  return (HRSharedBufferHeader*)m_memory;</a>
<a name="ln273">}</a>
<a name="ln274"> </a>
<a name="ln275"> </a>
<a name="ln276">IHRSharedAccumImage* CreateImageAccum()</a>
<a name="ln277">{</a>
<a name="ln278">  return new SharedAccumImageWin32();</a>
<a name="ln279">}</a>

</code></pre>
<div class="balloon" rel="105"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'a_width * a_height' operator to the 'int64_t' type, not the result.</p></div>
<div class="balloon" rel="226"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands, not the result.</p></div>
<div class="balloon" rel="257"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands, not the result.</p></div>
<div class="balloon" rel="257"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'layerId * 4' operator to the 'int64_t' type, not the result.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
