
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>HydraAPI_FrameBuffer.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#include &quot;HydraAPI.h&quot;</a>
<a name="ln2">#include &quot;HydraInternal.h&quot;</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;memory&gt;</a>
<a name="ln5">#include &lt;vector&gt;</a>
<a name="ln6">#include &lt;string&gt;</a>
<a name="ln7">#include &lt;map&gt;</a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;sstream&gt;</a>
<a name="ln10">#include &lt;fstream&gt;</a>
<a name="ln11">#include &lt;iomanip&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;HydraObjectManager.h&quot;</a>
<a name="ln14"> </a>
<a name="ln15">extern std::wstring      g_lastError;</a>
<a name="ln16">extern std::wstring      g_lastErrorCallerPlace;</a>
<a name="ln17">extern HRObjectManager   g_objManager;</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;FreeImage.h&gt;</a>
<a name="ln20">#include &lt;cmath&gt;</a>
<a name="ln21"> </a>
<a name="ln22">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln23">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln24">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln25">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln26"> </a>
<a name="ln27">HAPI bool hrRenderLockFrameBufferUpdate(HRRenderRef a_pRender)</a>
<a name="ln28">{</a>
<a name="ln29">  HRRender* pRender = g_objManager.PtrById(a_pRender);</a>
<a name="ln30">  </a>
<a name="ln31">  if (pRender == nullptr)</a>
<a name="ln32">  {</a>
<a name="ln33">    HrError(L&quot;hrRenderLockFrameBufferUpdate, nullptr Render Driver &quot;);</a>
<a name="ln34">    return false;</a>
<a name="ln35">  }</a>
<a name="ln36">  </a>
<a name="ln37">  if (pRender-&gt;m_pDriver == nullptr)</a>
<a name="ln38">  {</a>
<a name="ln39">    HrError(L&quot;hrRenderLockFrameBufferUpdate, nullptr Render Driver impl &quot;);</a>
<a name="ln40">    return false;</a>
<a name="ln41">  }</a>
<a name="ln42">  </a>
<a name="ln43">  pRender-&gt;m_pDriver-&gt;LockFrameBufferUpdate();</a>
<a name="ln44"> </a>
<a name="ln45">  return true;</a>
<a name="ln46">}</a>
<a name="ln47"> </a>
<a name="ln48"> </a>
<a name="ln49">HAPI void hrRenderUnlockFrameBufferUpdate(HRRenderRef a_pRender)</a>
<a name="ln50">{</a>
<a name="ln51">  HRRender* pRender = g_objManager.PtrById(a_pRender);</a>
<a name="ln52">  </a>
<a name="ln53">  if (pRender == nullptr)</a>
<a name="ln54">  {</a>
<a name="ln55">    HrError(L&quot;hrRenderUnlockFrameBufferUpdate, nullptr Render Driver &quot;);</a>
<a name="ln56">    return;</a>
<a name="ln57">  }</a>
<a name="ln58">  </a>
<a name="ln59">  if (pRender-&gt;m_pDriver == nullptr)</a>
<a name="ln60">  {</a>
<a name="ln61">    HrError(L&quot;hrRenderUnlockFrameBufferUpdate, nullptr Render Driver impl &quot;);</a>
<a name="ln62">    return;</a>
<a name="ln63">  }</a>
<a name="ln64">  </a>
<a name="ln65">  pRender-&gt;m_pDriver-&gt;UnlockFrameBufferUpdate();</a>
<a name="ln66">}</a>
<a name="ln67"> </a>
<a name="ln68">HAPI bool hrRenderGetFrameBufferHDR4f(HRRenderRef a_pRender, int w, int h, float* imgData, const wchar_t* a_layerName) // (w,h) is strongly related to viewport size; return true if image was final</a>
<a name="ln69">{</a>
<a name="ln70">  HRRender* pRender = g_objManager.PtrById(a_pRender);</a>
<a name="ln71"> </a>
<a name="ln72">  if (pRender == nullptr)</a>
<a name="ln73">  {</a>
<a name="ln74">    HrError(L&quot;hrRenderGetFrameBufferHDR4f, nullptr Render Driver &quot;);</a>
<a name="ln75">    return false;</a>
<a name="ln76">  }</a>
<a name="ln77"> </a>
<a name="ln78">  if (pRender-&gt;m_pDriver == nullptr)</a>
<a name="ln79">  {</a>
<a name="ln80">    HrError(L&quot;hrRenderGetFrameBufferHDR4f, nullptr Render Driver impl &quot;);</a>
<a name="ln81">    return false;</a>
<a name="ln82">  }</a>
<a name="ln83">  </a>
<a name="ln84">  pRender-&gt;m_pDriver-&gt;LockFrameBufferUpdate();</a>
<a name="ln85">  pRender-&gt;m_pDriver-&gt;GetFrameBufferHDR(w, h, imgData, a_layerName);</a>
<a name="ln86">  pRender-&gt;m_pDriver-&gt;UnlockFrameBufferUpdate();</a>
<a name="ln87">  </a>
<a name="ln88">  return true;</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91"> </a>
<a name="ln92">HAPI bool hrRenderGetFrameBufferLDR1i(HRRenderRef a_pRender, int w, int h, int32_t* imgData)</a>
<a name="ln93">{</a>
<a name="ln94">  HRRender* pRender = g_objManager.PtrById(a_pRender);</a>
<a name="ln95"> </a>
<a name="ln96">  if (pRender == nullptr)</a>
<a name="ln97">  {</a>
<a name="ln98">    HrError(L&quot;hrRenderGetFrameBufferLDR1i, nullptr Render Driver &quot;);</a>
<a name="ln99">    return false;</a>
<a name="ln100">  }</a>
<a name="ln101"> </a>
<a name="ln102">  if (pRender-&gt;m_pDriver == nullptr)</a>
<a name="ln103">  {</a>
<a name="ln104">    HrError(L&quot;hrRenderGetFrameBufferLDR1i, nullptr Render Driver impl &quot;);</a>
<a name="ln105">    return false;</a>
<a name="ln106">  }</a>
<a name="ln107">  </a>
<a name="ln108">  pRender-&gt;m_pDriver-&gt;LockFrameBufferUpdate();</a>
<a name="ln109">  pRender-&gt;m_pDriver-&gt;GetFrameBufferLDR(w, h, imgData);</a>
<a name="ln110">  pRender-&gt;m_pDriver-&gt;UnlockFrameBufferUpdate();</a>
<a name="ln111">  </a>
<a name="ln112">  return true;</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">HAPI bool hrRenderGetFrameBufferLineHDR4f(HRRenderRef a_pRender, int a_begin, int a_end, int a_y, float* imgData, const wchar_t* a_layerName)</a>
<a name="ln116">{</a>
<a name="ln117">  HRRender* pRender = g_objManager.PtrById(a_pRender);</a>
<a name="ln118"> </a>
<a name="ln119">  if (pRender == nullptr)</a>
<a name="ln120">  {</a>
<a name="ln121">    HrError(L&quot;hrRenderGetFrameBufferLineHDR4f, nullptr Render Driver &quot;);</a>
<a name="ln122">    return false;</a>
<a name="ln123">  }</a>
<a name="ln124"> </a>
<a name="ln125">  if (pRender-&gt;m_pDriver == nullptr)</a>
<a name="ln126">  {</a>
<a name="ln127">    HrError(L&quot;hrRenderGetFrameBufferLineHDR4f, nullptr Render Driver impl &quot;);</a>
<a name="ln128">    return false;</a>
<a name="ln129">  }</a>
<a name="ln130"> </a>
<a name="ln131">  std::wstring driver_name;</a>
<a name="ln132">  pRender-&gt;m_pDriver-&gt;GetRenderDriverName(driver_name);</a>
<a name="ln133">  auto driver_info = RenderDriverFactory::GetDriverInfo(driver_name.c_str());</a>
<a name="ln134"> </a>
<a name="ln135">  if (!driver_info.supportGetFrameBufferLine)</a>
<a name="ln136">  {</a>
<a name="ln137">    HrError(L&quot;hrRenderGetFrameBufferLineHDR4f is not implemented for general case yet. try different render driver&quot;);</a>
<a name="ln138">    return false;</a>
<a name="ln139">  }</a>
<a name="ln140"> </a>
<a name="ln141">  pRender-&gt;m_pDriver-&gt;GetFrameBufferLineHDR(a_begin, a_end, a_y, imgData, a_layerName);</a>
<a name="ln142">  return true;</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">HAPI bool hrRenderGetFrameBufferLineLDR1i(HRRenderRef a_pRender, int a_begin, int a_end, int a_y, int32_t* imgData)</a>
<a name="ln146">{</a>
<a name="ln147">  HRRender* pRender = g_objManager.PtrById(a_pRender);</a>
<a name="ln148">  if (pRender == nullptr)</a>
<a name="ln149">  {</a>
<a name="ln150">    HrError(L&quot;hrRenderGetFrameBufferLineLDR1i, nullptr Render Driver &quot;);</a>
<a name="ln151">    return false;</a>
<a name="ln152">  }</a>
<a name="ln153"> </a>
<a name="ln154">  if (pRender-&gt;m_pDriver == nullptr)</a>
<a name="ln155">  {</a>
<a name="ln156">    HrError(L&quot;hrRenderGetFrameBufferLineLDR1i, nullptr Render Driver impl &quot;);</a>
<a name="ln157">    return false;</a>
<a name="ln158">  }</a>
<a name="ln159"> </a>
<a name="ln160">  std::wstring driver_name;</a>
<a name="ln161">  pRender-&gt;m_pDriver-&gt;GetRenderDriverName(driver_name);</a>
<a name="ln162">  auto driver_info = RenderDriverFactory::GetDriverInfo(driver_name.c_str());</a>
<a name="ln163">  if (!driver_info.supportGetFrameBufferLine)</a>
<a name="ln164">  {</a>
<a name="ln165">    HrError(L&quot;GetFrameBufferLineLDR1i is not implemented for general case yet. try different render driver&quot;);</a>
<a name="ln166">    return false;</a>
<a name="ln167">  }</a>
<a name="ln168"> </a>
<a name="ln169">  pRender-&gt;m_pDriver-&gt;GetFrameBufferLineLDR(a_begin, a_end, a_y, imgData);</a>
<a name="ln170">  return true;</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173"> </a>
<a name="ln174">//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln175"> </a>
<a name="ln176">HAPI bool hrRenderSaveFrameBufferLDR(HRRenderRef a_pRender, const wchar_t* a_outFileName)</a>
<a name="ln177">{</a>
<a name="ln178">  HRRender* pRender = g_objManager.PtrById(a_pRender);</a>
<a name="ln179"> </a>
<a name="ln180">  if (pRender == nullptr)</a>
<a name="ln181">  {</a>
<a name="ln182">    HrError(L&quot;hrRenderSaveFrameBufferLDR, nullptr Render Driver &quot;);</a>
<a name="ln183">    return false;</a>
<a name="ln184">  }</a>
<a name="ln185"> </a>
<a name="ln186">  if (pRender-&gt;m_pDriver == nullptr)</a>
<a name="ln187">  {</a>
<a name="ln188">    HrError(L&quot;hrRenderSaveFrameBufferLDR, nullptr Render Driver impl &quot;);</a>
<a name="ln189">    return false;</a>
<a name="ln190">  }</a>
<a name="ln191"> </a>
<a name="ln192">  pugi::xml_node node = pRender-&gt;xml_node();</a>
<a name="ln193"> </a>
<a name="ln194">  int w = node.child(L&quot;width&quot;).text().as_int();</a>
<a name="ln195">  int h = node.child(L&quot;height&quot;).text().as_int();</a>
<a name="ln196"> </a>
<a name="ln197">  if (w &lt;= 0 || h &lt;= 0)</a>
<a name="ln198">  {</a>
<a name="ln199">    HrError(L&quot;hrRenderSaveFrameBufferLDR, &lt;width&gt; or &lt;height&gt; xml param of render was not set&quot;);</a>
<a name="ln200">    return false;</a>
<a name="ln201">  }</a>
<a name="ln202"> </a>
<a name="ln203">  auto pImgTool = g_objManager.m_pImgTool;</a>
<a name="ln204">  auto&amp; imgData = g_objManager.m_tempBuffer;</a>
<a name="ln205">  if (imgData.size() &lt; w*h)</a>
<a name="ln206">    imgData.resize(w*h);</a>
<a name="ln207"> </a>
<a name="ln208">  pRender-&gt;m_pDriver-&gt;GetFrameBufferLDR(w, h, imgData.data());</a>
<a name="ln209">  pImgTool-&gt;SaveLDRImageToFileLDR(a_outFileName, w, h, imgData.data());</a>
<a name="ln210"> </a>
<a name="ln211">  if (imgData.size() &gt; TEMP_BUFFER_MAX_SIZE_DONT_FREE) // free temp buffer if it's too large</a>
<a name="ln212">    imgData = g_objManager.EmptyBuffer();</a>
<a name="ln213"> </a>
<a name="ln214">  return true;</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217">HAPI bool hrRenderSaveFrameBufferHDR(HRRenderRef a_pRender, const wchar_t* a_outFileName)</a>
<a name="ln218">{</a>
<a name="ln219">  HRRender* pRender = g_objManager.PtrById(a_pRender);</a>
<a name="ln220"> </a>
<a name="ln221">  if (pRender == nullptr)</a>
<a name="ln222">  {</a>
<a name="ln223">    HrError(L&quot;hrRenderSaveFrameBufferHDR, nullptr Render Driver &quot;);</a>
<a name="ln224">    return false;</a>
<a name="ln225">  }</a>
<a name="ln226"> </a>
<a name="ln227">  if (pRender-&gt;m_pDriver == nullptr)</a>
<a name="ln228">  {</a>
<a name="ln229">    HrError(L&quot;hrRenderSaveFrameBufferHDR, nullptr Render Driver impl &quot;);</a>
<a name="ln230">    return false;</a>
<a name="ln231">  }</a>
<a name="ln232"> </a>
<a name="ln233">  pugi::xml_node node = pRender-&gt;xml_node();</a>
<a name="ln234"> </a>
<a name="ln235">  const int w = node.child(L&quot;width&quot;).text().as_int();</a>
<a name="ln236">  const int h = node.child(L&quot;height&quot;).text().as_int();</a>
<a name="ln237"> </a>
<a name="ln238">  if (w &lt;= 0 || h &lt;= 0)</a>
<a name="ln239">  {</a>
<a name="ln240">    HrError(L&quot;hrRenderSaveFrameBufferHDR, &lt;width&gt; or &lt;height&gt; xml param of render was not set&quot;);</a>
<a name="ln241">    return false;</a>
<a name="ln242">  }</a>
<a name="ln243"> </a>
<a name="ln244">  auto pImgTool = g_objManager.m_pImgTool;</a>
<a name="ln245">  auto&amp; imgData = g_objManager.m_tempBuffer;</a>
<a name="ln246">  if (imgData.size() &lt; size_t(w*h)*size_t(4))</a>
<a name="ln247">    imgData.resize(size_t(w*h)*size_t(4));</a>
<a name="ln248"> </a>
<a name="ln249">  pRender-&gt;m_pDriver-&gt;GetFrameBufferHDR(w, h, (float*)imgData.data(), L&quot;color&quot;);</a>
<a name="ln250">  pImgTool-&gt;SaveHDRImageToFileHDR(a_outFileName, w, h, (const float*)imgData.data());</a>
<a name="ln251"> </a>
<a name="ln252">  if (imgData.size() &gt; TEMP_BUFFER_MAX_SIZE_DONT_FREE) // free temp buffer if it's too large</a>
<a name="ln253">    imgData = g_objManager.EmptyBuffer();</a>
<a name="ln254"> </a>
<a name="ln255">  return true;</a>
<a name="ln256">}</a>
<a name="ln257"> </a>
<a name="ln258">HAPI void hrRenderCommand(HRRenderRef a_pRender, const wchar_t* a_command, wchar_t* a_answer)</a>
<a name="ln259">{</a>
<a name="ln260">  HRRender* pRender = g_objManager.PtrById(a_pRender);</a>
<a name="ln261"> </a>
<a name="ln262">  if (pRender == nullptr)</a>
<a name="ln263">  {</a>
<a name="ln264">    HrError(L&quot;[hrRenderCommand]: nullptr Render Driver &quot;);</a>
<a name="ln265">    return;</a>
<a name="ln266">  }</a>
<a name="ln267"> </a>
<a name="ln268">  if (pRender-&gt;m_pDriver == nullptr)</a>
<a name="ln269">  {</a>
<a name="ln270">    HrError(L&quot;[hrRenderCommand]: nullptr Render Driver impl &quot;);</a>
<a name="ln271">    return;</a>
<a name="ln272">  }</a>
<a name="ln273">  </a>
<a name="ln274">  std::wstring command(a_command);</a>
<a name="ln275">  if(command == L&quot;start&quot; &amp;&amp; g_objManager.scnData.m_fileState!= L&quot;&quot;) // just 'start', without additional arguments</a>
<a name="ln276">  {</a>
<a name="ln277">    command += std::wstring(L&quot; -statefile &quot;) + g_objManager.scnData.m_fileState;</a>
<a name="ln278">    a_command = command.c_str();</a>
<a name="ln279">  }</a>
<a name="ln280">  </a>
<a name="ln281">  pRender-&gt;m_pDriver-&gt;ExecuteCommand(a_command, a_answer);</a>
<a name="ln282"> </a>
<a name="ln283">}</a>
<a name="ln284"> </a>
<a name="ln285">HAPI void hrRenderLogDir(HRRenderRef a_pRender, const wchar_t* a_logDir, bool a_hrRenderLogDir)</a>
<a name="ln286">{</a>
<a name="ln287">  HRRender* pRender = g_objManager.PtrById(a_pRender);</a>
<a name="ln288">  if (pRender == nullptr)</a>
<a name="ln289">  {</a>
<a name="ln290">    HrError(L&quot;[hrRenderLogDir]: nullptr Render Driver &quot;);</a>
<a name="ln291">    return;</a>
<a name="ln292">  }</a>
<a name="ln293"> </a>
<a name="ln294">  if (pRender-&gt;m_pDriver == nullptr)</a>
<a name="ln295">  {</a>
<a name="ln296">    HrError(L&quot;[hrRenderLogDir]: nullptr Render Driver impl &quot;);</a>
<a name="ln297">    return;</a>
<a name="ln298">  }</a>
<a name="ln299"> </a>
<a name="ln300">  // fix directory path if it don't end with '\' or '/'</a>
<a name="ln301">  //</a>
<a name="ln302">  std::wstring copyOfPath(a_logDir);</a>
<a name="ln303">  if (copyOfPath != L&quot;&quot;)</a>
<a name="ln304">  {</a>
<a name="ln305">    if (copyOfPath[copyOfPath.size() - 1] != L&quot;/&quot;[0] &amp;&amp;</a>
<a name="ln306">      copyOfPath[copyOfPath.size() - 1] != L&quot;\\&quot;[0])</a>
<a name="ln307">      copyOfPath += L&quot;/&quot;;</a>
<a name="ln308">  }</a>
<a name="ln309">  pRender-&gt;m_pDriver-&gt;SetLogDir(copyOfPath.c_str(), a_hrRenderLogDir);</a>
<a name="ln310"> </a>
<a name="ln311">}</a>

</code></pre>
<div class="balloon" rel="247"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'w * h' operator to the 'size_t' type, not the result.</p></div>
<div class="balloon" rel="246"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'w * h' operator to the 'size_t' type, not the result.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
