
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>HydraAPI_LoadExistingLibrary.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#include &quot;HydraAPI.h&quot;</a>
<a name="ln2">#include &quot;HydraInternal.h&quot;</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;memory&gt;</a>
<a name="ln5">#include &lt;vector&gt;</a>
<a name="ln6">#include &lt;string&gt;</a>
<a name="ln7">#include &lt;map&gt;</a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;sstream&gt;</a>
<a name="ln10">#include &lt;iomanip&gt;</a>
<a name="ln11"> </a>
<a name="ln12">#include &quot;HydraObjectManager.h&quot;</a>
<a name="ln13"> </a>
<a name="ln14">extern HRObjectManager g_objManager;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;string&gt;</a>
<a name="ln17">#include &lt;iostream&gt;</a>
<a name="ln18">#include &lt;algorithm&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;xxhash.h&quot;</a>
<a name="ln21">#include &quot;HydraXMLHelpers.h&quot;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;tiny_obj_loader.h&quot;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;LiteMath.h&quot;</a>
<a name="ln26">using namespace HydraLiteMath;</a>
<a name="ln27"> </a>
<a name="ln28"> </a>
<a name="ln29">HRTextureNodeRef _hrTexture2DCreateFromNode(pugi::xml_node a_node)</a>
<a name="ln30">{</a>
<a name="ln31">  const wchar_t* a_fileName1 = a_node.attribute(L&quot;name&quot;).as_string();</a>
<a name="ln32">  const wchar_t* a_fileName2 = a_node.attribute(L&quot;path&quot;).as_string();</a>
<a name="ln33">  const std::wstring loc     = g_objManager.GetLoc(a_node);</a>
<a name="ln34">  const wchar_t* a_chunkPath = loc.c_str(); </a>
<a name="ln35"> </a>
<a name="ln36">  HRTextureNodeRef ref;</a>
<a name="ln37">  ref.id = HR_IDType(g_objManager.scnData.textures.size());</a>
<a name="ln38"> </a>
<a name="ln39">  HRTextureNode texRes;</a>
<a name="ln40">  texRes.name = std::wstring(a_fileName1);</a>
<a name="ln41">  texRes.id   = ref.id;</a>
<a name="ln42">  g_objManager.scnData.textures.push_back(texRes);</a>
<a name="ln43"> </a>
<a name="ln44"> </a>
<a name="ln45">  HRTextureNode&amp; texture   = g_objManager.scnData.textures[ref.id];</a>
<a name="ln46">  texture.m_loadedFromFile = true;</a>
<a name="ln47"> </a>
<a name="ln48">  g_objManager.scnData.textures      [ref.id].update(a_node);</a>
<a name="ln49">  g_objManager.scnData.m_textureCache[a_fileName2] = ref.id; // remember texture id for given file name</a>
<a name="ln50"> </a>
<a name="ln51">  if (a_chunkPath != L&quot;&quot;)</a>
<a name="ln52">    texture.pImpl = g_objManager.m_pFactory-&gt;CreateTextureInfoFromChunkFile(&amp;texture, a_chunkPath, a_node);</a>
<a name="ln53"> </a>
<a name="ln54">  return ref;</a>
<a name="ln55">}</a>
<a name="ln56"> </a>
<a name="ln57">HRMaterialRef _hrMaterialCreateFromNode(pugi::xml_node a_node)</a>
<a name="ln58">{</a>
<a name="ln59">  const wchar_t* a_objectName = a_node.attribute(L&quot;name&quot;).as_string();</a>
<a name="ln60"> </a>
<a name="ln61">  HRMaterialRef ref;</a>
<a name="ln62">  ref.id = HR_IDType(g_objManager.scnData.materials.size());</a>
<a name="ln63"> </a>
<a name="ln64">  HRMaterial mat;</a>
<a name="ln65">  mat.name = std::wstring(a_objectName);</a>
<a name="ln66">  mat.id = ref.id;</a>
<a name="ln67">  g_objManager.scnData.materials.push_back(mat);</a>
<a name="ln68">  g_objManager.scnData.materials[ref.id].update(a_node);</a>
<a name="ln69"> </a>
<a name="ln70">  return ref;</a>
<a name="ln71">}</a>
<a name="ln72"> </a>
<a name="ln73">const std::wstring GetRealFilePathOfDelayedMesh(pugi::xml_node a_node)</a>
<a name="ln74">{</a>
<a name="ln75">  const std::wstring dl       = a_node.attribute(L&quot;dl&quot;).as_string();</a>
<a name="ln76">  const std::wstring loc      = g_objManager.GetLoc(a_node);</a>
<a name="ln77">  const wchar_t* a_objectName = a_node.attribute(L&quot;name&quot;).as_string();</a>
<a name="ln78">  const wchar_t* a_fileName   = (dl == L&quot;1&quot;) ? a_node.attribute(L&quot;path&quot;).as_string() : loc.c_str();</a>
<a name="ln79"> </a>
<a name="ln80">  if(std::wstring(a_fileName) == L&quot;&quot;) //  then get path from &quot;loc&quot; due to we actually copied file to 'data' folder</a>
<a name="ln81">    return loc;</a>
<a name="ln82">  else</a>
<a name="ln83">    return std::wstring(a_fileName);</a>
<a name="ln84">}</a>
<a name="ln85"> </a>
<a name="ln86"> </a>
<a name="ln87">HAPI HRMeshRef _hrMeshCreateFromNode(pugi::xml_node a_node)</a>
<a name="ln88">{</a>
<a name="ln89">  const std::wstring filePathStr = GetRealFilePathOfDelayedMesh(a_node);</a>
<a name="ln90">  const wchar_t* a_fileName      = filePathStr.c_str();</a>
<a name="ln91">  const wchar_t* a_objectName    = a_node.attribute(L&quot;name&quot;).as_string();</a>
<a name="ln92"> </a>
<a name="ln93">  HRMeshRef ref;</a>
<a name="ln94"> </a>
<a name="ln95">  ref.id = a_node.attribute(L&quot;id&quot;).as_int(); //HR_IDType(g_objManager.scnData.meshes.size());</a>
<a name="ln96"> </a>
<a name="ln97">  HRMesh mesh;</a>
<a name="ln98">  mesh.name = std::wstring(a_objectName);</a>
<a name="ln99">  mesh.id   = ref.id;</a>
<a name="ln100">  mesh.update(a_node);</a>
<a name="ln101">  g_objManager.scnData.meshes.push_back(mesh);</a>
<a name="ln102"> </a>
<a name="ln103">  HRMesh* pMesh = &amp;g_objManager.scnData.meshes.back();</a>
<a name="ln104">  pMesh-&gt;pImpl  = g_objManager.m_pFactory-&gt;CreateVSGFProxy(a_fileName); // delay mesh load untill it will be needed by RenderDriver::UpdateMesh</a>
<a name="ln105"> </a>
<a name="ln106">  if (pMesh-&gt;pImpl == nullptr)</a>
<a name="ln107">    HrError(L&quot;LoadExistingLibrary, _hrMeshCreateFromNode can't load mesh from location = &quot;, a_fileName);</a>
<a name="ln108"> </a>
<a name="ln109">  return ref;</a>
<a name="ln110">}</a>
<a name="ln111"> </a>
<a name="ln112">HRLightRef _hrLightCreateFromNode(pugi::xml_node a_node)</a>
<a name="ln113">{</a>
<a name="ln114">  const wchar_t* a_objectName = a_node.attribute(L&quot;name&quot;).as_string();</a>
<a name="ln115"> </a>
<a name="ln116">  HRLightRef ref;</a>
<a name="ln117">  ref.id = HR_IDType(g_objManager.scnData.lights.size());</a>
<a name="ln118"> </a>
<a name="ln119">  HRLight light;</a>
<a name="ln120">  light.name = std::wstring(a_objectName);</a>
<a name="ln121">  light.id = ref.id;</a>
<a name="ln122">  g_objManager.scnData.lights.push_back(light);</a>
<a name="ln123"> </a>
<a name="ln124">  g_objManager.scnData.lights[ref.id].update(a_node);</a>
<a name="ln125">  g_objManager.scnData.lights[ref.id].id = ref.id;</a>
<a name="ln126"> </a>
<a name="ln127">  return ref;</a>
<a name="ln128">}</a>
<a name="ln129"> </a>
<a name="ln130">HAPI HRCameraRef _hrCameraCreateFromNode(pugi::xml_node a_node)</a>
<a name="ln131">{</a>
<a name="ln132">  const wchar_t* a_objectName = a_node.attribute(L&quot;name&quot;).as_string();</a>
<a name="ln133"> </a>
<a name="ln134">  HRCameraRef ref;</a>
<a name="ln135">  ref.id = HR_IDType(g_objManager.scnData.cameras.size());</a>
<a name="ln136"> </a>
<a name="ln137">  HRCamera cam;</a>
<a name="ln138">  cam.name = std::wstring(a_objectName);</a>
<a name="ln139">  cam.id = ref.id;</a>
<a name="ln140">  g_objManager.scnData.cameras.push_back(cam);</a>
<a name="ln141"> </a>
<a name="ln142"> </a>
<a name="ln143">  g_objManager.scnData.cameras[ref.id].update(a_node);</a>
<a name="ln144">  g_objManager.scnData.cameras[ref.id].id = ref.id;</a>
<a name="ln145"> </a>
<a name="ln146">  return ref;</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln150">//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln151">//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln152">//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln153"> </a>
<a name="ln154"> </a>
<a name="ln155">HAPI void _hrMeshInstanceFromNode(HRSceneInstRef a_pScn, pugi::xml_node a_node)</a>
<a name="ln156">{</a>
<a name="ln157">  HRSceneInst* pScn = g_objManager.PtrById(a_pScn);</a>
<a name="ln158">  if (pScn == nullptr)</a>
<a name="ln159">  {</a>
<a name="ln160">    HrError(L&quot;hrMeshInstance: nullptr input&quot;);</a>
<a name="ln161">    return;</a>
<a name="ln162">  }</a>
<a name="ln163"> </a>
<a name="ln164">  HRSceneInst::Instance model;</a>
<a name="ln165">  model.meshId = a_node.attribute(L&quot;mesh_id&quot;).as_int();</a>
<a name="ln166"> </a>
<a name="ln167">  if (a_node.attribute(L&quot;linst_id&quot;) == nullptr)</a>
<a name="ln168">  {</a>
<a name="ln169">    model.lightId     = -1;</a>
<a name="ln170">    model.lightInstId = -1;</a>
<a name="ln171">  }</a>
<a name="ln172">  else</a>
<a name="ln173">  {</a>
<a name="ln174">    model.lightId     = a_node.attribute(L&quot;light_id&quot;).as_int();</a>
<a name="ln175">    model.lightInstId = a_node.attribute(L&quot;linst_id&quot;).as_int();</a>
<a name="ln176">  }</a>
<a name="ln177"> </a>
<a name="ln178">  if(a_node.attribute(L&quot;rmap_id&quot;) == nullptr)</a>
<a name="ln179">    model.remapListId = -1;</a>
<a name="ln180">  else</a>
<a name="ln181">    model.remapListId = a_node.attribute(L&quot;rmap_id&quot;).as_int();</a>
<a name="ln182"> </a>
<a name="ln183">  /////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln184">  const wchar_t* matString = a_node.attribute(L&quot;matrix&quot;).as_string();</a>
<a name="ln185">  std::wstringstream matStream(matString);</a>
<a name="ln186">  float a_mat[16];</a>
<a name="ln187">  for (int i = 0; i &lt; 16; i++)</a>
<a name="ln188">    matStream &gt;&gt; a_mat[i];</a>
<a name="ln189">  /////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln190"> </a>
<a name="ln191">  memcpy(model.m, a_mat, 16 * sizeof(float));</a>
<a name="ln192">  pScn-&gt;drawList.push_back(model);</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195">HAPI void _hrLightInstanceFromNode(HRSceneInstRef a_pScn, pugi::xml_node a_node)</a>
<a name="ln196">{</a>
<a name="ln197">  HRSceneInst* pScn = g_objManager.PtrById(a_pScn);</a>
<a name="ln198">  if (pScn == nullptr)</a>
<a name="ln199">  {</a>
<a name="ln200">    HrError(L&quot;hrMeshInstance: nullptr input&quot;);</a>
<a name="ln201">    return;</a>
<a name="ln202">  }</a>
<a name="ln203"> </a>
<a name="ln204">  HRSceneInst::Instance model;</a>
<a name="ln205">  model.lightId          = a_node.attribute(L&quot;light_id&quot;).as_int();</a>
<a name="ln206">  model.lightGroupInstId = a_node.attribute(L&quot;lgroup_id&quot;).as_int();</a>
<a name="ln207">  model.meshId           = -1;</a>
<a name="ln208">  model.remapListId      = -1;</a>
<a name="ln209"> </a>
<a name="ln210">  /////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln211">  const wchar_t* matString = a_node.attribute(L&quot;matrix&quot;).as_string();</a>
<a name="ln212">  std::wstringstream matStream(matString);</a>
<a name="ln213">  float a_mat[16];</a>
<a name="ln214">  for (int i = 0; i &lt; 16; i++)</a>
<a name="ln215">    matStream &gt;&gt; a_mat[i];</a>
<a name="ln216">  /////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln217"> </a>
<a name="ln218">  memcpy(model.m, a_mat, 16 * sizeof(float));</a>
<a name="ln219">  model.node = a_node;</a>
<a name="ln220">  pScn-&gt;drawListLights.push_back(model);</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223">HRRenderRef _hrRenderSettingsFromNode(pugi::xml_node a_node)</a>
<a name="ln224">{</a>
<a name="ln225">  const wchar_t* a_className = a_node.attribute(L&quot;type&quot;).as_string();</a>
<a name="ln226"> </a>
<a name="ln227">  int maxRaysPerPixel = a_node.child(L&quot;maxRaysPerPixel&quot;).text().as_int();</a>
<a name="ln228">  HRRenderRef ref;</a>
<a name="ln229">  ref.id = HR_IDType(g_objManager.renderSettings.size());</a>
<a name="ln230"> </a>
<a name="ln231">  HRRender settingsTmp;</a>
<a name="ln232">  settingsTmp.name = a_className;</a>
<a name="ln233">  settingsTmp.maxRaysPerPixel = maxRaysPerPixel;</a>
<a name="ln234">  g_objManager.renderSettings.push_back(settingsTmp);</a>
<a name="ln235"> </a>
<a name="ln236">  HRRender&amp; settings = g_objManager.renderSettings[ref.id];</a>
<a name="ln237"> </a>
<a name="ln238">  g_objManager.renderSettings[ref.id].update(a_node); // ???</a>
<a name="ln239">  g_objManager.renderSettings[ref.id].id = ref.id;</a>
<a name="ln240"> </a>
<a name="ln241">  settings.m_pDriver = std::shared_ptr&lt;IHRRenderDriver&gt;(RenderDriverFactory::Create(a_className));</a>
<a name="ln242"> </a>
<a name="ln243">  return ref;</a>
<a name="ln244">}</a>
<a name="ln245"> </a>
<a name="ln246">//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln247">//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln248">//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln249">//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln250"> </a>
<a name="ln251">std::string ws2s(const std::wstring&amp; s);</a>
<a name="ln252">std::wstring s2ws(const std::string&amp; s);</a>
<a name="ln253"> </a>
<a name="ln254"> </a>
<a name="ln255">void _hrFindTargetOrLastState(const wchar_t* a_libPath, int32_t a_stateId,</a>
<a name="ln256">                              std::wstring&amp; fileName, int&amp; stateId)</a>
<a name="ln257">{</a>
<a name="ln258">  // (0) (a_stateId == -1) =&gt; find last state in folder</a>
<a name="ln259">  //</a>
<a name="ln260">  </a>
<a name="ln261">  if (a_stateId == -1)</a>
<a name="ln262">  {</a>
<a name="ln263">#if (_POSIX_C_SOURCE &gt;= 200112L || _XOPEN_SOURCE &gt;= 600)</a>
<a name="ln264">    </a>
<a name="ln265">    std::wstring s1(a_libPath);</a>
<a name="ln266">    std::string libPath = ws2s(s1);</a>
<a name="ln267">    </a>
<a name="ln268">    auto fileList = hr_listfiles(libPath.c_str());</a>
<a name="ln269">    </a>
<a name="ln270">    std::sort(fileList.begin(), fileList.end());</a>
<a name="ln271">    </a>
<a name="ln272">    for (auto p : fileList)</a>
<a name="ln273">    {</a>
<a name="ln274">      const std::string&amp; currFile = p;</a>
<a name="ln275">      </a>
<a name="ln276">      if (currFile.find(&quot;statex&quot;) != std::string::npos)</a>
<a name="ln277">      {</a>
<a name="ln278">        fileName    = s2ws(currFile);</a>
<a name="ln279">        auto first  = currFile.find(&quot;statex_&quot;) + 7;</a>
<a name="ln280">        auto last   = currFile.find(&quot;.xml&quot;);</a>
<a name="ln281">        auto strNew = currFile.substr(first, last - first);</a>
<a name="ln282">        stateId     = atoi(strNew.c_str());</a>
<a name="ln283">      }</a>
<a name="ln284">    }</a>
<a name="ln285">#elif defined WIN32</a>
<a name="ln286">    auto fileList = hr_listfiles(a_libPath);</a>
<a name="ln287"> </a>
<a name="ln288">    //for (auto p : std_fs::directory_iterator(a_libPath))</a>
<a name="ln289">    for (auto p : fileList)</a>
<a name="ln290">    {</a>
<a name="ln291">      //std::cout &lt;&lt; p &lt;&lt; std::endl;</a>
<a name="ln292">      //const std::wstring&amp; currFile = p.path().wstring();</a>
<a name="ln293">      const std::wstring&amp; currFile = p;</a>
<a name="ln294"> </a>
<a name="ln295">      if (currFile.find(L&quot;statex&quot;) != std::wstring::npos)</a>
<a name="ln296">      {</a>
<a name="ln297">        fileName = currFile;</a>
<a name="ln298">        auto first  = fileName.find(L&quot;statex_&quot;) + 7;</a>
<a name="ln299">        auto last   = fileName.find(L&quot;.xml&quot;);</a>
<a name="ln300">        auto strNew = fileName.substr(first, last - first);</a>
<a name="ln301">        auto strStd = ws2s(strNew);</a>
<a name="ln302">        stateId     = atoi(strStd.c_str());</a>
<a name="ln303">      }</a>
<a name="ln304">    }</a>
<a name="ln305">#endif</a>
<a name="ln306">  }</a>
<a name="ln307">}</a>
<a name="ln308"> </a>
<a name="ln309">int32_t _hrSceneLibraryLoad(const wchar_t* a_libPath, int a_stateId, const std::wstring&amp; a_stateFileName)</a>
<a name="ln310">{</a>
<a name="ln311">  // (0) (a_stateId == -1) =&gt; find last state in folder</a>
<a name="ln312">  //</a>
<a name="ln313">  std::wstring fileName = a_stateFileName;</a>
<a name="ln314">  int stateId           = a_stateId;</a>
<a name="ln315">  </a>
<a name="ln316">  if(fileName == L&quot;&quot;)</a>
<a name="ln317">  {</a>
<a name="ln318">    _hrFindTargetOrLastState(a_libPath, -1,</a>
<a name="ln319">                             fileName, stateId);</a>
<a name="ln320">  }</a>
<a name="ln321">  else</a>
<a name="ln322">    fileName = std::wstring(a_libPath) + L&quot;/&quot; + a_stateFileName;</a>
<a name="ln323">  </a>
<a name="ln324">	if(fileName == L&quot;&quot;)</a>
<a name="ln325">	{</a>
<a name="ln326">    HrError(L&quot;[_hrSceneLibraryLoad]: can't find existing library at: &quot;, a_libPath);</a>
<a name="ln327">	  return 0;</a>
<a name="ln328">  }</a>
<a name="ln329"> </a>
<a name="ln330">  // stateId--; // #NOTE: uncomment this if ypu need to chenge current state?</a>
<a name="ln331"> </a>
<a name="ln332">  // (1) open last state.xml</a>
<a name="ln333">  //</a>
<a name="ln334">  g_objManager.scnData.clear();</a>
<a name="ln335">  g_objManager.scnInst.clear();</a>
<a name="ln336"> </a>
<a name="ln337">  if (g_objManager.m_attachMode)</a>
<a name="ln338">    HrPrint(HR_SEVERITY_INFO, L&quot;HydraAPI, loading xml ... &quot;);</a>
<a name="ln339"> </a>
<a name="ln340">  auto loadResult = g_objManager.scnData.m_xmlDoc.load_file(fileName.c_str());</a>
<a name="ln341"> </a>
<a name="ln342">  if (!loadResult)</a>
<a name="ln343">  {</a>
<a name="ln344">    HrError(L&quot;[_hrSceneLibraryLoad]: pugixml load: &quot;, loadResult.description());</a>
<a name="ln345">    return 0;</a>
<a name="ln346">  }</a>
<a name="ln347"> </a>
<a name="ln348">  if (g_objManager.m_attachMode)</a>
<a name="ln349">    HrPrint(HR_SEVERITY_INFO, L&quot;HydraAPI, initialising virtual buffer&quot;);</a>
<a name="ln350"> </a>
<a name="ln351">  g_objManager.scnData.init_existing(g_objManager.m_attachMode, g_objManager.m_pVBSysMutex, g_objManager.m_lastInitInfo.vbSize);</a>
<a name="ln352"> </a>
<a name="ln353">  // (2) set change id to curr value</a>
<a name="ln354">  //</a>
<a name="ln355">  g_objManager.scnData.changeId   = stateId;</a>
<a name="ln356">  g_objManager.scnData.m_commitId = stateId;</a>
<a name="ln357"> </a>
<a name="ln358">  // (3) load textures</a>
<a name="ln359">  //</a>
<a name="ln360">  g_objManager.scnData.textures.reserve(HRSceneData::TEXTURES_RESERVE);</a>
<a name="ln361">  g_objManager.scnData.meshes.reserve(HRSceneData::MESHES_RESERVE);</a>
<a name="ln362">  g_objManager.scnData.lights.reserve(HRSceneData::LIGHTS_RESERVE);</a>
<a name="ln363">  g_objManager.scnData.materials.reserve(HRSceneData::MATERIAL_RESERVE);</a>
<a name="ln364">  g_objManager.scnData.cameras.reserve(HRSceneData::CAMERAS_RESERVE);</a>
<a name="ln365"> </a>
<a name="ln366">  if (g_objManager.m_attachMode)</a>
<a name="ln367">    HrPrint(HR_SEVERITY_INFO, L&quot;HydraAPI, before system mutex lock&quot;);</a>
<a name="ln368"> </a>
<a name="ln369">  if(g_objManager.m_attachMode &amp;&amp; g_objManager.m_pVBSysMutex != nullptr)</a>
<a name="ln370">    hr_lock_system_mutex(g_objManager.m_pVBSysMutex, VB_LOCK_WAIT_TIME_MS); // need to lock here because _hrMeshCreateFromNode may load data from virtual buffer</a>
<a name="ln371">  </a>
<a name="ln372">  if (g_objManager.m_attachMode)</a>
<a name="ln373">    HrPrint(HR_SEVERITY_INFO, L&quot;HydraAPI, loading objects from xml ... &quot;);</a>
<a name="ln374"> </a>
<a name="ln375">  for (pugi::xml_node node = g_objManager.scnData.m_texturesLib.first_child(); node != nullptr; node = node.next_sibling())</a>
<a name="ln376">    if(node.attribute(L&quot;id&quot;) != nullptr)</a>
<a name="ln377">      _hrTexture2DCreateFromNode(node);</a>
<a name="ln378"> </a>
<a name="ln379">  // (4) load materials</a>
<a name="ln380">  //</a>
<a name="ln381">  for (pugi::xml_node node = g_objManager.scnData.m_materialsLib.first_child(); node != nullptr; node = node.next_sibling())</a>
<a name="ln382">    if(node.attribute(L&quot;id&quot;) != nullptr)</a>
<a name="ln383">      _hrMaterialCreateFromNode(node);</a>
<a name="ln384"> </a>
<a name="ln385">  // (5) load geom</a>
<a name="ln386">  //</a>
<a name="ln387">  for (pugi::xml_node node = g_objManager.scnData.m_geometryLib.first_child(); node != nullptr; node = node.next_sibling())</a>
<a name="ln388">    if(node.attribute(L&quot;id&quot;) != nullptr)</a>
<a name="ln389">      _hrMeshCreateFromNode(node);</a>
<a name="ln390"> </a>
<a name="ln391">  std::sort(</a>
<a name="ln392">          g_objManager.scnData.meshes.begin(), g_objManager.scnData.meshes.end(),</a>
<a name="ln393">          [&amp;](auto a, auto b) { return a.id &lt; b.id; });</a>
<a name="ln394"> </a>
<a name="ln395">  // (6) load lights</a>
<a name="ln396">  //</a>
<a name="ln397">  for (pugi::xml_node node = g_objManager.scnData.m_lightsLib.first_child(); node != nullptr; node = node.next_sibling())</a>
<a name="ln398">    _hrLightCreateFromNode(node);</a>
<a name="ln399"> </a>
<a name="ln400">  // (7) load camera</a>
<a name="ln401">  //</a>
<a name="ln402">  for (pugi::xml_node node = g_objManager.scnData.m_cameraLib.first_child(); node != nullptr; node = node.next_sibling())</a>
<a name="ln403">    _hrCameraCreateFromNode(node);</a>
<a name="ln404"> </a>
<a name="ln405">  g_objManager.scnInst.resize(0);</a>
<a name="ln406">  </a>
<a name="ln407">  if(g_objManager.m_attachMode &amp;&amp; g_objManager.m_pVBSysMutex != nullptr)</a>
<a name="ln408">    hr_unlock_system_mutex(g_objManager.m_pVBSysMutex);</a>
<a name="ln409"> </a>
<a name="ln410">  if (g_objManager.m_attachMode)</a>
<a name="ln411">    HrPrint(HR_SEVERITY_INFO, L&quot;HydraAPI, generating instances&quot;);</a>
<a name="ln412"> </a>
<a name="ln413">  // (8) load instanced objects (i.e. scenes)</a>
<a name="ln414">  //</a>
<a name="ln415">  for (pugi::xml_node node = g_objManager.scnData.m_sceneNode.first_child(); node != nullptr; node = node.next_sibling())</a>
<a name="ln416">  {</a>
<a name="ln417"> </a>
<a name="ln418">    HRSceneInstRef a_pScn;</a>
<a name="ln419">    a_pScn.id = HR_IDType(g_objManager.scnInst.size());</a>
<a name="ln420"> </a>
<a name="ln421">    HRSceneInst scn;</a>
<a name="ln422">    scn.name = node.attribute(L&quot;name&quot;).value();</a>
<a name="ln423">    scn.id = a_pScn.id;</a>
<a name="ln424"> </a>
<a name="ln425">    g_objManager.scnInst.push_back(scn);</a>
<a name="ln426"> </a>
<a name="ln427">    /*g_objManager.scnInst.push_back(HRSceneInst());</a>
<a name="ln428"> </a>
<a name="ln429">    HRSceneInstRef a_pScn;</a>
<a name="ln430">    a_pScn.id = HR_IDType(g_objManager.scnInst.size()-1);*/</a>
<a name="ln431"> </a>
<a name="ln432">    for (pugi::xml_node nodeInst = node.first_child(); nodeInst != nullptr; nodeInst = nodeInst.next_sibling())</a>
<a name="ln433">    {</a>
<a name="ln434">      if (std::wstring(nodeInst.name()) == L&quot;instance&quot;)</a>
<a name="ln435">        _hrMeshInstanceFromNode(a_pScn, nodeInst);</a>
<a name="ln436">      else if (std::wstring(nodeInst.name()) == L&quot;instance_light&quot;)</a>
<a name="ln437">        _hrLightInstanceFromNode(a_pScn, nodeInst);</a>
<a name="ln438">    }</a>
<a name="ln439">    </a>
<a name="ln440">    g_objManager.scnInst[a_pScn.id].driverDirtyFlag = true; // driver need to Update this scene</a>
<a name="ln441">    g_objManager.scnInst[a_pScn.id].update(node);</a>
<a name="ln442">  }</a>
<a name="ln443"> </a>
<a name="ln444">  // (9) load render settings</a>
<a name="ln445">  //</a>
<a name="ln446">  for(pugi::xml_node renderSettings : g_objManager.scnData.m_settingsNode.children())</a>
<a name="ln447">    _hrRenderSettingsFromNode(renderSettings);</a>
<a name="ln448"> </a>
<a name="ln449">  // (10) load empty chunks to have correct chunk id for new objects if we are not in 'attach mode'</a>
<a name="ln450">  //</a>
<a name="ln451">  if(!g_objManager.m_attachMode)</a>
<a name="ln452">  {</a>
<a name="ln453">    size_t chunks = size_t(g_objManager.scnData.m_geometryLib.attribute(L&quot;total_chunks&quot;).as_llong());</a>
<a name="ln454">    g_objManager.scnData.m_vbCache.ResizeAndAllocEmptyChunks(chunks);</a>
<a name="ln455">  }</a>
<a name="ln456">  </a>
<a name="ln457">  return 1;</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">void fixTextureIds(pugi::xml_node a_node, const std::wstring &amp;a_libPath, const std::unordered_map&lt;int32_t, int32_t&gt; &amp;texIdUpdates,</a>
<a name="ln461">                   bool mergeDependencies = false)</a>
<a name="ln462">{</a>
<a name="ln463">  if (std::wstring(a_node.name()) == L&quot;texture&quot;)</a>
<a name="ln464">  {</a>
<a name="ln465">    int32_t id = a_node.attribute(L&quot;id&quot;).as_int();</a>
<a name="ln466"> </a>
<a name="ln467">    if (mergeDependencies)</a>
<a name="ln468">    {</a>
<a name="ln469">      auto texRef = HRUtils::MergeOneTextureIntoLibrary(a_libPath.c_str(), nullptr, id);</a>
<a name="ln470"> </a>
<a name="ln471">      a_node.attribute(L&quot;id&quot;).set_value(texRef.id);</a>
<a name="ln472">    }</a>
<a name="ln473">    else</a>
<a name="ln474">    {</a>
<a name="ln475">      a_node.attribute(L&quot;id&quot;).set_value(texIdUpdates.at(id));</a>
<a name="ln476">    }</a>
<a name="ln477"> </a>
<a name="ln478">  }</a>
<a name="ln479">  else</a>
<a name="ln480">  {</a>
<a name="ln481">    for (pugi::xml_node child = a_node.first_child(); child != nullptr; child = child.next_sibling())</a>
<a name="ln482">      fixTextureIds(child, a_libPath, texIdUpdates, mergeDependencies);</a>
<a name="ln483">  }</a>
<a name="ln484">}</a>
<a name="ln485"> </a>
<a name="ln486"> </a>
<a name="ln487">HRMaterialRef _hrMaterialMergeFromNode(pugi::xml_node a_node, const std::wstring &amp;a_libPath, const std::unordered_map&lt;int32_t, int32_t&gt;&amp; texIdUpdates,//int32_t numTexturesPreMerge,</a>
<a name="ln488">                                       int32_t numMaterialsPreMerge, bool mergeDependencies = false, bool forceMerge = false)</a>
<a name="ln489">{</a>
<a name="ln490">  const wchar_t* a_objectName = a_node.attribute(L&quot;name&quot;).as_string();</a>
<a name="ln491"> </a>
<a name="ln492">  std::wstring matType = a_node.attribute(L&quot;type&quot;).as_string();</a>
<a name="ln493">  int notBlend = matType.compare(std::wstring(L&quot;hydra_blend&quot;));</a>
<a name="ln494">  HRMaterialRef ref;</a>
<a name="ln495"> </a>
<a name="ln496">  /*auto isLightMat = (a_node.attribute(L&quot;light_id&quot;) != nullptr);</a>
<a name="ln497"> </a>
<a name="ln498">  if(isLightMat &amp;&amp; !forceMerge)</a>
<a name="ln499">    return HRMaterialRef();*/</a>
<a name="ln500"> </a>
<a name="ln501">  if(notBlend)</a>
<a name="ln502">  {</a>
<a name="ln503">    ref = hrMaterialCreate(a_objectName);</a>
<a name="ln504"> </a>
<a name="ln505">    hrMaterialOpen(ref, HR_WRITE_DISCARD);</a>
<a name="ln506">    {</a>
<a name="ln507">      auto matNode = hrMaterialParamNode(ref);</a>
<a name="ln508"> </a>
<a name="ln509">      for (pugi::xml_node node = a_node.first_child(); node != nullptr; node = node.next_sibling())</a>
<a name="ln510">      {</a>
<a name="ln511">        matNode.append_copy(node);</a>
<a name="ln512">      }</a>
<a name="ln513">      fixTextureIds(matNode, a_libPath, texIdUpdates, mergeDependencies);</a>
<a name="ln514">    }</a>
<a name="ln515">    hrMaterialClose(ref);</a>
<a name="ln516">  }</a>
<a name="ln517">  else</a>
<a name="ln518">  {</a>
<a name="ln519">    HRMaterialRef matA;</a>
<a name="ln520">    HRMaterialRef matB;</a>
<a name="ln521"> </a>
<a name="ln522">    if (mergeDependencies)</a>
<a name="ln523">    {</a>
<a name="ln524">      matA = HRUtils::MergeOneMaterialIntoLibrary(a_libPath.c_str(), nullptr, a_node.attribute(L&quot;node_top&quot;).as_int());</a>
<a name="ln525">      matB = HRUtils::MergeOneMaterialIntoLibrary(a_libPath.c_str(), nullptr, a_node.attribute(L&quot;node_bottom&quot;).as_int());</a>
<a name="ln526">    }</a>
<a name="ln527">    else</a>
<a name="ln528">    {</a>
<a name="ln529">      matA.id = a_node.attribute(L&quot;node_top&quot;).as_int() + numMaterialsPreMerge;</a>
<a name="ln530">      matB.id = a_node.attribute(L&quot;node_bottom&quot;).as_int() + numMaterialsPreMerge;</a>
<a name="ln531">    }</a>
<a name="ln532"> </a>
<a name="ln533">    ref = hrMaterialCreateBlend(a_objectName, matA, matB);</a>
<a name="ln534"> </a>
<a name="ln535">    hrMaterialOpen(ref, HR_WRITE_DISCARD);</a>
<a name="ln536">    {</a>
<a name="ln537">      auto matNode = hrMaterialParamNode(ref);</a>
<a name="ln538"> </a>
<a name="ln539">      for (pugi::xml_node node = a_node.first_child(); node != nullptr; node = node.next_sibling())</a>
<a name="ln540">      {</a>
<a name="ln541">        matNode.append_copy(node);</a>
<a name="ln542">      }</a>
<a name="ln543">      fixTextureIds(matNode, a_libPath, texIdUpdates, mergeDependencies);</a>
<a name="ln544"> </a>
<a name="ln545">    }</a>
<a name="ln546">    hrMaterialClose(ref);</a>
<a name="ln547">  }</a>
<a name="ln548"> </a>
<a name="ln549">  return ref;</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552">HRTextureNodeRef _hrTexture2DMergeFromNode(pugi::xml_node a_node, const std::wstring &amp;a_libPath)</a>
<a name="ln553">{</a>
<a name="ln554">  const std::wstring dl       = a_node.attribute(L&quot;dl&quot;).as_string();</a>
<a name="ln555">  const std::wstring loc      = a_node.attribute(L&quot;loc&quot;).as_string();</a>
<a name="ln556">  const std::wstring a_objectName = a_node.attribute(L&quot;name&quot;).as_string();</a>
<a name="ln557"> </a>
<a name="ln558">  std::wstring a_fileName;</a>
<a name="ln559">  if(dl == L&quot;1&quot;)</a>
<a name="ln560">  {</a>
<a name="ln561">    a_fileName = a_node.attribute(L&quot;path&quot;).as_string();</a>
<a name="ln562">  }</a>
<a name="ln563">  else</a>
<a name="ln564">  {</a>
<a name="ln565">    std::wstringstream ss;</a>
<a name="ln566">    ss &lt;&lt; a_libPath &lt;&lt; L&quot;/&quot; &lt;&lt; loc;</a>
<a name="ln567">    a_fileName = ss.str();</a>
<a name="ln568">  }</a>
<a name="ln569"> </a>
<a name="ln570">  HRTextureNodeRef ref = hrTexture2DCreateFromFile(a_fileName.c_str());</a>
<a name="ln571"> </a>
<a name="ln572">  return ref;</a>
<a name="ln573">}</a>
<a name="ln574"> </a>
<a name="ln575">HRLightRef _hrLightMergeFromNode(pugi::xml_node a_node, const std::wstring &amp;a_libPath, const std::unordered_map&lt;int32_t, int32_t&gt; &amp;texIdUpdates,</a>
<a name="ln576">                                 bool mergeDependencies = false)</a>
<a name="ln577">{</a>
<a name="ln578">  const wchar_t* a_objectName = a_node.attribute(L&quot;name&quot;).as_string();</a>
<a name="ln579">  const wchar_t* a_lightType = a_node.attribute(L&quot;type&quot;).as_string();</a>
<a name="ln580">  const wchar_t* a_lightShape = a_node.attribute(L&quot;shape&quot;).as_string();</a>
<a name="ln581">  const wchar_t* a_lightDistribution = a_node.attribute(L&quot;distribution&quot;).as_string();</a>
<a name="ln582">  int a_lightVisibility = a_node.attribute(L&quot;visible&quot;).as_int();</a>
<a name="ln583"> </a>
<a name="ln584">  HRLightRef ref = hrLightCreate(a_objectName);</a>
<a name="ln585"> </a>
<a name="ln586">  hrLightOpen(ref, HR_WRITE_DISCARD);</a>
<a name="ln587">  {</a>
<a name="ln588">    auto lightNode = hrLightParamNode(ref);</a>
<a name="ln589"> </a>
<a name="ln590">    lightNode.force_attribute(L&quot;type&quot;).set_value(a_lightType);</a>
<a name="ln591">    lightNode.force_attribute(L&quot;shape&quot;).set_value(a_lightShape);</a>
<a name="ln592">    lightNode.force_attribute(L&quot;distribution&quot;).set_value(a_lightDistribution);</a>
<a name="ln593">    lightNode.force_attribute(L&quot;visible&quot;).set_value(a_lightVisibility);</a>
<a name="ln594"> </a>
<a name="ln595">    for (pugi::xml_node node = a_node.first_child(); node != nullptr; node = node.next_sibling())</a>
<a name="ln596">    {</a>
<a name="ln597">      lightNode.append_copy(node);</a>
<a name="ln598">    }</a>
<a name="ln599">    fixTextureIds(lightNode, a_libPath, texIdUpdates, mergeDependencies);</a>
<a name="ln600"> </a>
<a name="ln601">  }</a>
<a name="ln602">  hrLightClose(ref);</a>
<a name="ln603"> </a>
<a name="ln604"> </a>
<a name="ln605"> </a>
<a name="ln606">  return ref;</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609"> </a>
<a name="ln610">HRMeshRef _hrMeshMergeFromNode(pugi::xml_node a_node, const std::wstring &amp;a_libPath, int32_t numMaterialsPreMerge,</a>
<a name="ln611">                               bool mergeDependencies = false, bool forceMerge = false)</a>
<a name="ln612">{</a>
<a name="ln613">  const std::wstring dl       = a_node.attribute(L&quot;dl&quot;).as_string();</a>
<a name="ln614">  const std::wstring loc      = a_node.attribute(L&quot;loc&quot;).as_string();</a>
<a name="ln615">  const std::wstring a_objectName = a_node.attribute(L&quot;name&quot;).as_string();</a>
<a name="ln616"> </a>
<a name="ln617">  auto isLightMesh = (a_node.attribute(L&quot;light_id&quot;) != nullptr);</a>
<a name="ln618"> </a>
<a name="ln619">  //std::cout &lt;&lt; &quot;mesh : &quot; &lt;&lt; ws2s(a_objectName) &lt;&lt; std::endl;</a>
<a name="ln620"> </a>
<a name="ln621">  if(isLightMesh &amp;&amp; !forceMerge)</a>
<a name="ln622">    return HRMeshRef();</a>
<a name="ln623"> </a>
<a name="ln624">  std::wstring a_fileName;</a>
<a name="ln625">  if(dl == L&quot;1&quot;)</a>
<a name="ln626">  {</a>
<a name="ln627">    a_fileName = a_node.attribute(L&quot;path&quot;).as_string();</a>
<a name="ln628">  }</a>
<a name="ln629">  else</a>
<a name="ln630">  {</a>
<a name="ln631">    std::wstringstream ss;</a>
<a name="ln632">    ss &lt;&lt; a_libPath &lt;&lt; L&quot;/&quot; &lt;&lt; loc;</a>
<a name="ln633">    a_fileName = ss.str();</a>
<a name="ln634">  }</a>
<a name="ln635"> </a>
<a name="ln636">  HRMeshRef ref = hrMeshCreateFromFileDL(a_fileName.c_str());</a>
<a name="ln637"> </a>
<a name="ln638">  //std::cout &lt;&lt; &quot;mesh : &quot; &lt;&lt; ws2s(a_fileName) &lt;&lt; std::endl;</a>
<a name="ln639"> </a>
<a name="ln640">  hrMeshOpen(ref, HR_TRIANGLE_IND3, HR_OPEN_EXISTING);</a>
<a name="ln641">  {</a>
<a name="ln642">    auto meshInfo = hrMeshGetInfo(ref);</a>
<a name="ln643"> </a>
<a name="ln644">    const int triNum = meshInfo.indicesNum / 3;</a>
<a name="ln645"> </a>
<a name="ln646">    auto matindices = (int32_t*)hrMeshGetPrimitiveAttribPointer(ref, L&quot;mind&quot;);</a>
<a name="ln647"> </a>
<a name="ln648">    std::unordered_set&lt;int&gt; matIdsToMerge;</a>
<a name="ln649"> </a>
<a name="ln650">    for (auto i = 0; i &lt; triNum; ++i)</a>
<a name="ln651">    {</a>
<a name="ln652">      if (mergeDependencies)</a>
<a name="ln653">      {</a>
<a name="ln654">        matIdsToMerge.insert(matindices[i]);</a>
<a name="ln655">      }</a>
<a name="ln656">      else</a>
<a name="ln657">      {</a>
<a name="ln658">        matindices[i] += numMaterialsPreMerge;</a>
<a name="ln659">      }</a>
<a name="ln660">    }</a>
<a name="ln661"> </a>
<a name="ln662">    if (mergeDependencies)</a>
<a name="ln663">    {</a>
<a name="ln664">      std::unordered_map&lt;int, int&gt; matIdsOldToNew;</a>
<a name="ln665">      for (auto matId : matIdsToMerge)</a>
<a name="ln666">      {</a>
<a name="ln667">        matIdsOldToNew[matId] = HRUtils::MergeOneMaterialIntoLibrary(a_libPath.c_str(), nullptr, matId).id;</a>
<a name="ln668">      }</a>
<a name="ln669"> </a>
<a name="ln670">      for (auto i = 0; i &lt; triNum; ++i)</a>
<a name="ln671">      {</a>
<a name="ln672">        matindices[i] = matIdsOldToNew[matindices[i]];</a>
<a name="ln673">      }</a>
<a name="ln674">    }</a>
<a name="ln675"> </a>
<a name="ln676">  }</a>
<a name="ln677">  hrMeshClose(ref);</a>
<a name="ln678"> </a>
<a name="ln679">  return ref;</a>
<a name="ln680">}</a>
<a name="ln681"> </a>
<a name="ln682">void _hrInstanceMergeFromNode(HRSceneInstRef a_scn, pugi::xml_node a_node, int32_t numMeshesPreMerge,</a>
<a name="ln683">                              const std::vector&lt;std::vector&lt;int&gt; &gt; &amp;remap_lists, bool mergeLights = false,</a>
<a name="ln684">                              int32_t numLightsPreMerge = 0)</a>
<a name="ln685">{</a>
<a name="ln686">  std::wstring nodeName = a_node.name();</a>
<a name="ln687"> </a>
<a name="ln688">  float matrix[16];</a>
<a name="ln689">  HydraXMLHelpers::ReadMatrix4x4(a_node, L&quot;matrix&quot;, matrix);</a>
<a name="ln690"> </a>
<a name="ln691">  if(mergeLights &amp;&amp; nodeName == std::wstring(L&quot;instance_light&quot;))</a>
<a name="ln692">  {</a>
<a name="ln693">    int light_id = a_node.attribute(L&quot;light_id&quot;).as_int();</a>
<a name="ln694">    //int lgroup_id = a_node.attribute(L&quot;lgroup_id&quot;).as_int();</a>
<a name="ln695"> </a>
<a name="ln696">    HRLightRef ref;</a>
<a name="ln697">    ref.id = light_id + numLightsPreMerge;</a>
<a name="ln698"> </a>
<a name="ln699">    hrLightInstance(a_scn, ref, matrix);</a>
<a name="ln700">  }</a>
<a name="ln701">  else if(nodeName == std::wstring(L&quot;instance&quot;))</a>
<a name="ln702">  {</a>
<a name="ln703">    int mesh_id = a_node.attribute(L&quot;mesh_id&quot;).as_int();</a>
<a name="ln704">    int rmap_id = -1;</a>
<a name="ln705">    if(a_node.attribute(L&quot;rmap_id&quot;) != nullptr)</a>
<a name="ln706">      rmap_id = a_node.attribute(L&quot;rmap_id&quot;).as_int();</a>
<a name="ln707"> </a>
<a name="ln708">    bool isLightMesh = (a_node.attribute(L&quot;light_id&quot;) != nullptr);</a>
<a name="ln709"> </a>
<a name="ln710">    if(!isLightMesh)</a>
<a name="ln711">    {</a>
<a name="ln712">      HRMeshRef ref;</a>
<a name="ln713">      ref.id = mesh_id + numMeshesPreMerge;</a>
<a name="ln714"> </a>
<a name="ln715">      if (rmap_id == -1)</a>
<a name="ln716">        hrMeshInstance(a_scn, ref, matrix);</a>
<a name="ln717">      else</a>
<a name="ln718">        hrMeshInstance(a_scn, ref, matrix, &amp;remap_lists.at((unsigned long) rmap_id)[0],</a>
<a name="ln719">                       int32_t(remap_lists.at((unsigned long) rmap_id).size()));</a>
<a name="ln720">    }</a>
<a name="ln721">  }</a>
<a name="ln722"> </a>
<a name="ln723">}</a>
<a name="ln724"> </a>
<a name="ln725"> </a>
<a name="ln726">HRSceneInstRef HRUtils::MergeLibraryIntoLibrary(const wchar_t* a_libPath, bool mergeLights, bool copyScene,</a>
<a name="ln727">                                                const wchar_t* a_stateFileName, MergeInfo* pInfo)</a>
<a name="ln728">{</a>
<a name="ln729">  std::wstring fileName(a_stateFileName);</a>
<a name="ln730">  int stateId = 0;</a>
<a name="ln731"> </a>
<a name="ln732">  if(fileName == L&quot;&quot;)</a>
<a name="ln733">  {</a>
<a name="ln734">    _hrFindTargetOrLastState(a_libPath, -1,</a>
<a name="ln735">                             fileName, stateId);</a>
<a name="ln736">  }</a>
<a name="ln737">  else</a>
<a name="ln738">    fileName = std::wstring(a_libPath) + L&quot;/&quot; + a_stateFileName;</a>
<a name="ln739"> </a>
<a name="ln740">  HRSceneInstRef mergedScn;</a>
<a name="ln741"> </a>
<a name="ln742">  if(fileName.empty())</a>
<a name="ln743">  {</a>
<a name="ln744">    HrError(L&quot;MergeLibraryIntoLibrary, can't find existing library at: &quot;, a_libPath);</a>
<a name="ln745">    return mergedScn;</a>
<a name="ln746">  }</a>
<a name="ln747"> </a>
<a name="ln748">  pugi::xml_document docToMerge;</a>
<a name="ln749"> </a>
<a name="ln750">  auto loadResult = docToMerge.load_file(fileName.c_str());</a>
<a name="ln751"> </a>
<a name="ln752">  if (!loadResult)</a>
<a name="ln753">  {</a>
<a name="ln754">    HrError(L&quot;MergeLibraryIntoLibrary, pugixml load: &quot;, loadResult.description());</a>
<a name="ln755">    return mergedScn;</a>
<a name="ln756">  }</a>
<a name="ln757"> </a>
<a name="ln758">  auto numTexturesPreMerge  = int32_t(g_objManager.scnData.textures.size());</a>
<a name="ln759">  auto numMaterialsPreMerge = int32_t(g_objManager.scnData.materials.size());</a>
<a name="ln760">  auto numMeshesPreMerge    = int32_t(g_objManager.scnData.meshes.size());</a>
<a name="ln761">  auto numLightsPreMerge    = int32_t(g_objManager.scnData.lights.size());</a>
<a name="ln762"> </a>
<a name="ln763">  if(pInfo != nullptr)</a>
<a name="ln764">  {</a>
<a name="ln765">    pInfo-&gt;texturesRange[0] = numTexturesPreMerge;</a>
<a name="ln766">    pInfo-&gt;materialRange[0] = numMaterialsPreMerge;</a>
<a name="ln767">    pInfo-&gt;meshRange    [0] = numMeshesPreMerge;</a>
<a name="ln768">    pInfo-&gt;lightsRange  [0] = numLightsPreMerge;</a>
<a name="ln769">  }</a>
<a name="ln770"> </a>
<a name="ln771">  std::unordered_map&lt;int32_t, int32_t&gt; texIdUpdates;</a>
<a name="ln772"> </a>
<a name="ln773">  for (pugi::xml_node node = docToMerge.child(L&quot;textures_lib&quot;).first_child(); node != nullptr; node = node.next_sibling())</a>
<a name="ln774">  {</a>
<a name="ln775">    auto ref = _hrTexture2DMergeFromNode(node, std::wstring(a_libPath));</a>
<a name="ln776">    //bool isNewTex = (g_objManager.scnData.textures.size() - numTexturesPreMerge) &gt; 0;</a>
<a name="ln777">    auto srcSceneId = node.attribute(L&quot;id&quot;).as_int();</a>
<a name="ln778"> </a>
<a name="ln779">    texIdUpdates[srcSceneId] = ref.id;</a>
<a name="ln780">  }</a>
<a name="ln781"> </a>
<a name="ln782">  //int32_t newTexturesMerged = int32_t(g_objManager.scnData.textures.size()) - numTexturesPreMerge;</a>
<a name="ln783"> </a>
<a name="ln784">  for (pugi::xml_node node = docToMerge.child(L&quot;materials_lib&quot;).first_child(); node != nullptr; node = node.next_sibling())</a>
<a name="ln785">    _hrMaterialMergeFromNode(node, std::wstring(a_libPath), texIdUpdates, numMaterialsPreMerge);</a>
<a name="ln786"> </a>
<a name="ln787">  //int32_t newMaterialsMerged = int32_t(g_objManager.scnData.materials.size()) - numMaterialsPreMerge;</a>
<a name="ln788"> </a>
<a name="ln789"> </a>
<a name="ln790">  for (pugi::xml_node node = docToMerge.child(L&quot;geometry_lib&quot;).first_child(); node != nullptr; node = node.next_sibling())</a>
<a name="ln791">    _hrMeshMergeFromNode(node, std::wstring(a_libPath), numMaterialsPreMerge);</a>
<a name="ln792"> </a>
<a name="ln793"> </a>
<a name="ln794">  //int32_t newMeshesMerged = int32_t(g_objManager.scnData.meshes.size()) - numMeshesPreMerge;</a>
<a name="ln795"> </a>
<a name="ln796">  if(mergeLights)</a>
<a name="ln797">  {</a>
<a name="ln798">    for (pugi::xml_node node = docToMerge.child(L&quot;lights_lib&quot;).first_child(); node != nullptr; node = node.next_sibling())</a>
<a name="ln799">      _hrLightMergeFromNode(node, std::wstring(a_libPath), texIdUpdates);</a>
<a name="ln800">  }</a>
<a name="ln801"> </a>
<a name="ln802">  if(copyScene)</a>
<a name="ln803">  {</a>
<a name="ln804">    mergedScn = hrSceneCreate(a_libPath);</a>
<a name="ln805"> </a>
<a name="ln806">    hrSceneOpen(mergedScn, HR_WRITE_DISCARD);</a>
<a name="ln807"> </a>
<a name="ln808">    std::vector&lt; std::vector &lt;int&gt; &gt; remap_lists;</a>
<a name="ln809">    pugi::xml_node sceneToMergeNode = docToMerge.child(L&quot;scenes&quot;).first_child();</a>
<a name="ln810">    for (pugi::xml_node node = sceneToMergeNode.first_child(); node != nullptr; node = node.next_sibling())</a>
<a name="ln811">    {</a>
<a name="ln812">      if(node.name() == std::wstring(L&quot;remap_lists&quot;))</a>
<a name="ln813">      {</a>
<a name="ln814">        remap_lists = HydraXMLHelpers::ReadRemapLists(node);</a>
<a name="ln815"> </a>
<a name="ln816">        for(auto&amp; list : remap_lists)</a>
<a name="ln817">        {</a>
<a name="ln818">          std::for_each(list.begin(), list.end(), [=](int &amp;x) { x += numMaterialsPreMerge ; });</a>
<a name="ln819">         // list += numMaterialsPreMerge;</a>
<a name="ln820">          /*for(auto i = 0; i &lt; list.size(); ++i)</a>
<a name="ln821">          {</a>
<a name="ln822">            if(i % 2 != 0)</a>
<a name="ln823">              list.at(i) += numMaterialsPreMerge;</a>
<a name="ln824">          }*/</a>
<a name="ln825">        }</a>
<a name="ln826">      }</a>
<a name="ln827">      else</a>
<a name="ln828">      {</a>
<a name="ln829">        _hrInstanceMergeFromNode(mergedScn, node, numMeshesPreMerge, remap_lists, mergeLights, numLightsPreMerge);</a>
<a name="ln830">      }</a>
<a name="ln831">    }</a>
<a name="ln832"> </a>
<a name="ln833">    hrSceneClose(mergedScn);</a>
<a name="ln834">  }</a>
<a name="ln835"> </a>
<a name="ln836">  auto numTexturesPostMerge  = int32_t(g_objManager.scnData.textures.size());</a>
<a name="ln837">  auto numMaterialsPostMerge = int32_t(g_objManager.scnData.materials.size());</a>
<a name="ln838">  auto numMeshesPostMerge    = int32_t(g_objManager.scnData.meshes.size());</a>
<a name="ln839">  auto numLightsPostMerge    = int32_t(g_objManager.scnData.lights.size());</a>
<a name="ln840"> </a>
<a name="ln841">  if(pInfo != nullptr)</a>
<a name="ln842">  {</a>
<a name="ln843">    pInfo-&gt;texturesRange[1] = numTexturesPostMerge;</a>
<a name="ln844">    pInfo-&gt;materialRange[1] = numMaterialsPostMerge;</a>
<a name="ln845">    pInfo-&gt;meshRange    [1] = numMeshesPostMerge;</a>
<a name="ln846">    pInfo-&gt;lightsRange  [1] = numLightsPostMerge;</a>
<a name="ln847">  }</a>
<a name="ln848"> </a>
<a name="ln849">  return mergedScn;</a>
<a name="ln850">}</a>
<a name="ln851"> </a>
<a name="ln852">HRTextureNodeRef HRUtils::MergeOneTextureIntoLibrary(const wchar_t* a_libPath, const wchar_t* a_texName, int a_texId)</a>
<a name="ln853">{</a>
<a name="ln854">  std::wstring fileName;</a>
<a name="ln855">  int stateId = 0;</a>
<a name="ln856">  HRTextureNodeRef ref;</a>
<a name="ln857"> </a>
<a name="ln858">  _hrFindTargetOrLastState(a_libPath, -1, fileName, stateId);</a>
<a name="ln859"> </a>
<a name="ln860">  if (fileName.empty())</a>
<a name="ln861">  {</a>
<a name="ln862">    HrError(L&quot;MergeOneTextureIntoLibrary, can't find existing library at: &quot;, a_libPath);</a>
<a name="ln863">    return ref;</a>
<a name="ln864">  }</a>
<a name="ln865"> </a>
<a name="ln866">  pugi::xml_document docToMerge;</a>
<a name="ln867"> </a>
<a name="ln868">  auto loadResult = docToMerge.load_file(fileName.c_str());</a>
<a name="ln869"> </a>
<a name="ln870">  if (!loadResult)</a>
<a name="ln871">  {</a>
<a name="ln872">    HrError(L&quot;MergeOneTextureIntoLibrary, pugixml load: &quot;, loadResult.description());</a>
<a name="ln873">    return ref;</a>
<a name="ln874">  }</a>
<a name="ln875"> </a>
<a name="ln876">  //auto numTexturesPreMerge = int32_t(g_objManager.scnData.textures.size());</a>
<a name="ln877"> </a>
<a name="ln878">  for (pugi::xml_node node = docToMerge.child(L&quot;textures_lib&quot;).first_child(); node != nullptr; node = node.next_sibling())</a>
<a name="ln879">  {</a>
<a name="ln880">    std::wstring texName = node.attribute(L&quot;name&quot;).as_string();</a>
<a name="ln881">    if ((a_texName != nullptr &amp;&amp; texName == std::wstring(a_texName))</a>
<a name="ln882">          || node.attribute(L&quot;id&quot;).as_int() == a_texId)</a>
<a name="ln883">    {</a>
<a name="ln884">      ref = _hrTexture2DMergeFromNode(node, std::wstring(a_libPath));</a>
<a name="ln885">      break;</a>
<a name="ln886">    }</a>
<a name="ln887">  }</a>
<a name="ln888"> </a>
<a name="ln889">  return ref;</a>
<a name="ln890">}</a>
<a name="ln891"> </a>
<a name="ln892"> </a>
<a name="ln893">HRMaterialRef HRUtils::MergeOneMaterialIntoLibrary(const wchar_t* a_libPath, const wchar_t* a_matName, int a_matId)</a>
<a name="ln894">{</a>
<a name="ln895">  std::wstring fileName;</a>
<a name="ln896">  int stateId = 0;</a>
<a name="ln897">  HRMaterialRef ref;</a>
<a name="ln898"> </a>
<a name="ln899">  _hrFindTargetOrLastState(a_libPath, -1, fileName, stateId);</a>
<a name="ln900"> </a>
<a name="ln901">  if (fileName.empty())</a>
<a name="ln902">  {</a>
<a name="ln903">    HrError(L&quot;MergeOneMaterialIntoLibrary, can't find existing library at: &quot;, a_libPath);</a>
<a name="ln904">    return ref;</a>
<a name="ln905">  }</a>
<a name="ln906"> </a>
<a name="ln907">  pugi::xml_document docToMerge;</a>
<a name="ln908"> </a>
<a name="ln909">  auto loadResult = docToMerge.load_file(fileName.c_str());</a>
<a name="ln910"> </a>
<a name="ln911">  if (!loadResult)</a>
<a name="ln912">  {</a>
<a name="ln913">    HrError(L&quot;MergeOneMaterialIntoLibrary, pugixml load: &quot;, loadResult.description());</a>
<a name="ln914">    return ref;</a>
<a name="ln915">  }</a>
<a name="ln916"> </a>
<a name="ln917">  //auto numTexturesPreMerge = int32_t(g_objManager.scnData.textures.size());</a>
<a name="ln918">  auto numMaterialsPreMerge = int32_t(g_objManager.scnData.materials.size());</a>
<a name="ln919"> </a>
<a name="ln920">  std::unordered_map&lt;int32_t, int32_t&gt; texIdsUpdate;</a>
<a name="ln921"> </a>
<a name="ln922">  for (pugi::xml_node node = docToMerge.child(L&quot;materials_lib&quot;).first_child(); node != nullptr; node = node.next_sibling())</a>
<a name="ln923">  {</a>
<a name="ln924">    std::wstring matName = node.attribute(L&quot;name&quot;).as_string();</a>
<a name="ln925">    if ((a_matName != nullptr &amp;&amp; matName == std::wstring(a_matName))</a>
<a name="ln926">          || node.attribute(L&quot;id&quot;).as_int() == a_matId)</a>
<a name="ln927">    {</a>
<a name="ln928">      ref = _hrMaterialMergeFromNode(node, std::wstring(a_libPath), texIdsUpdate, numMaterialsPreMerge, true, true);</a>
<a name="ln929">      break;</a>
<a name="ln930">    }</a>
<a name="ln931">  }</a>
<a name="ln932"> </a>
<a name="ln933">  return ref;</a>
<a name="ln934">}</a>
<a name="ln935"> </a>
<a name="ln936">HRMeshRef HRUtils::MergeOneMeshIntoLibrary(const wchar_t* a_libPath, const wchar_t* a_meshName)</a>
<a name="ln937">{</a>
<a name="ln938">  std::wstring fileName;</a>
<a name="ln939">  int stateId = 0;</a>
<a name="ln940">  HRMeshRef ref;</a>
<a name="ln941"> </a>
<a name="ln942">  _hrFindTargetOrLastState(a_libPath, -1, fileName, stateId);</a>
<a name="ln943"> </a>
<a name="ln944">  if (fileName.empty())</a>
<a name="ln945">  {</a>
<a name="ln946">    HrError(L&quot;MergeOneMeshIntoLibrary, can't find existing library at: &quot;, a_libPath);</a>
<a name="ln947">    return ref;</a>
<a name="ln948">  }</a>
<a name="ln949"> </a>
<a name="ln950">  pugi::xml_document docToMerge;</a>
<a name="ln951"> </a>
<a name="ln952">  auto loadResult = docToMerge.load_file(fileName.c_str());</a>
<a name="ln953"> </a>
<a name="ln954">  if (!loadResult)</a>
<a name="ln955">  {</a>
<a name="ln956">    HrError(L&quot;MergeOneMeshIntoLibrary, pugixml load: &quot;, loadResult.description());</a>
<a name="ln957">    return ref;</a>
<a name="ln958">  }</a>
<a name="ln959"> </a>
<a name="ln960">  auto numMaterialsPreMerge = int32_t(g_objManager.scnData.materials.size());</a>
<a name="ln961"> </a>
<a name="ln962"> </a>
<a name="ln963">  for (pugi::xml_node node = docToMerge.child(L&quot;geometry_lib&quot;).first_child(); node != nullptr; node = node.next_sibling())</a>
<a name="ln964">  {</a>
<a name="ln965">    std::wstring meshName = node.attribute(L&quot;name&quot;).as_string();</a>
<a name="ln966">    if (meshName == std::wstring(a_meshName))</a>
<a name="ln967">    {</a>
<a name="ln968">      ref = _hrMeshMergeFromNode(node, std::wstring(a_libPath), numMaterialsPreMerge, true, true);</a>
<a name="ln969">      break;</a>
<a name="ln970">    }</a>
<a name="ln971">  }</a>
<a name="ln972">  return ref;</a>
<a name="ln973">}</a>
<a name="ln974"> </a>
<a name="ln975"> </a>
<a name="ln976">HRLightRef HRUtils::MergeOneLightIntoLibrary(const wchar_t* a_libPath, const wchar_t* a_lightName)</a>
<a name="ln977">{</a>
<a name="ln978">  std::wstring fileName;</a>
<a name="ln979">  int stateId = 0;</a>
<a name="ln980">  HRLightRef ref;</a>
<a name="ln981"> </a>
<a name="ln982">  _hrFindTargetOrLastState(a_libPath, -1, fileName, stateId);</a>
<a name="ln983"> </a>
<a name="ln984">  if (fileName.empty())</a>
<a name="ln985">  {</a>
<a name="ln986">    HrError(L&quot;MergeOneLightIntoLibrary, can't find existing library at: &quot;, a_libPath);</a>
<a name="ln987">    return ref;</a>
<a name="ln988">  }</a>
<a name="ln989"> </a>
<a name="ln990">  pugi::xml_document docToMerge;</a>
<a name="ln991"> </a>
<a name="ln992">  auto loadResult = docToMerge.load_file(fileName.c_str());</a>
<a name="ln993"> </a>
<a name="ln994">  if (!loadResult)</a>
<a name="ln995">  {</a>
<a name="ln996">    HrError(L&quot;MergeOneLightIntoLibrary, pugixml load: &quot;, loadResult.description());</a>
<a name="ln997">    return ref;</a>
<a name="ln998">  }</a>
<a name="ln999"> </a>
<a name="ln1000">  //auto numTexturesPreMerge = int32_t(g_objManager.scnData.textures.size());</a>
<a name="ln1001"> </a>
<a name="ln1002">  std::unordered_map&lt;int32_t, int32_t&gt; texIdsUpdate;</a>
<a name="ln1003"> </a>
<a name="ln1004">  for (pugi::xml_node node = docToMerge.child(L&quot;lights_lib&quot;).first_child(); node != nullptr; node = node.next_sibling())</a>
<a name="ln1005">  {</a>
<a name="ln1006">    std::wstring lightName = node.attribute(L&quot;name&quot;).as_string();</a>
<a name="ln1007">    if (lightName == std::wstring(a_lightName))</a>
<a name="ln1008">    {</a>
<a name="ln1009">      ref = _hrLightMergeFromNode(node, std::wstring(a_libPath), texIdsUpdate, true);</a>
<a name="ln1010">      break;</a>
<a name="ln1011">    }</a>
<a name="ln1012">  }</a>
<a name="ln1013">  return ref;</a>
<a name="ln1014">}</a>
<a name="ln1015"> </a>
<a name="ln1016">BBox HRUtils::InstanceSceneIntoScene(HRSceneInstRef a_scnFrom, HRSceneInstRef a_scnTo, float a_mat[16],</a>
<a name="ln1017">                                     bool origin, const int32_t* remapListOverride, int32_t remapListSize)</a>
<a name="ln1018">{</a>
<a name="ln1019">  HRSceneInst *pScn = g_objManager.PtrById(a_scnFrom);</a>
<a name="ln1020">  HRSceneInst *pScn2 = g_objManager.PtrById(a_scnTo);</a>
<a name="ln1021">  bool overrideRemapLists = (remapListSize != 0) &amp;&amp; (remapListOverride != nullptr);</a>
<a name="ln1022">  if (pScn == nullptr || pScn2 == nullptr)</a>
<a name="ln1023">  {</a>
<a name="ln1024">    HrError(L&quot;HRUtils::InstanceSceneIntoScene: one of the scenes is nullptr&quot;);</a>
<a name="ln1025">    return BBox();</a>
<a name="ln1026">  }</a>
<a name="ln1027"> </a>
<a name="ln1028">  if (pScn-&gt;opened)</a>
<a name="ln1029">  {</a>
<a name="ln1030">    hrSceneClose(a_scnFrom);</a>
<a name="ln1031">  }</a>
<a name="ln1032">  if (pScn2-&gt;opened)</a>
<a name="ln1033">  {</a>
<a name="ln1034">    hrSceneClose(a_scnTo);</a>
<a name="ln1035">  }</a>
<a name="ln1036"> </a>
<a name="ln1037"> /* std::cout &lt;&lt; &quot;pScn-&gt;m_bbox of loaded scene: &quot; &lt;&lt; pScn-&gt;m_bbox.x_min &lt;&lt; &quot; &quot; &lt;&lt; pScn-&gt;m_bbox.x_max &lt;&lt; &quot; &quot; &lt;&lt;</a>
<a name="ln1038">            pScn-&gt;m_bbox.y_min &lt;&lt; &quot; &quot; &lt;&lt; pScn-&gt;m_bbox.y_max &lt;&lt; &quot; &quot; &lt;&lt;</a>
<a name="ln1039">            pScn-&gt;m_bbox.z_min &lt;&lt; &quot; &quot; &lt;&lt; pScn-&gt;m_bbox.z_max &lt;&lt; std::endl;</a>
<a name="ln1040"> </a>
<a name="ln1041">  std::cout &lt;&lt; &quot;matrix: &quot;;</a>
<a name="ln1042">  for(int i = 0; i &lt; 16; ++i)</a>
<a name="ln1043">  {</a>
<a name="ln1044">    std::cout &lt;&lt; a_mat[i] &lt;&lt; &quot; &quot;;</a>
<a name="ln1045">  }</a>
<a name="ln1046">  std::cout &lt;&lt; std::endl;</a>
<a name="ln1047">*/</a>
<a name="ln1048">  BBox bbox(HRUtils::transformBBox(pScn-&gt;m_bbox, a_mat));</a>
<a name="ln1049">/*</a>
<a name="ln1050">  std::cout &lt;&lt; &quot;bbox of transformed scene: &quot; &lt;&lt; bbox.x_min &lt;&lt; &quot; &quot; &lt;&lt; bbox.x_max &lt;&lt; &quot; &quot;</a>
<a name="ln1051">                                             &lt;&lt; bbox.y_min &lt;&lt; &quot; &quot; &lt;&lt; bbox.y_max &lt;&lt; &quot; &quot;</a>
<a name="ln1052">                                             &lt;&lt; bbox.z_min &lt;&lt; &quot; &quot; &lt;&lt; bbox.z_max &lt;&lt; std::endl;</a>
<a name="ln1053">*/</a>
<a name="ln1054">  hrSceneOpen(a_scnFrom, HR_OPEN_READ_ONLY);</a>
<a name="ln1055"> </a>
<a name="ln1056">  std::vector&lt;HRSceneInst::Instance&gt; backupListMeshes(pScn-&gt;drawList);</a>
<a name="ln1057">  std::vector&lt;HRSceneInst::Instance&gt; backupListLights(pScn-&gt;drawListLights);</a>
<a name="ln1058">  std::vector&lt;std::vector&lt;int32_t&gt; &gt; backupListRemapLists;</a>
<a name="ln1059">  if(!overrideRemapLists)</a>
<a name="ln1060">    backupListRemapLists = pScn-&gt;m_remapList;</a>
<a name="ln1061"> </a>
<a name="ln1062">  hrSceneClose(a_scnFrom);</a>
<a name="ln1063"> </a>
<a name="ln1064">  HR_OPEN_MODE mode;</a>
<a name="ln1065"> </a>
<a name="ln1066">  if(a_scnFrom.id == a_scnTo.id)</a>
<a name="ln1067">    mode = HR_WRITE_DISCARD;</a>
<a name="ln1068">  else</a>
<a name="ln1069">    mode = HR_OPEN_EXISTING;</a>
<a name="ln1070"> </a>
<a name="ln1071">  hrSceneOpen(a_scnTo, mode);</a>
<a name="ln1072"> </a>
<a name="ln1073">  pScn2-&gt;instancedScenesCounter++;</a>
<a name="ln1074"> </a>
<a name="ln1075">  for (auto light : backupListLights)</a>
<a name="ln1076">  {</a>
<a name="ln1077">    HRLightRef tmp;</a>
<a name="ln1078">    tmp.id = light.lightId;</a>
<a name="ln1079">    hrLightInstance(a_scnTo, tmp, light.m);</a>
<a name="ln1080">  }</a>
<a name="ln1081"> </a>
<a name="ln1082">  for (auto mesh : backupListMeshes)</a>
<a name="ln1083">  {</a>
<a name="ln1084">    if (mesh.lightId &lt; 0)</a>
<a name="ln1085">    {</a>
<a name="ln1086">      HRMeshRef tmp;</a>
<a name="ln1087">      tmp.id = mesh.meshId;</a>
<a name="ln1088">      float currentMatrix[16];</a>
<a name="ln1089">      memcpy(currentMatrix, mesh.m, 16 * sizeof(float));</a>
<a name="ln1090"> </a>
<a name="ln1091">      float4x4 m1(currentMatrix);</a>
<a name="ln1092">      float4x4 m2(a_mat);</a>
<a name="ln1093">      float4x4 mRes;</a>
<a name="ln1094"> </a>
<a name="ln1095">      if (origin)</a>
<a name="ln1096">        mRes = mul(m1, m2);</a>
<a name="ln1097">      else</a>
<a name="ln1098">        mRes = mul(m2, m1);</a>
<a name="ln1099"> </a>
<a name="ln1100">      int remapListId = mesh.remapListId;</a>
<a name="ln1101"> </a>
<a name="ln1102">      if(overrideRemapLists)</a>
<a name="ln1103">        hrMeshInstance(a_scnTo, tmp, mRes.L(), remapListOverride, remapListSize);</a>
<a name="ln1104">      else if(remapListId == -1)</a>
<a name="ln1105">        hrMeshInstance(a_scnTo, tmp, mRes.L());</a>
<a name="ln1106">      else</a>
<a name="ln1107">        hrMeshInstance(a_scnTo, tmp, mRes.L(), &amp;backupListRemapLists.at((unsigned long)remapListId)[0],</a>
<a name="ln1108">                       int32_t(backupListRemapLists.at((unsigned long)remapListId).size()));</a>
<a name="ln1109"> </a>
<a name="ln1110"> </a>
<a name="ln1111">      pScn2-&gt;drawList.back().scene_id  = a_scnFrom.id; //actual source scene id</a>
<a name="ln1112">      pScn2-&gt;drawList.back().scene_sid = pScn2-&gt;instancedScenesCounter; //sequential &quot;scene instance&quot; id</a>
<a name="ln1113">    }</a>
<a name="ln1114">  }</a>
<a name="ln1115"> </a>
<a name="ln1116">  hrSceneClose(a_scnTo);</a>
<a name="ln1117">  return bbox;</a>
<a name="ln1118">}</a>
<a name="ln1119"> </a>
<a name="ln1120">MergeInfo HRUtils::LoadMultipleShapesFromObj(const wchar_t* a_objectName, bool a_copyToLocalFolder){</a>
<a name="ln1121">  tinyobj::attrib_t attrib;</a>
<a name="ln1122">  std::vector&lt;tinyobj::shape_t&gt; shapes;</a>
<a name="ln1123">  std::vector&lt;tinyobj::material_t&gt; materials;</a>
<a name="ln1124"> </a>
<a name="ln1125">  std::string warn;</a>
<a name="ln1126">  std::string err;</a>
<a name="ln1127"> </a>
<a name="ln1128">  MergeInfo res_mergeinfo;</a>
<a name="ln1129"> </a>
<a name="ln1130">  bool res = tinyobj::LoadObj(&amp;attrib, &amp;shapes, &amp;materials, &amp;warn, &amp;err, ws2s(a_objectName).c_str());</a>
<a name="ln1131"> </a>
<a name="ln1132">  for (size_t s = 0; s &lt; shapes.size(); s++) {</a>
<a name="ln1133">    // The number of indices</a>
<a name="ln1134">    int indices_number = shapes[s].mesh.indices.size();</a>
<a name="ln1135"> </a>
<a name="ln1136">    // Vertices, Normals, Texture coordinates, Indices</a>
<a name="ln1137">    float *verts = new float[indices_number * 4];</a>
<a name="ln1138">    float *norms = new float[indices_number * 4];</a>
<a name="ln1139">    float *tex_s = new float[indices_number * 2];</a>
<a name="ln1140">    int *indxs = new int[indices_number];</a>
<a name="ln1141"> </a>
<a name="ln1142">    bool has_normals = true;</a>
<a name="ln1143"> </a>
<a name="ln1144">    size_t index_offset = 0;</a>
<a name="ln1145">    size_t vertices_num = shapes[s].mesh.num_face_vertices.size();</a>
<a name="ln1146">    for (size_t f = 0; f &lt; vertices_num; f++) {</a>
<a name="ln1147">      int fv = shapes[0].mesh.num_face_vertices[f];</a>
<a name="ln1148">      // Loop over vertices in the face.</a>
<a name="ln1149">      for (size_t v = 0; v &lt; fv; v++) {</a>
<a name="ln1150">        // Current index</a>
<a name="ln1151">        tinyobj::index_t idx = shapes[s].mesh.indices[index_offset + v];</a>
<a name="ln1152">        // Setting the actual index (we duplicate the vertices so that one vertex corresponds to only one index)</a>
<a name="ln1153">        indxs[index_offset + v] = index_offset + v;</a>
<a name="ln1154">        // Setting vertices</a>
<a name="ln1155">        verts[4 * (index_offset + v) + 0] = attrib.vertices[3 * idx.vertex_index + 0];</a>
<a name="ln1156">        verts[4 * (index_offset + v) + 1] = attrib.vertices[3 * idx.vertex_index + 1];</a>
<a name="ln1157">        verts[4 * (index_offset + v) + 2] = attrib.vertices[3 * idx.vertex_index + 2];</a>
<a name="ln1158">        verts[4 * (index_offset + v) + 3] = 1.0;</a>
<a name="ln1159">        // Setting normals</a>
<a name="ln1160">        if (idx.normal_index != -1) {</a>
<a name="ln1161">          norms[4 * (index_offset + v) + 0] = attrib.normals[3 * idx.normal_index + 0];</a>
<a name="ln1162">          norms[4 * (index_offset + v) + 1] = attrib.normals[3 * idx.normal_index + 1];</a>
<a name="ln1163">          norms[4 * (index_offset + v) + 2] = attrib.normals[3 * idx.normal_index + 2];</a>
<a name="ln1164">          norms[4 * (index_offset + v) + 3] = 0.0;</a>
<a name="ln1165">        } else {</a>
<a name="ln1166">          has_normals = false;</a>
<a name="ln1167">        }</a>
<a name="ln1168">        // Setting texture coordinates</a>
<a name="ln1169">        if (idx.texcoord_index != -1) {</a>
<a name="ln1170">          tex_s[2 * (index_offset + v) + 0] = attrib.texcoords[2 * idx.texcoord_index + 0];</a>
<a name="ln1171">          tex_s[2 * (index_offset + v) + 1] = attrib.texcoords[2 * idx.texcoord_index + 1];</a>
<a name="ln1172">        } else {</a>
<a name="ln1173">          tex_s[2 * (index_offset + v) + 0] = 0.0;</a>
<a name="ln1174">          tex_s[2 * (index_offset + v) + 1] = 0.0;</a>
<a name="ln1175">        }</a>
<a name="ln1176">      }</a>
<a name="ln1177">      index_offset += fv;</a>
<a name="ln1178">    }</a>
<a name="ln1179"> </a>
<a name="ln1180"> </a>
<a name="ln1181">    HRMeshRef ref = hrMeshCreate(a_objectName);</a>
<a name="ln1182"> </a>
<a name="ln1183">    hrMeshOpen(ref, HR_TRIANGLE_IND3, HR_WRITE_DISCARD);</a>
<a name="ln1184">    {</a>
<a name="ln1185">      hrMeshVertexAttribPointer4f(ref, L&quot;pos&quot;, verts);</a>
<a name="ln1186"> </a>
<a name="ln1187">      if (has_normals)</a>
<a name="ln1188">        hrMeshVertexAttribPointer4f(ref, L&quot;norm&quot;, norms);</a>
<a name="ln1189">      else</a>
<a name="ln1190">        hrMeshVertexAttribPointer4f(ref, L&quot;norm&quot;, nullptr);</a>
<a name="ln1191"> </a>
<a name="ln1192">      hrMeshVertexAttribPointer2f(ref, L&quot;texcoord&quot;, tex_s);</a>
<a name="ln1193"> </a>
<a name="ln1194">      hrMeshMaterialId(ref, 0);</a>
<a name="ln1195"> </a>
<a name="ln1196">      hrMeshAppendTriangles3(ref, indices_number, indxs);</a>
<a name="ln1197">    }</a>
<a name="ln1198">    hrMeshClose(ref);</a>
<a name="ln1199"> </a>
<a name="ln1200">    if(s == 0)</a>
<a name="ln1201">      res_mergeinfo.meshRange[0] = ref.id;</a>
<a name="ln1202">    if(s == shapes.size() - 1)</a>
<a name="ln1203">      res_mergeinfo.meshRange[1] = ref.id + 1;</a>
<a name="ln1204">  }</a>
<a name="ln1205"> </a>
<a name="ln1206">  return res_mergeinfo;</a>
<a name="ln1207">}</a>
<a name="ln1208"> </a>

</code></pre>
<div class="balloon" rel="51"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'a_chunkPath != L""' is always true. To compare strings you should use wcscmp() function.</p></div>
<div class="balloon" rel="457"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1020/" target="_blank">V1020</a> The function exited without calling the 'hr_unlock_system_mutex' function. Check lines: 457, 370.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
