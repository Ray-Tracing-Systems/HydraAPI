
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>HydraDriverUpdate.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#include &quot;HydraObjectManager.h&quot;</a>
<a name="ln2">#include &lt;unordered_set&gt;</a>
<a name="ln3">#include &lt;map&gt;</a>
<a name="ln4"> </a>
<a name="ln5">#include &lt;fstream&gt;</a>
<a name="ln6"> </a>
<a name="ln7">#pragma warning(disable:4996)</a>
<a name="ln8"> </a>
<a name="ln9">#if defined(WIN32)</a>
<a name="ln10">#include &quot;FreeImage.h&quot;</a>
<a name="ln11">#pragma comment(lib, &quot;FreeImage.lib&quot;)</a>
<a name="ln12">#undef min</a>
<a name="ln13">#undef max</a>
<a name="ln14">#else</a>
<a name="ln15">#include &lt;FreeImage.h&gt;</a>
<a name="ln16">#endif</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;algorithm&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;HydraVSGFExport.h&quot;</a>
<a name="ln21">#include &quot;HydraVSGFCompress.h&quot;</a>
<a name="ln22">#include &quot;RenderDriverOpenGL3_Utility.h&quot;</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;chrono&gt;</a>
<a name="ln25">#include &lt;cassert&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;tiny_obj_loader.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29">extern HRObjectManager g_objManager;</a>
<a name="ln30">extern HR_INFO_CALLBACK  g_pInfoCallback;</a>
<a name="ln31"> </a>
<a name="ln32">using resolution_dict = std::unordered_map&lt;uint32_t, std::pair&lt;uint32_t, uint32_t&gt; &gt;;</a>
<a name="ln33"> </a>
<a name="ln34">void ScanXmlNodeRecursiveAndAppendTexture(pugi::xml_node a_node, std::unordered_set&lt;int32_t&gt;&amp; a_outSet)</a>
<a name="ln35">{</a>
<a name="ln36">  std::wstring nodeName(a_node.name());</a>
<a name="ln37">  if (nodeName == L&quot;texture&quot; || nodeName.find(L&quot;texture_&quot;) != std::wstring::npos)</a>
<a name="ln38">  {</a>
<a name="ln39">    int32_t id = a_node.attribute(L&quot;id&quot;).as_int();</a>
<a name="ln40">    a_outSet.insert(id);</a>
<a name="ln41">    </a>
<a name="ln42">    // list all bitmaps which we depend of</a>
<a name="ln43">    //</a>
<a name="ln44">    if (std::wstring(a_node.attribute(L&quot;type&quot;).as_string()) == L&quot;texref_proc&quot;)</a>
<a name="ln45">    {</a>
<a name="ln46">      for (pugi::xml_node arg : a_node.children())</a>
<a name="ln47">      {</a>
<a name="ln48">        if (std::wstring(arg.name()) == L&quot;arg&quot; &amp;&amp; std::wstring(arg.attribute(L&quot;type&quot;).as_string()) == L&quot;sampler2D&quot;)</a>
<a name="ln49">        {</a>
<a name="ln50">          int size = arg.attribute(L&quot;size&quot;).as_int();</a>
<a name="ln51">          if(size &lt;= 1)</a>
<a name="ln52">            a_outSet.insert(arg.attribute(L&quot;val&quot;).as_int());</a>
<a name="ln53">          else</a>
<a name="ln54">          {</a>
<a name="ln55">            const wchar_t* value = arg.attribute(L&quot;val&quot;).as_string();</a>
<a name="ln56">            std::wstringstream strIn(value);</a>
<a name="ln57">            for (int i = 0; i &lt; size; i++)</a>
<a name="ln58">            {</a>
<a name="ln59">              int texId = 0;</a>
<a name="ln60">              strIn &gt;&gt; texId;</a>
<a name="ln61">              a_outSet.insert(texId);</a>
<a name="ln62">            }</a>
<a name="ln63">          }</a>
<a name="ln64">        }</a>
<a name="ln65">      }</a>
<a name="ln66">    }</a>
<a name="ln67">  }</a>
<a name="ln68">  </a>
<a name="ln69">  for (pugi::xml_node child = a_node.first_child(); child != nullptr; child = child.next_sibling())</a>
<a name="ln70">    ScanXmlNodeRecursiveAndAppendTexture(child, a_outSet);</a>
<a name="ln71">  </a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">void AddUsedMaterialChildrenRecursive(ChangeList&amp; objects, int32_t matId)</a>
<a name="ln75">{</a>
<a name="ln76">	if (matId &gt;= g_objManager.scnData.materials.size())</a>
<a name="ln77">		return;</a>
<a name="ln78"> </a>
<a name="ln79">  HRMaterial&amp; mat = g_objManager.scnData.materials[matId];</a>
<a name="ln80">  auto matNode = mat.xml_node();</a>
<a name="ln81">  auto matType = std::wstring(matNode.attribute(L&quot;type&quot;).as_string());</a>
<a name="ln82"> </a>
<a name="ln83">  if (matType == L&quot;hydra_blend&quot;)</a>
<a name="ln84">  {</a>
<a name="ln85">    auto subMatId1 = matNode.attribute(L&quot;node_top&quot;).as_int();</a>
<a name="ln86">    auto subMatId2 = matNode.attribute(L&quot;node_bottom&quot;).as_int();</a>
<a name="ln87"> </a>
<a name="ln88">    objects.matUsed.insert(subMatId1);</a>
<a name="ln89">    objects.matUsed.insert(subMatId2);</a>
<a name="ln90"> </a>
<a name="ln91">    AddUsedMaterialChildrenRecursive(objects, subMatId1);</a>
<a name="ln92">    AddUsedMaterialChildrenRecursive(objects, subMatId2);</a>
<a name="ln93">  }</a>
<a name="ln94">  else if (matType == L&quot;layer_material&quot;)</a>
<a name="ln95">  {</a>
<a name="ln96">    auto layers = matNode.child(L&quot;layers&quot;);</a>
<a name="ln97">    for (auto node = layers.first_child(); node != nullptr; node = node.next_sibling())</a>
<a name="ln98">    {</a>
<a name="ln99">      uint32_t mat_idx   = node.attribute(L&quot;material_id&quot;).as_uint();</a>
<a name="ln100">      objects.matUsed.insert(mat_idx);</a>
<a name="ln101">      AddUsedMaterialChildrenRecursive(objects, mat_idx);</a>
<a name="ln102">    }</a>
<a name="ln103">  }</a>
<a name="ln104">}</a>
<a name="ln105"> </a>
<a name="ln106">void AddInstanceToDrawSequence(const HRSceneInst::Instance &amp;instance,</a>
<a name="ln107">                               std::unordered_map&lt;int32_t, ChangeList::InstancesInfo&gt; &amp;drawSeq, int a_instId)</a>
<a name="ln108">{</a>
<a name="ln109"> </a>
<a name="ln110">  auto p = drawSeq.find(instance.meshId);</a>
<a name="ln111">  if (p == drawSeq.end())</a>
<a name="ln112">  {</a>
<a name="ln113">    drawSeq[instance.meshId].matrices   = std::vector&lt;float&gt;  (instance.m, instance.m + 16);</a>
<a name="ln114">    drawSeq[instance.meshId].linstid    = std::vector&lt;int32_t&gt;(&amp;instance.lightInstId, &amp;instance.lightInstId + 1);</a>
<a name="ln115">    drawSeq[instance.meshId].remapid    = std::vector&lt;int32_t&gt;(&amp;instance.remapListId, &amp;instance.remapListId + 1);</a>
<a name="ln116">    drawSeq[instance.meshId].instIdReal = std::vector&lt;int32_t&gt;(&amp;a_instId, &amp;a_instId + 1);</a>
<a name="ln117"> </a>
<a name="ln118">    const int RESERVE_SIZE = 100;</a>
<a name="ln119"> </a>
<a name="ln120">    drawSeq[instance.meshId].matrices.reserve(RESERVE_SIZE);</a>
<a name="ln121">    drawSeq[instance.meshId].linstid.reserve(RESERVE_SIZE);</a>
<a name="ln122">    drawSeq[instance.meshId].remapid.reserve(RESERVE_SIZE);</a>
<a name="ln123">    drawSeq[instance.meshId].instIdReal.reserve(RESERVE_SIZE);</a>
<a name="ln124"> </a>
<a name="ln125">  }</a>
<a name="ln126">  else</a>
<a name="ln127">  {</a>
<a name="ln128">    std::vector&lt;float&gt; data(instance.m, instance.m + 16);</a>
<a name="ln129">    p-&gt;second.matrices.insert(p-&gt;second.matrices.end(), data.begin(), data.end());</a>
<a name="ln130">    p-&gt;second.linstid.push_back(instance.lightInstId);</a>
<a name="ln131">    p-&gt;second.remapid.push_back(instance.remapListId);</a>
<a name="ln132">    p-&gt;second.instIdReal.push_back(a_instId);</a>
<a name="ln133">  }</a>
<a name="ln134"> </a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137">void AddMaterialsFromRemapList(const HRSceneInst::Instance &amp;instance, const std::vector&lt; std::vector&lt;int32_t&gt; &gt;&amp; a_remapLists,</a>
<a name="ln138">                               std::unordered_set&lt;int32_t&gt;&amp; a_outMats)</a>
<a name="ln139">{</a>
<a name="ln140">  if(instance.remapListId &gt;= 0 &amp;&amp; instance.remapListId &lt; a_remapLists.size() )</a>
<a name="ln141">  {</a>
<a name="ln142">    const auto&amp; remapList = a_remapLists[instance.remapListId];</a>
<a name="ln143">    for(int i=0; i&lt;remapList.size(); i+=2 )                    // [0-&gt;1, 2-&gt;5, 7-&gt;0, ... ] pairs of values ...</a>
<a name="ln144">    {</a>
<a name="ln145">      if(i+1 &lt; remapList.size())</a>
<a name="ln146">        a_outMats.insert(remapList[i+1]);</a>
<a name="ln147">    }</a>
<a name="ln148">  }</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151">void FindNewObjects(ChangeList&amp; objects, HRSceneInst&amp; scn, HRRender* a_pRender)</a>
<a name="ln152">{</a>
<a name="ln153">  assert(a_pRender != nullptr);</a>
<a name="ln154"> </a>
<a name="ln155">  // (1.1) loop through all scene instances to define what meshes used in scene  --&gt; ~ok</a>
<a name="ln156">  //</a>
<a name="ln157">  for (size_t i = 0; i &lt; scn.drawList.size(); i++)</a>
<a name="ln158">  {</a>
<a name="ln159">    auto instance = scn.drawList[i];</a>
<a name="ln160">    if (instance.meshId &gt;= g_objManager.scnData.meshes.size()) //#TODO: ? add log message if need to debug some thing here</a>
<a name="ln161">      continue;</a>
<a name="ln162"> </a>
<a name="ln163">    if (a_pRender-&gt;m_updated.meshUsed.find(instance.meshId) == a_pRender-&gt;m_updated.meshUsed.end())</a>
<a name="ln164">      objects.meshUsed.insert(instance.meshId);</a>
<a name="ln165">    </a>
<a name="ln166">    // form draw sequence for each mesh</a>
<a name="ln167">    //</a>
<a name="ln168">    AddInstanceToDrawSequence(instance, objects.drawSeq, int(i));</a>
<a name="ln169">    AddMaterialsFromRemapList(instance, scn.m_remapList, objects.matUsed);</a>
<a name="ln170">  }</a>
<a name="ln171"> </a>
<a name="ln172">  for (size_t i = 0; i &lt; scn.drawListLights.size(); i++)</a>
<a name="ln173">  {</a>
<a name="ln174">    auto instance = scn.drawListLights[i];</a>
<a name="ln175"> </a>
<a name="ln176">    if (a_pRender-&gt;m_updated.lightUsed.find(instance.lightId) == a_pRender-&gt;m_updated.lightUsed.end())</a>
<a name="ln177">      objects.lightUsed.insert(instance.lightId);</a>
<a name="ln178">  }</a>
<a name="ln179"> </a>
<a name="ln180">  // (1.2) loop through needed meshed to define what material used in scene      --&gt; ?</a>
<a name="ln181">  //</a>
<a name="ln182">  if (!g_objManager.scnData.meshes.empty())</a>
<a name="ln183">  {</a>
<a name="ln184">    for (auto p = objects.meshUsed.begin(); p != objects.meshUsed.end(); ++p)</a>
<a name="ln185">    {</a>
<a name="ln186">      size_t meshId = (*p);</a>
<a name="ln187">      if (meshId &gt;= g_objManager.scnData.meshes.size()) //#TODO: ? add log message if need to debug some thiing here</a>
<a name="ln188">        continue;</a>
<a name="ln189"> </a>
<a name="ln190">      HRMesh&amp; mesh = g_objManager.scnData.meshes[meshId];</a>
<a name="ln191">      auto pImpl = mesh.pImpl;</a>
<a name="ln192"> </a>
<a name="ln193">      if (pImpl != nullptr)</a>
<a name="ln194">      {</a>
<a name="ln195">        const auto&amp; mlist = pImpl-&gt;MList();</a>
<a name="ln196">        for(const auto&amp; trio : mlist)</a>
<a name="ln197">        {</a>
<a name="ln198">          objects.matUsed.insert(trio.matId);</a>
<a name="ln199">          AddUsedMaterialChildrenRecursive(objects, trio.matId);</a>
<a name="ln200">        }</a>
<a name="ln201">      }</a>
<a name="ln202">    }</a>
<a name="ln203"> </a>
<a name="ln204">  }</a>
<a name="ln205"> </a>
<a name="ln206">  // (1.3) loop through needed materials to define what textures used in scene </a>
<a name="ln207">  //</a>
<a name="ln208">  if (!g_objManager.scnData.materials.empty())</a>
<a name="ln209">  {</a>
<a name="ln210">    for (auto matId : objects.matUsed)</a>
<a name="ln211">    {</a>
<a name="ln212">      if (matId &gt;= g_objManager.scnData.materials.size()) //#TODO: ? add log message if need to debug some thiing here</a>
<a name="ln213">        continue;</a>
<a name="ln214"> </a>
<a name="ln215">      if (matId &lt; g_objManager.scnData.materials.size())</a>
<a name="ln216">      {</a>
<a name="ln217">        HRMaterial&amp; mat = g_objManager.scnData.materials[matId];</a>
<a name="ln218"> </a>
<a name="ln219">        // (1.3.1) list all textures for mat, add them to set</a>
<a name="ln220">        //</a>
<a name="ln221">        ScanXmlNodeRecursiveAndAppendTexture(mat.xml_node(), objects.texturesUsed);</a>
<a name="ln222">      }</a>
<a name="ln223">      else</a>
<a name="ln224">        g_objManager.BadMaterialId(int32_t(matId));</a>
<a name="ln225">    }</a>
<a name="ln226"> </a>
<a name="ln227">    </a>
<a name="ln228"> </a>
<a name="ln229">  }</a>
<a name="ln230"> </a>
<a name="ln231">  // (1.4) loop through all changed lights to define what lights are used in scene --&gt; TEXTURES</a>
<a name="ln232">  //</a>
<a name="ln233">  if (!g_objManager.scnData.lights.empty())</a>
<a name="ln234">  {</a>
<a name="ln235">    for (auto p = objects.lightUsed.begin(); p != objects.lightUsed.end(); ++p)</a>
<a name="ln236">    {</a>
<a name="ln237">      size_t lightId = (*p);</a>
<a name="ln238">      if (lightId &gt;= g_objManager.scnData.lights.size()) //#TODO: ? add log message if need to debug some thiing here</a>
<a name="ln239">        continue;</a>
<a name="ln240"> </a>
<a name="ln241">      if (lightId &lt; g_objManager.scnData.lights.size())</a>
<a name="ln242">      {</a>
<a name="ln243">        HRLight&amp; light = g_objManager.scnData.lights[lightId];</a>
<a name="ln244">        ScanXmlNodeRecursiveAndAppendTexture(light.xml_node(), objects.texturesUsed);</a>
<a name="ln245">      }</a>
<a name="ln246">    }</a>
<a name="ln247">  }</a>
<a name="ln248"> </a>
<a name="ln249">}</a>
<a name="ln250"> </a>
<a name="ln251">void FindOldObjectsThatWeNeedToUpdate(ChangeList&amp; objects, HRSceneInst&amp; scn, HRRender* a_pRender)</a>
<a name="ln252">{</a>
<a name="ln253">  assert(a_pRender != nullptr);</a>
<a name="ln254"> </a>
<a name="ln255">  // AddMaterialsFromSceneRemapList</a>
<a name="ln256">  //</a>
<a name="ln257">  pugi::xml_node scnRemLists = scn.xml_node().child(L&quot;remap_lists&quot;);</a>
<a name="ln258"> </a>
<a name="ln259">  for (auto remapList : scnRemLists.children())</a>
<a name="ln260">  {</a>
<a name="ln261">    const wchar_t* inputStr = remapList.attribute(L&quot;val&quot;).as_string();</a>
<a name="ln262">    const int listSize = remapList.attribute(L&quot;size&quot;).as_int();</a>
<a name="ln263">    std::wstringstream inStrStream(inputStr);</a>
<a name="ln264"> </a>
<a name="ln265">    for (int i = 0; i &lt; listSize; i++)</a>
<a name="ln266">    {</a>
<a name="ln267">      if (inStrStream.eof())</a>
<a name="ln268">        break;</a>
<a name="ln269"> </a>
<a name="ln270">      int matId = 0;</a>
<a name="ln271">      inStrStream &gt;&gt; matId;</a>
<a name="ln272"> </a>
<a name="ln273">      if (objects.matUsed.find(matId)  == objects.matUsed.end() &amp;&amp; // we don't add this object to list yet</a>
<a name="ln274">          a_pRender-&gt;m_updated.matUsed.find(matId) == a_pRender-&gt;m_updated.matUsed.end())  // and it was not added in previous updates</a>
<a name="ln275">      {</a>
<a name="ln276">        objects.matUsed.insert(matId);</a>
<a name="ln277">        AddUsedMaterialChildrenRecursive(objects, matId);</a>
<a name="ln278">      }</a>
<a name="ln279">    }</a>
<a name="ln280">  }</a>
<a name="ln281"> </a>
<a name="ln282">  // now we must add to change list all textures that are presented in the materials of matUsed </a>
<a name="ln283">  // but (!!!) does not present in scnlib.texturesUsedByDrv</a>
<a name="ln284">  //</a>
<a name="ln285">  for (auto p = objects.matUsed.begin(); p != objects.matUsed.end(); ++p)</a>
<a name="ln286">  {</a>
<a name="ln287">    int matId = (*p);</a>
<a name="ln288"> </a>
<a name="ln289">    if (size_t(matId) &lt; g_objManager.scnData.materials.size() &amp;&amp; a_pRender-&gt;m_updated.texturesUsed.find(matId) == a_pRender-&gt;m_updated.texturesUsed.end())</a>
<a name="ln290">    {</a>
<a name="ln291">      HRMaterial&amp; mat = g_objManager.scnData.materials[matId];</a>
<a name="ln292"> </a>
<a name="ln293">      // (1.3.1) list all textures for mat, add them to set</a>
<a name="ln294">      //</a>
<a name="ln295">      ScanXmlNodeRecursiveAndAppendTexture(mat.xml_node(), objects.texturesUsed);</a>
<a name="ln296">    }</a>
<a name="ln297">    else</a>
<a name="ln298">      g_objManager.BadMaterialId(int32_t(matId));</a>
<a name="ln299">  }</a>
<a name="ln300">  </a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303">/// find objects that we have to Update because they depends of some other objects that we already know we have to Update. </a>
<a name="ln304">//</a>
<a name="ln305">void FindObjectsByDependency(ChangeList&amp; objList, HRSceneInst&amp; scn, HRRender* a_pRender)</a>
<a name="ln306">{</a>
<a name="ln307">  if(a_pRender == nullptr)</a>
<a name="ln308">    return;</a>
<a name="ln309">  </a>
<a name="ln310">  IHRRenderDriver* a_pDriver = a_pRender-&gt;m_pDriver.get();</a>
<a name="ln311">  if (a_pDriver == nullptr)</a>
<a name="ln312">    return;</a>
<a name="ln313"> </a>
<a name="ln314">  auto dInfo = a_pDriver-&gt;DependencyInfo();</a>
<a name="ln315"> </a>
<a name="ln316">  // if (dInfo.materialDependsOfTexture)</a>
<a name="ln317">  // {</a>
<a name="ln318">  //   for (auto p = objList.texturesUsed.begin(); p != objList.texturesUsed.end(); ++p)</a>
<a name="ln319">  //   {</a>
<a name="ln320">  // </a>
<a name="ln321">  //   }</a>
<a name="ln322">  // }</a>
<a name="ln323"> </a>
<a name="ln324">  if (dInfo.meshDependsOfMaterial)</a>
<a name="ln325">  {</a>
<a name="ln326">    // damn inefficient, but simple and rarely used feature</a>
<a name="ln327">    //</a>
<a name="ln328">    for (auto meshId : a_pRender-&gt;m_updated.meshUsed)</a>
<a name="ln329">    {</a>
<a name="ln330">      const auto&amp; meshSysObj = g_objManager.scnData.meshes[meshId];</a>
<a name="ln331">      if(meshSysObj.pImpl == nullptr)</a>
<a name="ln332">        continue;</a>
<a name="ln333">      </a>
<a name="ln334">      const auto&amp; batches = meshSysObj.pImpl-&gt;MList();</a>
<a name="ln335">      for(auto batch : batches)</a>
<a name="ln336">      {</a>
<a name="ln337">        if( objList.matUsed.find(batch.matId) != objList.matUsed.end())</a>
<a name="ln338">          objList.meshUsed.insert(meshSysObj.id);</a>
<a name="ln339">      }</a>
<a name="ln340">    }</a>
<a name="ln341">  }</a>
<a name="ln342"> </a>
<a name="ln343">  //if (dInfo.lightDependsOfMesh)</a>
<a name="ln344">  //{</a>
<a name="ln345">  //  for (auto p = objList.meshUsed.begin(); p != objList.meshUsed.end(); ++p)</a>
<a name="ln346">  //  {</a>
<a name="ln347">  //</a>
<a name="ln348">  //  }</a>
<a name="ln349">  //}</a>
<a name="ln350"> </a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353"> </a>
<a name="ln354">/// collect all id's of objects we need to Update</a>
<a name="ln355">//</a>
<a name="ln356">ChangeList FindChangedObjects(HRSceneInst&amp; scn, HRRender* a_pRender)</a>
<a name="ln357">{</a>
<a name="ln358">  ChangeList&amp; objectsThatRenderAlreadyHas = a_pRender-&gt;m_updated;</a>
<a name="ln359">  ChangeList  objects                     = objectsThatRenderAlreadyHas.intersect_with(g_objManager.scnData.m_changeList);</a>
<a name="ln360"> </a>
<a name="ln361">  FindNewObjects                  (objects, scn, a_pRender);</a>
<a name="ln362">  FindOldObjectsThatWeNeedToUpdate(objects, scn, a_pRender);</a>
<a name="ln363">  FindObjectsByDependency         (objects, scn, a_pRender);</a>
<a name="ln364">  </a>
<a name="ln365">  return objects;</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368">///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln369"> </a>
<a name="ln370"> </a>
<a name="ln371">void UpdateImageFromFileOrChunk(int32_t a_id, HRTextureNode&amp; img, IHRRenderDriver* a_pDriver) // #TODO: debug and test this</a>
<a name="ln372">{</a>
<a name="ln373">  pugi::xml_node node = img.xml_node();</a>
<a name="ln374"> </a>
<a name="ln375">  bool delayedLoad = (node.attribute(L&quot;dl&quot;).as_int() == 1);</a>
<a name="ln376"> </a>
<a name="ln377">  if (delayedLoad &amp;&amp; img.m_loadedFromFile) // load external image from file </a>
<a name="ln378">  {</a>
<a name="ln379">    const wchar_t* filename = node.attribute(L&quot;path&quot;).as_string();</a>
<a name="ln380"> </a>
<a name="ln381">    int width, height, bpp;</a>
<a name="ln382">    bool loaded = g_objManager.m_pImgTool-&gt;LoadImageFromFile(filename, </a>
<a name="ln383">                                                             width, height, bpp, g_objManager.m_tempBuffer);</a>
<a name="ln384"> </a>
<a name="ln385">    if(loaded)</a>
<a name="ln386">      a_pDriver-&gt;UpdateImage(a_id, width, height, bpp, (char*)g_objManager.m_tempBuffer.data(), node);</a>
<a name="ln387">    else</a>
<a name="ln388">      a_pDriver-&gt;UpdateImage(a_id, 0, 0, 0, nullptr, node);</a>
<a name="ln389"> </a>
<a name="ln390">    if (g_objManager.m_tempBuffer.size() &gt; TEMP_BUFFER_MAX_SIZE_DONT_FREE)</a>
<a name="ln391">      g_objManager.m_tempBuffer = g_objManager.EmptyBuffer();</a>
<a name="ln392">  }</a>
<a name="ln393">  else // load chunk</a>
<a name="ln394">  {</a>
<a name="ln395">    auto w           = node.attribute(L&quot;width&quot;).as_int();</a>
<a name="ln396">    auto h           = node.attribute(L&quot;height&quot;).as_int();</a>
<a name="ln397">    auto sizeInBytes = node.attribute(L&quot;bytesize&quot;).as_llong();</a>
<a name="ln398"> </a>
<a name="ln399">    if(w == 0 || h == 0 || sizeInBytes == 0)</a>
<a name="ln400">    {</a>
<a name="ln401">      HrError(L&quot;UpdateImageFromFileOrChunk: zero or unknown image size/resolution&quot;);</a>
<a name="ln402">      return;</a>
<a name="ln403">    }</a>
<a name="ln404"> </a>
<a name="ln405">    int bpp = int(sizeInBytes / (w*h));</a>
<a name="ln406"> </a>
<a name="ln407">    sizeInBytes += size_t(sizeof(int) * 2);</a>
<a name="ln408"> </a>
<a name="ln409">    g_objManager.m_tempBuffer.resize(sizeInBytes / uint64_t(sizeof(int)) + uint64_t(sizeof(int) * 16));</a>
<a name="ln410">    char* data = (char*)&amp;g_objManager.m_tempBuffer[0];</a>
<a name="ln411"> </a>
<a name="ln412">    const std::wstring path = g_objManager.GetLoc(node);</a>
<a name="ln413">#if (_POSIX_C_SOURCE &gt;= 200112L || _XOPEN_SOURCE &gt;= 600)</a>
<a name="ln414">    std::wstring s1(path);</a>
<a name="ln415">    std::string  s2(s1.begin(), s1.end());</a>
<a name="ln416">    std::ifstream fin(s2.c_str(), std::ios::binary);</a>
<a name="ln417">#elif defined WIN32</a>
<a name="ln418">    std::ifstream fin(path.c_str(), std::ios::binary);</a>
<a name="ln419">#endif</a>
<a name="ln420">    if (fin.is_open())</a>
<a name="ln421">    {</a>
<a name="ln422">      fin.read(data, sizeInBytes);</a>
<a name="ln423">      uint64_t dataOffset = node.attribute(L&quot;offset&quot;).as_ullong();</a>
<a name="ln424">      a_pDriver-&gt;UpdateImage(a_id, w, h, bpp, data + dataOffset, node);</a>
<a name="ln425">      fin.close();</a>
<a name="ln426">    }</a>
<a name="ln427">    else</a>
<a name="ln428">      a_pDriver-&gt;UpdateImage(a_id, w, h, bpp, nullptr, node);</a>
<a name="ln429">  }</a>
<a name="ln430"> </a>
<a name="ln431">}</a>
<a name="ln432"> </a>
<a name="ln433">/////</a>
<a name="ln434">//</a>
<a name="ln435">int32_t HR_DriverUpdateTextures(HRSceneInst&amp; scn, ChangeList&amp; objList, HRRender* a_pRender)</a>
<a name="ln436">{</a>
<a name="ln437">  IHRRenderDriver* a_pDriver = a_pRender-&gt;m_pDriver.get();</a>
<a name="ln438">  if (g_objManager.scnData.textures.empty() || a_pDriver == nullptr)</a>
<a name="ln439">    return 0;</a>
<a name="ln440"> </a>
<a name="ln441">  a_pDriver-&gt;BeginTexturesUpdate();</a>
<a name="ln442"> </a>
<a name="ln443">  int32_t texturesUpdated = 0;</a>
<a name="ln444">  std::wstring driver_name;</a>
<a name="ln445">  a_pDriver-&gt;GetRenderDriverName(driver_name);</a>
<a name="ln446">  auto info = RenderDriverFactory::GetDriverInfo(driver_name.c_str());</a>
<a name="ln447"> </a>
<a name="ln448">  std::vector&lt;int32_t&gt; texturesUsed;</a>
<a name="ln449">  texturesUsed.assign(objList.texturesUsed.begin(), objList.texturesUsed.end());</a>
<a name="ln450">  std::sort(texturesUsed.begin(), texturesUsed.end());</a>
<a name="ln451"> </a>
<a name="ln452">  for (auto texId : texturesUsed)</a>
<a name="ln453">  {</a>
<a name="ln454">    if (texId &lt; 0)</a>
<a name="ln455">      continue;</a>
<a name="ln456"> </a>
<a name="ln457">    HRTextureNode&amp; texNode = g_objManager.scnData.textures[texId];</a>
<a name="ln458"> </a>
<a name="ln459">    int32_t w     = 0;</a>
<a name="ln460">    int32_t h     = 0;</a>
<a name="ln461">    int32_t bpp   = 4;</a>
<a name="ln462">    char* dataPtr = nullptr;</a>
<a name="ln463"> </a>
<a name="ln464">    if (texNode.pImpl != nullptr)</a>
<a name="ln465">    {</a>
<a name="ln466">      w   = texNode.pImpl-&gt;width();</a>
<a name="ln467">      h   = texNode.pImpl-&gt;height();</a>
<a name="ln468">      bpp = texNode.pImpl-&gt;bpp();</a>
<a name="ln469"> </a>
<a name="ln470">      uint64_t chunkId = texNode.pImpl-&gt;chunkId();</a>
<a name="ln471">      if (chunkId != uint64_t(-1) &amp;&amp; chunkId &lt; g_objManager.scnData.m_vbCache.size()) // cache may be inactive, so m_vbCache.size() size may be 0</a>
<a name="ln472">      {</a>
<a name="ln473">        ChunkPointer chunk = g_objManager.scnData.m_vbCache.chunk_at(chunkId);</a>
<a name="ln474">        dataPtr = (char*)chunk.GetMemoryNow();</a>
<a name="ln475">      }</a>
<a name="ln476">    }</a>
<a name="ln477"> </a>
<a name="ln478">    pugi::xml_node texNodeXML  = texNode.xml_node();</a>
<a name="ln479">    uint64_t       dataOffset  = texNodeXML.attribute(L&quot;offset&quot;).as_ullong(); //#SAFETY: check dataOffset for too big value ?</a>
<a name="ln480">    bool           delayedLoad = (texNodeXML.attribute(L&quot;dl&quot;).as_int() == 1);</a>
<a name="ln481">    bool isProc = (texNodeXML.attribute(L&quot;loc&quot;).as_string() == std::wstring(L&quot;&quot;) &amp;&amp; !delayedLoad);</a>
<a name="ln482"> </a>
<a name="ln483">    if (dataPtr == nullptr)</a>
<a name="ln484">    {</a>
<a name="ln485"> </a>
<a name="ln486">      if (info.supportImageLoadFromExternalFormat &amp;&amp; texNode.m_loadedFromFile)</a>
<a name="ln487">      {</a>
<a name="ln488">        const wchar_t* path = texNodeXML.attribute(L&quot;path&quot;).as_string();</a>
<a name="ln489">        a_pDriver-&gt;UpdateImageFromFile(texId, path, texNodeXML);</a>
<a name="ln490">      }</a>
<a name="ln491">      else if (info.supportImageLoadFromInternalFormat &amp;&amp; !delayedLoad)</a>
<a name="ln492">      {</a>
<a name="ln493">        const std::wstring path = g_objManager.GetLoc(texNodeXML);</a>
<a name="ln494">        a_pDriver-&gt;UpdateImageFromFile(texId, path.c_str(), texNodeXML);</a>
<a name="ln495">      }</a>
<a name="ln496">      else if(isProc)</a>
<a name="ln497">      {</a>
<a name="ln498">        a_pRender-&gt;m_updated.texturesUsed.insert(texId);</a>
<a name="ln499">        a_pDriver-&gt;UpdateImage(texId, -1, -1, 4, nullptr, texNodeXML);</a>
<a name="ln500">      }</a>
<a name="ln501">      else</a>
<a name="ln502">        UpdateImageFromFileOrChunk(texId, texNode, a_pDriver);</a>
<a name="ln503">    }</a>
<a name="ln504">    else</a>
<a name="ln505">    {</a>
<a name="ln506">      a_pRender-&gt;m_updated.texturesUsed.insert(texId);</a>
<a name="ln507">      a_pDriver-&gt;UpdateImage(texId, w, h, bpp, dataPtr + dataOffset, texNodeXML);</a>
<a name="ln508">    }</a>
<a name="ln509"> </a>
<a name="ln510">    texturesUpdated++;</a>
<a name="ln511">  }</a>
<a name="ln512"> </a>
<a name="ln513">  a_pDriver-&gt;EndTexturesUpdate();</a>
<a name="ln514"> </a>
<a name="ln515">  return texturesUpdated;</a>
<a name="ln516">}</a>
<a name="ln517"> </a>
<a name="ln518">/////</a>
<a name="ln519">//</a>
<a name="ln520">int32_t HR_DriverUpdateMaterials(HRSceneInst&amp; scn, ChangeList&amp; objList, HRRender* a_pRender)</a>
<a name="ln521">{</a>
<a name="ln522">  IHRRenderDriver* a_pDriver = a_pRender-&gt;m_pDriver.get();</a>
<a name="ln523">  if (g_objManager.scnData.materials.empty() || a_pDriver == nullptr)</a>
<a name="ln524">    return 0;</a>
<a name="ln525"> </a>
<a name="ln526">  a_pDriver-&gt;BeginMaterialUpdate();</a>
<a name="ln527"> </a>
<a name="ln528">  // we should update meterials in their id order !!!</a>
<a name="ln529">  //</a>
<a name="ln530">  std::vector&lt;int32_t&gt; idsToUpdate; </a>
<a name="ln531">  idsToUpdate.reserve(objList.matUsed.size());</a>
<a name="ln532">  std::copy(objList.matUsed.begin(), objList.matUsed.end(), std::back_inserter(idsToUpdate));</a>
<a name="ln533">  std::sort(idsToUpdate.begin(), idsToUpdate.end());</a>
<a name="ln534"> </a>
<a name="ln535">  int32_t updatedMaterials = 0;</a>
<a name="ln536"> </a>
<a name="ln537">  for (auto matId : idsToUpdate)</a>
<a name="ln538">  {</a>
<a name="ln539">    if (matId &lt; g_objManager.scnData.materials.size())</a>
<a name="ln540">    {</a>
<a name="ln541">      pugi::xml_node node = g_objManager.scnData.materials[matId].xml_node();</a>
<a name="ln542">      a_pRender-&gt;m_updated.matUsed.insert(matId);</a>
<a name="ln543">      a_pDriver-&gt;UpdateMaterial(int32_t(matId), node);</a>
<a name="ln544">      if (std::wstring(L&quot;shadow_catcher&quot;) == node.attribute(L&quot;type&quot;).as_string())</a>
<a name="ln545">        g_objManager.scnData.m_shadowCatchers.insert(matId);</a>
<a name="ln546">      updatedMaterials++;</a>
<a name="ln547">    }</a>
<a name="ln548">    else</a>
<a name="ln549">      g_objManager.BadMaterialId(matId);</a>
<a name="ln550">  }</a>
<a name="ln551"> </a>
<a name="ln552">  a_pDriver-&gt;EndMaterialUpdate();</a>
<a name="ln553"> </a>
<a name="ln554">  return updatedMaterials;</a>
<a name="ln555">}</a>
<a name="ln556"> </a>
<a name="ln557">int32_t _hr_UtilityDriverUpdateMaterials(HRSceneInst&amp; scn, HRRender* a_pRender)</a>
<a name="ln558">{</a>
<a name="ln559">  IHRRenderDriver* a_pDriver = a_pRender-&gt;m_pDriver.get();</a>
<a name="ln560">  if (g_objManager.scnData.materials.empty() || a_pDriver == nullptr)</a>
<a name="ln561">    return 0;</a>
<a name="ln562"> </a>
<a name="ln563">  a_pDriver-&gt;BeginMaterialUpdate();</a>
<a name="ln564"> </a>
<a name="ln565">  int32_t updatedMaterials = 0;</a>
<a name="ln566"> </a>
<a name="ln567">  for(auto matId : a_pRender-&gt;m_updated.matUsed)</a>
<a name="ln568">  {</a>
<a name="ln569">    if (matId &lt; g_objManager.scnData.materials.size())</a>
<a name="ln570">    {</a>
<a name="ln571">      pugi::xml_node node = g_objManager.scnData.materials[matId].xml_node();</a>
<a name="ln572">      a_pDriver-&gt;UpdateMaterial(matId, node);</a>
<a name="ln573">      updatedMaterials++;</a>
<a name="ln574">    }</a>
<a name="ln575">    else</a>
<a name="ln576">      g_objManager.BadMaterialId(matId);</a>
<a name="ln577">  }</a>
<a name="ln578"> </a>
<a name="ln579">  a_pDriver-&gt;EndMaterialUpdate();</a>
<a name="ln580"> </a>
<a name="ln581">  return updatedMaterials;</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584">/////</a>
<a name="ln585">//</a>
<a name="ln586">int32_t HR_DriverUpdateLight(HRSceneInst&amp; scn, ChangeList&amp; objList, HRRender* a_pRender)</a>
<a name="ln587">{</a>
<a name="ln588">  IHRRenderDriver* a_pDriver = a_pRender-&gt;m_pDriver.get();</a>
<a name="ln589">  if (g_objManager.scnData.lights.empty() || a_pDriver == nullptr)</a>
<a name="ln590">    return 0;</a>
<a name="ln591"> </a>
<a name="ln592">  a_pDriver-&gt;BeginLightsUpdate();</a>
<a name="ln593"> </a>
<a name="ln594">  int32_t updatedLights = 0;</a>
<a name="ln595"> </a>
<a name="ln596">  for (auto id : objList.lightUsed)</a>
<a name="ln597">  {</a>
<a name="ln598">    if (id &gt;= 0)</a>
<a name="ln599">    {</a>
<a name="ln600">      pugi::xml_node node = g_objManager.scnData.lights[id].xml_node();</a>
<a name="ln601"> </a>
<a name="ln602">      a_pRender-&gt;m_updated.lightUsed.insert(id);</a>
<a name="ln603">      a_pDriver-&gt;UpdateLight(int32_t(id), node);</a>
<a name="ln604">      updatedLights++;</a>
<a name="ln605">    }</a>
<a name="ln606">  }</a>
<a name="ln607"> </a>
<a name="ln608">  a_pDriver-&gt;EndLightsUpdate();</a>
<a name="ln609"> </a>
<a name="ln610">  return updatedLights;</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613"> </a>
<a name="ln614">HRMeshDriverInput HR_GetMeshDataPointers(size_t a_meshId)</a>
<a name="ln615">{</a>
<a name="ln616">  HRSceneData&amp; scn = g_objManager.scnData;</a>
<a name="ln617"> </a>
<a name="ln618">  HRMeshDriverInput input;</a>
<a name="ln619">  if (a_meshId &gt;= scn.meshes.size())</a>
<a name="ln620">    return input;</a>
<a name="ln621"> </a>
<a name="ln622">  HRMesh&amp; mesh = scn.meshes[a_meshId];</a>
<a name="ln623">  if (mesh.pImpl == nullptr)</a>
<a name="ln624">    return input;</a>
<a name="ln625"> </a>
<a name="ln626">  input.vertNum = int(mesh.pImpl-&gt;vertNum());</a>
<a name="ln627">  input.triNum  = int(mesh.pImpl-&gt;indNum()/3);</a>
<a name="ln628"> </a>
<a name="ln629">  auto chunkId  = mesh.pImpl-&gt;chunkId();</a>
<a name="ln630"> </a>
<a name="ln631">  if (chunkId == uint64_t(-1))</a>
<a name="ln632">    return input;</a>
<a name="ln633"> </a>
<a name="ln634">  ChunkPointer chunk;</a>
<a name="ln635">  if(chunkId &lt; g_objManager.scnData.m_vbCache.size())</a>
<a name="ln636">    chunk = g_objManager.scnData.m_vbCache.chunk_at(chunkId);</a>
<a name="ln637"> </a>
<a name="ln638">  char* dataPtr = (char*)chunk.GetMemoryNow();</a>
<a name="ln639">  if (dataPtr == nullptr)</a>
<a name="ln640">  {</a>
<a name="ln641">     input.pos4f         = nullptr;</a>
<a name="ln642">     input.norm4f        = nullptr;</a>
<a name="ln643">     input.texcoord2f    = nullptr;</a>
<a name="ln644">     input.indices       = nullptr;</a>
<a name="ln645">     input.triMatIndices = nullptr;</a>
<a name="ln646">     input.triNum        = 0;</a>
<a name="ln647">     input.vertNum       = 0;</a>
<a name="ln648">  }</a>
<a name="ln649">  else</a>
<a name="ln650">  {</a>
<a name="ln651">    uint64_t offsetPos  = mesh.pImpl-&gt;offset(L&quot;pos&quot;);</a>
<a name="ln652">    uint64_t offsetNorm = mesh.pImpl-&gt;offset(L&quot;norm&quot;);</a>
<a name="ln653">    uint64_t offsetTexc = mesh.pImpl-&gt;offset(L&quot;texc&quot;);</a>
<a name="ln654">    uint64_t offsetTang = mesh.pImpl-&gt;offset(L&quot;tan&quot;);</a>
<a name="ln655">    uint64_t offsetInd  = mesh.pImpl-&gt;offset(L&quot;ind&quot;);</a>
<a name="ln656">    uint64_t offsetMInd = mesh.pImpl-&gt;offset(L&quot;mind&quot;);</a>
<a name="ln657"> </a>
<a name="ln658">    input.pos4f         = (float*)(dataPtr + offsetPos);</a>
<a name="ln659">    input.norm4f        = (float*)(dataPtr + offsetNorm);</a>
<a name="ln660">    input.texcoord2f    = (float*)(dataPtr + offsetTexc);</a>
<a name="ln661">    input.tan4f         = (float*)(dataPtr + offsetTang);</a>
<a name="ln662">    input.indices       = (int*)  (dataPtr + offsetInd);</a>
<a name="ln663">    input.triMatIndices = (int*)  (dataPtr + offsetMInd);</a>
<a name="ln664">    input.allData       = dataPtr;</a>
<a name="ln665">  }</a>
<a name="ln666"> </a>
<a name="ln667">  return input;</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670">std::vector&lt;HRBatchInfo&gt; FormMatDrawListRLE(const std::vector&lt;uint32_t&gt;&amp; matIndices);</a>
<a name="ln671"> </a>
<a name="ln672">void HR_CopyMeshToInputMeshFromHydraGeomData(const HydraGeomData&amp; data,  HRMesh::InputTriMesh&amp; mesh2)</a>
<a name="ln673">{</a>
<a name="ln674">  HydraGeomData::Header header = data.getHeader();</a>
<a name="ln675">  const bool dontHaveTangents  = (header.flags &amp; HydraGeomData::HAS_TANGENT)    == 0;</a>
<a name="ln676">  const bool dontHaveNormals   = (header.flags &amp; HydraGeomData::HAS_NO_NORMALS) != 0;</a>
<a name="ln677"> </a>
<a name="ln678">  mesh2.resize(data.getVerticesNumber(), data.getIndicesNumber());</a>
<a name="ln679"> </a>
<a name="ln680">  memcpy(mesh2.verticesPos.data(),      data.getVertexPositionsFloat4Array(), sizeof(float)*4*data.getVerticesNumber());</a>
<a name="ln681">  memcpy(mesh2.verticesTexCoord.data(), data.getVertexTexcoordFloat2Array(),  sizeof(float)*2*data.getVerticesNumber());</a>
<a name="ln682"> </a>
<a name="ln683">  memcpy(mesh2.triIndices.data(), data.getTriangleVertexIndicesArray(),   sizeof(int)*data.getIndicesNumber());</a>
<a name="ln684">  memcpy(mesh2.matIndices.data(), data.getTriangleMaterialIndicesArray(), sizeof(int)*data.getIndicesNumber()/3);</a>
<a name="ln685"> </a>
<a name="ln686">  if(!dontHaveNormals)</a>
<a name="ln687">    memcpy(mesh2.verticesNorm.data(), data.getVertexNormalsFloat4Array(), sizeof(float)*4*data.getVerticesNumber());</a>
<a name="ln688">  else</a>
<a name="ln689">    ComputeVertexNormals(mesh2, data.getIndicesNumber(), false);</a>
<a name="ln690"> </a>
<a name="ln691">  if(dontHaveTangents)</a>
<a name="ln692">    ComputeVertexTangents(mesh2, data.getIndicesNumber());</a>
<a name="ln693">  else</a>
<a name="ln694">    memcpy(mesh2.verticesTangent.data(), data.getVertexTangentsFloat4Array(), sizeof(float)*4*data.getVerticesNumber());</a>
<a name="ln695">}</a>
<a name="ln696"> </a>
<a name="ln697">std::string ws2s(const std::wstring&amp; s);</a>
<a name="ln698"> </a>
<a name="ln699">void UpdateMeshFromChunk(int32_t a_id, HRMesh&amp; mesh, std::vector&lt;HRBatchInfo&gt;&amp; a_batches, IHRRenderDriver* a_pDriver, const wchar_t* path, int64_t a_byteSize)</a>
<a name="ln700">{</a>
<a name="ln701">  pugi::xml_node nodeXML = mesh.xml_node();</a>
<a name="ln702"> </a>
<a name="ln703">  std::ifstream fin;</a>
<a name="ln704">  hr_ifstream_open(fin, path);</a>
<a name="ln705"> </a>
<a name="ln706">  if(!fin.is_open())</a>
<a name="ln707">  {</a>
<a name="ln708">    HrError(L&quot;UpdateMeshFromChunk: Can't open file: &quot;, path);</a>
<a name="ln709">    return;</a>
<a name="ln710">  }</a>
<a name="ln711">  </a>
<a name="ln712">  HydraGeomData::Header header;</a>
<a name="ln713">  fin.read((char*)&amp;header, sizeof(header));</a>
<a name="ln714">  fin.close();</a>
<a name="ln715">  </a>
<a name="ln716">  const std::wstring tail = str_tail(path, 6);</a>
<a name="ln717">  if(tail != L&quot;.vsgfc&quot; &amp;&amp; header.fileSizeInBytes != a_byteSize)</a>
<a name="ln718">  {</a>
<a name="ln719">    HrPrint(HR_SEVERITY_WARNING, L&quot;UpdateMeshFromChunk, different byte size of chunk, may be broken mesh: &quot;, path);</a>
<a name="ln720">    a_byteSize = std::max&lt;int64_t&gt;(a_byteSize, header.fileSizeInBytes);</a>
<a name="ln721">  }</a>
<a name="ln722">  </a>
<a name="ln723">  g_objManager.m_tempBuffer.resize(a_byteSize / sizeof(int) + sizeof(int) * 16);</a>
<a name="ln724">  char* dataPtr = (char*)g_objManager.m_tempBuffer.data();</a>
<a name="ln725">  </a>
<a name="ln726">  const bool dontHaveTangents = (header.flags &amp; HydraGeomData::HAS_TANGENT)    == 0;</a>
<a name="ln727">  const bool dontHaveNormals  = (header.flags &amp; HydraGeomData::HAS_NO_NORMALS) != 0;</a>
<a name="ln728">  </a>
<a name="ln729">  HRMeshDriverInput    input;</a>
<a name="ln730">  HRMesh::InputTriMesh mesh2;</a>
<a name="ln731">  HydraGeomData        data;</a>
<a name="ln732"> </a>
<a name="ln733">  ///////////////////////////////////////////////////////////////////////////////////////////////////////////// obj loader</a>
<a name="ln734">  tinyobj::attrib_t attrib;</a>
<a name="ln735">  std::vector&lt;tinyobj::shape_t&gt; shapes;</a>
<a name="ln736">  std::vector&lt;tinyobj::material_t&gt; materials;</a>
<a name="ln737">  std::vector&lt;float&gt; verts;</a>
<a name="ln738">  std::vector&lt;float&gt; norms;</a>
<a name="ln739">  std::vector&lt;float&gt; tex_s;</a>
<a name="ln740">  std::vector&lt;int  &gt; indxs;</a>
<a name="ln741">  ///////////////////////////////////////////////////////////////////////////////////////////////////////////// obj loader</a>
<a name="ln742"> </a>
<a name="ln743">  // decompress '.vsgfc' format</a>
<a name="ln744">  //</a>
<a name="ln745">  if(tail == L&quot;.obj&quot;)</a>
<a name="ln746">  {</a>
<a name="ln747">    HrPrint(HR_SEVERITY_ERROR, L&quot;UpdateMeshFromChunk, obj loader is not implemented here, &quot;, path);</a>
<a name="ln748">    return;</a>
<a name="ln749">  }</a>
<a name="ln750">  else if(tail == L&quot;.vsgfc&quot;)</a>
<a name="ln751">  {</a>
<a name="ln752">    data                = HR_LoadVSGFCompressedData(path, g_objManager.m_tempBuffer, &amp;a_batches);</a>
<a name="ln753"> </a>
<a name="ln754">    input.vertNum       = data.getVerticesNumber();</a>
<a name="ln755">    input.triNum        = data.getIndicesNumber()/3;</a>
<a name="ln756"> </a>
<a name="ln757">    input.pos4f         = data.getVertexPositionsFloat4Array();</a>
<a name="ln758">    input.norm4f        = data.getVertexNormalsFloat4Array();</a>
<a name="ln759">    input.tan4f         = data.getVertexTangentsFloat4Array();</a>
<a name="ln760">    input.texcoord2f    = data.getVertexTexcoordFloat2Array();</a>
<a name="ln761">    input.indices       = (const int*)data.getTriangleVertexIndicesArray();</a>
<a name="ln762">    input.triMatIndices = (const int*)data.getTriangleMaterialIndicesArray();</a>
<a name="ln763">    input.allData       = (char*)g_objManager.m_tempBuffer.data();</a>
<a name="ln764">  }</a>
<a name="ln765">  else if(dontHaveTangents || dontHaveNormals)  // (1) process the case when we don't have tangents or normals ...</a>
<a name="ln766">  {</a>
<a name="ln767">    data.read(path);</a>
<a name="ln768">    HR_CopyMeshToInputMeshFromHydraGeomData(data, mesh2);</a>
<a name="ln769"> </a>
<a name="ln770">    a_batches           = FormMatDrawListRLE(mesh2.matIndices);</a>
<a name="ln771"> </a>
<a name="ln772">    input.vertNum       = data.getVerticesNumber();</a>
<a name="ln773">    input.triNum        = data.getIndicesNumber()/3;</a>
<a name="ln774">  </a>
<a name="ln775">    input.pos4f         = mesh2.verticesPos.data();</a>
<a name="ln776">    input.norm4f        = mesh2.verticesNorm.data();</a>
<a name="ln777">    input.tan4f         = mesh2.verticesTangent.data();</a>
<a name="ln778">    input.texcoord2f    = mesh2.verticesTexCoord.data();</a>
<a name="ln779">    input.indices       = (const int*)mesh2.triIndices.data();</a>
<a name="ln780">    input.triMatIndices = (const int*)mesh2.matIndices.data();</a>
<a name="ln781">    input.allData       = nullptr;</a>
<a name="ln782">  }</a>
<a name="ln783">  // (3) read it &quot;as is&quot;</a>
<a name="ln784">  //</a>
<a name="ln785">  else</a>
<a name="ln786">  {</a>
<a name="ln787">    hr_ifstream_open(fin, path);</a>
<a name="ln788">    fin.read(dataPtr, a_byteSize);</a>
<a name="ln789">    fin.close();</a>
<a name="ln790">  </a>
<a name="ln791">    uint64_t offsetPos  = mesh.pImpl-&gt;offset(L&quot;pos&quot;);</a>
<a name="ln792">    uint64_t offsetNorm = mesh.pImpl-&gt;offset(L&quot;norm&quot;);</a>
<a name="ln793">    uint64_t offsetTexc = mesh.pImpl-&gt;offset(L&quot;texc&quot;);</a>
<a name="ln794">    uint64_t offsetTang = mesh.pImpl-&gt;offset(L&quot;tan&quot;);</a>
<a name="ln795">    uint64_t offsetInd  = mesh.pImpl-&gt;offset(L&quot;ind&quot;);</a>
<a name="ln796">    uint64_t offsetMInd = mesh.pImpl-&gt;offset(L&quot;mind&quot;);</a>
<a name="ln797">  </a>
<a name="ln798">    input.vertNum       = nodeXML.attribute(L&quot;vertNum&quot;).as_int();</a>
<a name="ln799">    input.triNum        = nodeXML.attribute(L&quot;triNum&quot;).as_int();</a>
<a name="ln800">  </a>
<a name="ln801">    input.pos4f         = (float*)(dataPtr + offsetPos);</a>
<a name="ln802">    input.norm4f        = (float*)(dataPtr + offsetNorm);</a>
<a name="ln803">    input.tan4f         = (float*)(dataPtr + offsetTang);</a>
<a name="ln804">    input.texcoord2f    = (float*)(dataPtr + offsetTexc);</a>
<a name="ln805">    input.indices       = (int*)  (dataPtr + offsetInd);</a>
<a name="ln806">    input.triMatIndices = (int*)  (dataPtr + offsetMInd);</a>
<a name="ln807">    input.allData       = dataPtr;</a>
<a name="ln808"> </a>
<a name="ln809">    a_batches           = FormMatDrawListRLE(std::vector&lt;uint32_t&gt;(input.triMatIndices, input.triMatIndices + input.triNum));</a>
<a name="ln810">  }</a>
<a name="ln811"> </a>
<a name="ln812">  //#TODO: add debug assert/check that all materials from 'a_batches' were updated previously to 'a_pDriver'</a>
<a name="ln813"> </a>
<a name="ln814">  a_pDriver-&gt;UpdateMesh(a_id, nodeXML, input, a_batches.data(), int32_t(a_batches.size()));</a>
<a name="ln815">  </a>
<a name="ln816">}</a>
<a name="ln817"> </a>
<a name="ln818">const std::wstring GetRealFilePathOfDelayedMesh(pugi::xml_node a_node);</a>
<a name="ln819"> </a>
<a name="ln820">/////</a>
<a name="ln821">//</a>
<a name="ln822">int32_t HR_DriverUpdateMeshes(HRSceneInst&amp; scn, ChangeList&amp; objList, HRRender* a_pRender)</a>
<a name="ln823">{</a>
<a name="ln824">  IHRRenderDriver* a_pDriver = a_pRender-&gt;m_pDriver.get();</a>
<a name="ln825">  if (g_objManager.scnData.meshes.empty() || a_pDriver == nullptr)</a>
<a name="ln826">    return 0;</a>
<a name="ln827"> </a>
<a name="ln828">  a_pDriver-&gt;BeginGeomUpdate();</a>
<a name="ln829"> </a>
<a name="ln830">  //static bool wasThere = false;</a>
<a name="ln831">  std::wstring driver_name;</a>
<a name="ln832">  a_pDriver-&gt;GetRenderDriverName(driver_name);</a>
<a name="ln833">  auto info = RenderDriverFactory::GetDriverInfo(driver_name.c_str());</a>
<a name="ln834"> </a>
<a name="ln835">  //std::cout &lt;&lt; std::endl;</a>
<a name="ln836">  //std::cout &lt;&lt; &quot;##HR_DriverUpdateMeshes: objList.meshUsed.size() = &quot; &lt;&lt; objList.meshUsed.size() &lt;&lt; std::endl;</a>
<a name="ln837">  //std::cout &lt;&lt; std::endl;</a>
<a name="ln838"> </a>
<a name="ln839">  //auto drawSeq = FormInstDrawSequence(scnlib);</a>
<a name="ln840"> </a>
<a name="ln841">  int32_t updatedMeshes = 0;</a>
<a name="ln842"> </a>
<a name="ln843">  std::vector&lt;int32_t&gt; idsToUpdate;</a>
<a name="ln844">  idsToUpdate.reserve(objList.meshUsed.size());</a>
<a name="ln845">  std::copy(objList.meshUsed.begin(), objList.meshUsed.end(), std::back_inserter(idsToUpdate));</a>
<a name="ln846">  std::sort(idsToUpdate.begin(), idsToUpdate.end());</a>
<a name="ln847"> </a>
<a name="ln848"> </a>
<a name="ln849">  for (auto id : idsToUpdate)</a>
<a name="ln850">  {</a>
<a name="ln851">    HRMesh&amp; mesh            = g_objManager.scnData.meshes[id];</a>
<a name="ln852">    HRMeshDriverInput input = HR_GetMeshDataPointers(id);</a>
<a name="ln853">    pugi::xml_node meshNode = mesh.xml_node();</a>
<a name="ln854"> </a>
<a name="ln855">    const std::wstring filePathStr = GetRealFilePathOfDelayedMesh(meshNode);</a>
<a name="ln856">    const wchar_t* path            = filePathStr.c_str();</a>
<a name="ln857"> </a>
<a name="ln858">    if (mesh.pImpl != nullptr)</a>
<a name="ln859">    {</a>
<a name="ln860">      auto&amp; mlist = mesh.pImpl-&gt;MList();</a>
<a name="ln861"> </a>
<a name="ln862">      if (input.pos4f == nullptr)</a>
<a name="ln863">      {</a>
<a name="ln864">        a_pRender-&gt;m_updated.meshUsed.insert(id);</a>
<a name="ln865"> </a>
<a name="ln866">        if (info.supportMeshLoadFromInternalFormat)</a>
<a name="ln867">        {</a>
<a name="ln868">          a_pDriver-&gt;UpdateMeshFromFile(int32_t(id), meshNode, path);</a>
<a name="ln869">        }</a>
<a name="ln870">        else</a>
<a name="ln871">        {</a>
<a name="ln872">          int64_t byteSize = meshNode.attribute(L&quot;bytesize&quot;).as_llong();</a>
<a name="ln873">          UpdateMeshFromChunk(int32_t(id), mesh, mlist, a_pDriver, path, byteSize);</a>
<a name="ln874">        }</a>
<a name="ln875">      }</a>
<a name="ln876">      else</a>
<a name="ln877">      {</a>
<a name="ln878">        a_pRender-&gt;m_updated.meshUsed.insert(id);</a>
<a name="ln879">        a_pDriver-&gt;UpdateMesh(int32_t(id), meshNode, input, &amp;mlist[0], int32_t(mlist.size()));</a>
<a name="ln880">      }</a>
<a name="ln881"> </a>
<a name="ln882">      updatedMeshes++;</a>
<a name="ln883">    }</a>
<a name="ln884">    </a>
<a name="ln885">  }</a>
<a name="ln886"> </a>
<a name="ln887">  a_pDriver-&gt;EndGeomUpdate();</a>
<a name="ln888"> </a>
<a name="ln889">  return updatedMeshes;</a>
<a name="ln890">}</a>
<a name="ln891"> </a>
<a name="ln892">int32_t _hr_UtilityDriverUpdateMeshes(HRSceneInst&amp; scn, HRRender* a_pRender)</a>
<a name="ln893">{</a>
<a name="ln894">  IHRRenderDriver* a_pDriver = a_pRender-&gt;m_pDriver.get();</a>
<a name="ln895">  if (g_objManager.scnData.meshes.empty() || a_pDriver == nullptr)</a>
<a name="ln896">    return 0;</a>
<a name="ln897"> </a>
<a name="ln898">  a_pDriver-&gt;BeginGeomUpdate();</a>
<a name="ln899"> </a>
<a name="ln900">  std::wstring driver_name;</a>
<a name="ln901">  a_pDriver-&gt;GetRenderDriverName(driver_name);</a>
<a name="ln902">  auto info = RenderDriverFactory::GetDriverInfo(driver_name.c_str());</a>
<a name="ln903"> </a>
<a name="ln904">  int32_t updatedMeshes = 0;</a>
<a name="ln905"> </a>
<a name="ln906"> </a>
<a name="ln907">  for(auto p : a_pRender-&gt;m_updated.meshUsed)</a>
<a name="ln908">  {</a>
<a name="ln909">    HRMesh&amp; mesh            = g_objManager.scnData.meshes[p];</a>
<a name="ln910">    HRMeshDriverInput input = HR_GetMeshDataPointers(p);</a>
<a name="ln911">    pugi::xml_node meshNode = mesh.xml_node();</a>
<a name="ln912"> </a>
<a name="ln913">    const std::wstring delayedLoad = meshNode.attribute(L&quot;dl&quot;).as_string();</a>
<a name="ln914">    const std::wstring locStr      = g_objManager.GetLoc(meshNode);</a>
<a name="ln915">    const wchar_t* path = (delayedLoad == L&quot;1&quot;) ? meshNode.attribute(L&quot;path&quot;).as_string() : locStr.c_str();</a>
<a name="ln916"> </a>
<a name="ln917">    if (mesh.pImpl != nullptr)</a>
<a name="ln918">    {</a>
<a name="ln919">      auto&amp; mlist = mesh.pImpl-&gt;MList();</a>
<a name="ln920"> </a>
<a name="ln921">      if (input.pos4f == nullptr)</a>
<a name="ln922">      {</a>
<a name="ln923">        if (info.supportMeshLoadFromInternalFormat)</a>
<a name="ln924">        {</a>
<a name="ln925">          a_pDriver-&gt;UpdateMeshFromFile(p, meshNode, path);</a>
<a name="ln926">        }</a>
<a name="ln927">        else</a>
<a name="ln928">        {</a>
<a name="ln929">          int64_t byteSize = meshNode.attribute(L&quot;bytesize&quot;).as_llong();</a>
<a name="ln930">          UpdateMeshFromChunk(p, mesh, mlist, a_pDriver, path, byteSize);</a>
<a name="ln931">        }</a>
<a name="ln932">      }</a>
<a name="ln933">      else</a>
<a name="ln934">      {</a>
<a name="ln935">        a_pDriver-&gt;UpdateMesh(p, meshNode, input, &amp;mlist[0], int32_t(mlist.size()));</a>
<a name="ln936">      }</a>
<a name="ln937">      updatedMeshes++;</a>
<a name="ln938">    }</a>
<a name="ln939">  }</a>
<a name="ln940"> </a>
<a name="ln941">  a_pDriver-&gt;EndGeomUpdate();</a>
<a name="ln942"> </a>
<a name="ln943">  return updatedMeshes;</a>
<a name="ln944">}</a>
<a name="ln945"> </a>
<a name="ln946">void HR_DriverUpdateCamera(HRSceneInst&amp; scn, IHRRenderDriver* a_pDriver)</a>
<a name="ln947">{</a>
<a name="ln948">  if (g_objManager.m_currCamId &gt;= g_objManager.scnData.cameras.size())</a>
<a name="ln949">    return;</a>
<a name="ln950"> </a>
<a name="ln951">  HRCamera&amp; cam = g_objManager.scnData.cameras[g_objManager.m_currCamId];</a>
<a name="ln952"> </a>
<a name="ln953">  a_pDriver-&gt;UpdateCamera(cam.xml_node());</a>
<a name="ln954">}</a>
<a name="ln955"> </a>
<a name="ln956">void HR_DriverUpdateSettings(HRSceneInst&amp; scn, IHRRenderDriver* a_pDriver)</a>
<a name="ln957">{</a>
<a name="ln958">  if (g_objManager.renderSettings.empty())</a>
<a name="ln959">    return;</a>
<a name="ln960"> </a>
<a name="ln961">  auto&amp; settings = g_objManager.renderSettings[g_objManager.m_currRenderId];</a>
<a name="ln962"> </a>
<a name="ln963">  a_pDriver-&gt;UpdateSettings(settings.xml_node());</a>
<a name="ln964">}</a>
<a name="ln965"> </a>
<a name="ln966"> </a>
<a name="ln967">void HR_CheckCommitErrors(HRSceneInst&amp; scn, ChangeList&amp; objList)</a>
<a name="ln968">{</a>
<a name="ln969">  if (!g_objManager.m_badMaterialId.empty())</a>
<a name="ln970">  {</a>
<a name="ln971">    std::wstringstream outStr;</a>
<a name="ln972">    outStr &lt;&lt; L&quot;bad material id (10 first): [&quot;;</a>
<a name="ln973">    for (size_t i = 0; i &lt; g_objManager.m_badMaterialId.size() - 1; i++)</a>
<a name="ln974">      outStr &lt;&lt; g_objManager.m_badMaterialId[i] &lt;&lt; L&quot;, &quot;;</a>
<a name="ln975">    outStr &lt;&lt; g_objManager.m_badMaterialId[g_objManager.m_badMaterialId.size() - 1] &lt;&lt; L&quot;]&quot;;</a>
<a name="ln976">    g_objManager.m_badMaterialId.clear();</a>
<a name="ln977">    std::wstring strErr = outStr.str();</a>
<a name="ln978">    HrError(L&quot;commit error, &quot;, strErr.c_str());</a>
<a name="ln979">  }</a>
<a name="ln980">}</a>
<a name="ln981"> </a>
<a name="ln982">//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln983">//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln984">//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln985"> </a>
<a name="ln986">void union_sets(ChangeList&amp; in1, const ChangeList&amp; in2)</a>
<a name="ln987">{</a>
<a name="ln988">  in1.lightUsed.insert(in2.lightUsed.begin(), in2.lightUsed.end());</a>
<a name="ln989">  in1.matUsed.insert(in2.matUsed.begin(), in2.matUsed.end());</a>
<a name="ln990">  in1.meshUsed.insert(in2.meshUsed.begin(), in2.meshUsed.end());</a>
<a name="ln991">  in1.texturesUsed.insert(in2.texturesUsed.begin(), in2.texturesUsed.end());</a>
<a name="ln992">}</a>
<a name="ln993"> </a>
<a name="ln994">int64_t EstimateGeometryMem(const ChangeList&amp; a_objList)</a>
<a name="ln995">{</a>
<a name="ln996">  int64_t memAmount = 0;</a>
<a name="ln997"> </a>
<a name="ln998">  for (auto texId : a_objList.meshUsed)</a>
<a name="ln999">  {</a>
<a name="ln1000">    auto meshObj          = g_objManager.scnData.meshes[texId];</a>
<a name="ln1001">    pugi::xml_node node   = meshObj.xml_node();</a>
<a name="ln1002">  </a>
<a name="ln1003">    size_t byteSize2 = 0;</a>
<a name="ln1004">    if(meshObj.pImpl == nullptr) // well, we try to estimate it in some way</a>
<a name="ln1005">    {</a>
<a name="ln1006">      // mul to 1.5 due to external generated '.vsgf' mesh may not have tangents (and normals) and</a>
<a name="ln1007">      // and we try to estimate upper bound of memory that mesh will take</a>
<a name="ln1008">      //</a>
<a name="ln1009">      const size_t byteSize = node.attribute(L&quot;bytesize&quot;).as_double() * 1.5;</a>
<a name="ln1010">      const int trisNum     = int(node.child(L&quot;indices&quot;).attribute(L&quot;bytesize&quot;).as_llong() / (sizeof(int) * 3)); // aux per poly shadow ray offsets</a>
<a name="ln1011">      byteSize2             = (byteSize + trisNum * sizeof(float));</a>
<a name="ln1012">    }</a>
<a name="ln1013">    else</a>
<a name="ln1014">    {</a>
<a name="ln1015">      // more accurate method</a>
<a name="ln1016">      //</a>
<a name="ln1017">      const int trisNum     = int(node.child(L&quot;indices&quot;).attribute(L&quot;bytesize&quot;).as_llong() / (sizeof(int) * 3)); // aux per poly shadow ray offsets</a>
<a name="ln1018">      byteSize2 = meshObj.pImpl-&gt;EstimatedDataSizeInBytes() + trisNum*sizeof(float);</a>
<a name="ln1019">    }</a>
<a name="ln1020">    </a>
<a name="ln1021">    memAmount += byteSize2;</a>
<a name="ln1022">  }</a>
<a name="ln1023"> </a>
<a name="ln1024">  return memAmount + int64_t(1*1024*1024);</a>
<a name="ln1025">}</a>
<a name="ln1026"> </a>
<a name="ln1027">int64_t EstimateTexturesMem(const ChangeList&amp; a_objList, std::unordered_map&lt;int32_t, HRTexResInfo&gt;&amp; out_texInfo)</a>
<a name="ln1028">{</a>
<a name="ln1029">  int64_t memAmount = 0;</a>
<a name="ln1030"> </a>
<a name="ln1031">  for (auto texId : a_objList.texturesUsed)</a>
<a name="ln1032">  {</a>
<a name="ln1033">    if (texId &lt; 0 || texId &gt;= g_objManager.scnData.textures.size())</a>
<a name="ln1034">      continue;</a>
<a name="ln1035"> </a>
<a name="ln1036">    auto texObj           = g_objManager.scnData.textures[texId];</a>
<a name="ln1037">    pugi::xml_node node   = texObj.xml_node();</a>
<a name="ln1038"> </a>
<a name="ln1039">    const size_t byteSize    = node.attribute(L&quot;bytesize&quot;).as_llong();</a>
<a name="ln1040">    const int widthOriginal  = node.attribute(L&quot;width&quot;).as_int();</a>
<a name="ln1041">    const int heightOriginal = node.attribute(L&quot;height&quot;).as_int();</a>
<a name="ln1042"> </a>
<a name="ln1043">    if (byteSize == 0 || heightOriginal == 0 || widthOriginal == 0)</a>
<a name="ln1044">      continue;</a>
<a name="ln1045"> </a>
<a name="ln1046">    const size_t elemSize    = byteSize / (widthOriginal*heightOriginal);</a>
<a name="ln1047">    HRTexResInfo texInfo;</a>
<a name="ln1048">    texInfo.id  = texId;</a>
<a name="ln1049">    texInfo.w   = widthOriginal;</a>
<a name="ln1050">    texInfo.h   = heightOriginal;</a>
<a name="ln1051">    texInfo.rw  = widthOriginal;</a>
<a name="ln1052">    texInfo.rh  = heightOriginal;</a>
<a name="ln1053">    texInfo.aw  = widthOriginal;</a>
<a name="ln1054">    texInfo.ah  = heightOriginal;</a>
<a name="ln1055">    texInfo.bpp = int(elemSize);</a>
<a name="ln1056">    texInfo.usedAsBump = false;</a>
<a name="ln1057"> </a>
<a name="ln1058">    if (node.attribute(L&quot;rwidth&quot;) != nullptr &amp;&amp; node.attribute(L&quot;rheight&quot;) != nullptr)</a>
<a name="ln1059">    {</a>
<a name="ln1060">      const int rwidth  = node.attribute(L&quot;rwidth&quot;).as_int();</a>
<a name="ln1061">      const int rheight = node.attribute(L&quot;rheight&quot;).as_int();</a>
<a name="ln1062">      texInfo.rw = rwidth;</a>
<a name="ln1063">      texInfo.rh = rheight;</a>
<a name="ln1064">      //memAmount += size_t(rwidth*rheight)*elemSize;</a>
<a name="ln1065">    }</a>
<a name="ln1066">    memAmount += byteSize;</a>
<a name="ln1067"> </a>
<a name="ln1068">    out_texInfo[texId] = texInfo;</a>
<a name="ln1069">  }</a>
<a name="ln1070"> </a>
<a name="ln1071">  return memAmount;</a>
<a name="ln1072">}</a>
<a name="ln1073"> </a>
<a name="ln1074"> </a>
<a name="ln1075">static void FindAllTexturesForNormalMaps(pugi::xml_node a_node, const std::unordered_map&lt;int, pugi::xml_node &gt;&amp; a_matNodes, </a>
<a name="ln1076">                                         std::unordered_set&lt;int32_t&gt;&amp; out_texIds)</a>
<a name="ln1077">{</a>
<a name="ln1078"> </a>
<a name="ln1079">  if (a_node.name() == std::wstring(L&quot;displacement&quot;))</a>
<a name="ln1080">  {</a>
<a name="ln1081">    int32_t texId = a_node.child(L&quot;height_map&quot;).child(L&quot;texture&quot;).attribute(L&quot;id&quot;).as_int();</a>
<a name="ln1082">    if(texId == 0)</a>
<a name="ln1083">      texId = a_node.child(L&quot;normal_map&quot;).child(L&quot;texture&quot;).attribute(L&quot;id&quot;).as_int();</a>
<a name="ln1084"> </a>
<a name="ln1085">    out_texIds.insert(texId);</a>
<a name="ln1086">  }</a>
<a name="ln1087">  else</a>
<a name="ln1088">  {</a>
<a name="ln1089">    for (auto child : a_node.children())</a>
<a name="ln1090">      FindAllTexturesForNormalMaps(child, a_matNodes, out_texIds);</a>
<a name="ln1091">  }</a>
<a name="ln1092"> </a>
<a name="ln1093">  if (a_node.name() == std::wstring(L&quot;material&quot;) &amp;&amp; a_node.attribute(L&quot;type&quot;).as_string() == std::wstring(L&quot;hydra_blend&quot;))</a>
<a name="ln1094">  {</a>
<a name="ln1095">    int mid1 = a_node.attribute(L&quot;node_top&quot;).as_int();</a>
<a name="ln1096">    int mid2 = a_node.attribute(L&quot;node_bottom&quot;).as_int();</a>
<a name="ln1097"> </a>
<a name="ln1098">    auto p1 = a_matNodes.find(mid1);</a>
<a name="ln1099">    auto p2 = a_matNodes.find(mid2);</a>
<a name="ln1100"> </a>
<a name="ln1101">    if (p1 != a_matNodes.end())</a>
<a name="ln1102">      FindAllTexturesForNormalMaps(p1-&gt;second, a_matNodes, out_texIds);</a>
<a name="ln1103"> </a>
<a name="ln1104">    if (p2 != a_matNodes.end())</a>
<a name="ln1105">      FindAllTexturesForNormalMaps(p2-&gt;second, a_matNodes, out_texIds);</a>
<a name="ln1106">  }</a>
<a name="ln1107"> </a>
<a name="ln1108">}</a>
<a name="ln1109"> </a>
<a name="ln1110">int64_t EstimateTexturesMemBump(const ChangeList&amp; a_objList, std::unordered_map&lt;int32_t, HRTexResInfo&gt;&amp; a_outTexInfo)</a>
<a name="ln1111">{</a>
<a name="ln1112">  std::unordered_set&lt;int32_t&gt; texturesUsedForNormalMaps;</a>
<a name="ln1113">  texturesUsedForNormalMaps.reserve(100);</a>
<a name="ln1114"> </a>
<a name="ln1115">  std::unordered_map&lt;int, pugi::xml_node &gt; matNodesById;</a>
<a name="ln1116">  for (auto mId : a_objList.matUsed)</a>
<a name="ln1117">  {</a>
<a name="ln1118">    if (mId &lt; 0 || mId &gt;= g_objManager.scnData.materials.size())</a>
<a name="ln1119">      continue;</a>
<a name="ln1120"> </a>
<a name="ln1121">    auto&amp; hmat = g_objManager.scnData.materials[mId];</a>
<a name="ln1122">    pugi::xml_node matNode = hmat.xml_node();</a>
<a name="ln1123">  </a>
<a name="ln1124">    matNodesById[mId] = hmat.xml_node();</a>
<a name="ln1125">  }</a>
<a name="ln1126"> </a>
<a name="ln1127">  for (auto matNodePair : matNodesById)</a>
<a name="ln1128">    FindAllTexturesForNormalMaps(matNodePair.second, matNodesById, texturesUsedForNormalMaps);</a>
<a name="ln1129"> </a>
<a name="ln1130">  // finally calculate needed memory amount</a>
<a name="ln1131">  //</a>
<a name="ln1132">  int64_t memAmount = 0;</a>
<a name="ln1133"> </a>
<a name="ln1134">  for (auto texId : texturesUsedForNormalMaps)</a>
<a name="ln1135">  {</a>
<a name="ln1136">    if (texId &lt; 0 || texId &gt;= g_objManager.scnData.textures.size())</a>
<a name="ln1137">      continue;</a>
<a name="ln1138"> </a>
<a name="ln1139">    auto texObj           = g_objManager.scnData.textures[texId];</a>
<a name="ln1140">    pugi::xml_node node   = texObj.xml_node();</a>
<a name="ln1141">    const size_t byteSize = node.attribute(L&quot;bytesize&quot;).as_llong();</a>
<a name="ln1142"> </a>
<a name="ln1143">    if (byteSize == 0)</a>
<a name="ln1144">      continue;</a>
<a name="ln1145"> </a>
<a name="ln1146">    if (node.attribute(L&quot;rwidth&quot;) != nullptr &amp;&amp; node.attribute(L&quot;rheight&quot;) != nullptr)</a>
<a name="ln1147">    {</a>
<a name="ln1148">      const int widthOriginal  = node.attribute(L&quot;width&quot;).as_int();</a>
<a name="ln1149">      const int heightOriginal = node.attribute(L&quot;height&quot;).as_int();</a>
<a name="ln1150">      //const size_t elemSize    = byteSize / (widthOriginal*heightOriginal);</a>
<a name="ln1151">      const int rwidth  = node.attribute(L&quot;rwidth&quot;).as_int();</a>
<a name="ln1152">      const int rheight = node.attribute(L&quot;rheight&quot;).as_int();</a>
<a name="ln1153">      a_outTexInfo[texId].rw = rwidth;</a>
<a name="ln1154">      a_outTexInfo[texId].rh = rheight;</a>
<a name="ln1155">    }</a>
<a name="ln1156">  </a>
<a name="ln1157">    memAmount += byteSize;</a>
<a name="ln1158"> </a>
<a name="ln1159">    a_outTexInfo[texId].usedAsBump = true;</a>
<a name="ln1160">  }</a>
<a name="ln1161"> </a>
<a name="ln1162">  return memAmount;</a>
<a name="ln1163">}</a>
<a name="ln1164"> </a>
<a name="ln1165">void EstimateMemHungryLights(const ChangeList&amp; a_objList, bool* pIsHDR, int* pHungryLightsNumber, int* pEnvSize)</a>
<a name="ln1166">{</a>
<a name="ln1167">  size_t  envMemAmount   = 0;</a>
<a name="ln1168">  int32_t hungryLightNum = 0;</a>
<a name="ln1169"> </a>
<a name="ln1170">  std::unordered_set&lt;std::wstring&gt; processed;</a>
<a name="ln1171"> </a>
<a name="ln1172">  for (auto lid : a_objList.lightUsed)</a>
<a name="ln1173">  {</a>
<a name="ln1174">    auto objLight       = g_objManager.scnData.lights[lid];</a>
<a name="ln1175">    pugi::xml_node node = objLight.xml_node();</a>
<a name="ln1176"> </a>
<a name="ln1177">    if (std::wstring(node.attribute(L&quot;distribution&quot;).as_string()) == L&quot;ies&quot; ||</a>
<a name="ln1178">        std::wstring(node.attribute(L&quot;shape&quot;).as_string()) == L&quot;mesh&quot;)</a>
<a name="ln1179">    {</a>
<a name="ln1180">      const std::wstring path = node.child(L&quot;ies&quot;).attribute(L&quot;loc&quot;).as_string();</a>
<a name="ln1181"> </a>
<a name="ln1182">      auto p = processed.find(path);</a>
<a name="ln1183">      if (p == processed.end())</a>
<a name="ln1184">      {</a>
<a name="ln1185">        hungryLightNum++;</a>
<a name="ln1186">        processed.insert(path);</a>
<a name="ln1187">      }</a>
<a name="ln1188">    }</a>
<a name="ln1189">    else if (std::wstring(node.attribute(L&quot;type&quot;).as_string()) == L&quot;sky&quot;)</a>
<a name="ln1190">    {</a>
<a name="ln1191">      pugi::xml_attribute attrId = node.child(L&quot;intensity&quot;).child(L&quot;color&quot;).child(L&quot;texture&quot;).attribute(L&quot;id&quot;);</a>
<a name="ln1192">      if (attrId != nullptr)</a>
<a name="ln1193">      {</a>
<a name="ln1194">        int32_t texId          = attrId.as_int();</a>
<a name="ln1195">        auto texObj            = g_objManager.scnData.textures[texId];</a>
<a name="ln1196">        pugi::xml_node nodeTex = texObj.xml_node();</a>
<a name="ln1197"> </a>
<a name="ln1198">        const int32_t width    = nodeTex.attribute(L&quot;width&quot;).as_int();</a>
<a name="ln1199">        const int32_t height   = nodeTex.attribute(L&quot;height&quot;).as_int();</a>
<a name="ln1200">        const size_t bytesize  = nodeTex.attribute(L&quot;bytesize&quot;).as_llong(); </a>
<a name="ln1201">                               </a>
<a name="ln1202">        const int32_t bpp      = int32_t(bytesize / (width*height));</a>
<a name="ln1203"> </a>
<a name="ln1204">        if (bpp &lt; 16)</a>
<a name="ln1205">        {</a>
<a name="ln1206">          (*pIsHDR) = false;</a>
<a name="ln1207">          if(envMemAmount &lt; 256 * 256 * 4)</a>
<a name="ln1208">            envMemAmount = 256*256*4;</a>
<a name="ln1209">        }</a>
<a name="ln1210">        else</a>
<a name="ln1211">        {</a>
<a name="ln1212">          (*pIsHDR) = true;</a>
<a name="ln1213">          if(envMemAmount &lt; bytesize)</a>
<a name="ln1214">            envMemAmount = bytesize;</a>
<a name="ln1215">        }</a>
<a name="ln1216">      }</a>
<a name="ln1217">    }</a>
<a name="ln1218">  }</a>
<a name="ln1219"> </a>
<a name="ln1220">  (*pHungryLightsNumber) = hungryLightNum;</a>
<a name="ln1221">  (*pEnvSize)            = int(envMemAmount);</a>
<a name="ln1222">}</a>
<a name="ln1223"> </a>
<a name="ln1224">bool g_hydraApiDisableSceneLoadInfo = false;</a>
<a name="ln1225"> </a>
<a name="ln1226">/////</a>
<a name="ln1227">//</a>
<a name="ln1228">void HR_DriverUpdate(HRSceneInst&amp; scn, HRRender* a_pRender)</a>
<a name="ln1229">{</a>
<a name="ln1230">  IHRRenderDriver* a_pDriver = a_pRender-&gt;m_pDriver.get();</a>
<a name="ln1231">  </a>
<a name="ln1232">  if (a_pDriver == nullptr)</a>
<a name="ln1233">    return;</a>
<a name="ln1234"> </a>
<a name="ln1235">  ChangeList objList = FindChangedObjects(scn, a_pRender);</a>
<a name="ln1236"> </a>
<a name="ln1237">  auto p = g_objManager.driverAllocated.find(a_pDriver);</a>
<a name="ln1238">  if (p == g_objManager.driverAllocated.end())</a>
<a name="ln1239">  {</a>
<a name="ln1240">    g_objManager.driverAllocated.insert(a_pDriver);</a>
<a name="ln1241">    HRDriverAllocInfo allocInfo;</a>
<a name="ln1242"> </a>
<a name="ln1243">	  const auto p1 = std::max_element(objList.meshUsed.begin(),     objList.meshUsed.end());</a>
<a name="ln1244">	  const auto p2 = std::max_element(objList.texturesUsed.begin(), objList.texturesUsed.end());</a>
<a name="ln1245">	  const auto p3 = std::max_element(objList.matUsed.begin(),      objList.matUsed.end());</a>
<a name="ln1246">	  const auto p4 = std::max_element(objList.lightUsed.begin(),    objList.lightUsed.end());</a>
<a name="ln1247"> </a>
<a name="ln1248">	  const size_t geomNum  = (p1 == objList.meshUsed.end())     ? 10 : *p1;</a>
<a name="ln1249">    const size_t imgNum   = (p2 == objList.texturesUsed.end()) ? 10 : *p2;</a>
<a name="ln1250">    const size_t matNum   = (p3 == objList.matUsed.end())      ? 10 : *p3;</a>
<a name="ln1251">    const size_t lightNum = (p4 == objList.lightUsed.end())    ? 10 : *p4;</a>
<a name="ln1252"> </a>
<a name="ln1253">    allocInfo.geomNum     = int32_t(geomNum  + geomNum/3  + 100);</a>
<a name="ln1254">    allocInfo.imgNum      = int32_t(imgNum   + imgNum/3   + 100);</a>
<a name="ln1255">    allocInfo.matNum      = int32_t(matNum   + matNum/3   + 100);</a>
<a name="ln1256">    allocInfo.lightNum    = int32_t(lightNum + lightNum/3 + 100);</a>
<a name="ln1257"> </a>
<a name="ln1258">    std::unordered_map&lt;int32_t, HRTexResInfo&gt; allTexInfo;</a>
<a name="ln1259">    std::vector&lt;HRTexResInfo&gt; imgResInfo;</a>
<a name="ln1260">    allTexInfo.reserve(imgNum);</a>
<a name="ln1261"> </a>
<a name="ln1262">    const int64_t neededMemT  = EstimateTexturesMem(objList, allTexInfo);</a>
<a name="ln1263">    const int64_t neededMemT2 = EstimateTexturesMemBump(objList, allTexInfo);</a>
<a name="ln1264">    const int64_t neededMemG  = EstimateGeometryMem(objList);</a>
<a name="ln1265"> </a>
<a name="ln1266">    allocInfo.libraryPath   = g_objManager.scnData.m_path.c_str();</a>
<a name="ln1267">    allocInfo.stateFileName = g_objManager.scnData.m_fileState.c_str();</a>
<a name="ln1268">    </a>
<a name="ln1269">    allocInfo.imgMem      = neededMemT;</a>
<a name="ln1270">    allocInfo.imgMemAux   = neededMemT2;</a>
<a name="ln1271">    allocInfo.geomMem     = neededMemG;</a>
<a name="ln1272"> </a>
<a name="ln1273">    if (g_objManager.scnData.m_texturesLib.attribute(L&quot;resize_textures&quot;).as_int() == 1)</a>
<a name="ln1274">    {</a>
<a name="ln1275">      imgResInfo.resize(allocInfo.imgNum);</a>
<a name="ln1276">      for (auto texInfoPair : allTexInfo)</a>
<a name="ln1277">        imgResInfo[texInfoPair.first] = texInfoPair.second;</a>
<a name="ln1278">      allocInfo.imgResInfoArray = imgResInfo.data();</a>
<a name="ln1279">    }</a>
<a name="ln1280">    else</a>
<a name="ln1281">      allocInfo.imgResInfoArray = nullptr;</a>
<a name="ln1282"> </a>
<a name="ln1283">    EstimateMemHungryLights(objList, </a>
<a name="ln1284">                            &amp;allocInfo.envIsHDR, </a>
<a name="ln1285">                            &amp;allocInfo.lightsWithIESNum, </a>
<a name="ln1286">                            &amp;allocInfo.envLightTexSize);</a>
<a name="ln1287"> </a>
<a name="ln1288">    HR_DriverUpdateSettings(scn, a_pDriver);</a>
<a name="ln1289"> </a>
<a name="ln1290">    allocInfo = a_pDriver-&gt;AllocAll(allocInfo);</a>
<a name="ln1291"> </a>
<a name="ln1292">    if (allocInfo.geomMem &lt; neededMemG)</a>
<a name="ln1293">    {</a>
<a name="ln1294">      std::wstringstream errMsg;</a>
<a name="ln1295">      errMsg &lt;&lt; L&quot;RenderDriver can't alloc enough memory for geom, needed = &quot; &lt;&lt; neededMemG &lt;&lt; L&quot;, allocated = &quot; &lt;&lt; allocInfo.geomMem;</a>
<a name="ln1296">      std::wstring msg = errMsg.str();</a>
<a name="ln1297">      HrError(msg);</a>
<a name="ln1298">    }</a>
<a name="ln1299"> </a>
<a name="ln1300">    if (allocInfo.imgMem &lt; neededMemT)</a>
<a name="ln1301">    {</a>
<a name="ln1302">      std::wstringstream errMsg;</a>
<a name="ln1303">      errMsg &lt;&lt; L&quot;RenderDriver can't alloc enough memory for textures, needed = &quot; &lt;&lt; neededMemT &lt;&lt; L&quot;, allocated = &quot; &lt;&lt; allocInfo.imgMem;</a>
<a name="ln1304">      std::wstring msg = errMsg.str();</a>
<a name="ln1305">      HrError(msg);</a>
<a name="ln1306">    }</a>
<a name="ln1307"> </a>
<a name="ln1308">  }</a>
<a name="ln1309">  </a>
<a name="ln1310">  g_objManager.m_badMaterialId.clear();</a>
<a name="ln1311">  </a>
<a name="ln1312">  auto timeBeg = std::chrono::system_clock::now();</a>
<a name="ln1313">  </a>
<a name="ln1314">  if(g_objManager.m_attachMode &amp;&amp; g_objManager.m_pVBSysMutex != nullptr)</a>
<a name="ln1315">    hr_lock_system_mutex(g_objManager.m_pVBSysMutex, VB_LOCK_WAIT_TIME_MS);          // need to lock here because update may load data from virtual buffer</a>
<a name="ln1316">  </a>
<a name="ln1317">  HR_DriverUpdateCamera(scn, a_pDriver);</a>
<a name="ln1318">  HR_DriverUpdateSettings(scn, a_pDriver);</a>
<a name="ln1319"> </a>
<a name="ln1320">  if(g_objManager.m_attachMode &amp;&amp; !g_hydraApiDisableSceneLoadInfo)</a>
<a name="ln1321">    HrPrint(HR_SEVERITY_INFO, L&quot;HydraAPI, loading textures ... &quot;);</a>
<a name="ln1322">  </a>
<a name="ln1323">  int32_t updatedTextures  = HR_DriverUpdateTextures (scn, objList, a_pRender);</a>
<a name="ln1324">  int32_t updatedMaterials = HR_DriverUpdateMaterials(scn, objList, a_pRender);</a>
<a name="ln1325">  </a>
<a name="ln1326">  if(g_objManager.m_attachMode &amp;&amp; !g_hydraApiDisableSceneLoadInfo)</a>
<a name="ln1327">    HrPrint(HR_SEVERITY_INFO, L&quot;HydraAPI, loading meshes   ... &quot;);</a>
<a name="ln1328">  </a>
<a name="ln1329">  int32_t updatedMeshes    = HR_DriverUpdateMeshes   (scn, objList, a_pRender);</a>
<a name="ln1330">  int32_t updatedLights    = HR_DriverUpdateLight    (scn, objList, a_pRender);</a>
<a name="ln1331"> </a>
<a name="ln1332">  HR_CheckCommitErrors    (scn, objList);</a>
<a name="ln1333">  </a>
<a name="ln1334">  if(g_objManager.m_attachMode &amp;&amp; g_objManager.m_pVBSysMutex != nullptr)</a>
<a name="ln1335">    hr_unlock_system_mutex(g_objManager.m_pVBSysMutex);</a>
<a name="ln1336">  </a>
<a name="ln1337">  if(g_objManager.m_attachMode &amp;&amp; !g_hydraApiDisableSceneLoadInfo)</a>
<a name="ln1338">    HrPrint(HR_SEVERITY_INFO, L&quot;HydraAPI, begin scene &quot;);</a>
<a name="ln1339">  </a>
<a name="ln1340">  const auto dInfo = a_pDriver-&gt;DependencyInfo();</a>
<a name="ln1341"> </a>
<a name="ln1342">  const bool haveSomeThingNew      = scn.driverDirtyFlag || (updatedTextures &gt; 0) || (updatedMaterials &gt; 0) || (updatedLights &gt; 0) || (updatedMeshes &gt; 0);</a>
<a name="ln1343">  const bool driverMustUpdateScene = dInfo.needRedrawWhenCameraChanges || haveSomeThingNew;</a>
<a name="ln1344"> </a>
<a name="ln1345">  if (driverMustUpdateScene)</a>
<a name="ln1346">  {</a>
<a name="ln1347">    // draw/add instances to scene</a>
<a name="ln1348">    //</a>
<a name="ln1349">    a_pDriver-&gt;BeginScene(scn.xml_node());</a>
<a name="ln1350"> </a>
<a name="ln1351">    for (auto p1 = objList.drawSeq.begin(); p1 != objList.drawSeq.end(); p1++)</a>
<a name="ln1352">    {</a>
<a name="ln1353">      const auto&amp; seq = p1-&gt;second;</a>
<a name="ln1354">      a_pDriver-&gt;InstanceMeshes(p1-&gt;first, &amp;seq.matrices[0], int32_t(seq.matrices.size() / 16), &amp;seq.linstid[0], &amp;seq.remapid[0], &amp;seq.instIdReal[0]);</a>
<a name="ln1355">    }</a>
<a name="ln1356"> </a>
<a name="ln1357">    for (auto&amp; instance : scn.drawListLights) // #NOTE: this loop can be optimized</a>
<a name="ln1358">      a_pDriver-&gt;InstanceLights(instance.lightId, instance.m, &amp;instance.node, 1, instance.lightGroupInstId);</a>
<a name="ln1359"> </a>
<a name="ln1360">    a_pDriver-&gt;EndScene();</a>
<a name="ln1361">  }</a>
<a name="ln1362">  </a>
<a name="ln1363">  auto timeEnd  = std::chrono::system_clock::now();</a>
<a name="ln1364">  auto msPassed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timeEnd - timeBeg).count();</a>
<a name="ln1365">  </a>
<a name="ln1366">  if(g_objManager.m_attachMode &amp;&amp; !g_hydraApiDisableSceneLoadInfo)</a>
<a name="ln1367">    HrPrint(HR_SEVERITY_INFO, L&quot;HydraAPI, end scene; total load time = &quot;, float(msPassed)/1000.0f, &quot; s&quot;);</a>
<a name="ln1368">  </a>
<a name="ln1369">  // reset dirty flag; now we don't need to Update the scene to driver untill this flag changes or</a>
<a name="ln1370">  // some new objects will be added/updated</a>
<a name="ln1371">  //rj</a>
<a name="ln1372">  scn.driverDirtyFlag = false; </a>
<a name="ln1373">}</a>
<a name="ln1374"> </a>
<a name="ln1375">void HR_DriverDraw(HRSceneInst&amp; scn, HRRender* a_pRender)</a>
<a name="ln1376">{</a>
<a name="ln1377">  IHRRenderDriver* a_pDriver = a_pRender-&gt;m_pDriver.get();</a>
<a name="ln1378">  if(a_pDriver == nullptr)</a>
<a name="ln1379">    return;</a>
<a name="ln1380">  </a>
<a name="ln1381">  a_pDriver-&gt;Draw();</a>
<a name="ln1382">}</a>
<a name="ln1383"> </a>
<a name="ln1384"> </a>
<a name="ln1385">void _hr_UtilityDriverUpdate(HRSceneInst&amp; scn, HRRender* a_pRender)</a>
<a name="ln1386">{</a>
<a name="ln1387">  IHRRenderDriver* a_pDriver = a_pRender-&gt;m_pDriver.get();</a>
<a name="ln1388">  if(a_pDriver == nullptr)</a>
<a name="ln1389">    return;</a>
<a name="ln1390">  </a>
<a name="ln1391">  HRDriverAllocInfo allocInfo;</a>
<a name="ln1392"> </a>
<a name="ln1393">  const auto p1 = std::max_element(a_pRender-&gt;m_updated.meshUsed.begin(),     a_pRender-&gt;m_updated.meshUsed.end());</a>
<a name="ln1394">  const auto p2 = std::max_element(a_pRender-&gt;m_updated.texturesUsed.begin(), a_pRender-&gt;m_updated.texturesUsed.end());</a>
<a name="ln1395">  const auto p3 = std::max_element(a_pRender-&gt;m_updated.matUsed.begin(),      a_pRender-&gt;m_updated.matUsed.end());</a>
<a name="ln1396">  const auto p4 = std::max_element(a_pRender-&gt;m_updated.lightUsed.begin(),    a_pRender-&gt;m_updated.lightUsed.end());</a>
<a name="ln1397"> </a>
<a name="ln1398">  const size_t geomNum  = (p1 == a_pRender-&gt;m_updated.meshUsed.end())     ? 10 : *p1;</a>
<a name="ln1399">  const size_t imgNum   = (p2 == a_pRender-&gt;m_updated.texturesUsed.end()) ? 10 : *p2;</a>
<a name="ln1400">  const size_t matNum   = (p3 == a_pRender-&gt;m_updated.matUsed.end())      ? 10 : *p3;</a>
<a name="ln1401">  const size_t lightNum = (p4 == a_pRender-&gt;m_updated.lightUsed.end())    ? 10 : *p4;</a>
<a name="ln1402"> </a>
<a name="ln1403">  allocInfo.geomNum     = int32_t(geomNum  + geomNum/3  + 100);</a>
<a name="ln1404">  allocInfo.imgNum      = int32_t(imgNum   + imgNum/3   + 100);</a>
<a name="ln1405">  allocInfo.matNum      = int32_t(matNum   + matNum/3   + 100);</a>
<a name="ln1406">  allocInfo.lightNum    = int32_t(lightNum + lightNum/3 + 100);</a>
<a name="ln1407">  </a>
<a name="ln1408">  auto&amp; settings      = g_objManager.renderSettings[g_objManager.m_currRenderId];</a>
<a name="ln1409">  auto resources_path = settings.xml_node().child(L&quot;resources_path&quot;).text().as_string();</a>
<a name="ln1410">  </a>
<a name="ln1411">  allocInfo.resourcesPath = resources_path;</a>
<a name="ln1412">  allocInfo.libraryPath   = g_objManager.scnData.m_path.c_str();</a>
<a name="ln1413">  allocInfo.stateFileName = g_objManager.scnData.m_fileState.c_str();</a>
<a name="ln1414">  </a>
<a name="ln1415">  allocInfo = a_pDriver-&gt;AllocAll(allocInfo);</a>
<a name="ln1416"> </a>
<a name="ln1417">  HR_DriverUpdateCamera(scn, a_pDriver);</a>
<a name="ln1418">  HR_DriverUpdateSettings(scn, a_pDriver);</a>
<a name="ln1419"> </a>
<a name="ln1420">  int32_t updatedMaterials = _hr_UtilityDriverUpdateMaterials(scn, a_pRender);</a>
<a name="ln1421">  int32_t updatedMeshes    = _hr_UtilityDriverUpdateMeshes   (scn, a_pRender);</a>
<a name="ln1422"> </a>
<a name="ln1423"> </a>
<a name="ln1424">  const auto dInfo = a_pDriver-&gt;DependencyInfo();</a>
<a name="ln1425"> </a>
<a name="ln1426"> </a>
<a name="ln1427">  ///////////////////////////////</a>
<a name="ln1428"> </a>
<a name="ln1429">  std::unordered_map&lt;int32_t, ChangeList::InstancesInfo &gt; drawSeq;</a>
<a name="ln1430"> </a>
<a name="ln1431"> </a>
<a name="ln1432">  for (size_t i = 0; i &lt; scn.drawList.size(); i++)</a>
<a name="ln1433">  {</a>
<a name="ln1434">    auto instance = scn.drawList[i];</a>
<a name="ln1435">    if (instance.meshId &gt;= g_objManager.scnData.meshes.size())</a>
<a name="ln1436">      continue;</a>
<a name="ln1437"> </a>
<a name="ln1438">    // form draw sequence for each mesh</a>
<a name="ln1439">    //</a>
<a name="ln1440">    AddInstanceToDrawSequence(instance, drawSeq, int(i));</a>
<a name="ln1441">  }</a>
<a name="ln1442"> </a>
<a name="ln1443">  ////////////////////////</a>
<a name="ln1444">  a_pDriver-&gt;BeginScene(scn.xml_node());</a>
<a name="ln1445">  {</a>
<a name="ln1446">    // draw/add instances to scene</a>
<a name="ln1447">    for (auto p = drawSeq.begin(); p != drawSeq.end(); p++)</a>
<a name="ln1448">    {</a>
<a name="ln1449">      const auto&amp; seq = p-&gt;second;</a>
<a name="ln1450">      a_pDriver-&gt;InstanceMeshes(p-&gt;first, &amp;seq.matrices[0], int32_t(seq.matrices.size() / 16), &amp;seq.linstid[0], &amp;seq.remapid[0], &amp;seq.instIdReal[0]);</a>
<a name="ln1451">    }</a>
<a name="ln1452">  }</a>
<a name="ln1453">  a_pDriver-&gt;EndScene();</a>
<a name="ln1454"> </a>
<a name="ln1455">}</a>
<a name="ln1456"> </a>
<a name="ln1457">void CreatePrecompProcTex(pugi::xml_document &amp;doc, resolution_dict &amp;dict)</a>
<a name="ln1458">{</a>
<a name="ln1459">  if (g_objManager.scnData.textures.empty())</a>
<a name="ln1460">    return;</a>
<a name="ln1461"> </a>
<a name="ln1462">  auto scn = g_objManager.scnInst[g_objManager.m_currSceneId];</a>
<a name="ln1463"> </a>
<a name="ln1464">  for (auto texIdRes : dict)</a>
<a name="ln1465">  {</a>
<a name="ln1466">    auto texRefId = texIdRes.first;</a>
<a name="ln1467">    auto w = texIdRes.second.first;</a>
<a name="ln1468">    auto h = texIdRes.second.second;</a>
<a name="ln1469"> </a>
<a name="ln1470">    HRTextureNode &amp;texture = g_objManager.scnData.textures[texIdRes.first];</a>
<a name="ln1471"> </a>
<a name="ln1472">    int bpp = 4;</a>
<a name="ln1473">    bool isProc = false;</a>
<a name="ln1474">    if (texture.hdrCallback != nullptr)</a>
<a name="ln1475">    {</a>
<a name="ln1476">      bpp = sizeof(float) * 4;</a>
<a name="ln1477">      auto *imageData = new float[w * h * bpp / sizeof(float)];</a>
<a name="ln1478"> </a>
<a name="ln1479">      texture.hdrCallback(imageData, w, h, texture.customData);</a>
<a name="ln1480"> </a>
<a name="ln1481">      auto pTextureImpl = g_objManager.m_pFactory-&gt;CreateTexture2DFromMemory(&amp;texture, w, h, bpp, imageData);</a>
<a name="ln1482">      texture.pImpl = pTextureImpl;</a>
<a name="ln1483"> </a>
<a name="ln1484">      delete[] imageData;</a>
<a name="ln1485"> </a>
<a name="ln1486">      isProc = true;</a>
<a name="ln1487">    }</a>
<a name="ln1488">    else if (texture.ldrCallback != nullptr)</a>
<a name="ln1489">    {</a>
<a name="ln1490">      auto *imageData = new unsigned char[w * h * bpp];</a>
<a name="ln1491"> </a>
<a name="ln1492">      texture.ldrCallback(imageData, w, h, texture.customData);</a>
<a name="ln1493"> </a>
<a name="ln1494">      auto pTextureImpl = g_objManager.m_pFactory-&gt;CreateTexture2DFromMemory(&amp;texture, w, h, bpp, imageData);</a>
<a name="ln1495">      texture.pImpl = pTextureImpl;</a>
<a name="ln1496"> </a>
<a name="ln1497">      delete[] imageData;</a>
<a name="ln1498"> </a>
<a name="ln1499">      isProc = true;</a>
<a name="ln1500">    }</a>
<a name="ln1501"> </a>
<a name="ln1502">    if (isProc)</a>
<a name="ln1503">    {</a>
<a name="ln1504">      auto texIdStr = ToWString(texRefId);</a>
<a name="ln1505">      auto texNode = doc.child(L&quot;textures_lib&quot;).find_child_by_attribute(L&quot;texture&quot;, L&quot;id&quot;, texIdStr.c_str());</a>
<a name="ln1506">      auto byteSize = size_t(w) * size_t(h) * size_t(bpp);</a>
<a name="ln1507"> </a>
<a name="ln1508">      ChunkPointer chunk = g_objManager.scnData.m_vbCache.chunk_at(texture.pImpl-&gt;chunkId());</a>
<a name="ln1509">      std::wstring location = ChunkName(chunk);</a>
<a name="ln1510"> </a>
<a name="ln1511">      std::wstring bytesize = ToWString(byteSize);</a>
<a name="ln1512">      g_objManager.SetLoc(texNode, location);</a>
<a name="ln1513">      texNode.force_attribute(L&quot;offset&quot;).set_value(L&quot;8&quot;);</a>
<a name="ln1514">      texNode.force_attribute(L&quot;bytesize&quot;).set_value(bytesize.c_str());</a>
<a name="ln1515">      texNode.force_attribute(L&quot;width&quot;) = w;</a>
<a name="ln1516">      texNode.force_attribute(L&quot;height&quot;) = h;</a>
<a name="ln1517">    }</a>
<a name="ln1518">  }</a>
<a name="ln1519">}</a>
<a name="ln1520"> </a>
<a name="ln1521"> </a>
<a name="ln1522">static std::tuple&lt;int, int&gt; RecommendedTexResolutionFix(int w, int h, int rwidth, int rheight)</a>
<a name="ln1523">{</a>
<a name="ln1524"> </a>
<a name="ln1525">  if(w == -1 || h == -1)</a>
<a name="ln1526">    return std::tuple&lt;int, int&gt;(rwidth, rheight);</a>
<a name="ln1527">  else if(rwidth &gt;= w || rheight &gt;= h)</a>
<a name="ln1528">    return std::tuple&lt;int, int&gt;(w, h);</a>
<a name="ln1529"> </a>
<a name="ln1530">  if (rwidth &lt; 256 || rheight &lt; 256)</a>
<a name="ln1531">  {</a>
<a name="ln1532">    const double relation = double(w) / double(h);</a>
<a name="ln1533"> </a>
<a name="ln1534">    if (rwidth &gt;= rheight)</a>
<a name="ln1535">    {</a>
<a name="ln1536">      rheight = 256;</a>
<a name="ln1537">      rwidth = int(double(rheight)*relation);</a>
<a name="ln1538">    }</a>
<a name="ln1539">    else</a>
<a name="ln1540">    {</a>
<a name="ln1541">      rwidth = 256;</a>
<a name="ln1542">      rheight = int(relation / double(rwidth));</a>
<a name="ln1543">    }</a>
<a name="ln1544"> </a>
<a name="ln1545">  }</a>
<a name="ln1546">  else if (w % rwidth != 0 || h % rheight != 0)</a>
<a name="ln1547">  {</a>
<a name="ln1548">    int w2 = w, h2 = h;</a>
<a name="ln1549"> </a>
<a name="ln1550">    while ((w2 &gt;&gt; 1) &gt;= rwidth || (h2 &gt;&gt; 1) &gt;= rheight)</a>
<a name="ln1551">    {</a>
<a name="ln1552">      w2 = w2 &gt;&gt; 1;</a>
<a name="ln1553">      h2 = h2 &gt;&gt; 1;</a>
<a name="ln1554">    }</a>
<a name="ln1555"> </a>
<a name="ln1556">    rwidth = w2;</a>
<a name="ln1557">    rheight = h2;</a>
<a name="ln1558">  }</a>
<a name="ln1559"> </a>
<a name="ln1560">  return std::tuple&lt;int, int&gt;(rwidth, rheight);</a>
<a name="ln1561">}</a>
<a name="ln1562"> </a>
<a name="ln1563"> </a>
<a name="ln1564">resolution_dict InsertMipLevelInfoIntoXML(pugi::xml_document &amp;stateToProcess, const std::unordered_map&lt;uint32_t, uint32_t&gt; &amp;dict, int a_winWidth, int a_winHeight)</a>
<a name="ln1565">{</a>
<a name="ln1566">  resolution_dict resDict;</a>
<a name="ln1567">  for (std::pair&lt;int32_t, int32_t&gt; elem : dict)</a>
<a name="ln1568">  {</a>
<a name="ln1569">    std::wstringstream tmp;</a>
<a name="ln1570">    tmp &lt;&lt; elem.first;</a>
<a name="ln1571">    auto texIdStr = tmp.str();</a>
<a name="ln1572">    auto texNode = stateToProcess.child(L&quot;textures_lib&quot;).find_child_by_attribute(L&quot;texture&quot;, L&quot;id&quot;, texIdStr.c_str());</a>
<a name="ln1573"> </a>
<a name="ln1574">    if(texNode != nullptr)</a>
<a name="ln1575">    {</a>
<a name="ln1576">      int currW = texNode.attribute(L&quot;width&quot;).as_int();</a>
<a name="ln1577">      int currH = texNode.attribute(L&quot;height&quot;).as_int();</a>
<a name="ln1578"> </a>
<a name="ln1579">      auto settingsNode = stateToProcess.child(L&quot;render_lib&quot;).child(L&quot;render_settings&quot;);</a>
<a name="ln1580"> </a>
<a name="ln1581">      int32_t newW = MAX_TEXTURE_RESOLUTION;</a>
<a name="ln1582">      int32_t newH = MAX_TEXTURE_RESOLUTION;</a>
<a name="ln1583"> </a>
<a name="ln1584">     /* if(settingsNode != nullptr)</a>
<a name="ln1585">      {</a>
<a name="ln1586">        newW = std::min(settingsNode.child(L&quot;width&quot;).text().as_int(), newW);</a>
<a name="ln1587">        newH = std::min(settingsNode.child(L&quot;height&quot;).text().as_int(), newH);</a>
<a name="ln1588">      }*/</a>
<a name="ln1589"> </a>
<a name="ln1590">      for(int i = 0; i &lt; elem.second; ++i)</a>
<a name="ln1591">      {</a>
<a name="ln1592">        newW /= 2;</a>
<a name="ln1593">        newH /= 2;</a>
<a name="ln1594">      }</a>
<a name="ln1595"> </a>
<a name="ln1596">      std::tie(newW, newH) = RecommendedTexResolutionFix(currW, currH, newW, newH);</a>
<a name="ln1597"> </a>
<a name="ln1598">      texNode.force_attribute(L&quot;rwidth&quot;).set_value(newW);</a>
<a name="ln1599">      texNode.force_attribute(L&quot;rheight&quot;).set_value(newH);</a>
<a name="ln1600"> </a>
<a name="ln1601">      resDict[elem.first] = std::pair&lt;uint32_t, uint32_t&gt;(newW, newH);</a>
<a name="ln1602">    }</a>
<a name="ln1603">  }</a>
<a name="ln1604"> </a>
<a name="ln1605">  // next, for all textures that we don't see at all insert renderer screen resolution as recommended</a>
<a name="ln1606">  //</a>
<a name="ln1607">  auto texLib = stateToProcess.child(L&quot;textures_lib&quot;);</a>
<a name="ln1608"> </a>
<a name="ln1609">  for (auto texNode : texLib.children())</a>
<a name="ln1610">  {</a>
<a name="ln1611">    const int32_t id = texNode.attribute(L&quot;id&quot;).as_int();</a>
<a name="ln1612">    const auto p     = resDict.find(id);</a>
<a name="ln1613"> </a>
<a name="ln1614">    if (id &gt; 0 &amp;&amp; p == resDict.end())</a>
<a name="ln1615">    {</a>
<a name="ln1616">      int32_t newW = a_winWidth;</a>
<a name="ln1617">      int32_t newH = a_winHeight;</a>
<a name="ln1618"> </a>
<a name="ln1619">      std::tie(newW, newH) = RecommendedTexResolutionFix(texNode.attribute(L&quot;width&quot;).as_int(), texNode.attribute(L&quot;height&quot;).as_int(), newW, newH);</a>
<a name="ln1620"> </a>
<a name="ln1621">      texNode.force_attribute(L&quot;rwidth&quot;)  = newW;</a>
<a name="ln1622">      texNode.force_attribute(L&quot;rheight&quot;) = newH;</a>
<a name="ln1623">    }</a>
<a name="ln1624">  }</a>
<a name="ln1625"> </a>
<a name="ln1626">  return resDict;</a>
<a name="ln1627">}</a>
<a name="ln1628"> </a>
<a name="ln1629"> </a>
<a name="ln1630">std::wstring SaveFixedStateXML(pugi::xml_document &amp;doc, const std::wstring &amp;oldPath, const std::wstring &amp;suffix)</a>
<a name="ln1631">{</a>
<a name="ln1632">  std::wstringstream ss;</a>
<a name="ln1633">  ss &lt;&lt; std::wstring(oldPath.begin(), oldPath.end() - 4) &lt;&lt; suffix &lt;&lt; L&quot;.xml&quot;; //cut &quot;.xml&quot; from initial path and append new suffix</a>
<a name="ln1634">  std::wstring new_state_path = ss.str();</a>
<a name="ln1635">  doc.save_file(new_state_path.c_str(), L&quot;  &quot;);</a>
<a name="ln1636">  return new_state_path;</a>
<a name="ln1637">}</a>
<a name="ln1638"> </a>
<a name="ln1639"> </a>
<a name="ln1640">#ifdef WIN32</a>
<a name="ln1641">void HydraDestroyHiddenWindow();</a>
<a name="ln1642">bool HydraCreateHiddenWindow(int width, int height, int a_major, int a_minor, int a_flags);</a>
<a name="ln1643">#endif</a>
<a name="ln1644"> </a>
<a name="ln1645">std::wstring HR_UtilityDriverStart(const wchar_t* state_path, HRRender* a_pOriginalRender)</a>
<a name="ln1646">{</a>
<a name="ln1647">  std::wstring new_state_path(L&quot;&quot;);</a>
<a name="ln1648"> </a>
<a name="ln1649">  if (state_path == std::wstring(L&quot;&quot;) || state_path == nullptr)</a>
<a name="ln1650">  {</a>
<a name="ln1651">    HrError(L&quot;No state for Utility driver at location: &quot;, state_path);</a>
<a name="ln1652">    return new_state_path;</a>
<a name="ln1653">  }</a>
<a name="ln1654"> </a>
<a name="ln1655">  pugi::xml_document stateToProcess;</a>
<a name="ln1656"> </a>
<a name="ln1657">  auto loadResult = stateToProcess.load_file(state_path);</a>
<a name="ln1658"> </a>
<a name="ln1659">  if (!loadResult)</a>
<a name="ln1660">  {</a>
<a name="ln1661">    HrError(L&quot;HR_UtilityDriverStart, pugixml load: &quot;, loadResult.description());</a>
<a name="ln1662">    return new_state_path;</a>
<a name="ln1663">  }</a>
<a name="ln1664"> </a>
<a name="ln1665">  stateToProcess.child(L&quot;textures_lib&quot;).force_attribute(L&quot;resize_textures&quot;) = 1;</a>
<a name="ln1666"> </a>
<a name="ln1667">#ifdef WIN32</a>
<a name="ln1668">  bool windowCreated = HydraCreateHiddenWindow(1024, 1024, 3, 3, 0);</a>
<a name="ln1669">  if (!windowCreated)</a>
<a name="ln1670">  {</a>
<a name="ln1671">    HrError(L&quot;HydraCreateHiddenWindow FAILED!&quot;);</a>
<a name="ln1672">    return new_state_path;</a>
<a name="ln1673">  }</a>
<a name="ln1674"> </a>
<a name="ln1675">  gladLoadGLLoader((GLADloadproc)GetProcAddress);</a>
<a name="ln1676">  if (!gladLoadGL())</a>
<a name="ln1677">  {</a>
<a name="ln1678">    HrError(L&quot;gladLoadGL FAILED!&quot;);</a>
<a name="ln1679">    return new_state_path;</a>
<a name="ln1680">  }</a>
<a name="ln1681">#else</a>
<a name="ln1682">  auto offscreen_context = InitGLForUtilityDriver();               //#TODO: refactor this</a>
<a name="ln1683">#endif</a>
<a name="ln1684"> </a>
<a name="ln1685">  HRRender tempRender;</a>
<a name="ln1686">  tempRender.m_pDriver = std::shared_ptr&lt;IHRRenderDriver&gt;(RenderDriverFactory::Create(L&quot;opengl3Utility&quot;));</a>
<a name="ln1687"> </a>
<a name="ln1688">  if (tempRender.m_pDriver != nullptr &amp;&amp; g_objManager.m_currSceneId &lt; g_objManager.scnInst.size())</a>
<a name="ln1689">  {</a>
<a name="ln1690">    tempRender.m_pDriver-&gt;SetInfoCallBack(g_pInfoCallback);</a>
<a name="ln1691">    tempRender.m_updated = a_pOriginalRender-&gt;m_updated; // pass same objects to the utility render</a>
<a name="ln1692"> </a>
<a name="ln1693">    _hr_UtilityDriverUpdate(g_objManager.scnInst[g_objManager.m_currSceneId], &amp;tempRender);</a>
<a name="ln1694"> </a>
<a name="ln1695">    auto mipLevelsDict = getMipLevelsFromUtilityDriver(tempRender.m_pDriver.get());</a>
<a name="ln1696">//</a>
<a name="ln1697">//#ifdef IN_DEBUG</a>
<a name="ln1698">//    auto pImgTool = g_objManager.m_pImgTool;</a>
<a name="ln1699">//    auto&amp; imgData = g_objManager.m_tempBuffer;</a>
<a name="ln1700">//    if (imgData.size() &lt; 1024*1024)</a>
<a name="ln1701">//      imgData.resize(1024*1024);</a>
<a name="ln1702">//</a>
<a name="ln1703">//    utilityDriver-&gt;GetFrameBufferLDR(1024, 1024, imgData.data());</a>
<a name="ln1704">//    pImgTool-&gt;SaveLDRImageToFileLDR(L&quot;tests_images/z_out.png&quot;, 1024, 1024, imgData.data());</a>
<a name="ln1705">//</a>
<a name="ln1706">//    if (imgData.size() &gt; TEMP_BUFFER_MAX_SIZE_DONT_FREE) // free temp buffer if it's too large</a>
<a name="ln1707">//      imgData = g_objManager.EmptyBuffer();</a>
<a name="ln1708">//#endif</a>
<a name="ln1709"> </a>
<a name="ln1710">    for (auto elem : mipLevelsDict)</a>
<a name="ln1711">      std::cout &lt;&lt; &quot; &quot; &lt;&lt; elem.first &lt;&lt; &quot;:&quot; &lt;&lt; elem.second &lt;&lt; std::endl;</a>
<a name="ln1712"> </a>
<a name="ln1713">#ifdef WIN32</a>
<a name="ln1714">    HydraDestroyHiddenWindow();</a>
<a name="ln1715">#else</a>
<a name="ln1716">    glfwSetWindowShouldClose(offscreen_context, GL_TRUE);         //#TODO: refactor this</a>
<a name="ln1717">#endif</a>
<a name="ln1718"> </a>
<a name="ln1719">    int winWidthRender  = 1024;</a>
<a name="ln1720">    int winHeightRender = 1024;</a>
<a name="ln1721"> </a>
<a name="ln1722">    auto renderSettings = stateToProcess.child(L&quot;render_lib&quot;).child(L&quot;render_settings&quot;);</a>
<a name="ln1723">    if (renderSettings != nullptr)</a>
<a name="ln1724">    {</a>
<a name="ln1725">      winWidthRender  = renderSettings.child(L&quot;width&quot;).text().as_int();</a>
<a name="ln1726">      winHeightRender = renderSettings.child(L&quot;height&quot;).text().as_int();</a>
<a name="ln1727">    }</a>
<a name="ln1728"> </a>
<a name="ln1729">    auto resDict = InsertMipLevelInfoIntoXML(stateToProcess, mipLevelsDict, winWidthRender, winHeightRender);</a>
<a name="ln1730">    CreatePrecompProcTex(stateToProcess, resDict);</a>
<a name="ln1731">  }</a>
<a name="ln1732">  return SaveFixedStateXML(stateToProcess, state_path, L&quot;_fixed&quot;);</a>
<a name="ln1733">}</a>

</code></pre>
<div class="balloon" rel="1372"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1020/" target="_blank">V1020</a> The function exited without calling the 'hr_unlock_system_mutex' function. Check lines: 1372, 1315.</p></div>
<div class="balloon" rel="752"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1002/" target="_blank">V1002</a> The 'HydraGeomData' class, containing pointers, constructor and destructor, is copied by the automatically generated operator=.</p></div>
<div class="balloon" rel="241"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
