
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>HydraLaunchProcessWin32.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//</a>
<a name="ln2">// Created by vsan on 21.01.18.</a>
<a name="ln3">//</a>
<a name="ln4"> </a>
<a name="ln5">#include &quot;HydraLegacyUtils.h&quot;</a>
<a name="ln6">#include &quot;HydraObjectManager.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8"> </a>
<a name="ln9">bool g_materialProcessStart = false;</a>
<a name="ln10">PROCESS_INFORMATION g_materialProcessInfo;</a>
<a name="ln11"> </a>
<a name="ln12">struct PluginShmemPipe : public IHydraNetPluginAPI</a>
<a name="ln13">{</a>
<a name="ln14">  PluginShmemPipe(const char* imageFileName, const char* messageFileName, const char* guiFile, int width, int height, const char* connectionType = &quot;main&quot;,</a>
<a name="ln15">                  std::ostream* m_pLog = nullptr);</a>
<a name="ln16"> </a>
<a name="ln17">  virtual ~PluginShmemPipe();</a>
<a name="ln18">  bool hasConnection() const;</a>
<a name="ln19"> </a>
<a name="ln20">  void runAllRenderProcesses(RenderProcessRunParams a_params, const std::vector&lt;HydraRenderDevice&gt;&amp; a_devList, const std::vector&lt;int&gt;&amp; activeDevices, bool a_appendMode = false);</a>
<a name="ln21">  void stopAllRenderProcesses();</a>
<a name="ln22"> </a>
<a name="ln23">  HANDLE getMtlRenderHProcess() const { return g_materialProcessInfo.hProcess; }</a>
<a name="ln24"> </a>
<a name="ln25">protected:</a>
<a name="ln26"> </a>
<a name="ln27">  void CreateConnectionMainType(const char* imageFileName, const char* messageFileName, const char* guiFile, int width, int height);</a>
<a name="ln28"> </a>
<a name="ln29">  STARTUPINFOA m_hydraStartupInfo;</a>
<a name="ln30">  PROCESS_INFORMATION m_hydraProcessInfo;</a>
<a name="ln31">  BOOL m_hydraServerStarted;</a>
<a name="ln32">  bool m_staticConnection;</a>
<a name="ln33"> </a>
<a name="ln34">  std::vector&lt;PROCESS_INFORMATION&gt; m_mdProcessList;</a>
<a name="ln35"> </a>
<a name="ln36">  unsigned int m_lastImageType;</a>
<a name="ln37"> </a>
<a name="ln38">  enum { MESSAGE_BUFF_SIZE = 1024 };</a>
<a name="ln39"> </a>
<a name="ln40"> </a>
<a name="ln41">  // params that we have to remember after connection created</a>
<a name="ln42">  //</a>
<a name="ln43">  std::string m_connectionType;</a>
<a name="ln44">  std::string m_imageFileName;</a>
<a name="ln45"> </a>
<a name="ln46">  int m_width;</a>
<a name="ln47">  int m_height;</a>
<a name="ln48"> </a>
<a name="ln49">  std::ostream* m_pLog;</a>
<a name="ln50">};</a>
<a name="ln51"> </a>
<a name="ln52">static IHydraNetPluginAPI* g_pMaterialRenderConnect = nullptr;</a>
<a name="ln53">static std::ofstream g_logMain;</a>
<a name="ln54"> </a>
<a name="ln55">IHydraNetPluginAPI* CreateHydraServerConnection(int renderWidth, int renderHeight, bool inMatEditor)</a>
<a name="ln56">{</a>
<a name="ln57">  static int m_matRenderTimes = 0;</a>
<a name="ln58"> </a>
<a name="ln59">  IHydraNetPluginAPI* pImpl = nullptr;</a>
<a name="ln60">  DWORD ticks = GetTickCount();</a>
<a name="ln61"> </a>
<a name="ln62">  std::stringstream ss;</a>
<a name="ln63">  ss &lt;&lt; ticks;</a>
<a name="ln64"> </a>
<a name="ln65">  std::string imageName   = std::string(&quot;HydraHDRImage_&quot;) + ss.str();</a>
<a name="ln66">  std::string messageName = std::string(&quot;HydraMessageShmem_&quot;) + ss.str();</a>
<a name="ln67">  std::string guiName     = std::string(&quot;HydraGuiShmem_&quot;) + ss.str();</a>
<a name="ln68"> </a>
<a name="ln69">  std::ostream* logPtr = nullptr;</a>
<a name="ln70"> </a>
<a name="ln71">  if (!inMatEditor)</a>
<a name="ln72">  {</a>
<a name="ln73">    if (!g_logMain.is_open())</a>
<a name="ln74">      g_logMain.open(&quot;C:/[Hydra]/logs/plugin_log.txt&quot;);</a>
<a name="ln75">    logPtr = &amp;g_logMain;</a>
<a name="ln76">    pImpl  = new PluginShmemPipe(imageName.c_str(), messageName.c_str(), guiName.c_str(), renderWidth, renderHeight, &quot;main&quot;, logPtr);</a>
<a name="ln77">  }</a>
<a name="ln78">  else // if in matEditor</a>
<a name="ln79">  {</a>
<a name="ln80">  </a>
<a name="ln81"> </a>
<a name="ln82">    m_matRenderTimes++;</a>
<a name="ln83">  }</a>
<a name="ln84"> </a>
<a name="ln85">  if (pImpl-&gt;hasConnection())</a>
<a name="ln86">    return pImpl;</a>
<a name="ln87">  else</a>
<a name="ln88">  {</a>
<a name="ln89">    delete pImpl;</a>
<a name="ln90">    return nullptr;</a>
<a name="ln91">  }</a>
<a name="ln92"> </a>
<a name="ln93">}</a>
<a name="ln94"> </a>
<a name="ln95"> </a>
<a name="ln96">PluginShmemPipe::PluginShmemPipe(const char* imageFileName, const char* messageFileName, const char* guiFileName, int width, int height, const char* connectionType, std::ostream* a_pLog) : m_hydraServerStarted(false), m_staticConnection(false), m_pLog(a_pLog)</a>
<a name="ln97">{</a>
<a name="ln98">  m_mdProcessList.clear();</a>
<a name="ln99">  m_connectionType = connectionType;</a>
<a name="ln100">  CreateConnectionMainType(imageFileName, messageFileName, guiFileName, width, height);</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">void PluginShmemPipe::CreateConnectionMainType(const char* imageFileName, const char* messageFileName, const char* guiFileName, int width, int height)</a>
<a name="ln104">{</a>
<a name="ln105">  m_staticConnection = false;</a>
<a name="ln106"> </a>
<a name="ln107">  // remember params</a>
<a name="ln108">  //</a>
<a name="ln109">  m_imageFileName = imageFileName;</a>
<a name="ln110"> </a>
<a name="ln111">  m_width  = width;</a>
<a name="ln112">  m_height = height;</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115"> </a>
<a name="ln116"> </a>
<a name="ln117">void PluginShmemPipe::runAllRenderProcesses(RenderProcessRunParams a_params, const std::vector&lt;HydraRenderDevice&gt;&amp; a_devList, const std::vector&lt;int&gt;&amp; activeDevices, bool a_appendMode)</a>
<a name="ln118">{</a>
<a name="ln119">  std::ostream* outp = m_pLog;</a>
<a name="ln120"> </a>
<a name="ln121">  // restore params</a>
<a name="ln122">  //</a>
<a name="ln123">  bool a_showCmd           = a_params.showConsole;</a>
<a name="ln124">  bool a_normalPriorityCPU = a_params.normalPriorityCPU;</a>
<a name="ln125">  bool a_debug             = a_params.debug;</a>
<a name="ln126"> </a>
<a name="ln127">  const char* imageFileName = m_imageFileName.c_str();</a>
<a name="ln128"> </a>
<a name="ln129">  int width  = m_width;</a>
<a name="ln130">  int height = m_height;</a>
<a name="ln131"> </a>
<a name="ln132">  m_mdProcessList.resize(activeDevices.size());</a>
<a name="ln133"> </a>
<a name="ln134">  if (m_connectionType == &quot;main&quot;)</a>
<a name="ln135">  {</a>
<a name="ln136">    ZeroMemory(&amp;m_hydraStartupInfo, sizeof(STARTUPINFOA));</a>
<a name="ln137">    ZeroMemory(&amp;m_hydraProcessInfo, sizeof(PROCESS_INFORMATION));</a>
<a name="ln138"> </a>
<a name="ln139">    m_hydraStartupInfo.cb = sizeof(STARTUPINFO);</a>
<a name="ln140">    m_hydraStartupInfo.dwFlags     = STARTF_USESHOWWINDOW; // CREATE_NEW_CONSOLE // DETACHED_PROCESS</a>
<a name="ln141">    m_hydraStartupInfo.wShowWindow = SW_SHOWMINNOACTIVE;</a>
<a name="ln142"> </a>
<a name="ln143">    std::string hydraPath = &quot;C:/[Hydra]/bin2/hydra.exe&quot;;</a>
<a name="ln144">    if (a_params.customExePath != &quot;&quot;)</a>
<a name="ln145">      hydraPath = a_params.customExePath + &quot;/hydra.exe&quot;;</a>
<a name="ln146"> </a>
<a name="ln147">    if (!isFileExist(hydraPath.c_str()))</a>
<a name="ln148">    {</a>
<a name="ln149">      m_hydraServerStarted = false;</a>
<a name="ln150">      HrPrint(HR_SEVERITY_ERROR, L&quot;hydra.exe was not found! (perhaps you have forgotten to install HydraCore to : &quot;, hydraPath.c_str());</a>
<a name="ln151">    }</a>
<a name="ln152">    else</a>
<a name="ln153">    {</a>
<a name="ln154">      std::stringstream ss;</a>
<a name="ln155">      ss &lt;&lt; &quot;-nowindow 1 &quot;;</a>
<a name="ln156">      ss &lt;&lt; a_params.customExeArgs.c_str();</a>
<a name="ln157">      if(a_params.customLogFold != &quot;&quot;)</a>
<a name="ln158">        ss &lt;&lt; &quot; -logdir \&quot;&quot; &lt;&lt; a_params.customLogFold.c_str() &lt;&lt; &quot;\&quot; &quot;;</a>
<a name="ln159"> </a>
<a name="ln160">      //if (pImageA != nullptr)</a>
<a name="ln161">      //pImageA-&gt;SendMsg(&quot;-node_t A -sid 0 -layer wait -action wait&quot;);</a>
<a name="ln162"> </a>
<a name="ln163">      int deviceId  = activeDevices.size() == 0 ? -1 : activeDevices[0];</a>
<a name="ln164"> </a>
<a name="ln165">      std::string basicCmd = ss.str();</a>
<a name="ln166"> </a>
<a name="ln167">      m_hydraServerStarted = true;</a>
<a name="ln168">      std::ofstream fout;</a>
<a name="ln169">      if (a_params.customExePath != &quot;&quot;)</a>
<a name="ln170">      {</a>
<a name="ln171">        fout.close();</a>
<a name="ln172">        fout.open(a_params.customExePath + &quot;/zcmd.txt&quot;);</a>
<a name="ln173">      }</a>
<a name="ln174">      else</a>
<a name="ln175">        fout.open(&quot;C:/[Hydra]/zcmd.txt&quot;);</a>
<a name="ln176"> </a>
<a name="ln177">      for (size_t i = 0; i &lt; activeDevices.size(); i++)</a>
<a name="ln178">      {</a>
<a name="ln179">        DWORD dwCreationFlags = a_showCmd ? 0 : CREATE_NO_WINDOW;</a>
<a name="ln180"> </a>
<a name="ln181">        int devId = activeDevices[i];</a>
<a name="ln182">        if (isTargetDevIdACPU(devId, a_devList))</a>
<a name="ln183">        {</a>
<a name="ln184">          if (isTargetDevIdAHydraCPU(devId, a_devList))</a>
<a name="ln185">          {</a>
<a name="ln186">            devId *= -1;</a>
<a name="ln187">            if (activeDevices.size() != 1 &amp;&amp; !a_normalPriorityCPU)</a>
<a name="ln188">              dwCreationFlags |= BELOW_NORMAL_PRIORITY_CLASS; // is CPU is the only one device, use normal priority, else use background mode</a>
<a name="ln189">          }</a>
<a name="ln190">        }</a>
<a name="ln191"> </a>
<a name="ln192">        if(a_showCmd)</a>
<a name="ln193">          dwCreationFlags |= CREATE_NEW_CONSOLE;</a>
<a name="ln194"> </a>
<a name="ln195">        std::stringstream ss3;</a>
<a name="ln196">        ss3 &lt;&lt; &quot; -cl_device_id &quot; &lt;&lt; devId &lt;&lt; &quot; &quot;;</a>
<a name="ln197">        if (a_params.customExePath != &quot;&quot;)</a>
<a name="ln198">          ss3 &lt;&lt; &quot;-hydradir &quot; &lt;&lt; a_params.customExePath.c_str() &lt;&lt; &quot; &quot;;</a>
<a name="ln199">        const std::string cmdFull = basicCmd + ss3.str();</a>
<a name="ln200"> </a>
<a name="ln201">        ZeroMemory(&amp;m_mdProcessList[i], sizeof(PROCESS_INFORMATION));</a>
<a name="ln202">        if (!a_debug)</a>
<a name="ln203">        {</a>
<a name="ln204">          m_hydraServerStarted = m_hydraServerStarted &amp;&amp; CreateProcessA(hydraPath.c_str(), (LPSTR)cmdFull.c_str(), NULL, NULL, FALSE, dwCreationFlags, NULL, NULL, &amp;m_hydraStartupInfo, &amp;m_mdProcessList[i]);</a>
<a name="ln205">          if (!m_hydraServerStarted &amp;&amp; outp != nullptr)</a>
<a name="ln206">          {</a>
<a name="ln207">            (*outp) &lt;&lt; &quot;[syscall failed]: runAllRenderProcesses-&gt;(m_connectionType == 'main')-&gt;CreateProcessA &quot; &lt;&lt; std::endl;</a>
<a name="ln208">            HrPrint(HR_SEVERITY_ERROR, L&quot;CreateProcessA have failed (perhaps you have forgottent to install C:/[Hydra]/bin2/hydra.exe)? : &quot;, hydraPath.c_str());</a>
<a name="ln209">          }</a>
<a name="ln210">          else if (!m_hydraServerStarted)</a>
<a name="ln211">            HrPrint(HR_SEVERITY_ERROR, L&quot;CreateProcessA have failed (perhaps you have forgottent to install C:/[Hydra]/bin2/hydra.exe)? : &quot;, hydraPath.c_str());</a>
<a name="ln212">        }</a>
<a name="ln213"> </a>
<a name="ln214">        fout &lt;&lt; cmdFull.c_str() &lt;&lt; std::endl;</a>
<a name="ln215">      }</a>
<a name="ln216"> </a>
<a name="ln217">      fout.close();</a>
<a name="ln218"> </a>
<a name="ln219">    }</a>
<a name="ln220">  }</a>
<a name="ln221"> </a>
<a name="ln222">}</a>
<a name="ln223"> </a>
<a name="ln224"> </a>
<a name="ln225">void PluginShmemPipe::stopAllRenderProcesses()</a>
<a name="ln226">{</a>
<a name="ln227">  if (!m_hydraServerStarted)</a>
<a name="ln228">    return;</a>
<a name="ln229">  </a>
<a name="ln230">  for (auto i = 0; i &lt; m_mdProcessList.size(); i++)</a>
<a name="ln231">  {</a>
<a name="ln232">    if (m_mdProcessList[i].hProcess == 0 || m_mdProcessList[i].hProcess == INVALID_HANDLE_VALUE)</a>
<a name="ln233">      continue;</a>
<a name="ln234">  </a>
<a name="ln235">    DWORD exitCode;</a>
<a name="ln236">    GetExitCodeProcess(m_mdProcessList[i].hProcess, &amp;exitCode);</a>
<a name="ln237">  </a>
<a name="ln238">    if (exitCode == STILL_ACTIVE)</a>
<a name="ln239">      Sleep(100);</a>
<a name="ln240">  </a>
<a name="ln241">    GetExitCodeProcess(m_mdProcessList[i].hProcess, &amp;exitCode);</a>
<a name="ln242">  </a>
<a name="ln243">    if (exitCode == STILL_ACTIVE)</a>
<a name="ln244">      TerminateProcess(m_mdProcessList[i].hProcess, NO_ERROR);</a>
<a name="ln245">  }</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248">PluginShmemPipe::~PluginShmemPipe()</a>
<a name="ln249">{</a>
<a name="ln250">  stopAllRenderProcesses();</a>
<a name="ln251">}</a>
<a name="ln252"> </a>
<a name="ln253">bool PluginShmemPipe::hasConnection() const</a>
<a name="ln254">{</a>
<a name="ln255">  if (m_mdProcessList.size() == 0)</a>
<a name="ln256">    return true;</a>
<a name="ln257"> </a>
<a name="ln258">  bool allProcessesAreBroken = true;</a>
<a name="ln259"> </a>
<a name="ln260">  for (auto i = 0; i &lt; m_mdProcessList.size(); i++)</a>
<a name="ln261">  {</a>
<a name="ln262">    if (m_mdProcessList[i].hProcess == 0 || m_mdProcessList[i].hProcess == INVALID_HANDLE_VALUE)</a>
<a name="ln263">      continue;</a>
<a name="ln264">    </a>
<a name="ln265">	DWORD exitCode;</a>
<a name="ln266">    GetExitCodeProcess(m_mdProcessList[i].hProcess, &amp;exitCode);</a>
<a name="ln267"> </a>
<a name="ln268">	if (exitCode == STILL_ACTIVE)</a>
<a name="ln269">	{</a>
<a name="ln270">      allProcessesAreBroken = false;</a>
<a name="ln271">	  break;</a>
<a name="ln272">	}</a>
<a name="ln273">  }</a>
<a name="ln274"> </a>
<a name="ln275">  return !allProcessesAreBroken;</a>
<a name="ln276">}</a>

</code></pre>
<div class="balloon" rel="96"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> It is possible that not all members of a class are initialized inside the constructor. Consider inspecting: m_hydraStartupInfo, m_hydraProcessInfo, m_lastImageType.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
