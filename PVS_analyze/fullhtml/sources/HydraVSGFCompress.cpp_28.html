
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>HydraVSGFCompress.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//</a>
<a name="ln2">// Created by frol on 05.04.19.</a>
<a name="ln3">//</a>
<a name="ln4"> </a>
<a name="ln5">#include &quot;HydraVSGFCompress.h&quot;</a>
<a name="ln6">#include &lt;fstream&gt;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;HydraRenderDriverAPI.h&quot;</a>
<a name="ln9">std::vector&lt;HRBatchInfo&gt; FormMatDrawListRLE(const std::vector&lt;uint32_t&gt;&amp; matIndices);</a>
<a name="ln10"> </a>
<a name="ln11">#include &quot;../utils/corto/corto.h&quot;</a>
<a name="ln12">#include &quot;LiteMath.h&quot;</a>
<a name="ln13"> </a>
<a name="ln14">#ifdef WIN32</a>
<a name="ln15">#undef min</a>
<a name="ln16">#undef max</a>
<a name="ln17">#endif</a>
<a name="ln18"> </a>
<a name="ln19">size_t WriteCompressed(const HydraGeomData&amp; a_data, std::ostream&amp; a_out, const std::vector&lt;HRBatchInfo&gt;&amp; a_batchesList)</a>
<a name="ln20">{</a>
<a name="ln21">  // convert positions to float3 due to corto does not understand float4 input for positions by default</a>
<a name="ln22">  //</a>
<a name="ln23"> </a>
<a name="ln24">  const float* positions4 = a_data.getVertexPositionsFloat4Array();</a>
<a name="ln25">  const float* normals4   = a_data.getVertexNormalsFloat4Array();</a>
<a name="ln26"> </a>
<a name="ln27">  std::vector&lt;float&gt; positions3(a_data.getVerticesNumber()*3);</a>
<a name="ln28">  std::vector&lt;float&gt; normals3  (a_data.getVerticesNumber()*3);</a>
<a name="ln29"> </a>
<a name="ln30">  for(int i=0;i&lt;a_data.getVerticesNumber();i++)</a>
<a name="ln31">  {</a>
<a name="ln32">    positions3[i*3+0] = positions4[i*4+0];</a>
<a name="ln33">    positions3[i*3+1] = positions4[i*4+1];</a>
<a name="ln34">    positions3[i*3+2] = positions4[i*4+2];</a>
<a name="ln35"> </a>
<a name="ln36">    normals3[i*3+0]   = normals4[i*4+0];</a>
<a name="ln37">    normals3[i*3+1]   = normals4[i*4+1];</a>
<a name="ln38">    normals3[i*3+2]   = normals4[i*4+2];</a>
<a name="ln39">  }</a>
<a name="ln40"> </a>
<a name="ln41">  const int uv_bits   = 12;</a>
<a name="ln42">  const int norm_bits = 10;</a>
<a name="ln43">  //auto* normalAttrs      = new crt::NormalAttr(norm_bits);</a>
<a name="ln44"> </a>
<a name="ln45">  crt::Encoder encoder(a_data.getVerticesNumber(), a_data.getIndicesNumber()/3);</a>
<a name="ln46">  {</a>
<a name="ln47">    encoder.addPositions(positions3.data(), a_data.getTriangleVertexIndicesArray()); // vertex_quantization_step</a>
<a name="ln48">    encoder.addUvs(a_data.getVertexTexcoordFloat2Array(), pow(2, -uv_bits));</a>
<a name="ln49">    encoder.addNormals(normals3.data(), norm_bits, crt::NormalAttr::ESTIMATED);</a>
<a name="ln50"> </a>
<a name="ln51">    for(auto&amp; batch : a_batchesList) // preserve groups to save material indices per triangle</a>
<a name="ln52">      encoder.addGroup(batch.triEnd);</a>
<a name="ln53">  }</a>
<a name="ln54">  encoder.encode();</a>
<a name="ln55"> </a>
<a name="ln56">  //delete normalAttrs; normalAttrs = nullptr;</a>
<a name="ln57"> </a>
<a name="ln58">  a_out.write((char*)encoder.stream.data(), encoder.stream.size());</a>
<a name="ln59"> </a>
<a name="ln60">  return encoder.stream.size();</a>
<a name="ln61">}</a>
<a name="ln62"> </a>
<a name="ln63">using HydraLiteMath::float4;</a>
<a name="ln64">using HydraLiteMath::float2;</a>
<a name="ln65"> </a>
<a name="ln66">void HR_ComputeTangentSpaceSimple(const int     vertexCount, const int     triangleCount, const uint32_t* triIndices,</a>
<a name="ln67">                                  const float4* verticesPos, const float4* verticesNorm, const float2* vertTexCoord,</a>
<a name="ln68">                                  float4* verticesTang);</a>
<a name="ln69"> </a>
<a name="ln70">void ReadCompressed(HydraGeomData&amp; a_data, std::istream&amp; a_input, size_t a_compressedSize)</a>
<a name="ln71">{</a>
<a name="ln72">  std::vector&lt;char&gt; dataTemp(a_compressedSize);</a>
<a name="ln73">  a_input.read(dataTemp.data(), a_compressedSize);</a>
<a name="ln74"> </a>
<a name="ln75">  std::vector&lt;float&gt; positions3(a_data.getVerticesNumber()*3);</a>
<a name="ln76">  std::vector&lt;float&gt; normals3  (a_data.getVerticesNumber()*3);</a>
<a name="ln77"> </a>
<a name="ln78">  crt::Decoder decoder(a_compressedSize, (const unsigned char*)dataTemp.data());</a>
<a name="ln79">  {</a>
<a name="ln80">    decoder.setPositions(positions3.data());</a>
<a name="ln81">    decoder.setIndex((uint32_t*)a_data.getTriangleVertexIndicesArray());</a>
<a name="ln82">    decoder.setUvs(const_cast&lt;float*&gt;(a_data.getVertexTexcoordFloat2Array()));</a>
<a name="ln83">    decoder.setNormals(normals3.data());</a>
<a name="ln84">  }</a>
<a name="ln85">  decoder.decode();</a>
<a name="ln86"> </a>
<a name="ln87">    for(int i = 0; i &lt; a_data.getIndicesNumber(); i += 3)</a>
<a name="ln88">    {</a>
<a name="ln89">      auto idx1 = a_data.getTriangleVertexIndicesArray()[i + 0];</a>
<a name="ln90">      auto idx2 = a_data.getTriangleVertexIndicesArray()[i + 1];</a>
<a name="ln91">      auto idx3 = a_data.getTriangleVertexIndicesArray()[i + 2];</a>
<a name="ln92">      if(idx1 &lt; 0 || idx1 &gt;= a_data.getVerticesNumber() ||</a>
<a name="ln93">         idx2 &lt; 0 || idx2 &gt;= a_data.getVerticesNumber() ||</a>
<a name="ln94">         idx3 &lt; 0 || idx3 &gt;= a_data.getVerticesNumber())</a>
<a name="ln95">      {</a>
<a name="ln96">        auto arr = (uint32_t*) a_data.getTriangleVertexIndicesArray();</a>
<a name="ln97">        arr[i + 0] = 0;</a>
<a name="ln98">        arr[i + 1] = 0;</a>
<a name="ln99">        arr[i + 2] = 0;</a>
<a name="ln100">      }</a>
<a name="ln101">    }</a>
<a name="ln102"> </a>
<a name="ln103">  float* positions = const_cast&lt;float*&gt;(a_data.getVertexPositionsFloat4Array());</a>
<a name="ln104">  float* normals   = const_cast&lt;float*&gt;(a_data.getVertexNormalsFloat4Array());</a>
<a name="ln105">  float* tangents  = const_cast&lt;float*&gt;(a_data.getVertexTangentsFloat4Array());</a>
<a name="ln106"> </a>
<a name="ln107">  for(int i=0;i&lt;a_data.getVerticesNumber();i++)</a>
<a name="ln108">  {</a>
<a name="ln109">    positions[i*4+0] = positions3[i*3+0];</a>
<a name="ln110">    positions[i*4+1] = positions3[i*3+1];</a>
<a name="ln111">    positions[i*4+2] = positions3[i*3+2];</a>
<a name="ln112">    positions[i*4+3] = 1.0f;</a>
<a name="ln113"> </a>
<a name="ln114">    normals[i*4+0]   = normals3[i*3+0];</a>
<a name="ln115">    normals[i*4+1]   = normals3[i*3+1];</a>
<a name="ln116">    normals[i*4+2]   = normals3[i*3+2];</a>
<a name="ln117">    normals[i*4+3]   = 0.0f;</a>
<a name="ln118">  }</a>
<a name="ln119"> </a>
<a name="ln120">  HR_ComputeTangentSpaceSimple(a_data.getVerticesNumber(), a_data.getIndicesNumber()/3, a_data.getTriangleVertexIndicesArray(),</a>
<a name="ln121">                               (float4*)positions, (float4*)normals, (float2*)a_data.getVertexTexcoordFloat2Array(),</a>
<a name="ln122">                               (float4*)tangents);</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125"> </a>
<a name="ln126">#include &quot;HydraObjectManager.h&quot;   // #TODO: remove this</a>
<a name="ln127">#include &quot;vfloat4_x64.h&quot;</a>
<a name="ln128"> </a>
<a name="ln129">BBox CalcBoundingBox4f(const float* in_array, const uint32_t a_vertexNumber)</a>
<a name="ln130">{</a>
<a name="ln131">  BBox res;</a>
<a name="ln132"> </a>
<a name="ln133">  cvex::vfloat4 boxMax = {res.x_max, res.x_max, res.x_max, 0};</a>
<a name="ln134">  cvex::vfloat4 boxMin = {res.x_min, res.x_min, res.x_min, 0};</a>
<a name="ln135"> </a>
<a name="ln136">  for(uint32_t i=0; i &lt; a_vertexNumber; i++) // #TODO: can opt via loop vectorisation</a>
<a name="ln137">  {</a>
<a name="ln138">    const cvex::vfloat4 vpos = cvex::load_u(in_array + i*4);</a>
<a name="ln139">    boxMin = cvex::min(boxMin, vpos);</a>
<a name="ln140">    boxMax = cvex::max(boxMax, vpos);</a>
<a name="ln141">  }</a>
<a name="ln142"> </a>
<a name="ln143">  float boxMin2[4], boxMax2[4];</a>
<a name="ln144">  {</a>
<a name="ln145">    cvex::store_u(boxMin2, boxMin);</a>
<a name="ln146">    cvex::store_u(boxMax2, boxMax);</a>
<a name="ln147">  }</a>
<a name="ln148"> </a>
<a name="ln149">  res.x_min = boxMin2[0];</a>
<a name="ln150">  res.y_min = boxMin2[1];</a>
<a name="ln151">  res.z_min = boxMin2[2];</a>
<a name="ln152"> </a>
<a name="ln153">  res.x_max = boxMax2[0];</a>
<a name="ln154">  res.y_max = boxMax2[1];</a>
<a name="ln155">  res.z_max = boxMax2[2];</a>
<a name="ln156"> </a>
<a name="ln157">  return res;</a>
<a name="ln158">}</a>
<a name="ln159"> </a>
<a name="ln160">size_t HR_SaveVSGFCompressed(const HydraGeomData&amp; data, const wchar_t* a_outfileName, const char* a_customData, const int a_customDataSize, bool a_placeToOrigin)</a>
<a name="ln161">{</a>
<a name="ln162">  // (1) open file</a>
<a name="ln163">  //</a>
<a name="ln164">  std::ofstream fout;</a>
<a name="ln165">  hr_ofstream_open(fout, a_outfileName);</a>
<a name="ln166"> </a>
<a name="ln167">  // (2) put vsgf header</a>
<a name="ln168">  //</a>
<a name="ln169">  const auto h1 = data.getHeader();</a>
<a name="ln170">  fout.write((char*)&amp;h1, sizeof(HydraGeomData::Header));</a>
<a name="ln171"> </a>
<a name="ln172">  // (3) put header2 (bbox, compressed file size in bytes that we have to overwrite later, and other)</a>
<a name="ln173">  //</a>
<a name="ln174">  const uint32_t* pInd    = (const uint32_t*)data.getTriangleMaterialIndicesArray();</a>
<a name="ln175">  const auto      indSize = data.getIndicesNumber()/3;</a>
<a name="ln176"> </a>
<a name="ln177">  const auto&amp; matDrawList = FormMatDrawListRLE(std::vector&lt;uint32_t&gt;(pInd, pInd+indSize));</a>
<a name="ln178">  auto bbox               = CalcBoundingBox4f(data.getVertexPositionsFloat4Array(), data.getVerticesNumber());</a>
<a name="ln179"> </a>
<a name="ln180">  if (a_placeToOrigin)</a>
<a name="ln181">  {</a>
<a name="ln182">    const float centerX = 0.5f*(bbox.x_min + bbox.x_max);</a>
<a name="ln183">    const float centerY = 0.5f*(bbox.y_min + bbox.y_max);</a>
<a name="ln184">    const float centerZ = 0.5f*(bbox.z_min + bbox.z_max);</a>
<a name="ln185"> </a>
<a name="ln186">    bbox.x_min -= centerX;</a>
<a name="ln187">    bbox.y_min -= centerY;</a>
<a name="ln188">    bbox.z_min -= centerZ;</a>
<a name="ln189"> </a>
<a name="ln190">    bbox.x_max -= centerX;</a>
<a name="ln191">    bbox.y_max -= centerY;</a>
<a name="ln192">    bbox.z_max -= centerZ;</a>
<a name="ln193"> </a>
<a name="ln194">    const int vNum = data.getVerticesNumber();</a>
<a name="ln195">    float4* vertices = (float4*)data.getVertexPositionsFloat4Array();</a>
<a name="ln196"> </a>
<a name="ln197">    for (int i = 0; i &lt; vNum; i++)</a>
<a name="ln198">    {</a>
<a name="ln199">      vertices[i].x -= centerX;</a>
<a name="ln200">      vertices[i].y -= centerY;</a>
<a name="ln201">      vertices[i].z -= centerZ;</a>
<a name="ln202">    }</a>
<a name="ln203">  }</a>
<a name="ln204"> </a>
<a name="ln205">  //std::cout &lt;&lt; &quot;bbox.x_min\t&quot; &lt;&lt; bbox.x_min &lt;&lt; std::endl;</a>
<a name="ln206">  //std::cout &lt;&lt; &quot;bbox.x_max\t&quot; &lt;&lt; bbox.x_max &lt;&lt; std::endl;</a>
<a name="ln207">  </a>
<a name="ln208">  //const std::string xmlNodeData = &quot;&quot;;</a>
<a name="ln209"> </a>
<a name="ln210">  HydraHeaderC h2;</a>
<a name="ln211"> </a>
<a name="ln212">  h2.compressedSizeInBytes = 0;</a>
<a name="ln213">  h2.batchListArraySize    = matDrawList.size();</a>
<a name="ln214">  h2.boxMin[0]             = bbox.x_min;</a>
<a name="ln215">  h2.boxMin[1]             = bbox.y_min;</a>
<a name="ln216">  h2.boxMin[2]             = bbox.z_min;</a>
<a name="ln217">  h2.boxMax[0]             = bbox.x_max;</a>
<a name="ln218">  h2.boxMax[1]             = bbox.y_max;</a>
<a name="ln219">  h2.boxMax[2]             = bbox.z_max;</a>
<a name="ln220">  h2.customDataOffset      = 0;</a>
<a name="ln221">  h2.customDataSize        = 0;</a>
<a name="ln222"> </a>
<a name="ln223">  fout.write((char*)&amp;h2, sizeof(HydraHeaderC));</a>
<a name="ln224"> </a>
<a name="ln225">  // (4) put material batch list</a>
<a name="ln226">  //</a>
<a name="ln227">  fout.write((char*)matDrawList.data(), matDrawList.size()*sizeof(HRBatchInfo));</a>
<a name="ln228"> </a>
<a name="ln229">  // (5) #TODO: put xml data of mesh in file ...</a>
<a name="ln230">  //</a>
<a name="ln231"> </a>
<a name="ln232">  // (6) compress mesh via corto lib</a>
<a name="ln233">  //</a>
<a name="ln234">  auto compressedBytes = WriteCompressed(data, fout, matDrawList);</a>
<a name="ln235"> </a>
<a name="ln236">  if(a_customDataSize != 0)</a>
<a name="ln237">    fout.write(a_customData, a_customDataSize);</a>
<a name="ln238"> </a>
<a name="ln239">  size_t totalFileSize = sizeof(HydraGeomData::Header)  +</a>
<a name="ln240">                         sizeof(HydraHeaderC) +</a>
<a name="ln241">                         matDrawList.size()*sizeof(HRBatchInfo) + compressedBytes;</a>
<a name="ln242"> </a>
<a name="ln243">  h2.customDataOffset      = uint64_t(totalFileSize);</a>
<a name="ln244">  h2.customDataSize        = a_customDataSize;</a>
<a name="ln245"> </a>
<a name="ln246">  totalFileSize += a_customDataSize;</a>
<a name="ln247"> </a>
<a name="ln248">  // write true file size to 'h2.compressedSizeInBytes' in file</a>
<a name="ln249">  //</a>
<a name="ln250">  h2.compressedSizeInBytes = compressedBytes;</a>
<a name="ln251">  fout.seekp(sizeof(HydraGeomData::Header), ios_base::beg);</a>
<a name="ln252">  fout.write((char*)&amp;h2, sizeof(HydraHeaderC));</a>
<a name="ln253"> </a>
<a name="ln254">  return totalFileSize;</a>
<a name="ln255">}</a>
<a name="ln256"> </a>
<a name="ln257">size_t HR_SaveVSGFCompressed(const void* vsgfData, size_t a_vsgfSize, const wchar_t* a_outfileName, const char* a_customData, const int a_dataSize, bool a_placeToOrigin)</a>
<a name="ln258">{</a>
<a name="ln259">  HydraGeomData::Header* pHeader = (HydraGeomData::Header*)vsgfData;</a>
<a name="ln260"> </a>
<a name="ln261">  const VSGFOffsets offsets = CalcOffsets(pHeader-&gt;verticesNum, pHeader-&gt;indicesNum);</a>
<a name="ln262"> </a>
<a name="ln263">  char* p = (char*)vsgfData;</a>
<a name="ln264"> </a>
<a name="ln265">  HydraGeomData data;</a>
<a name="ln266"> </a>
<a name="ln267">  data.setData(uint32_t(pHeader-&gt;verticesNum), (float*)   (p + offsets.offsetPos),    (float*)(p + offsets.offsetNorm),</a>
<a name="ln268">               (float*)   (p + offsets.offsetTang),   (float*)(p + offsets.offsetTexc),</a>
<a name="ln269">               uint32_t(pHeader-&gt;indicesNum),  (uint32_t*)(p + offsets.offsetInd), (uint32_t*)(p + offsets.offsetMind));</a>
<a name="ln270"> </a>
<a name="ln271">  return HR_SaveVSGFCompressed(data, a_outfileName, a_customData, a_dataSize, a_placeToOrigin);</a>
<a name="ln272">}</a>
<a name="ln273"> </a>
<a name="ln274"> </a>
<a name="ln275">void HR_LoadVSGFCompressedBothHeaders(std::ifstream&amp; fin,</a>
<a name="ln276">                                      std::vector&lt;HRBatchInfo&gt;&amp; a_outBatchList, HydraGeomData::Header&amp; h1, HydraHeaderC&amp; h2)</a>
<a name="ln277">{</a>
<a name="ln278">  fin.read((char*)&amp;h1, sizeof(HydraGeomData::Header));</a>
<a name="ln279">  fin.read((char*)&amp;h2, sizeof(HydraHeaderC));</a>
<a name="ln280"> </a>
<a name="ln281">  a_outBatchList.resize(h2.batchListArraySize);</a>
<a name="ln282"> </a>
<a name="ln283">  fin.read((char*)a_outBatchList.data(), sizeof(HRBatchInfo)*a_outBatchList.size());</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286"> </a>
<a name="ln287">HydraGeomData HR_LoadVSGFCompressedData(const wchar_t* a_fileName, std::vector&lt;int&gt;&amp; dataBuffer, std::vector&lt;HRBatchInfo&gt;* pOutbatchList)</a>
<a name="ln288">{</a>
<a name="ln289">  std::ifstream fin;</a>
<a name="ln290">  hr_ifstream_open(fin, a_fileName);</a>
<a name="ln291"> </a>
<a name="ln292">  std::vector&lt;HRBatchInfo&gt; batchList;</a>
<a name="ln293">  HydraGeomData::Header    h1;</a>
<a name="ln294">  HydraHeaderC             h2;</a>
<a name="ln295"> </a>
<a name="ln296">  HR_LoadVSGFCompressedBothHeaders(fin,</a>
<a name="ln297">                                   batchList, h1, h2);</a>
<a name="ln298"> </a>
<a name="ln299">  </a>
<a name="ln300">  const size_t bufferSize = CalcVSGFSize(h1.verticesNum, h1.indicesNum);</a>
<a name="ln301">  dataBuffer.resize(bufferSize/sizeof(int) + 1);</a>
<a name="ln302">  char* p = (char*)dataBuffer.data();</a>
<a name="ln303"> </a>
<a name="ln304">  memcpy(p, &amp;h1, sizeof(HydraGeomData::Header));</a>
<a name="ln305"> </a>
<a name="ln306">  const VSGFOffsets offsets = CalcOffsets(h1.verticesNum, h1.indicesNum);</a>
<a name="ln307">  </a>
<a name="ln308">  int* pMaterialsId = (int*)(p + offsets.offsetMind);</a>
<a name="ln309">  </a>
<a name="ln310">  HydraGeomData data;</a>
<a name="ln311">  data.setData(uint32_t(h1.verticesNum), (float*)(p + offsets.offsetPos),  (float*)(p + offsets.offsetNorm),</a>
<a name="ln312">                                         (float*)(p + offsets.offsetTang), (float*)(p + offsets.offsetTexc),</a>
<a name="ln313">               uint32_t(h1.indicesNum),  (uint32_t*)(p + offsets.offsetInd), (uint32_t*)(pMaterialsId));</a>
<a name="ln314"> </a>
<a name="ln315">  ReadCompressed(data, fin, h2.compressedSizeInBytes);</a>
<a name="ln316">  </a>
<a name="ln317"> </a>
<a name="ln318">  for(int batchId = 0; batchId &lt; batchList.size(); batchId++)</a>
<a name="ln319">  {</a>
<a name="ln320">    const auto&amp; batch = batchList[batchId];</a>
<a name="ln321">    for(int i=batch.triBegin; i &lt; batch.triEnd; i++)</a>
<a name="ln322">      pMaterialsId[i] = batch.matId;</a>
<a name="ln323">  }</a>
<a name="ln324"> </a>
<a name="ln325">  if(pOutbatchList != nullptr)</a>
<a name="ln326">    (*pOutbatchList) = batchList;</a>
<a name="ln327"> </a>
<a name="ln328">  return data;</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331">void _hrCompressMesh(const std::wstring&amp; a_inPath, const std::wstring&amp; a_outPath)</a>
<a name="ln332">{</a>
<a name="ln333">  HydraGeomData data;</a>
<a name="ln334">  data.read(a_inPath.c_str());</a>
<a name="ln335">  HR_SaveVSGFCompressed(data, a_outPath.c_str(), &quot;&quot;, 0);</a>
<a name="ln336">}</a>
<a name="ln337"> </a>
<a name="ln338">void _hrDecompressMesh(const std::wstring&amp; a_path, const std::wstring&amp; a_newPath)</a>
<a name="ln339">{</a>
<a name="ln340">  std::vector&lt;int&gt; dataBuffer;</a>
<a name="ln341">  HydraGeomData data = HR_LoadVSGFCompressedData(a_path.c_str(), dataBuffer);</a>
<a name="ln342">  std::ofstream fout;</a>
<a name="ln343">  hr_ofstream_open(fout, a_newPath.c_str());</a>
<a name="ln344">  data.write(fout);</a>
<a name="ln345">}</a>

</code></pre>
<div class="balloon" rel="341"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1002/" target="_blank">V1002</a> The 'HydraGeomData' class, containing pointers, constructor and destructor, is copied by the automatically generated copy constructor.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
