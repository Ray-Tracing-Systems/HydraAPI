
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>HydraVSGFExport.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#include &quot;HydraVSGFExport.h&quot;</a>
<a name="ln2"> </a>
<a name="ln3">#include &lt;fstream&gt;</a>
<a name="ln4">#include &lt;sstream&gt;</a>
<a name="ln5">#include &lt;cassert&gt;</a>
<a name="ln6"> </a>
<a name="ln7">HydraGeomData::HydraGeomData()</a>
<a name="ln8">{</a>
<a name="ln9">  m_ownMemory = false;</a>
<a name="ln10"> </a>
<a name="ln11">  m_data      = nullptr;</a>
<a name="ln12">  m_positions = nullptr;</a>
<a name="ln13">  m_normals   = nullptr;</a>
<a name="ln14">  m_tangents  = nullptr;</a>
<a name="ln15">  m_texcoords = nullptr;</a>
<a name="ln16"> </a>
<a name="ln17">  m_triVertIndices     = nullptr;</a>
<a name="ln18">  m_triMaterialIndices = nullptr;</a>
<a name="ln19"> </a>
<a name="ln20">  m_header.fileSizeInBytes  = 0;</a>
<a name="ln21">  m_header.verticesNum      = 0;</a>
<a name="ln22">  m_header.indicesNum       = 0;</a>
<a name="ln23">  m_header.materialsNum     = 0;</a>
<a name="ln24">  m_header.flags            = 0;</a>
<a name="ln25">}</a>
<a name="ln26"> </a>
<a name="ln27">HydraGeomData::~HydraGeomData()</a>
<a name="ln28">{</a>
<a name="ln29">  freeMemIfNeeded();</a>
<a name="ln30">}</a>
<a name="ln31"> </a>
<a name="ln32">void HydraGeomData::freeMemIfNeeded()</a>
<a name="ln33">{</a>
<a name="ln34">  if(m_ownMemory)</a>
<a name="ln35">    delete [] m_data;</a>
<a name="ln36">  m_data = nullptr;</a>
<a name="ln37">}</a>
<a name="ln38"> </a>
<a name="ln39">uint32_t     HydraGeomData::getVerticesNumber()             const { return m_header.verticesNum; }</a>
<a name="ln40">const float* HydraGeomData::getVertexPositionsFloat4Array() const { return (const float*)m_positions; }</a>
<a name="ln41">const float* HydraGeomData::getVertexNormalsFloat4Array()   const { return (const float*)m_normals;   }</a>
<a name="ln42">const float* HydraGeomData::getVertexTangentsFloat4Array()  const { return (const float*)m_tangents;  }</a>
<a name="ln43">const float* HydraGeomData::getVertexTexcoordFloat2Array()  const { return (const float*)m_texcoords; }</a>
<a name="ln44"> </a>
<a name="ln45">uint32_t HydraGeomData::getIndicesNumber()                        const { return m_header.indicesNum; }</a>
<a name="ln46">const uint32_t* HydraGeomData::getTriangleVertexIndicesArray()    const { return m_triVertIndices; }</a>
<a name="ln47">const uint32_t* HydraGeomData::getTriangleMaterialIndicesArray()  const { return m_triMaterialIndices; }</a>
<a name="ln48"> </a>
<a name="ln49"> </a>
<a name="ln50">void HydraGeomData::setData(uint32_t a_vertNum, const float* a_pos, const float* a_norm, const float* a_tangent, const float* a_texCoord,</a>
<a name="ln51">                            uint32_t a_indicesNum, const uint32_t* a_triVertIndices, const uint32_t* a_triMatIndices)</a>
<a name="ln52">{</a>
<a name="ln53">  m_header.verticesNum     = a_vertNum;</a>
<a name="ln54">  m_header.indicesNum      = a_indicesNum;</a>
<a name="ln55">  m_header.fileSizeInBytes = sizeInBytes();</a>
<a name="ln56">  m_header.flags           = (a_tangent != nullptr) ? HAS_TANGENT : 0;</a>
<a name="ln57"> </a>
<a name="ln58">  m_positions = a_pos;</a>
<a name="ln59">  m_normals   = a_norm;</a>
<a name="ln60">  m_tangents  = a_tangent;</a>
<a name="ln61"> </a>
<a name="ln62">  m_texcoords = a_texCoord;</a>
<a name="ln63"> </a>
<a name="ln64">  m_triVertIndices     = a_triVertIndices;</a>
<a name="ln65">  m_triMaterialIndices = a_triMatIndices;</a>
<a name="ln66">}</a>
<a name="ln67"> </a>
<a name="ln68">size_t HydraGeomData::sizeInBytes()</a>
<a name="ln69">{</a>
<a name="ln70">  const size_t szInBytes = size_t(sizeof(float))*(m_header.verticesNum*4*3  + m_header.verticesNum*2) +</a>
<a name="ln71">                           size_t(sizeof(int))*(m_header.indicesNum + m_header.indicesNum/3);</a>
<a name="ln72"> </a>
<a name="ln73">  return szInBytes + size_t(sizeof(Header));</a>
<a name="ln74">}</a>
<a name="ln75"> </a>
<a name="ln76">void HydraGeomData::write(std::ostream&amp; a_out)</a>
<a name="ln77">{</a>
<a name="ln78">  if(m_tangents != nullptr)</a>
<a name="ln79">    m_header.flags |= HAS_TANGENT;</a>
<a name="ln80"> </a>
<a name="ln81">  if(m_normals == nullptr)</a>
<a name="ln82">    m_header.flags |= HAS_NO_NORMALS;</a>
<a name="ln83">  </a>
<a name="ln84">  m_header.fileSizeInBytes = m_header.verticesNum*( sizeof(float)*4 + sizeof(float)*2 );</a>
<a name="ln85">  if(!(m_header.flags &amp; HAS_NO_NORMALS))</a>
<a name="ln86">    m_header.fileSizeInBytes += m_header.verticesNum*sizeof(float)*4;</a>
<a name="ln87">  if(m_header.flags &amp; HAS_TANGENT)</a>
<a name="ln88">    m_header.fileSizeInBytes += m_header.verticesNum*sizeof(float)*4;</a>
<a name="ln89">  </a>
<a name="ln90">  m_header.fileSizeInBytes += (m_header.indicesNum / 3) * 4 * sizeof(uint32_t); // 3*num_triangles + num_triangles = 4*num_triangles</a>
<a name="ln91">  m_header.materialsNum = 0;</a>
<a name="ln92"> </a>
<a name="ln93">  // write data</a>
<a name="ln94">  //</a>
<a name="ln95">  a_out.write((const char*)&amp;m_header.fileSizeInBytes, sizeof(uint64_t));</a>
<a name="ln96">  a_out.write((const char*)&amp;m_header.verticesNum,     sizeof(uint32_t));</a>
<a name="ln97">  a_out.write((const char*)&amp;m_header.indicesNum,      sizeof(uint32_t));</a>
<a name="ln98">  a_out.write((const char*)&amp;m_header.materialsNum,    sizeof(uint32_t));</a>
<a name="ln99">  a_out.write((const char*)&amp;m_header.flags,           sizeof(uint32_t));</a>
<a name="ln100"> </a>
<a name="ln101">  a_out.write((const char*)m_positions, sizeof(float)*4*m_header.verticesNum);</a>
<a name="ln102"> </a>
<a name="ln103">  if(!(m_header.flags &amp; HAS_NO_NORMALS))</a>
<a name="ln104">    a_out.write((const char*)m_normals, sizeof(float)*4*m_header.verticesNum);</a>
<a name="ln105"> </a>
<a name="ln106">  if(m_header.flags &amp; HAS_TANGENT)</a>
<a name="ln107">    a_out.write((const char*)m_tangents, sizeof(float)*4*m_header.verticesNum);</a>
<a name="ln108"> </a>
<a name="ln109">  a_out.write((const char*)m_texcoords,  sizeof(float)*2*m_header.verticesNum);</a>
<a name="ln110"> </a>
<a name="ln111">  a_out.write((const char*)m_triVertIndices,     sizeof(uint32_t)*m_header.indicesNum);</a>
<a name="ln112">  a_out.write((const char*)m_triMaterialIndices, sizeof(uint32_t)*(m_header.indicesNum / 3));</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">void HydraGeomData::writeToMemory(char* a_dataToWrite)</a>
<a name="ln116">{</a>
<a name="ln117">  if (m_normals == nullptr)</a>
<a name="ln118">    m_header.flags |= HAS_NO_NORMALS;</a>
<a name="ln119"> </a>
<a name="ln120">  if (m_tangents != nullptr)</a>
<a name="ln121">    m_header.flags |= HAS_TANGENT;</a>
<a name="ln122">  </a>
<a name="ln123">  m_header.fileSizeInBytes = m_header.verticesNum*(sizeof(float) * 4 + sizeof(float) * 2);</a>
<a name="ln124"> </a>
<a name="ln125">  if (!(m_header.flags &amp; HAS_NO_NORMALS))</a>
<a name="ln126">    m_header.fileSizeInBytes += m_header.verticesNum*sizeof(float) * 4;</a>
<a name="ln127"> </a>
<a name="ln128">  if (m_header.flags &amp; HAS_TANGENT)</a>
<a name="ln129">    m_header.fileSizeInBytes += m_header.verticesNum*sizeof(float) * 4;</a>
<a name="ln130">  </a>
<a name="ln131">  m_header.fileSizeInBytes += (m_header.indicesNum / 3) * 4 * sizeof(uint32_t); // 3*num_triangles + num_triangles = 4*num_triangles</a>
<a name="ln132">  m_header.fileSizeInBytes += sizeof(Header);</a>
<a name="ln133">  m_header.materialsNum = 0;</a>
<a name="ln134"> </a>
<a name="ln135">  // write data</a>
<a name="ln136">  //</a>
<a name="ln137">  char* ptr     = a_dataToWrite;</a>
<a name="ln138">  Header header = m_header;</a>
<a name="ln139"> </a>
<a name="ln140">  memcpy(ptr, &amp;header,     sizeof(Header));                       ptr += sizeof(Header);</a>
<a name="ln141">  memcpy(ptr, m_positions, sizeof(float)*4*m_header.verticesNum); ptr += sizeof(float) * 4 * m_header.verticesNum;</a>
<a name="ln142"> </a>
<a name="ln143">  if(!(m_header.flags &amp; HAS_NO_NORMALS))</a>
<a name="ln144">  {</a>
<a name="ln145">    memcpy(ptr, m_normals, sizeof(float) * 4 * m_header.verticesNum);</a>
<a name="ln146">    ptr += sizeof(float) * 4 * m_header.verticesNum;</a>
<a name="ln147">  }</a>
<a name="ln148"> </a>
<a name="ln149">  if (m_header.flags &amp; HAS_TANGENT)</a>
<a name="ln150">  {</a>
<a name="ln151">    memcpy(ptr, m_tangents, sizeof(float) * 4 * m_header.verticesNum);</a>
<a name="ln152">    ptr += sizeof(float) * 4 * m_header.verticesNum;</a>
<a name="ln153">  }</a>
<a name="ln154"> </a>
<a name="ln155">  memcpy(ptr, m_texcoords,          sizeof(float)*2* m_header.verticesNum);      ptr += sizeof(float) * 2 * m_header.verticesNum;</a>
<a name="ln156">  memcpy(ptr, m_triVertIndices,     sizeof(uint32_t)*m_header.indicesNum);       ptr += sizeof(uint32_t)*m_header.indicesNum;</a>
<a name="ln157">  memcpy(ptr, m_triMaterialIndices, sizeof(uint32_t)*(m_header.indicesNum / 3)); ptr += sizeof(uint32_t)*(m_header.indicesNum / 3);</a>
<a name="ln158">}</a>
<a name="ln159"> </a>
<a name="ln160"> </a>
<a name="ln161">void HydraGeomData::write(const std::string&amp; a_fileName)</a>
<a name="ln162">{</a>
<a name="ln163">  std::ofstream fout(a_fileName.c_str(), std::ios::out | std::ios::binary);</a>
<a name="ln164">  write(fout);</a>
<a name="ln165">  fout.flush();</a>
<a name="ln166">  fout.close();</a>
<a name="ln167">}</a>
<a name="ln168"> </a>
<a name="ln169">inline const int readInt32(const unsigned char* ptr) // THIS IS CORRECT BOTH FOR X86 AND PPC !!!</a>
<a name="ln170">{</a>
<a name="ln171">  const unsigned char b0 = ptr[0];</a>
<a name="ln172">  const unsigned char b1 = ptr[1];</a>
<a name="ln173">  const unsigned char b2 = ptr[2];</a>
<a name="ln174">  const unsigned char b3 = ptr[3];</a>
<a name="ln175"> </a>
<a name="ln176">  return (b3 &lt;&lt; 24) | (b2 &lt;&lt; 16) | (b1 &lt;&lt; 8) | b0;</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179">inline const uint64_t readInt64(const unsigned char* ptr) // THIS IS CORRECT BOTH FOR X86 AND PPC !!!</a>
<a name="ln180">{</a>
<a name="ln181">  const unsigned char b0 = ptr[0];</a>
<a name="ln182">  const unsigned char b1 = ptr[1];</a>
<a name="ln183">  const unsigned char b2 = ptr[2];</a>
<a name="ln184">  const unsigned char b3 = ptr[3];</a>
<a name="ln185">  const unsigned char b4 = ptr[4];</a>
<a name="ln186">  const unsigned char b5 = ptr[5];</a>
<a name="ln187">  const unsigned char b6 = ptr[6];</a>
<a name="ln188">  const unsigned char b7 = ptr[7];</a>
<a name="ln189"> </a>
<a name="ln190">  return  (uint64_t(b7) &lt;&lt; 56) | (uint64_t(b6) &lt;&lt; 48) | (uint64_t(b5) &lt;&lt; 40) | (uint64_t(b4) &lt;&lt; 32) | (uint64_t(b3) &lt;&lt; 24) | (uint64_t(b2) &lt;&lt; 16) | (uint64_t(b1) &lt;&lt; 8) | uint64_t(b0);</a>
<a name="ln191">}</a>
<a name="ln192"> </a>
<a name="ln193">void convertLittleBigEndian(unsigned int* a_buffer, int a_size)</a>
<a name="ln194">{</a>
<a name="ln195">  unsigned char* bbuffer = (unsigned char*)a_buffer;</a>
<a name="ln196"> </a>
<a name="ln197">  for(int i=0;i&lt;a_size;i++)</a>
<a name="ln198">    a_buffer[i] = readInt32(bbuffer + i*4);</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201">void HydraGeomData::read(std::istream&amp; a_input)</a>
<a name="ln202">{</a>
<a name="ln203">  freeMemIfNeeded();</a>
<a name="ln204">  m_ownMemory = true;</a>
<a name="ln205"> </a>
<a name="ln206">  Header info;</a>
<a name="ln207"> </a>
<a name="ln208">  unsigned char temp1[sizeof(Header)];</a>
<a name="ln209">  a_input.read((char*)&amp;temp1[0], sizeof(Header));</a>
<a name="ln210"> </a>
<a name="ln211">  info.fileSizeInBytes = readInt64(&amp;temp1[0]);</a>
<a name="ln212">  info.verticesNum     = readInt32(&amp;temp1[8]);</a>
<a name="ln213">  info.indicesNum      = readInt32(&amp;temp1[12]);</a>
<a name="ln214">  info.materialsNum    = readInt32(&amp;temp1[16]);</a>
<a name="ln215">  info.flags           = readInt32(&amp;temp1[20]);</a>
<a name="ln216"> </a>
<a name="ln217">  m_header = info;</a>
<a name="ln218">  m_data   = new char [info.fileSizeInBytes];</a>
<a name="ln219">  a_input.read(m_data, info.fileSizeInBytes);</a>
<a name="ln220"> </a>
<a name="ln221">  // std::cout &lt;&lt; &quot;[HydraGeomData] data was read&quot; &lt;&lt; std::endl;</a>
<a name="ln222"> </a>
<a name="ln223">  char* ptr = m_data;</a>
<a name="ln224"> </a>
<a name="ln225">  m_positions = (float*)ptr; ptr += sizeof(float)*4*m_header.verticesNum;</a>
<a name="ln226"> </a>
<a name="ln227">  if(!(m_header.flags &amp; HAS_NO_NORMALS))</a>
<a name="ln228">  {</a>
<a name="ln229">    m_normals = (float *) ptr;</a>
<a name="ln230">    ptr += sizeof(float) * 4 * m_header.verticesNum;</a>
<a name="ln231">  }</a>
<a name="ln232"> </a>
<a name="ln233">  if(m_header.flags &amp; HAS_TANGENT)</a>
<a name="ln234">  {</a>
<a name="ln235">    m_tangents = (float*)ptr;</a>
<a name="ln236">    ptr += sizeof(float)*4*m_header.verticesNum;</a>
<a name="ln237">  }</a>
<a name="ln238"> </a>
<a name="ln239">  m_texcoords   = (float*)ptr; ptr += sizeof(float)*2*m_header.verticesNum;</a>
<a name="ln240"> </a>
<a name="ln241">  m_triVertIndices     = (uint32_t*)ptr; ptr += sizeof(uint32_t)*m_header.indicesNum;</a>
<a name="ln242">  m_triMaterialIndices = (uint32_t*)ptr; ptr += sizeof(uint32_t)*(m_header.indicesNum / 3);</a>
<a name="ln243">  </a>
<a name="ln244">  // #NOTE: enable if use ppc</a>
<a name="ln245">  //convertLittleBigEndian((unsigned int*)m_positions, m_header.verticesNum*4);</a>
<a name="ln246">  //if (!(m_header.flags &amp; HAS_NO_NORMALS))</a>
<a name="ln247">  //  convertLittleBigEndian((unsigned int*)m_normals, m_header.verticesNum*4);</a>
<a name="ln248">  //if (m_header.flags &amp; HAS_TANGENT)</a>
<a name="ln249">  //  convertLittleBigEndian((unsigned int*)m_tangents, m_header.verticesNum*4);</a>
<a name="ln250">  //convertLittleBigEndian((unsigned int*)m_texcoords, m_header.verticesNum*2);</a>
<a name="ln251">  //convertLittleBigEndian((unsigned int*)m_triVertIndices, m_header.indicesNum);</a>
<a name="ln252">  //convertLittleBigEndian((unsigned int*)m_triMaterialIndices, (m_header.indicesNum/3));</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255">void HydraGeomData::read(const std::string&amp; a_fileName)</a>
<a name="ln256">{</a>
<a name="ln257">  std::ifstream fin(a_fileName.c_str(), std::ios::binary);</a>
<a name="ln258">  if (!fin.is_open())</a>
<a name="ln259">    return;</a>
<a name="ln260"> </a>
<a name="ln261">  read(fin);</a>
<a name="ln262">  fin.close();</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265">void HydraGeomData::read(const std::wstring&amp; a_fileName)</a>
<a name="ln266">{</a>
<a name="ln267">#if (_POSIX_C_SOURCE &gt;= 200112L || _XOPEN_SOURCE &gt;= 600)</a>
<a name="ln268">  std::wstring s1(a_fileName);</a>
<a name="ln269">  std::string  s2(s1.begin(), s1.end());</a>
<a name="ln270">  std::ifstream fin(s2.c_str(), std::ios::binary);</a>
<a name="ln271">#elif defined WIN32</a>
<a name="ln272">  std::ifstream fin(a_fileName.c_str(), std::ios::binary);</a>
<a name="ln273">#endif</a>
<a name="ln274"> </a>
<a name="ln275">  if (!fin.is_open())</a>
<a name="ln276">    return;</a>
<a name="ln277"> </a>
<a name="ln278">  read(fin);</a>
<a name="ln279">  fin.close();</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">VSGFOffsets CalcOffsets(int numVert, int numInd, bool a_haveTangents, bool a_haveNormals)</a>
<a name="ln283">{</a>
<a name="ln284">  VSGFOffsets res;</a>
<a name="ln285"> </a>
<a name="ln286">  if(a_haveTangents &amp;&amp; a_haveNormals)</a>
<a name="ln287">  {</a>
<a name="ln288">    res.offsetPos  = sizeof(HydraGeomData::Header);</a>
<a name="ln289">    res.offsetNorm = res.offsetPos  + numVert * sizeof(float) * 4; // after pos</a>
<a name="ln290">    res.offsetTang = res.offsetNorm + numVert * sizeof(float) * 4; // after norm</a>
<a name="ln291">    res.offsetTexc = res.offsetTang + numVert * sizeof(float) * 4; // after tangent</a>
<a name="ln292">    res.offsetInd  = res.offsetTexc + numVert * sizeof(float) * 2; // after texcoord</a>
<a name="ln293">    res.offsetMind = res.offsetInd  + numInd * sizeof(int);        // after ind</a>
<a name="ln294">  }</a>
<a name="ln295">  else if (!a_haveTangents &amp;&amp; a_haveNormals)</a>
<a name="ln296">  {</a>
<a name="ln297">    res.offsetPos  = sizeof(HydraGeomData::Header);</a>
<a name="ln298">    res.offsetNorm = res.offsetPos  + numVert * sizeof(float) * 4; // after pos</a>
<a name="ln299">    res.offsetTang = res.offsetNorm; // res.offsetNorm + numVert * sizeof(float) * 4; // after norm</a>
<a name="ln300">    res.offsetTexc = res.offsetTang + numVert * sizeof(float) * 4; // after tangent</a>
<a name="ln301">    res.offsetInd  = res.offsetTexc + numVert * sizeof(float) * 2; // after texcoord</a>
<a name="ln302">    res.offsetMind = res.offsetInd  + numInd * sizeof(int);        // after ind</a>
<a name="ln303">  }</a>
<a name="ln304">  else</a>
<a name="ln305">  {</a>
<a name="ln306">    res.offsetPos  = sizeof(HydraGeomData::Header);</a>
<a name="ln307">    res.offsetNorm = res.offsetPos;  // res.offsetPos  + numVert * sizeof(float) * 4; // after pos</a>
<a name="ln308">    res.offsetTang = res.offsetNorm; // res.offsetNorm + numVert * sizeof(float) * 4; // after norm</a>
<a name="ln309">    res.offsetTexc = res.offsetTang + numVert * sizeof(float) * 4; // after tangent</a>
<a name="ln310">    res.offsetInd  = res.offsetTexc + numVert * sizeof(float) * 2; // after texcoord</a>
<a name="ln311">    res.offsetMind = res.offsetInd  + numInd * sizeof(int);        // after ind</a>
<a name="ln312">  }</a>
<a name="ln313"> </a>
<a name="ln314">  return res;</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317">size_t CalcVSGFSize(int numVert, int numInd)</a>
<a name="ln318">{</a>
<a name="ln319">  VSGFOffsets offsets = CalcOffsets(numVert, numInd, true, true);</a>
<a name="ln320">  return offsets.offsetMind + (numInd/3)*sizeof(int);</a>
<a name="ln321">}</a>

</code></pre>
<div class="balloon" rel="157"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1001/" target="_blank">V1001</a> The 'ptr' variable is assigned but is not used by the end of the function.</p></div>
<div class="balloon" rel="242"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1001/" target="_blank">V1001</a> The 'ptr' variable is assigned but is not used by the end of the function.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
