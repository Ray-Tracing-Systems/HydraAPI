
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>OpenGLCoreProfileUtils.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//</a>
<a name="ln2">// Created by hikawa on 18.08.17.</a>
<a name="ln3">//</a>
<a name="ln4"> </a>
<a name="ln5">#include &lt;iostream&gt;</a>
<a name="ln6">#include &lt;random&gt;</a>
<a name="ln7">#include &quot;OpenGLCoreProfileUtils.h&quot;</a>
<a name="ln8"> </a>
<a name="ln9">namespace oldies</a>
<a name="ln10">{</a>
<a name="ln11">  extern &quot;C&quot; {</a>
<a name="ln12">  #include &quot;../utils/ies_parser/IESNA.H&quot;</a>
<a name="ln13">  };</a>
<a name="ln14">};</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;FreeImage.h&quot;</a>
<a name="ln17">#include &lt;algorithm&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#ifndef WIN32</a>
<a name="ln20">#include &lt;unistd.h&gt;</a>
<a name="ln21">#include &lt;climits&gt;</a>
<a name="ln22"> </a>
<a name="ln23">std::string getexepath()</a>
<a name="ln24">{</a>
<a name="ln25">  char result[PATH_MAX];</a>
<a name="ln26">  ssize_t count = readlink(&quot;/proc/self/exe&quot;, result, PATH_MAX);</a>
<a name="ln27">  return std::string(result, (count &gt; 0) ? count : 0);</a>
<a name="ln28">}</a>
<a name="ln29"> </a>
<a name="ln30">#undef min</a>
<a name="ln31">#undef max</a>
<a name="ln32"> </a>
<a name="ln33">#else</a>
<a name="ln34">std::string getexepath()</a>
<a name="ln35">{</a>
<a name="ln36">  char NPath[512];</a>
<a name="ln37">  GetCurrentDirectoryA(512, NPath);</a>
<a name="ln38">  return std::string(NPath);</a>
<a name="ln39">}</a>
<a name="ln40">#endif</a>
<a name="ln41"> </a>
<a name="ln42">namespace GL_RENDER_DRIVER_UTILS</a>
<a name="ln43">{</a>
<a name="ln44">  #ifdef M_PI</a>
<a name="ln45">  #undef M_PI</a>
<a name="ln46">  #endif</a>
<a name="ln47">  static const float M_PI = 3.14159265358979323846f;</a>
<a name="ln48">  static const float INV_PI = 1.0f / M_PI;</a>
<a name="ln49">  static const float DEG_TO_RAD = M_PI / 180.0f;</a>
<a name="ln50"> </a>
<a name="ln51"> </a>
<a name="ln52">  void bindTexture(const ShaderProgram &amp;program, int unit, const std::string &amp;name, RenderTexture2D &amp;texture)</a>
<a name="ln53">  {</a>
<a name="ln54">    glActiveTexture(GL_TEXTURE0 + unit);</a>
<a name="ln55">    glBindTexture(GL_TEXTURE_2D, texture.GetTextureId(RenderTexture2D::RTEX_COLOR));</a>
<a name="ln56"> </a>
<a name="ln57">    program.SetUniform(name, unit);</a>
<a name="ln58">  }</a>
<a name="ln59"> </a>
<a name="ln60">  void bindTexture(const ShaderProgram &amp;program, int unit, const std::string &amp;name, GLuint textureId)</a>
<a name="ln61">  {</a>
<a name="ln62">    glActiveTexture(GL_TEXTURE0 + unit);</a>
<a name="ln63">    glBindTexture(GL_TEXTURE_2D, textureId);</a>
<a name="ln64"> </a>
<a name="ln65">    program.SetUniform(name, unit);</a>
<a name="ln66">  }</a>
<a name="ln67"> </a>
<a name="ln68">  void bindTextureBuffer(const ShaderProgram &amp;program, int unit, const std::string &amp;name, GLuint tbo, GLuint textureId, GLenum format)</a>
<a name="ln69">  {</a>
<a name="ln70">    glActiveTexture(GL_TEXTURE0 + unit);</a>
<a name="ln71">    glBindTexture(GL_TEXTURE_BUFFER, textureId);</a>
<a name="ln72">    glTexBuffer(GL_TEXTURE_BUFFER, format, tbo);</a>
<a name="ln73"> </a>
<a name="ln74">    program.SetUniform(name, unit);</a>
<a name="ln75">  }</a>
<a name="ln76"> </a>
<a name="ln77"> </a>
<a name="ln78">  void CreatePlaceholderWhiteTexture(GLuint &amp;a_whiteTex)</a>
<a name="ln79">  {</a>
<a name="ln80">    glBindTexture(GL_TEXTURE_2D, a_whiteTex);</a>
<a name="ln81"> </a>
<a name="ln82">    float white[4] = {1.0f, 1.0f, 1.0f, 1.0f};</a>
<a name="ln83"> </a>
<a name="ln84">    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, 1, 1, 0, GL_RGBA, GL_FLOAT, &amp;white);</a>
<a name="ln85"> </a>
<a name="ln86">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</a>
<a name="ln87">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</a>
<a name="ln88">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</a>
<a name="ln89">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</a>
<a name="ln90"> </a>
<a name="ln91">    glGenerateMipmap(GL_TEXTURE_2D);</a>
<a name="ln92">  }</a>
<a name="ln93"> </a>
<a name="ln94"> </a>
<a name="ln95">//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln96">//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln97"> </a>
<a name="ln98">  ShaderProgram::ShaderProgram(const std::unordered_map&lt;GLenum, std::string&gt; &amp;inputShaders, bool a_fromStrings)</a>
<a name="ln99">  {</a>
<a name="ln100"> </a>
<a name="ln101">    shaderProgram = glCreateProgram();</a>
<a name="ln102"> </a>
<a name="ln103">    if (inputShaders.find(GL_VERTEX_SHADER) != inputShaders.end())</a>
<a name="ln104">    {</a>
<a name="ln105">      shaderObjects[GL_VERTEX_SHADER] = LoadShaderObject(GL_VERTEX_SHADER, inputShaders.at(GL_VERTEX_SHADER), a_fromStrings);</a>
<a name="ln106">      glAttachShader(shaderProgram, shaderObjects[GL_VERTEX_SHADER]);</a>
<a name="ln107">    }</a>
<a name="ln108"> </a>
<a name="ln109">    if (inputShaders.find(GL_FRAGMENT_SHADER) != inputShaders.end())</a>
<a name="ln110">    {</a>
<a name="ln111">      shaderObjects[GL_FRAGMENT_SHADER] = LoadShaderObject(GL_FRAGMENT_SHADER, inputShaders.at(GL_FRAGMENT_SHADER), a_fromStrings);</a>
<a name="ln112">      glAttachShader(shaderProgram, shaderObjects[GL_FRAGMENT_SHADER]);</a>
<a name="ln113">    }</a>
<a name="ln114">    if (inputShaders.find(GL_GEOMETRY_SHADER) != inputShaders.end())</a>
<a name="ln115">    {</a>
<a name="ln116">      shaderObjects[GL_GEOMETRY_SHADER] = LoadShaderObject(GL_GEOMETRY_SHADER, inputShaders.at(GL_GEOMETRY_SHADER), a_fromStrings);</a>
<a name="ln117">      glAttachShader(shaderProgram, shaderObjects[GL_GEOMETRY_SHADER]);</a>
<a name="ln118">    }</a>
<a name="ln119">    if (inputShaders.find(GL_TESS_CONTROL_SHADER) != inputShaders.end())</a>
<a name="ln120">    {</a>
<a name="ln121">      shaderObjects[GL_TESS_CONTROL_SHADER] = LoadShaderObject(GL_TESS_CONTROL_SHADER,</a>
<a name="ln122">                                                               inputShaders.at(GL_TESS_CONTROL_SHADER), a_fromStrings);</a>
<a name="ln123">      glAttachShader(shaderProgram, shaderObjects[GL_TESS_CONTROL_SHADER]);</a>
<a name="ln124">    }</a>
<a name="ln125">    if (inputShaders.find(GL_TESS_EVALUATION_SHADER) != inputShaders.end())</a>
<a name="ln126">    {</a>
<a name="ln127">      shaderObjects[GL_TESS_EVALUATION_SHADER] = LoadShaderObject(GL_TESS_EVALUATION_SHADER,</a>
<a name="ln128">                                                                  inputShaders.at(GL_TESS_EVALUATION_SHADER), a_fromStrings);</a>
<a name="ln129">      glAttachShader(shaderProgram, shaderObjects[GL_TESS_EVALUATION_SHADER]);</a>
<a name="ln130">    }</a>
<a name="ln131">    if (inputShaders.find(GL_COMPUTE_SHADER) != inputShaders.end())</a>
<a name="ln132">    {</a>
<a name="ln133">      shaderObjects[GL_COMPUTE_SHADER] = LoadShaderObject(GL_COMPUTE_SHADER, inputShaders.at(GL_COMPUTE_SHADER), a_fromStrings);</a>
<a name="ln134">      glAttachShader(shaderProgram, shaderObjects[GL_COMPUTE_SHADER]);</a>
<a name="ln135">    }</a>
<a name="ln136"> </a>
<a name="ln137">    glLinkProgram(shaderProgram);</a>
<a name="ln138"> </a>
<a name="ln139">    GLint linkStatus;</a>
<a name="ln140"> </a>
<a name="ln141"> </a>
<a name="ln142">    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;linkStatus);</a>
<a name="ln143">    if (linkStatus != GL_TRUE)</a>
<a name="ln144">    {</a>
<a name="ln145">      GLchar infoLog[512];</a>
<a name="ln146">      glGetProgramInfoLog(shaderProgram, 512, nullptr, infoLog);</a>
<a name="ln147">      std::cerr &lt;&lt; &quot;Shader program linking failed\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;</a>
<a name="ln148">      shaderProgram = 0;</a>
<a name="ln149">    }</a>
<a name="ln150"> </a>
<a name="ln151">  }</a>
<a name="ln152"> </a>
<a name="ln153"> </a>
<a name="ln154">  void ShaderProgram::Release()</a>
<a name="ln155">  {</a>
<a name="ln156">    if (shaderObjects.find(GL_VERTEX_SHADER) != shaderObjects.end())</a>
<a name="ln157">    {</a>
<a name="ln158">      glDetachShader(shaderProgram, shaderObjects[GL_VERTEX_SHADER]);</a>
<a name="ln159">      glDeleteShader(shaderObjects[GL_VERTEX_SHADER]);</a>
<a name="ln160">    }</a>
<a name="ln161"> </a>
<a name="ln162">    if (shaderObjects.find(GL_FRAGMENT_SHADER) != shaderObjects.end())</a>
<a name="ln163">    {</a>
<a name="ln164">      glDetachShader(shaderProgram, shaderObjects[GL_FRAGMENT_SHADER]);</a>
<a name="ln165">      glDeleteShader(shaderObjects[GL_FRAGMENT_SHADER]);</a>
<a name="ln166">    }</a>
<a name="ln167"> </a>
<a name="ln168">    if (shaderObjects.find(GL_GEOMETRY_SHADER) != shaderObjects.end())</a>
<a name="ln169">    {</a>
<a name="ln170">      glDetachShader(shaderProgram, shaderObjects[GL_GEOMETRY_SHADER]);</a>
<a name="ln171">      glDeleteShader(shaderObjects[GL_GEOMETRY_SHADER]);</a>
<a name="ln172">    }</a>
<a name="ln173"> </a>
<a name="ln174">    if (shaderObjects.find(GL_TESS_CONTROL_SHADER) != shaderObjects.end())</a>
<a name="ln175">    {</a>
<a name="ln176">      glDetachShader(shaderProgram, shaderObjects[GL_TESS_CONTROL_SHADER]);</a>
<a name="ln177">      glDeleteShader(shaderObjects[GL_TESS_CONTROL_SHADER]);</a>
<a name="ln178">    }</a>
<a name="ln179"> </a>
<a name="ln180">    if (shaderObjects.find(GL_TESS_EVALUATION_SHADER) != shaderObjects.end())</a>
<a name="ln181">    {</a>
<a name="ln182">      glDetachShader(shaderProgram, shaderObjects[GL_TESS_EVALUATION_SHADER]);</a>
<a name="ln183">      glDeleteShader(shaderObjects[GL_TESS_EVALUATION_SHADER]);</a>
<a name="ln184">    }</a>
<a name="ln185">    if (shaderObjects.find(GL_COMPUTE_SHADER) != shaderObjects.end())</a>
<a name="ln186">    {</a>
<a name="ln187">      glDetachShader(shaderProgram, shaderObjects[GL_COMPUTE_SHADER]);</a>
<a name="ln188">      glDeleteShader(shaderObjects[GL_COMPUTE_SHADER]);</a>
<a name="ln189">    }</a>
<a name="ln190"> </a>
<a name="ln191">    glDeleteProgram(shaderProgram);</a>
<a name="ln192">  }</a>
<a name="ln193"> </a>
<a name="ln194">  bool ShaderProgram::reLink()</a>
<a name="ln195">  {</a>
<a name="ln196">    GLint linked;</a>
<a name="ln197"> </a>
<a name="ln198">    glLinkProgram(shaderProgram);</a>
<a name="ln199">    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;linked);</a>
<a name="ln200"> </a>
<a name="ln201">    if (!linked)</a>
<a name="ln202">    {</a>
<a name="ln203">      GLint logLength, charsWritten;</a>
<a name="ln204">      glGetProgramiv(this-&gt;shaderProgram, GL_INFO_LOG_LENGTH, &amp;logLength);</a>
<a name="ln205"> </a>
<a name="ln206">      auto log = new char[logLength];</a>
<a name="ln207">      glGetProgramInfoLog(this-&gt;shaderProgram, logLength, &amp;charsWritten, log);</a>
<a name="ln208"> </a>
<a name="ln209">      std::cerr &lt;&lt; &quot;Shader program link error: &quot; &lt;&lt; std::endl &lt;&lt; log &lt;&lt; std::endl;</a>
<a name="ln210"> </a>
<a name="ln211">      delete[] log;</a>
<a name="ln212">      shaderProgram = 0;</a>
<a name="ln213">      return false;</a>
<a name="ln214">    }</a>
<a name="ln215"> </a>
<a name="ln216">    return true;</a>
<a name="ln217">  }</a>
<a name="ln218"> </a>
<a name="ln219"> </a>
<a name="ln220">  GLuint ShaderProgram::LoadShaderObject(GLenum type, const std::string &amp;filename, bool a_fromStrings)</a>
<a name="ln221">  {</a>
<a name="ln222">    std::string shaderText;</a>
<a name="ln223"> </a>
<a name="ln224">    if (!a_fromStrings)</a>
<a name="ln225">    {</a>
<a name="ln226">      std::ifstream fs(filename);</a>
<a name="ln227">      if (!fs.is_open())</a>
<a name="ln228">      {</a>
<a name="ln229">        std::cerr &lt;&lt; &quot;ERROR: Could not read shader from &quot; &lt;&lt; filename &lt;&lt; std::endl;</a>
<a name="ln230">        return 0;</a>
<a name="ln231">      }</a>
<a name="ln232">      shaderText = std::string((std::istreambuf_iterator&lt;char&gt;(fs)), std::istreambuf_iterator&lt;char&gt;());</a>
<a name="ln233">    }</a>
<a name="ln234">    else</a>
<a name="ln235">      shaderText = filename;</a>
<a name="ln236"> </a>
<a name="ln237">    GLuint newShaderObject = glCreateShader(type);</a>
<a name="ln238"> </a>
<a name="ln239">    const char *shaderSrc = shaderText.c_str();</a>
<a name="ln240">    glShaderSource(newShaderObject, 1, &amp;shaderSrc, nullptr);</a>
<a name="ln241"> </a>
<a name="ln242">    glCompileShader(newShaderObject);</a>
<a name="ln243"> </a>
<a name="ln244">    GLint compileStatus;</a>
<a name="ln245">    glGetShaderiv(newShaderObject, GL_COMPILE_STATUS, &amp;compileStatus);</a>
<a name="ln246"> </a>
<a name="ln247">    if (compileStatus != GL_TRUE)</a>
<a name="ln248">    {</a>
<a name="ln249">      GLchar infoLog[512];</a>
<a name="ln250">      glGetShaderInfoLog(newShaderObject, 512, nullptr, infoLog);</a>
<a name="ln251">      std::cerr &lt;&lt; &quot;Shader compilation failed : &quot; &lt;&lt; std::endl &lt;&lt; infoLog &lt;&lt; std::endl;</a>
<a name="ln252">      return 0;</a>
<a name="ln253">    }</a>
<a name="ln254"> </a>
<a name="ln255">    return newShaderObject;</a>
<a name="ln256">  }</a>
<a name="ln257"> </a>
<a name="ln258">  void ShaderProgram::StartUseShader() const</a>
<a name="ln259">  {</a>
<a name="ln260">    glUseProgram(shaderProgram);</a>
<a name="ln261">  }</a>
<a name="ln262"> </a>
<a name="ln263">  void ShaderProgram::StopUseShader() const</a>
<a name="ln264">  {</a>
<a name="ln265">    glUseProgram(0);</a>
<a name="ln266">  }</a>
<a name="ln267"> </a>
<a name="ln268">  void ShaderProgram::SetUniform(const std::string &amp;location, const float4x4 &amp;value) const</a>
<a name="ln269">  {</a>
<a name="ln270">    GLint uniformLocation = glGetUniformLocation(shaderProgram, location.c_str());</a>
<a name="ln271">    if (uniformLocation == -1)</a>
<a name="ln272">    {</a>
<a name="ln273">      std::cerr &lt;&lt; &quot;Uniform  &quot; &lt;&lt; location &lt;&lt; &quot; not found&quot; &lt;&lt; std::endl;</a>
<a name="ln274">      return;</a>
<a name="ln275">    }</a>
<a name="ln276"> </a>
<a name="ln277">    glUniformMatrix4fv(uniformLocation, 1, GL_FALSE, value.L());</a>
<a name="ln278">  }</a>
<a name="ln279"> </a>
<a name="ln280">  void ShaderProgram::SetUniform(const std::string &amp;location, int value) const</a>
<a name="ln281">  {</a>
<a name="ln282">    GLint uniformLocation = glGetUniformLocation(shaderProgram, location.c_str());</a>
<a name="ln283">    if (uniformLocation == -1)</a>
<a name="ln284">    {</a>
<a name="ln285">      std::cerr &lt;&lt; &quot;Uniform  &quot; &lt;&lt; location &lt;&lt; &quot; not found&quot; &lt;&lt; std::endl;</a>
<a name="ln286">      return;</a>
<a name="ln287">    }</a>
<a name="ln288">    glUniform1i(uniformLocation, value);</a>
<a name="ln289">  }</a>
<a name="ln290"> </a>
<a name="ln291">  void ShaderProgram::SetUniform(const std::string &amp;location, unsigned int value) const</a>
<a name="ln292">  {</a>
<a name="ln293">    GLint uniformLocation = glGetUniformLocation(shaderProgram, location.c_str());</a>
<a name="ln294">    if (uniformLocation == -1)</a>
<a name="ln295">    {</a>
<a name="ln296">      std::cerr &lt;&lt; &quot;Uniform  &quot; &lt;&lt; location &lt;&lt; &quot; not found&quot; &lt;&lt; std::endl;</a>
<a name="ln297">      return;</a>
<a name="ln298">    }</a>
<a name="ln299">    glUniform1ui(uniformLocation, value);</a>
<a name="ln300">  }</a>
<a name="ln301"> </a>
<a name="ln302">  void ShaderProgram::SetUniform(const std::string &amp;location, float value) const</a>
<a name="ln303">  {</a>
<a name="ln304">    GLint uniformLocation = glGetUniformLocation(shaderProgram, location.c_str());</a>
<a name="ln305">    if (uniformLocation == -1)</a>
<a name="ln306">    {</a>
<a name="ln307">      std::cerr &lt;&lt; &quot;Uniform  &quot; &lt;&lt; location &lt;&lt; &quot; not found&quot; &lt;&lt; std::endl;</a>
<a name="ln308">      return;</a>
<a name="ln309">    }</a>
<a name="ln310">    glUniform1f(uniformLocation, value);</a>
<a name="ln311">  }</a>
<a name="ln312"> </a>
<a name="ln313">  void ShaderProgram::SetUniform(const std::string &amp;location, double value) const</a>
<a name="ln314">  {</a>
<a name="ln315">    GLint uniformLocation = glGetUniformLocation(shaderProgram, location.c_str());</a>
<a name="ln316">    if (uniformLocation == -1)</a>
<a name="ln317">    {</a>
<a name="ln318">      std::cerr &lt;&lt; &quot;Uniform  &quot; &lt;&lt; location &lt;&lt; &quot; not found&quot; &lt;&lt; std::endl;</a>
<a name="ln319">      return;</a>
<a name="ln320">    }</a>
<a name="ln321">    glUniform1d(uniformLocation, value);</a>
<a name="ln322">  }</a>
<a name="ln323"> </a>
<a name="ln324">  void ShaderProgram::SetUniform(const std::string &amp;location, const float4 &amp;value) const</a>
<a name="ln325">  {</a>
<a name="ln326">    GLint uniformLocation = glGetUniformLocation(shaderProgram, location.c_str());</a>
<a name="ln327">    if (uniformLocation == -1)</a>
<a name="ln328">    {</a>
<a name="ln329">      std::cerr &lt;&lt; &quot;Uniform  &quot; &lt;&lt; location &lt;&lt; &quot; not found&quot; &lt;&lt; std::endl;</a>
<a name="ln330">      return;</a>
<a name="ln331">    }</a>
<a name="ln332">    float val[] = {value.x, value.y, value.z, value.w};</a>
<a name="ln333">    glUniform4fv(uniformLocation, 1, val);</a>
<a name="ln334">  }</a>
<a name="ln335"> </a>
<a name="ln336">  void ShaderProgram::SetUniform(const std::string &amp;location, const float3 &amp;value) const</a>
<a name="ln337">  {</a>
<a name="ln338">    GLint uniformLocation = glGetUniformLocation(shaderProgram, location.c_str());</a>
<a name="ln339">    if (uniformLocation == -1)</a>
<a name="ln340">    {</a>
<a name="ln341">      std::cerr &lt;&lt; &quot;Uniform  &quot; &lt;&lt; location &lt;&lt; &quot; not found&quot; &lt;&lt; std::endl;</a>
<a name="ln342">      return;</a>
<a name="ln343">    }</a>
<a name="ln344">    float val[] = {value.x, value.y, value.z};</a>
<a name="ln345">    glUniform3fv(uniformLocation, 1, val);</a>
<a name="ln346">  }</a>
<a name="ln347"> </a>
<a name="ln348">  void ShaderProgram::SetUniform(const std::string &amp;location, const float2 &amp;value) const</a>
<a name="ln349">  {</a>
<a name="ln350">    GLint uniformLocation = glGetUniformLocation(shaderProgram, location.c_str());</a>
<a name="ln351">    if (uniformLocation == -1)</a>
<a name="ln352">    {</a>
<a name="ln353">      std::cerr &lt;&lt; &quot;Uniform  &quot; &lt;&lt; location &lt;&lt; &quot; not found&quot; &lt;&lt; std::endl;</a>
<a name="ln354">      return;</a>
<a name="ln355">    }</a>
<a name="ln356">    float val[] = {value.x, value.y};</a>
<a name="ln357">    glUniform2fv(uniformLocation, 1, val);</a>
<a name="ln358">  }</a>
<a name="ln359"> </a>
<a name="ln360">  void ShaderProgram::SetUniform(const std::string &amp;location, const int2 &amp;value) const</a>
<a name="ln361">  {</a>
<a name="ln362">    GLint uniformLocation = glGetUniformLocation(shaderProgram, location.c_str());</a>
<a name="ln363">    if (uniformLocation == -1)</a>
<a name="ln364">    {</a>
<a name="ln365">      std::cerr &lt;&lt; &quot;Uniform  &quot; &lt;&lt; location &lt;&lt; &quot; not found&quot; &lt;&lt; std::endl;</a>
<a name="ln366">      return;</a>
<a name="ln367">    }</a>
<a name="ln368">    int val[] = {value.x, value.y};</a>
<a name="ln369">    glUniform2iv(uniformLocation, 1, val);</a>
<a name="ln370">  }</a>
<a name="ln371"> </a>
<a name="ln372">//////////////////////////////////////////////////////////////////</a>
<a name="ln373">//////////////////////////////////////////////////////////////////</a>
<a name="ln374">  GLuint CreateEmptyTex(GLenum format, GLenum internalFormat, GLsizei width, GLsizei height, GLenum type)</a>
<a name="ln375">  {</a>
<a name="ln376">    GLuint texture;</a>
<a name="ln377"> </a>
<a name="ln378">    glGenTextures(1, &amp;texture);</a>
<a name="ln379"> </a>
<a name="ln380">    glBindTexture(GL_TEXTURE_2D, texture);</a>
<a name="ln381"> </a>
<a name="ln382">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</a>
<a name="ln383">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</a>
<a name="ln384">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</a>
<a name="ln385">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</a>
<a name="ln386"> </a>
<a name="ln387">    glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, width, height, 0, format, type, NULL);</a>
<a name="ln388"> </a>
<a name="ln389">    return texture;</a>
<a name="ln390">  }</a>
<a name="ln391"> </a>
<a name="ln392">  RenderTexture2D::RenderTexture2D() : frameBufferObject(-1), width(0), height(0)</a>
<a name="ln393">  {</a>
<a name="ln394">    for (int i = 0; i &lt; RTEX_NUM_TEXTURES; ++i)</a>
<a name="ln395">      renderTextures[i] = GLuint(-1);</a>
<a name="ln396">  }</a>
<a name="ln397"> </a>
<a name="ln398">  RenderTexture2D::RenderTexture2D(GLenum format, GLenum internal_format, GLsizei width, GLsizei height) : width(</a>
<a name="ln399">      width), height(height), m_format(format), m_internal_format(internal_format)</a>
<a name="ln400">  {</a>
<a name="ln401">    glGenFramebuffers(1, &amp;frameBufferObject);</a>
<a name="ln402">    glBindFramebuffer(GL_FRAMEBUFFER, frameBufferObject);</a>
<a name="ln403"> </a>
<a name="ln404">    for (int i = 0; i &lt; RTEX_NUM_TEXTURES; ++i)</a>
<a name="ln405">    {</a>
<a name="ln406">      renderTextures[i] = CreateEmptyTex(format, internal_format, width, height);</a>
<a name="ln407">      glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + i, renderTextures[i], 0);</a>
<a name="ln408">    }</a>
<a name="ln409"> </a>
<a name="ln410">    depthTex = CreateEmptyTex(GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT24, width, height, GL_UNSIGNED_BYTE);</a>
<a name="ln411">    glFramebufferTexture(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, depthTex, 0);</a>
<a name="ln412"> </a>
<a name="ln413">    GLenum fboStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);</a>
<a name="ln414">    if (fboStatus != GL_FRAMEBUFFER_COMPLETE)</a>
<a name="ln415">      std::cout &lt;&lt; &quot;Framebuffer is not complete&quot; &lt;&lt; std::endl;</a>
<a name="ln416"> </a>
<a name="ln417">    glBindFramebuffer(GL_FRAMEBUFFER, 0);</a>
<a name="ln418">  }</a>
<a name="ln419"> </a>
<a name="ln420">  void RenderTexture2D::ResizeAttachments(GLsizei width, GLsizei height)</a>
<a name="ln421">  {</a>
<a name="ln422">    for (int i = 0; i &lt; RTEX_NUM_TEXTURES; ++i)</a>
<a name="ln423">    {</a>
<a name="ln424">      glBindTexture(GL_TEXTURE_2D, renderTextures[i]);</a>
<a name="ln425">      glTexImage2D(GL_TEXTURE_2D, 0, m_internal_format, width, height, 0, m_format, GL_FLOAT, NULL);</a>
<a name="ln426">    }</a>
<a name="ln427"> </a>
<a name="ln428">    glBindTexture(GL_TEXTURE_2D, depthTex);</a>
<a name="ln429">    glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT24, width, height, 0, GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE,</a>
<a name="ln430">                 NULL);</a>
<a name="ln431">  }</a>
<a name="ln432"> </a>
<a name="ln433">  RenderTexture2D::~RenderTexture2D()</a>
<a name="ln434">  {</a>
<a name="ln435">    glDeleteTextures(RTEX_NUM_TEXTURES, renderTextures);</a>
<a name="ln436">    glDeleteTextures(1, &amp;depthTex);</a>
<a name="ln437">    for (int i = 0; i &lt; RTEX_NUM_TEXTURES; ++i)</a>
<a name="ln438">      renderTextures[i] = GLuint(-1);</a>
<a name="ln439"> </a>
<a name="ln440">    glDeleteFramebuffers(1, &amp;frameBufferObject);</a>
<a name="ln441">  }</a>
<a name="ln442"> </a>
<a name="ln443"> </a>
<a name="ln444">  void RenderTexture2D::StartRendering()</a>
<a name="ln445">  {</a>
<a name="ln446">    glBindFramebuffer(GL_FRAMEBUFFER, frameBufferObject);</a>
<a name="ln447">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</a>
<a name="ln448">  }</a>
<a name="ln449"> </a>
<a name="ln450">  void RenderTexture2D::EndRendering()</a>
<a name="ln451">  {</a>
<a name="ln452">    glBindFramebuffer(GL_FRAMEBUFFER, 0);</a>
<a name="ln453">  }</a>
<a name="ln454"> </a>
<a name="ln455"> </a>
<a name="ln456">//////////////////////////////////////////////////////////////////</a>
<a name="ln457">//////////////////////////////////////////////////////////////////</a>
<a name="ln458"> </a>
<a name="ln459"> </a>
<a name="ln460">  LODBuffer::LODBuffer(GLsizei width, GLsizei height) : width(width), height(height)</a>
<a name="ln461">  {</a>
<a name="ln462">    glGenFramebuffers(1, &amp;frameBufferObject);</a>
<a name="ln463">    glBindFramebuffer(GL_FRAMEBUFFER, frameBufferObject);</a>
<a name="ln464"> </a>
<a name="ln465">    for (int i = 0; i &lt; LODBUF_NUM_TEXTURES; ++i)</a>
<a name="ln466">    {</a>
<a name="ln467">      renderTextures[i] = CreateEmptyTex(GL_RGBA_INTEGER, GL_RGBA32UI, width, height, GL_UNSIGNED_INT);//GL_RGBA32I</a>
<a name="ln468">      glFramebufferTexture(GL_FRAMEBUFFER, GLenum(GL_COLOR_ATTACHMENT0 + i), renderTextures[i], 0);</a>
<a name="ln469">    }</a>
<a name="ln470"> </a>
<a name="ln471">    depthTex = CreateEmptyTex(GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT24, width, height, GL_UNSIGNED_BYTE);</a>
<a name="ln472">    glFramebufferTexture(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, depthTex, 0);</a>
<a name="ln473"> </a>
<a name="ln474">    GLenum fboStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);</a>
<a name="ln475">    if (fboStatus != GL_FRAMEBUFFER_COMPLETE)</a>
<a name="ln476">      std::cout &lt;&lt; &quot;(LODBuffer) Framebuffer is not complete&quot; &lt;&lt; std::endl;</a>
<a name="ln477"> </a>
<a name="ln478">    glBindFramebuffer(GL_FRAMEBUFFER, 0);</a>
<a name="ln479">  }</a>
<a name="ln480"> </a>
<a name="ln481">  void LODBuffer::ResizeAttachments(GLsizei width, GLsizei height)</a>
<a name="ln482">  {</a>
<a name="ln483">    for (int i = 0; i &lt; LODBUF_NUM_TEXTURES; ++i)</a>
<a name="ln484">    {</a>
<a name="ln485">      glBindTexture(GL_TEXTURE_2D, renderTextures[i]);</a>
<a name="ln486"> </a>
<a name="ln487">      glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA32UI, width, height, 0, GL_RGBA, GL_UNSIGNED_INT, NULL);</a>
<a name="ln488">    }</a>
<a name="ln489">    glBindTexture(GL_TEXTURE_2D, depthTex);</a>
<a name="ln490">    glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT24, width, height, 0, GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE, NULL);</a>
<a name="ln491">  }</a>
<a name="ln492"> </a>
<a name="ln493"> </a>
<a name="ln494">  LODBuffer::~LODBuffer()</a>
<a name="ln495">  {</a>
<a name="ln496">    glDeleteTextures(LODBUF_NUM_TEXTURES, renderTextures);</a>
<a name="ln497">    glDeleteTextures(1, &amp;depthTex);</a>
<a name="ln498">    for (int i = 0; i &lt; LODBUF_NUM_TEXTURES; ++i)</a>
<a name="ln499">      renderTextures[i] = GLuint(-1);</a>
<a name="ln500"> </a>
<a name="ln501">    glDeleteFramebuffers(1, &amp;frameBufferObject);</a>
<a name="ln502">  }</a>
<a name="ln503"> </a>
<a name="ln504">  void LODBuffer::StartRendering()</a>
<a name="ln505">  {</a>
<a name="ln506">    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, frameBufferObject);</a>
<a name="ln507">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</a>
<a name="ln508"> </a>
<a name="ln509">    GLenum attachments[LODBUF_NUM_TEXTURES];</a>
<a name="ln510"> </a>
<a name="ln511">    for (int i = 0; i &lt; LODBUF_NUM_TEXTURES; ++i)</a>
<a name="ln512">      attachments[i] = GLenum(GL_COLOR_ATTACHMENT0 + i);</a>
<a name="ln513"> </a>
<a name="ln514">    glDrawBuffers(LODBUF_NUM_TEXTURES, attachments);</a>
<a name="ln515">  }</a>
<a name="ln516"> </a>
<a name="ln517"> </a>
<a name="ln518">  void LODBuffer::EndRendering()</a>
<a name="ln519">  {</a>
<a name="ln520">    glBindFramebuffer(GL_FRAMEBUFFER, 0);</a>
<a name="ln521">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</a>
<a name="ln522">  }</a>
<a name="ln523"> </a>
<a name="ln524">  GLuint LODBuffer::GetTextureId(LODBUF_TEXTURE_TYPE type)</a>
<a name="ln525">  {</a>
<a name="ln526">    if (type == LODBUF_NUM_TEXTURES)</a>
<a name="ln527">      return GLuint(-1);</a>
<a name="ln528">    else</a>
<a name="ln529">      return renderTextures[type];</a>
<a name="ln530">  }</a>
<a name="ln531"> </a>
<a name="ln532">//////////////////////////////////////////////////////////////////</a>
<a name="ln533">//////////////////////////////////////////////////////////////////</a>
<a name="ln534"> </a>
<a name="ln535">  FullScreenQuad::FullScreenQuad()</a>
<a name="ln536">  {</a>
<a name="ln537">    float quadPos[] = {-1.0f, 1.0f,</a>
<a name="ln538">                       -1.0f, -1.0f,</a>
<a name="ln539">                       1.0f, 1.0f,</a>
<a name="ln540">                       1.0f, -1.0f};</a>
<a name="ln541"> </a>
<a name="ln542">    vertexPosBufferObject = 0;</a>
<a name="ln543">    vertexPosLocation = 0;</a>
<a name="ln544"> </a>
<a name="ln545">    glGenBuffers(1, &amp;vertexPosBufferObject);</a>
<a name="ln546">    glBindBuffer(GL_ARRAY_BUFFER, vertexPosBufferObject);</a>
<a name="ln547">    glBufferData(GL_ARRAY_BUFFER, 4 * 2 * sizeof(GLfloat), (GLfloat *) quadPos, GL_STATIC_DRAW);</a>
<a name="ln548"> </a>
<a name="ln549">    glGenVertexArrays(1, &amp;vertexArrayObject);</a>
<a name="ln550">    glBindVertexArray(vertexArrayObject);</a>
<a name="ln551"> </a>
<a name="ln552">    glBindBuffer(GL_ARRAY_BUFFER, vertexPosBufferObject);</a>
<a name="ln553">    glEnableVertexAttribArray(vertexPosLocation);</a>
<a name="ln554">    glVertexAttribPointer(vertexPosLocation, 2, GL_FLOAT, GL_FALSE, 0, 0);</a>
<a name="ln555"> </a>
<a name="ln556">    glBindVertexArray(0);</a>
<a name="ln557">  }</a>
<a name="ln558"> </a>
<a name="ln559">  FullScreenQuad::~FullScreenQuad()</a>
<a name="ln560">  {</a>
<a name="ln561">    if (vertexPosBufferObject)</a>
<a name="ln562">    {</a>
<a name="ln563">      glDeleteBuffers(1, &amp;vertexPosBufferObject);</a>
<a name="ln564">      vertexPosBufferObject = 0;</a>
<a name="ln565">    }</a>
<a name="ln566"> </a>
<a name="ln567">    if (vertexArrayObject)</a>
<a name="ln568">    {</a>
<a name="ln569">      glDeleteVertexArrays(1, &amp;vertexArrayObject);</a>
<a name="ln570">      vertexArrayObject = 0;</a>
<a name="ln571">    }</a>
<a name="ln572"> </a>
<a name="ln573">  }</a>
<a name="ln574"> </a>
<a name="ln575">  void FullScreenQuad::Draw()</a>
<a name="ln576">  {</a>
<a name="ln577">    glBindVertexArray(vertexArrayObject);</a>
<a name="ln578">    glDrawArrays(GL_TRIANGLE_STRIP, 0, 8);</a>
<a name="ln579">  }</a>
<a name="ln580"> </a>
<a name="ln581">//////////////////////////////////////////////////////////////////</a>
<a name="ln582">//////////////////////////////////////////////////////////////////</a>
<a name="ln583"> </a>
<a name="ln584">}</a>

</code></pre>
<div class="balloon" rel="392"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: m_format, m_internal_format, depthTex.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
