
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>RenderDriverHydraConnection.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#include &quot;HydraRenderDriverAPI.h&quot;</a>
<a name="ln2"> </a>
<a name="ln3">#include &lt;vector&gt;</a>
<a name="ln4">#include &lt;string&gt;</a>
<a name="ln5">#include &lt;sstream&gt;</a>
<a name="ln6">#include &lt;fstream&gt;</a>
<a name="ln7"> </a>
<a name="ln8">//#include &quot;HydraInternal.h&quot; // #TODO: this is only for hr_mkdir and hr_cleardir. Remove this further</a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;HydraLegacyUtils.h&quot;</a>
<a name="ln11"> </a>
<a name="ln12">#include &quot;HydraXMLHelpers.h&quot;</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;HR_HDRImage.h&quot;</a>
<a name="ln15">#include &quot;HydraInternal.h&quot;</a>
<a name="ln16">#include &quot;HydraObjectManager.h&quot;</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;mutex&gt;</a>
<a name="ln19">#include &lt;future&gt;</a>
<a name="ln20">#include &lt;thread&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &quot;ssemath.h&quot;</a>
<a name="ln23">#include &quot;vfloat4_x64.h&quot;</a>
<a name="ln24"> </a>
<a name="ln25"> </a>
<a name="ln26">#ifdef WIN32</a>
<a name="ln27">#include &quot;../utils/clew/clew.h&quot;</a>
<a name="ln28">#else</a>
<a name="ln29">#include &lt;CL/cl.h&gt;</a>
<a name="ln30">#endif</a>
<a name="ln31"> </a>
<a name="ln32">#pragma warning(disable:4996) // for wcscpy to be ok</a>
<a name="ln33"> </a>
<a name="ln34">static constexpr bool MODERN_DRIVER_DEBUG = false;</a>
<a name="ln35"> </a>
<a name="ln36">using HydraRender::HDRImage4f;</a>
<a name="ln37"> </a>
<a name="ln38">struct RD_HydraConnection : public IHRRenderDriver</a>
<a name="ln39">{</a>
<a name="ln40">  RD_HydraConnection();</a>
<a name="ln41"> </a>
<a name="ln42">  ~RD_HydraConnection() override</a>
<a name="ln43">  {</a>
<a name="ln44">    ClearAll();</a>
<a name="ln45">  }</a>
<a name="ln46"> </a>
<a name="ln47">  void GetRenderDriverName(std::wstring &amp;name) override { name = std::wstring(L&quot;HydraModern&quot;);};</a>
<a name="ln48">  void              ClearAll() override;</a>
<a name="ln49">  HRDriverAllocInfo AllocAll(HRDriverAllocInfo a_info) override;</a>
<a name="ln50"> </a>
<a name="ln51">  bool UpdateImage(int32_t a_texId, int32_t w, int32_t h, int32_t bpp, const void* a_data, pugi::xml_node a_texNode) override;</a>
<a name="ln52">  bool UpdateMaterial(int32_t a_matId, pugi::xml_node a_materialNode) override;</a>
<a name="ln53"> </a>
<a name="ln54">  bool UpdateLight(int32_t a_lightIdId, pugi::xml_node a_lightNode) override;</a>
<a name="ln55">  bool UpdateMesh(int32_t a_meshId, pugi::xml_node a_meshNode, const HRMeshDriverInput&amp; a_input, const HRBatchInfo* a_batchList, int32_t listSize) override;</a>
<a name="ln56"> </a>
<a name="ln57">  bool UpdateImageFromFile(int32_t a_texId, const wchar_t* a_fileName, pugi::xml_node a_texNode) override;</a>
<a name="ln58">  bool UpdateMeshFromFile(int32_t a_meshId, pugi::xml_node a_meshNode, const wchar_t* a_fileName) override;</a>
<a name="ln59"> </a>
<a name="ln60">  bool UpdateCamera(pugi::xml_node a_camNode) override;</a>
<a name="ln61">  bool UpdateSettings(pugi::xml_node a_settingsNode) override;</a>
<a name="ln62"> </a>
<a name="ln63">  /////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln64"> </a>
<a name="ln65">  void BeginScene(pugi::xml_node a_sceneNode) override;</a>
<a name="ln66">  void EndScene() override;</a>
<a name="ln67">  void InstanceMeshes(int32_t a_mesh_id, const float* a_matrices, int32_t a_instNum, const int* a_lightInstId, const int* a_remapId, const int* a_realInstId) override;</a>
<a name="ln68">  void InstanceLights(int32_t a_light_id, const float* a_matrix, pugi::xml_node* a_custAttrArray, int32_t a_instNum, int32_t a_lightGroupId) override;</a>
<a name="ln69"> </a>
<a name="ln70">  void Draw() override;</a>
<a name="ln71"> </a>
<a name="ln72">  HRRenderUpdateInfo HaveUpdateNow(int a_maxRaysPerPixel) override;</a>
<a name="ln73"> </a>
<a name="ln74">  void GetFrameBufferHDR(int32_t w, int32_t h, float*   a_out, const wchar_t* a_layerName) override;</a>
<a name="ln75">  void GetFrameBufferLDR(int32_t w, int32_t h, int32_t* a_out)                             override;</a>
<a name="ln76"> </a>
<a name="ln77">  void GetFrameBufferLineHDR(int32_t a_xBegin, int32_t a_xEnd, int32_t y, float* a_out, const wchar_t* a_layerName) override;</a>
<a name="ln78">  void GetFrameBufferLineLDR(int32_t a_xBegin, int32_t a_xEnd, int32_t y, int32_t* a_out)                           override;</a>
<a name="ln79"> </a>
<a name="ln80">  void GetGBufferLine(int32_t a_lineNumber, HRGBufferPixel* a_lineData, int32_t a_startX, int32_t a_endX, const std::unordered_set&lt;int32_t&gt;&amp; a_shadowCatchers) override;</a>
<a name="ln81">  </a>
<a name="ln82">  void    LockFrameBufferUpdate()   override;</a>
<a name="ln83">  void    UnlockFrameBufferUpdate() override;</a>
<a name="ln84">  </a>
<a name="ln85">  // info and devices</a>
<a name="ln86">  //</a>
<a name="ln87">  const HRRenderDeviceInfoListElem* DeviceList() const override;</a>
<a name="ln88">  bool EnableDevice(int32_t id, bool a_enable) override;</a>
<a name="ln89"> </a>
<a name="ln90">  void ExecuteCommand(const wchar_t* a_cmd, wchar_t* a_out) override;</a>
<a name="ln91">  void EndFlush() override;</a>
<a name="ln92"> </a>
<a name="ln93">  void SetLogDir(const wchar_t* a_logDir, bool a_hideCmd) override;</a>
<a name="ln94"> </a>
<a name="ln95">protected:</a>
<a name="ln96"> </a>
<a name="ln97">  std::wstring m_libPath;</a>
<a name="ln98">  std::wstring m_libFileState;</a>
<a name="ln99">  std::wstring m_logFolder;</a>
<a name="ln100">  std::string  m_logFolderS;</a>
<a name="ln101">  std::string  m_lastSharedImageName;</a>
<a name="ln102">  </a>
<a name="ln103">  int          m_instancesNum; //// current instance num in the scene; (m_instancesNum == 0) =&gt; empty scene!</a>
<a name="ln104">  int          m_oldCounter;</a>
<a name="ln105">  float        m_oldSPP;</a>
<a name="ln106">  int          m_clewInitRes;</a>
<a name="ln107">  bool         m_dontRun;</a>
<a name="ln108"> </a>
<a name="ln109">  void InitBothDeviceList();</a>
<a name="ln110">  void CreateAndClearSharedImage();</a>
<a name="ln111">  void RunAllHydraHeads();</a>
<a name="ln112">  void RunSingleHydraHead(const char* a_cmdLine);</a>
<a name="ln113"> </a>
<a name="ln114">  std::vector&lt;int&gt; GetCurrDeviceList();</a>
<a name="ln115">  std::string MakeRenderCommandLine(const std::string&amp; hydraImageName) const;</a>
<a name="ln116">  int GetCurrSharedImageLayersNum();</a>
<a name="ln117"> </a>
<a name="ln118">  RenderProcessRunParams GetCurrRunProcessParams();</a>
<a name="ln119"> </a>
<a name="ln120">  HRDriverAllocInfo m_currAllocInfo;</a>
<a name="ln121"> </a>
<a name="ln122">  IHydraNetPluginAPI*                  m_pConnection;</a>
<a name="ln123">  IHRSharedAccumImage*                 m_pSharedImage;</a>
<a name="ln124"> </a>
<a name="ln125">  std::vector&lt;HydraRenderDevice&gt;          m_devList;</a>
<a name="ln126">  std::vector&lt;HRRenderDeviceInfoListElem&gt; m_devList2;</a>
<a name="ln127"> </a>
<a name="ln128">  float m_progressVal;</a>
<a name="ln129">  RenderProcessRunParams m_params;</a>
<a name="ln130"> </a>
<a name="ln131">  bool m_enableMLT = false;</a>
<a name="ln132">  bool m_hideCmd   = false;</a>
<a name="ln133">  bool m_needGbuff = false;</a>
<a name="ln134"> </a>
<a name="ln135">  struct RenderPresets</a>
<a name="ln136">  {</a>
<a name="ln137">    int  maxrays;</a>
<a name="ln138">    bool allocImageB;</a>
<a name="ln139">    bool allocImageBOnGPU;</a>
<a name="ln140">    int   mmltThreads;</a>
<a name="ln141">    float mmltMultBrightness;</a>
<a name="ln142">    </a>
<a name="ln143">    float mlt_med_threshold;</a>
<a name="ln144">    bool  mlt_med_enable;</a>
<a name="ln145">  } m_presets;</a>
<a name="ln146"> </a>
<a name="ln147">  bool m_firstUpdate;</a>
<a name="ln148"> </a>
<a name="ln149">  int m_width;</a>
<a name="ln150">  int m_height;</a>
<a name="ln151"> </a>
<a name="ln152">  float m_avgBrightness;</a>
<a name="ln153">  int   m_avgBCounter;</a>
<a name="ln154"> </a>
<a name="ln155">  bool  m_enableMedianFilter;</a>
<a name="ln156">  float m_medianthreshold;</a>
<a name="ln157"> </a>
<a name="ln158">  bool m_stopThreadImmediately;</a>
<a name="ln159">  bool m_threadIsRun;</a>
<a name="ln160">  bool m_threadFinished;</a>
<a name="ln161">  bool haveUpdateFromMT;</a>
<a name="ln162">  bool hadFinalUpdate;</a>
<a name="ln163"> </a>
<a name="ln164">  // MLT/MMLT asynchronous frame buffer update</a>
<a name="ln165">  //</a>
<a name="ln166">  HydraRender::HDRImage4f m_colorMLTFinalImage;</a>
<a name="ln167">  std::future&lt;int&gt;        m_mltFrameBufferUpdateThread;</a>
<a name="ln168">  bool                    m_mltFrameBufferUpdate_ExitNow;</a>
<a name="ln169">  int                     m_lastMaxRaysPerPixel;</a>
<a name="ln170">  std::atomic&lt;bool&gt;       m_colorImageIsLocked;</a>
<a name="ln171"> </a>
<a name="ln172">  int MLT_FrameBufferUpdateLoop();</a>
<a name="ln173"> </a>
<a name="ln174">};</a>
<a name="ln175"> </a>
<a name="ln176">static inline float contribFunc(float colorX, float colorY, float colorZ)</a>
<a name="ln177">{</a>
<a name="ln178">  return fmax(0.33334f*(colorX + colorY + colorZ), 0.0f);</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">using namespace cvex;</a>
<a name="ln182"> </a>
<a name="ln183">int RD_HydraConnection::MLT_FrameBufferUpdateLoop()</a>
<a name="ln184">{</a>
<a name="ln185">  m_colorImageIsLocked = false;</a>
<a name="ln186">  </a>
<a name="ln187">  size_t iter = 0;</a>
<a name="ln188"> </a>
<a name="ln189">  const float* indirect = m_pSharedImage-&gt;ImageData(0);</a>
<a name="ln190">  const float* direct   = m_pSharedImage-&gt;ImageData(1);</a>
<a name="ln191"> </a>
<a name="ln192">  while(!m_mltFrameBufferUpdate_ExitNow)</a>
<a name="ln193">  {</a>
<a name="ln194">    std::this_thread::sleep_for(std::chrono::milliseconds(500));</a>
<a name="ln195"> </a>
<a name="ln196">    if(m_mltFrameBufferUpdate_ExitNow)</a>
<a name="ln197">      break;</a>
<a name="ln198"> </a>
<a name="ln199">    if(!HaveUpdateNow(m_lastMaxRaysPerPixel).haveUpdateFB)</a>
<a name="ln200">      continue;</a>
<a name="ln201"> </a>
<a name="ln202">    double summ[3];</a>
<a name="ln203">    std::tie(summ[0], summ[1], summ[2]) = HydraRender::ColorSummImage4f(indirect, m_width, m_height);</a>
<a name="ln204">    double avgDiv       = 1.0/double(m_width*m_height);</a>
<a name="ln205">	float avgBrightness = contribFunc(float(avgDiv*summ[0]), float(avgDiv*summ[1]), float(avgDiv*summ[2]));</a>
<a name="ln206">    </a>
<a name="ln207">    // calc normalisation constant</a>
<a name="ln208">    //</a>
<a name="ln209">    const float normC   = m_pSharedImage-&gt;Header()-&gt;avgImageB / fmax(avgBrightness, 1e-30f) * m_presets.mmltMultBrightness;</a>
<a name="ln210">    const float normDL  = 1.0f/float(m_pSharedImage-&gt;Header()-&gt;spp);</a>
<a name="ln211">  </a>
<a name="ln212">    const cvex::vfloat4 normDL4 = {normDL, normDL, normDL, 0.0f};</a>
<a name="ln213">    const cvex::vfloat4 normC4  = {normC,  normC,  normC,  0.0f};</a>
<a name="ln214">  </a>
<a name="ln215">    const size_t imagesize = m_colorMLTFinalImage.width()*m_colorMLTFinalImage.height()*4;</a>
<a name="ln216">    float* dataOut = m_colorMLTFinalImage.data();</a>
<a name="ln217">  </a>
<a name="ln218">    while(m_colorImageIsLocked); // wait for use to free framebuffer</a>
<a name="ln219">    m_colorImageIsLocked = true;</a>
<a name="ln220">    </a>
<a name="ln221">    if(m_presets.mlt_med_enable)</a>
<a name="ln222">    {</a>
<a name="ln223">      for(size_t i=0; i&lt;imagesize; i+=4)</a>
<a name="ln224">      {</a>
<a name="ln225">        const cvex::vfloat4 RGB0 = cvex::load_u(indirect + i)*normC4;</a>
<a name="ln226">        cvex::store(dataOut + i, RGB0);</a>
<a name="ln227">      }</a>
<a name="ln228">      </a>
<a name="ln229">      m_colorMLTFinalImage.medianFilterInPlace(m_presets.mlt_med_threshold);</a>
<a name="ln230">      </a>
<a name="ln231">      for(size_t i=0; i&lt;imagesize; i+=4)</a>
<a name="ln232">      {</a>
<a name="ln233">        const cvex::vfloat4 RGB0 = cvex::load(dataOut+i) + cvex::load_u(direct+i)*normDL4;</a>
<a name="ln234">        cvex::store(dataOut + i, RGB0);</a>
<a name="ln235">      }</a>
<a name="ln236">    }</a>
<a name="ln237">    else</a>
<a name="ln238">    {</a>
<a name="ln239">      for(size_t i=0; i&lt;imagesize; i+=4)</a>
<a name="ln240">      {</a>
<a name="ln241">        const cvex::vfloat4 RGB0 = cvex::load_u(direct+i)*normDL4 + cvex::load_u(indirect+i)*normC4;</a>
<a name="ln242">        cvex::store(dataOut + i, RGB0);</a>
<a name="ln243">      }</a>
<a name="ln244">    }</a>
<a name="ln245">    m_colorImageIsLocked = false;</a>
<a name="ln246">    </a>
<a name="ln247">    iter++;</a>
<a name="ln248">  }</a>
<a name="ln249"> </a>
<a name="ln250">  std::cout &lt;&lt; &quot;exit from MLT_FrameBufferUpdateLoop&quot; &lt;&lt; std::endl;</a>
<a name="ln251">  std::cout.flush();</a>
<a name="ln252"> </a>
<a name="ln253">  return 0;</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln257">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln258">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln259">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln260"> </a>
<a name="ln261">struct PlatformDevPair</a>
<a name="ln262">{</a>
<a name="ln263">  PlatformDevPair(cl_device_id a_dev, cl_platform_id a_platform) : dev(a_dev), platform(a_platform) {}</a>
<a name="ln264"> </a>
<a name="ln265">  cl_device_id   dev;</a>
<a name="ln266">  cl_platform_id platform;</a>
<a name="ln267">};</a>
<a name="ln268"> </a>
<a name="ln269">static std::string cutSpaces(const std::string&amp; a_rhs)</a>
<a name="ln270">{</a>
<a name="ln271">  int pos = 0;</a>
<a name="ln272">  for (int i = 0; i &lt; a_rhs.size(); i++)</a>
<a name="ln273">  {</a>
<a name="ln274">    if (a_rhs[i] != ' ')</a>
<a name="ln275">      break;</a>
<a name="ln276">    pos++;</a>
<a name="ln277">  }</a>
<a name="ln278"> </a>
<a name="ln279">  return a_rhs.substr(pos, a_rhs.size() - pos);</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">static std::vector&lt;PlatformDevPair&gt; listAllOpenCLDevices()</a>
<a name="ln283">{</a>
<a name="ln284">  const int MAXPLATFORMS = 4;</a>
<a name="ln285">  const int MAXDEVICES_PER_PLATFORM = 8;</a>
<a name="ln286"> </a>
<a name="ln287">  cl_platform_id platforms[MAXPLATFORMS];</a>
<a name="ln288">  cl_device_id   devices[MAXDEVICES_PER_PLATFORM];</a>
<a name="ln289"> </a>
<a name="ln290">  cl_uint factPlatroms = 0;</a>
<a name="ln291">  cl_uint factDevs = 0;</a>
<a name="ln292"> </a>
<a name="ln293">  std::vector&lt;PlatformDevPair&gt; result;</a>
<a name="ln294"> </a>
<a name="ln295">  clGetPlatformIDs(MAXPLATFORMS, platforms, &amp;factPlatroms);</a>
<a name="ln296"> </a>
<a name="ln297">  for (size_t i = 0; i &lt; factPlatroms; i++)</a>
<a name="ln298">  {</a>
<a name="ln299">    clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_ALL, MAXDEVICES_PER_PLATFORM, devices, &amp;factDevs);</a>
<a name="ln300">    for (cl_uint j = 0; j &lt; factDevs; j++)</a>
<a name="ln301">      result.push_back(PlatformDevPair(devices[j], platforms[i]));</a>
<a name="ln302">  }</a>
<a name="ln303"> </a>
<a name="ln304">  return result;</a>
<a name="ln305"> </a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308">void RD_HydraConnection::InitBothDeviceList()</a>
<a name="ln309">{</a>
<a name="ln310">#ifdef WIN32</a>
<a name="ln311">  if (m_clewInitRes == -1)</a>
<a name="ln312">  {</a>
<a name="ln313">    m_clewInitRes = clewInit(L&quot;opencl.dll&quot;);</a>
<a name="ln314">    if (m_clewInitRes == -1)</a>
<a name="ln315">    {</a>
<a name="ln316">      // HydraRenderDevice cpuDev; #TODO: add CPU &quot;-1&quot; dev when it will work</a>
<a name="ln317">      m_devList.resize(0);</a>
<a name="ln318">      m_devList2.resize(0);</a>
<a name="ln319">      return;</a>
<a name="ln320">    }</a>
<a name="ln321">  }</a>
<a name="ln322">#endif</a>
<a name="ln323"> </a>
<a name="ln324">  // (1) get device list and info</a>
<a name="ln325">  //</a>
<a name="ln326">  const std::vector&lt;PlatformDevPair&gt; devList = listAllOpenCLDevices();</a>
<a name="ln327">  m_devList.resize(devList.size());</a>
<a name="ln328">  char deviceName[1024];</a>
<a name="ln329"> </a>
<a name="ln330">  for (size_t i = 0; i &lt; devList.size(); i++)</a>
<a name="ln331">  {</a>
<a name="ln332">    memset(deviceName, 0, 1024);</a>
<a name="ln333">    clGetDeviceInfo(devList[i].dev, CL_DEVICE_NAME, 1024, deviceName, nullptr);</a>
<a name="ln334">    std::string devName2 = cutSpaces(deviceName);</a>
<a name="ln335">    m_devList[i].name    = s2ws(devName2);</a>
<a name="ln336"> </a>
<a name="ln337">    cl_device_type devType = CL_DEVICE_TYPE_GPU;</a>
<a name="ln338">    clGetDeviceInfo(devList[i].dev, CL_DEVICE_TYPE, sizeof(cl_device_type), &amp;devType, nullptr);</a>
<a name="ln339">    m_devList[i].isCPU = (devType == CL_DEVICE_TYPE_CPU);</a>
<a name="ln340"> </a>
<a name="ln341">    memset(deviceName, 0, 1024);</a>
<a name="ln342">    clGetPlatformInfo(devList[i].platform, CL_PLATFORM_VERSION, 1024, deviceName, nullptr);</a>
<a name="ln343">    m_devList[i].driverName = s2ws(deviceName);</a>
<a name="ln344">    m_devList[i].id         = int(i);</a>
<a name="ln345">  }</a>
<a name="ln346"> </a>
<a name="ln347">  // (2) form list in memory ... )</a>
<a name="ln348">  //</a>
<a name="ln349">  m_devList2.resize(m_devList.size()); </a>
<a name="ln350">  for (size_t i = 0; i &lt; m_devList2.size(); i++)</a>
<a name="ln351">  {</a>
<a name="ln352">    const HydraRenderDevice&amp;       devInfo = m_devList[i];</a>
<a name="ln353">    HRRenderDeviceInfoListElem* pListElem = &amp;m_devList2[i];</a>
<a name="ln354">  </a>
<a name="ln355">    pListElem-&gt;id        = (int32_t)(i);</a>
<a name="ln356">    pListElem-&gt;isCPU     = devInfo.isCPU;</a>
<a name="ln357">    pListElem-&gt;isEnabled = false;</a>
<a name="ln358">  </a>
<a name="ln359">    wcscpy(pListElem-&gt;name,   devInfo.name.c_str());</a>
<a name="ln360">    wcscpy(pListElem-&gt;driver, devInfo.driverName.c_str());</a>
<a name="ln361">  </a>
<a name="ln362">    if (i != m_devList2.size() - 1)</a>
<a name="ln363">      pListElem-&gt;next = &amp;m_devList2[i + 1];</a>
<a name="ln364">    else</a>
<a name="ln365">      pListElem-&gt;next = nullptr;</a>
<a name="ln366">  }</a>
<a name="ln367">}</a>
<a name="ln368"> </a>
<a name="ln369">IHRRenderDriver* CreateHydraConnection_RenderDriver()</a>
<a name="ln370">{</a>
<a name="ln371">  return new RD_HydraConnection;</a>
<a name="ln372">}</a>
<a name="ln373"> </a>
<a name="ln374"> </a>
<a name="ln375">RD_HydraConnection::RD_HydraConnection() : m_pConnection(nullptr), m_pSharedImage(nullptr), m_progressVal(0.0f), m_firstUpdate(true), m_width(0), m_height(0),</a>
<a name="ln376">                       m_avgBrightness(0.0f), m_avgBCounter(0), m_enableMedianFilter(false), m_medianthreshold(0.4f), m_stopThreadImmediately(false),</a>
<a name="ln377">                       haveUpdateFromMT(false), m_threadIsRun(false), m_threadFinished(false), hadFinalUpdate(false), m_clewInitRes(-1), m_instancesNum(0),</a>
<a name="ln378">                       m_colorImageIsLocked(false)</a>
<a name="ln379">{</a>
<a name="ln380">  InitBothDeviceList();</a>
<a name="ln381"> </a>
<a name="ln382">  m_oldCounter = 0;</a>
<a name="ln383">  m_oldSPP     = 0.0f;</a>
<a name="ln384">  m_dontRun    = false;</a>
<a name="ln385">  //#TODO: init m_presets</a>
<a name="ln386"> </a>
<a name="ln387">  HydraSSE::exp2_init();</a>
<a name="ln388">  HydraSSE::log2_init();</a>
<a name="ln389">}</a>
<a name="ln390"> </a>
<a name="ln391">void RD_HydraConnection::ClearAll()</a>
<a name="ln392">{</a>
<a name="ln393">  delete m_pConnection;</a>
<a name="ln394">  m_pConnection = nullptr;</a>
<a name="ln395"> </a>
<a name="ln396">  delete m_pSharedImage;</a>
<a name="ln397">  m_pSharedImage = nullptr;</a>
<a name="ln398"> </a>
<a name="ln399">  m_presets.maxrays          = 2048;</a>
<a name="ln400">  m_presets.allocImageB      = false;</a>
<a name="ln401">  m_presets.allocImageBOnGPU = false;</a>
<a name="ln402"> </a>
<a name="ln403">}</a>
<a name="ln404"> </a>
<a name="ln405">HRDriverAllocInfo RD_HydraConnection::AllocAll(HRDriverAllocInfo a_info)</a>
<a name="ln406">{</a>
<a name="ln407">  m_libPath = std::wstring(a_info.libraryPath);</a>
<a name="ln408">  if(a_info.stateFileName == nullptr)</a>
<a name="ln409">    m_libFileState = L&quot;&quot;;</a>
<a name="ln410">  else</a>
<a name="ln411">    m_libFileState = std::wstring(a_info.stateFileName);</a>
<a name="ln412">  </a>
<a name="ln413">  m_currAllocInfo = a_info;</a>
<a name="ln414">  return m_currAllocInfo;</a>
<a name="ln415">}</a>
<a name="ln416"> </a>
<a name="ln417">const HRRenderDeviceInfoListElem* RD_HydraConnection::DeviceList() const</a>
<a name="ln418">{</a>
<a name="ln419">  if (m_devList2.empty())</a>
<a name="ln420">    return nullptr;</a>
<a name="ln421">  else</a>
<a name="ln422">    return m_devList2.data();</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425">bool RD_HydraConnection::EnableDevice(int32_t id, bool a_enable)</a>
<a name="ln426">{</a>
<a name="ln427">  int devNumTotal = 0;</a>
<a name="ln428">  const auto* devList = DeviceList();</a>
<a name="ln429"> </a>
<a name="ln430">  while (devList != nullptr)</a>
<a name="ln431">  {</a>
<a name="ln432">    devNumTotal++;</a>
<a name="ln433">    devList = devList-&gt;next;</a>
<a name="ln434">  }</a>
<a name="ln435"> </a>
<a name="ln436">  if (id &gt;= devNumTotal)</a>
<a name="ln437">    return false;</a>
<a name="ln438"> </a>
<a name="ln439">  if (id &lt; m_devList2.size())</a>
<a name="ln440">    m_devList2[id].isEnabled = a_enable;</a>
<a name="ln441"> </a>
<a name="ln442">  return true;</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445"> </a>
<a name="ln446">void RD_HydraConnection::SetLogDir(const wchar_t* a_logDir, bool a_hideCmd)</a>
<a name="ln447">{</a>
<a name="ln448">  m_logFolder  = a_logDir;</a>
<a name="ln449">  m_logFolderS = ws2s(m_logFolder);</a>
<a name="ln450"> </a>
<a name="ln451">  const std::wstring check = s2ws(m_logFolderS);</a>
<a name="ln452">  if (m_logFolder != check)</a>
<a name="ln453">  {</a>
<a name="ln454">    if (m_pInfoCallBack != nullptr)</a>
<a name="ln455">      m_pInfoCallBack(L&quot;bad log dir&quot;, L&quot;RD_HydraConnection::SetLogDir&quot;, HR_SEVERITY_WARNING);</a>
<a name="ln456">  }</a>
<a name="ln457">  m_hideCmd = a_hideCmd;</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln461">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln462">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln463">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln464"> </a>
<a name="ln465"> </a>
<a name="ln466">bool RD_HydraConnection::UpdateImage(int32_t a_texId, int32_t w, int32_t h, int32_t bpp, const void* a_data, pugi::xml_node a_texNode)</a>
<a name="ln467">{</a>
<a name="ln468">  return true;</a>
<a name="ln469">}</a>
<a name="ln470"> </a>
<a name="ln471">bool RD_HydraConnection::UpdateImageFromFile(int32_t a_texId, const wchar_t* a_fileName, pugi::xml_node a_texNode)</a>
<a name="ln472">{</a>
<a name="ln473">  return true;</a>
<a name="ln474">}</a>
<a name="ln475"> </a>
<a name="ln476">bool RD_HydraConnection::UpdateMaterial(int32_t a_matId, pugi::xml_node a_materialNode)</a>
<a name="ln477">{</a>
<a name="ln478">  return true;</a>
<a name="ln479">}</a>
<a name="ln480"> </a>
<a name="ln481">bool RD_HydraConnection::UpdateLight(int32_t a_lightIdId, pugi::xml_node a_lightNode)</a>
<a name="ln482">{</a>
<a name="ln483">  return true;</a>
<a name="ln484">}</a>
<a name="ln485"> </a>
<a name="ln486">bool RD_HydraConnection::UpdateMesh(int32_t a_meshId, pugi::xml_node a_meshNode, const HRMeshDriverInput&amp; a_input, const HRBatchInfo* a_batchList, int32_t listSize)</a>
<a name="ln487">{</a>
<a name="ln488">  return true;</a>
<a name="ln489">}</a>
<a name="ln490"> </a>
<a name="ln491">bool RD_HydraConnection::UpdateMeshFromFile(int32_t a_meshId, pugi::xml_node a_meshNode, const wchar_t* a_fileName)</a>
<a name="ln492">{</a>
<a name="ln493">  return false;</a>
<a name="ln494">}</a>
<a name="ln495"> </a>
<a name="ln496">bool RD_HydraConnection::UpdateCamera(pugi::xml_node a_camNode)</a>
<a name="ln497">{</a>
<a name="ln498">  return true;</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501"> </a>
<a name="ln502">bool RD_HydraConnection::UpdateSettings(pugi::xml_node a_settingsNode)</a>
<a name="ln503">{</a>
<a name="ln504">  m_width     = a_settingsNode.child(L&quot;width&quot;).text().as_int();</a>
<a name="ln505">  m_height    = a_settingsNode.child(L&quot;height&quot;).text().as_int();</a>
<a name="ln506"> </a>
<a name="ln507">  m_needGbuff = (std::wstring(a_settingsNode.child(L&quot;evalgbuffer&quot;).text().as_string()) == L&quot;1&quot;);</a>
<a name="ln508"> </a>
<a name="ln509">  m_presets.maxrays     = a_settingsNode.child(L&quot;maxRaysPerPixel&quot;).text().as_int();</a>
<a name="ln510"> </a>
<a name="ln511">  m_presets.allocImageB = (std::wstring(a_settingsNode.child(L&quot;method_secondary&quot;).text().as_string()) == L&quot;lighttracing&quot;) || </a>
<a name="ln512">                          (std::wstring(a_settingsNode.child(L&quot;method_primary&quot;).text().as_string())   == L&quot;lighttracing&quot;) || </a>
<a name="ln513">                          (std::wstring(a_settingsNode.child(L&quot;method_primary&quot;).text().as_string())   == L&quot;IBPT&quot;) || </a>
<a name="ln514">                          (std::wstring(a_settingsNode.child(L&quot;method_secondary&quot;).text().as_string()) == L&quot;IBPT&quot;);</a>
<a name="ln515"> </a>
<a name="ln516">  m_presets.allocImageBOnGPU = (std::wstring(a_settingsNode.child(L&quot;forceGPUFrameBuffer&quot;).text().as_string()) == L&quot;1&quot;);</a>
<a name="ln517"> </a>
<a name="ln518">  std::wstring tmp  = std::wstring(a_settingsNode.child(L&quot;render_exe_dir&quot;).text().as_string());</a>
<a name="ln519">  if(!tmp.empty())</a>
<a name="ln520">    m_params.customExePath = std::string(tmp.begin(), tmp.end());</a>
<a name="ln521"> </a>
<a name="ln522">  if(a_settingsNode.child(L&quot;dont_run&quot;).text().as_int() == 1)</a>
<a name="ln523">    m_dontRun = true;</a>
<a name="ln524">  else</a>
<a name="ln525">    m_dontRun = false;</a>
<a name="ln526"> </a>
<a name="ln527">  m_enableMLT = false;</a>
<a name="ln528">  if(a_settingsNode.child(L&quot;method_secondary&quot;) != nullptr)</a>
<a name="ln529">  {</a>
<a name="ln530">    if (std::wstring(a_settingsNode.child(L&quot;method_secondary&quot;).text().as_string()) == L&quot;mmlt&quot; ||</a>
<a name="ln531">        std::wstring(a_settingsNode.child(L&quot;method_secondary&quot;).text().as_string()) == L&quot;mlt&quot;)</a>
<a name="ln532">      m_enableMLT = true;</a>
<a name="ln533">  }</a>
<a name="ln534"> </a>
<a name="ln535">  if (a_settingsNode.child(L&quot;mmlt_threads&quot;) != nullptr)</a>
<a name="ln536">    m_presets.mmltThreads = a_settingsNode.child(L&quot;mmlt_threads&quot;).text().as_int();</a>
<a name="ln537">  else</a>
<a name="ln538">    m_presets.mmltThreads = 0;</a>
<a name="ln539"> </a>
<a name="ln540">  if (a_settingsNode.child(L&quot;mmlt_multBrightness&quot;) != nullptr)</a>
<a name="ln541">    m_presets.mmltMultBrightness = a_settingsNode.child(L&quot;mmlt_multBrightness&quot;).text().as_float();</a>
<a name="ln542">  else</a>
<a name="ln543">    m_presets.mmltMultBrightness = 1.0f;</a>
<a name="ln544">  </a>
<a name="ln545">  // mlt median filter</a>
<a name="ln546">  //</a>
<a name="ln547">  if (a_settingsNode.child(L&quot;mlt_med_threshold&quot;) != nullptr)</a>
<a name="ln548">    m_presets.mlt_med_threshold = a_settingsNode.child(L&quot;mlt_med_threshold&quot;).text().as_float();</a>
<a name="ln549">  else</a>
<a name="ln550">    m_presets.mlt_med_threshold = 0.4f;</a>
<a name="ln551">  </a>
<a name="ln552">  if (a_settingsNode.child(L&quot;mlt_med_enable&quot;) != nullptr)</a>
<a name="ln553">    m_presets.mlt_med_enable = a_settingsNode.child(L&quot;mlt_med_enable&quot;).text().as_bool();</a>
<a name="ln554">  else</a>
<a name="ln555">    m_presets.mlt_med_enable = false;</a>
<a name="ln556">  </a>
<a name="ln557">  return true;</a>
<a name="ln558">}</a>
<a name="ln559"> </a>
<a name="ln560"> </a>
<a name="ln561">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln562">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln563">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln564">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln565"> </a>
<a name="ln566">std::wstring GetAbsolutePath(const std::wstring&amp; a_path);</a>
<a name="ln567"> </a>
<a name="ln568">std::vector&lt;int&gt; RD_HydraConnection::GetCurrDeviceList()</a>
<a name="ln569">{</a>
<a name="ln570">  std::vector&lt;int&gt; devList;</a>
<a name="ln571">  </a>
<a name="ln572">  for (const auto&amp; dev : m_devList2)</a>
<a name="ln573">  {</a>
<a name="ln574">    if (dev.isEnabled)</a>
<a name="ln575">      devList.push_back(dev.id);</a>
<a name="ln576">  }</a>
<a name="ln577">  </a>
<a name="ln578">  if (devList.empty())</a>
<a name="ln579">  {</a>
<a name="ln580">    devList.resize(1);</a>
<a name="ln581">    devList[0] = 0;</a>
<a name="ln582">    </a>
<a name="ln583">    if (m_pInfoCallBack != nullptr)</a>
<a name="ln584">      m_pInfoCallBack(L&quot;No device was selected; will use device 0 by default&quot;, L&quot;RD_HydraConnection::GetCurrDeviceList()&quot;, HR_SEVERITY_WARNING);</a>
<a name="ln585">  }</a>
<a name="ln586">  </a>
<a name="ln587">  return devList;</a>
<a name="ln588">}</a>
<a name="ln589"> </a>
<a name="ln590">std::string NewSharedImageName()</a>
<a name="ln591">{</a>
<a name="ln592">  auto currtime = std::chrono::system_clock::now();</a>
<a name="ln593">  auto now_ms   = std::chrono::time_point_cast&lt;std::chrono::milliseconds&gt;(currtime).time_since_epoch().count();</a>
<a name="ln594">  std::stringstream nameStream;</a>
<a name="ln595">  nameStream &lt;&lt; &quot;hydraimage_&quot; &lt;&lt; now_ms;</a>
<a name="ln596">  return nameStream.str();</a>
<a name="ln597">}</a>
<a name="ln598"> </a>
<a name="ln599">std::string RD_HydraConnection::MakeRenderCommandLine(const std::string&amp; hydraImageName) const </a>
<a name="ln600">{</a>
<a name="ln601">  const int  width       = m_width;</a>
<a name="ln602">  const int  height      = m_height;</a>
<a name="ln603">  const bool needGBuffer = m_needGbuff;</a>
<a name="ln604">  </a>
<a name="ln605">  const std::wstring libPath = GetAbsolutePath(m_libPath);</a>
<a name="ln606">  std::string temp = ws2s(libPath);</a>
<a name="ln607">  std::stringstream auxInput;</a>
<a name="ln608">  auxInput &lt;&lt; &quot;-inputlib \&quot;&quot; &lt;&lt; temp.c_str() &lt;&lt; &quot;\&quot; -width &quot; &lt;&lt; width &lt;&lt; &quot; -height &quot; &lt;&lt; height &lt;&lt; &quot; &quot;;</a>
<a name="ln609">  </a>
<a name="ln610">  if (m_presets.allocImageB)          // this is needed for LT and IBPT</a>
<a name="ln611">    auxInput &lt;&lt; &quot;-alloc_image_b 1 &quot;;  // this is needed for LT and IBPT</a>
<a name="ln612">  </a>
<a name="ln613">  if(m_presets.allocImageBOnGPU)</a>
<a name="ln614">    auxInput &lt;&lt; &quot;-cpu_fb 0 &quot;;</a>
<a name="ln615">  else</a>
<a name="ln616">    auxInput &lt;&lt; &quot;-cpu_fb 1 &quot;;</a>
<a name="ln617">  </a>
<a name="ln618">  if (m_enableMLT)</a>
<a name="ln619">  {</a>
<a name="ln620">    auxInput &lt;&lt; &quot;-enable_mlt 1 &quot;;</a>
<a name="ln621">    if (m_presets.mmltThreads != 0)</a>
<a name="ln622">      auxInput &lt;&lt; &quot;-mmltthreads &quot; &lt;&lt; m_presets.mmltThreads &lt;&lt; &quot; &quot;;</a>
<a name="ln623">  }</a>
<a name="ln624"> </a>
<a name="ln625">  if (needGBuffer)</a>
<a name="ln626">    auxInput &lt;&lt; &quot;-evalgbuffer 1 &quot;;</a>
<a name="ln627">  </a>
<a name="ln628">  auxInput &lt;&lt; &quot;-sharedimage &quot; &lt;&lt; hydraImageName.c_str() &lt;&lt; &quot; &quot;;</a>
<a name="ln629">  </a>
<a name="ln630">  return auxInput.str();</a>
<a name="ln631">}</a>
<a name="ln632"> </a>
<a name="ln633">int RD_HydraConnection::GetCurrSharedImageLayersNum()</a>
<a name="ln634">{</a>
<a name="ln635">  const bool runMLT      = m_enableMLT;</a>
<a name="ln636">  const bool needGBuffer = m_needGbuff;</a>
<a name="ln637"> </a>
<a name="ln638">  int layersNum;</a>
<a name="ln639">  if (runMLT &amp;&amp; needGBuffer)</a>
<a name="ln640">    layersNum = 4;</a>
<a name="ln641">  else if (needGBuffer)</a>
<a name="ln642">    layersNum = 3;</a>
<a name="ln643">  else if (runMLT)</a>
<a name="ln644">    layersNum = 2;</a>
<a name="ln645">  else</a>
<a name="ln646">    layersNum = 1;</a>
<a name="ln647"> </a>
<a name="ln648">  return layersNum;</a>
<a name="ln649">}</a>
<a name="ln650"> </a>
<a name="ln651">void RD_HydraConnection::CreateAndClearSharedImage()</a>
<a name="ln652">{</a>
<a name="ln653">  ////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln654"> </a>
<a name="ln655">  const std::string hydraImageName = NewSharedImageName();</a>
<a name="ln656">  const std::vector&lt;int&gt; devList   = GetCurrDeviceList();</a>
<a name="ln657"> </a>
<a name="ln658">  const bool needGBuffer = m_needGbuff;</a>
<a name="ln659">  const int layersNum    = GetCurrSharedImageLayersNum();</a>
<a name="ln660"> </a>
<a name="ln661">  ////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln662"> </a>
<a name="ln663">  if (m_pSharedImage == nullptr)</a>
<a name="ln664">    m_pSharedImage = CreateImageAccum();</a>
<a name="ln665">  else</a>
<a name="ln666">    m_pSharedImage-&gt;Clear();</a>
<a name="ln667"> </a>
<a name="ln668">  if (m_pSharedImage == nullptr)</a>
<a name="ln669">  {</a>
<a name="ln670">    //#TODO: call error callback or do some thing like that</a>
<a name="ln671">    return;</a>
<a name="ln672">  }</a>
<a name="ln673"> </a>
<a name="ln674">  char err[256];</a>
<a name="ln675">  </a>
<a name="ln676">  const bool shmemImageIsOk = m_pSharedImage-&gt;Create(m_width, m_height, layersNum, hydraImageName.c_str(), err); // #TODO: change this and pass via cmd line</a>
<a name="ln677">  </a>
<a name="ln678">  if (!shmemImageIsOk)</a>
<a name="ln679">  {</a>
<a name="ln680">    //#TODO: call error callback or do some thing like that</a>
<a name="ln681">    return;</a>
<a name="ln682">  }</a>
<a name="ln683"> </a>
<a name="ln684">  m_oldSPP     = 0.0f;</a>
<a name="ln685">  m_oldCounter = 0;</a>
<a name="ln686"> </a>
<a name="ln687">  m_pSharedImage-&gt;Header()-&gt;spp        = 0.0f;</a>
<a name="ln688">  m_pSharedImage-&gt;Header()-&gt;counterRcv = 0;</a>
<a name="ln689">  m_pSharedImage-&gt;Header()-&gt;counterSnd = 0;</a>
<a name="ln690">  m_pSharedImage-&gt;Header()-&gt;gbufferIsEmpty = needGBuffer ? 1 : -1;</a>
<a name="ln691"> </a>
<a name="ln692">  strncpy(m_pSharedImage-&gt;MessageSendData(), &quot;-layer color -action wait &quot;, 256); // #TODO: (sid, mid) !!!</a>
<a name="ln693">  m_pSharedImage-&gt;Header()-&gt;counterSnd++;</a>
<a name="ln694"> </a>
<a name="ln695">  m_lastSharedImageName = hydraImageName;</a>
<a name="ln696"> </a>
<a name="ln697">  delete m_pConnection;</a>
<a name="ln698">  m_pConnection = CreateHydraServerConnection(m_width, m_height, false);</a>
<a name="ln699">}</a>
<a name="ln700"> </a>
<a name="ln701">RenderProcessRunParams RD_HydraConnection::GetCurrRunProcessParams()</a>
<a name="ln702">{</a>
<a name="ln703">  RenderProcessRunParams params;</a>
<a name="ln704"> </a>
<a name="ln705">  params.compileShaders    = false;</a>
<a name="ln706">  params.debug             = MODERN_DRIVER_DEBUG;</a>
<a name="ln707">  params.enableMLT         = m_enableMLT;</a>
<a name="ln708">  params.normalPriorityCPU = false;</a>
<a name="ln709">  params.showConsole       = !m_hideCmd;</a>
<a name="ln710"> </a>
<a name="ln711">  params.customExePath     = m_params.customExePath;</a>
<a name="ln712">  params.customExeArgs     = MakeRenderCommandLine(m_lastSharedImageName);</a>
<a name="ln713">  params.customLogFold     = m_logFolderS;</a>
<a name="ln714"> </a>
<a name="ln715">  return params;</a>
<a name="ln716">}</a>
<a name="ln717"> </a>
<a name="ln718"> </a>
<a name="ln719">void RD_HydraConnection::RunAllHydraHeads()</a>
<a name="ln720">{</a>
<a name="ln721">  if (m_pConnection == nullptr)</a>
<a name="ln722">    return;</a>
<a name="ln723">  </a>
<a name="ln724">  auto currDevs = GetCurrDeviceList();</a>
<a name="ln725">  auto params   = GetCurrRunProcessParams();</a>
<a name="ln726">  m_params      = params;</a>
<a name="ln727">  </a>
<a name="ln728">  m_pConnection-&gt;runAllRenderProcesses(params, m_devList, currDevs);</a>
<a name="ln729">}</a>
<a name="ln730"> </a>
<a name="ln731">int ReadDeviceId(const char* a_cmdLine)</a>
<a name="ln732">{</a>
<a name="ln733">  std::stringstream strIn(a_cmdLine);</a>
<a name="ln734">  int devId = 0;  //#TODO: read device id from command line</a>
<a name="ln735">  std::string name;</a>
<a name="ln736">  while (!strIn.eof())</a>
<a name="ln737">  {</a>
<a name="ln738">    strIn &gt;&gt; name;</a>
<a name="ln739">    if (name == &quot;-cl_device_id&quot;)</a>
<a name="ln740">    {</a>
<a name="ln741">      strIn &gt;&gt; devId;</a>
<a name="ln742">      break;</a>
<a name="ln743">    }</a>
<a name="ln744">  }</a>
<a name="ln745"> </a>
<a name="ln746">  return devId;</a>
<a name="ln747">}</a>
<a name="ln748"> </a>
<a name="ln749">void RD_HydraConnection::RunSingleHydraHead(const char* a_cmdLine)</a>
<a name="ln750">{</a>
<a name="ln751">  if (m_pConnection == nullptr)</a>
<a name="ln752">    return;</a>
<a name="ln753"> </a>
<a name="ln754">  auto params = GetCurrRunProcessParams();</a>
<a name="ln755"> </a>
<a name="ln756">  std::vector&lt;int&gt; devs(1);</a>
<a name="ln757">  devs[0] = ReadDeviceId(a_cmdLine);</a>
<a name="ln758"> </a>
<a name="ln759">  params.customExeArgs += &quot; &quot;;</a>
<a name="ln760">  params.customExeArgs += a_cmdLine;</a>
<a name="ln761"> </a>
<a name="ln762">  m_pConnection-&gt;runAllRenderProcesses(params, m_devList, devs, true);</a>
<a name="ln763">}</a>
<a name="ln764"> </a>
<a name="ln765">void RD_HydraConnection::BeginScene(pugi::xml_node a_sceneNode)</a>
<a name="ln766">{</a>
<a name="ln767">  m_progressVal   = 0.0f;</a>
<a name="ln768">  m_avgBrightness = 1.0f;</a>
<a name="ln769">  m_avgBCounter   = 0;</a>
<a name="ln770"> </a>
<a name="ln771">  m_stopThreadImmediately = false;</a>
<a name="ln772">  haveUpdateFromMT        = false;</a>
<a name="ln773">  hadFinalUpdate          = false;</a>
<a name="ln774"> </a>
<a name="ln775">  // (3) run hydras</a>
<a name="ln776">  //</a>
<a name="ln777">  if (!m_dontRun)</a>
<a name="ln778">  {</a>
<a name="ln779">    CreateAndClearSharedImage();</a>
<a name="ln780">    RunAllHydraHeads();</a>
<a name="ln781">  }</a>
<a name="ln782"> </a>
<a name="ln783">  m_firstUpdate  = true;</a>
<a name="ln784">  m_instancesNum = 0;</a>
<a name="ln785">}</a>
<a name="ln786"> </a>
<a name="ln787"> </a>
<a name="ln788">void RD_HydraConnection::EndScene()</a>
<a name="ln789">{</a>
<a name="ln790">  </a>
<a name="ln791">}</a>
<a name="ln792"> </a>
<a name="ln793">void RD_HydraConnection::EndFlush()</a>
<a name="ln794">{</a>
<a name="ln795">  if (m_pSharedImage == nullptr)</a>
<a name="ln796">    return;</a>
<a name="ln797"> </a>
<a name="ln798">  // sent message to render that it can finally start</a>
<a name="ln799">  //</a>
<a name="ln800">  std::string firstMsg = &quot;-node_t A -sid 0 -layer color -action start&quot;;</a>
<a name="ln801">  strncpy(m_pSharedImage-&gt;MessageSendData(), firstMsg.c_str(), 256); // #TODO: (sid, mid) !!!</a>
<a name="ln802">  m_pSharedImage-&gt;Header()-&gt;counterSnd++;</a>
<a name="ln803"> </a>
<a name="ln804">  // run async framebuffer update loop if MLT is used</a>
<a name="ln805">  //</a>
<a name="ln806">  if(m_enableMLT)</a>
<a name="ln807">  {</a>
<a name="ln808">    </a>
<a name="ln809">    m_colorMLTFinalImage.resize(m_width, m_height);</a>
<a name="ln810">    const size_t imagesize = m_colorMLTFinalImage.width()*m_colorMLTFinalImage.height()*4;</a>
<a name="ln811">    float* colorMLTFinal   = m_colorMLTFinalImage.data();</a>
<a name="ln812">    </a>
<a name="ln813">    for(size_t i=0;i&lt;imagesize;i+=4)</a>
<a name="ln814">    {</a>
<a name="ln815">      colorMLTFinal[i+0] = 0.1f;</a>
<a name="ln816">      colorMLTFinal[i+1] = 0.0f;</a>
<a name="ln817">      colorMLTFinal[i+2] = 0.1f;</a>
<a name="ln818">      colorMLTFinal[i+3] = 0.0f;</a>
<a name="ln819">    }</a>
<a name="ln820">    </a>
<a name="ln821">    m_mltFrameBufferUpdateThread   = std::async(std::launch::async, &amp;RD_HydraConnection::MLT_FrameBufferUpdateLoop, this);</a>
<a name="ln822">    m_lastMaxRaysPerPixel          = 1000000;</a>
<a name="ln823">    m_mltFrameBufferUpdate_ExitNow = false;</a>
<a name="ln824">  }</a>
<a name="ln825">  else</a>
<a name="ln826">  {</a>
<a name="ln827">    m_mltFrameBufferUpdate_ExitNow = true;</a>
<a name="ln828">  }</a>
<a name="ln829"> </a>
<a name="ln830">}</a>
<a name="ln831"> </a>
<a name="ln832">void RD_HydraConnection::Draw()</a>
<a name="ln833">{</a>
<a name="ln834">  // like glFinish();</a>
<a name="ln835">}</a>
<a name="ln836"> </a>
<a name="ln837">void RD_HydraConnection::InstanceMeshes(int32_t a_meshId, const float* a_matrices, int32_t a_instNum, const int* a_lightInstId, const int* a_remapId, const int* a_realInstId)</a>
<a name="ln838">{</a>
<a name="ln839">  m_instancesNum += a_instNum;</a>
<a name="ln840">}</a>
<a name="ln841"> </a>
<a name="ln842">void RD_HydraConnection::InstanceLights(int32_t a_light_id, const float* a_matrix, pugi::xml_node* a_custAttrArray, int32_t a_instNum, int32_t a_lightGroupId)</a>
<a name="ln843">{</a>
<a name="ln844"> </a>
<a name="ln845">}</a>
<a name="ln846"> </a>
<a name="ln847">HRRenderUpdateInfo RD_HydraConnection::HaveUpdateNow(int a_maxRaysPerPixel)</a>
<a name="ln848">{</a>
<a name="ln849">  m_lastMaxRaysPerPixel = a_maxRaysPerPixel;</a>
<a name="ln850"> </a>
<a name="ln851">  HRRenderUpdateInfo result;</a>
<a name="ln852">  result.finalUpdate   = false;</a>
<a name="ln853">  result.progress      = 0.0f; </a>
<a name="ln854">  result.haveUpdateFB  = false;</a>
<a name="ln855">  result.haveUpdateMSG = false;</a>
<a name="ln856"> </a>
<a name="ln857">  if (m_instancesNum == 0)</a>
<a name="ln858">  {</a>
<a name="ln859">    result.finalUpdate   = true;</a>
<a name="ln860">    result.progress      = 100.0f;</a>
<a name="ln861">    result.haveUpdateFB  = true;</a>
<a name="ln862">    result.haveUpdateMSG = false;</a>
<a name="ln863">    HrPrint(HR_SEVERITY_ERROR, L&quot;RD_HydraConnection::HaveUpdateNow: no instances in scene!!&quot;);</a>
<a name="ln864">    return result;</a>
<a name="ln865">  }</a>
<a name="ln866"> </a>
<a name="ln867">  if (m_pSharedImage == nullptr)</a>
<a name="ln868">    return result;</a>
<a name="ln869">  </a>
<a name="ln870">  auto pHeader = m_pSharedImage-&gt;Header();</a>
<a name="ln871"> </a>
<a name="ln872">  if(pHeader == nullptr)</a>
<a name="ln873">    return result;</a>
<a name="ln874"> </a>
<a name="ln875">  if (pHeader-&gt;counterRcv == m_oldCounter)</a>
<a name="ln876">  {</a>
<a name="ln877">    result.haveUpdateFB  = false;</a>
<a name="ln878">    result.haveUpdateMSG = false;</a>
<a name="ln879">  }</a>
<a name="ln880">  else</a>
<a name="ln881">  {</a>
<a name="ln882">    result.haveUpdateFB = fabs(m_oldSPP - m_pSharedImage-&gt;Header()-&gt;spp) &gt; 1e-5f;</a>
<a name="ln883">    result.progress     = 100.0f*m_pSharedImage-&gt;Header()-&gt;spp / float(a_maxRaysPerPixel);</a>
<a name="ln884">    if(m_enableMLT)</a>
<a name="ln885">      result.progress *= (2.0f); // MMLT sample indirect light 2 times more than direct light.</a>
<a name="ln886">    m_oldCounter        = pHeader-&gt;counterRcv;</a>
<a name="ln887">    m_oldSPP            = m_pSharedImage-&gt;Header()-&gt;spp;</a>
<a name="ln888">  }</a>
<a name="ln889"> </a>
<a name="ln890">  result.finalUpdate = (result.progress &gt;= 100.0f);</a>
<a name="ln891">  </a>
<a name="ln892">  if(!result.finalUpdate &amp;&amp; m_enableMLT &amp;&amp; m_mltFrameBufferUpdate_ExitNow)</a>
<a name="ln893">    result.finalUpdate = true;</a>
<a name="ln894"> </a>
<a name="ln895">  if(result.finalUpdate)</a>
<a name="ln896">  {</a>
<a name="ln897">    m_mltFrameBufferUpdate_ExitNow = true;</a>
<a name="ln898">    this-&gt;ExecuteCommand(L&quot;exitnow&quot;, nullptr);</a>
<a name="ln899">  }</a>
<a name="ln900"> </a>
<a name="ln901">  // check if processes are still running</a>
<a name="ln902">  //</a>
<a name="ln903">  if (m_pConnection != nullptr &amp;&amp; !m_pConnection-&gt;hasConnection())</a>
<a name="ln904">  { </a>
<a name="ln905">    result.finalUpdate = true;</a>
<a name="ln906">	this-&gt;ExecuteCommand(L&quot;exitnow&quot;, nullptr);</a>
<a name="ln907">  }  </a>
<a name="ln908"> </a>
<a name="ln909">  return result;</a>
<a name="ln910">}</a>
<a name="ln911"> </a>
<a name="ln912">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln913">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln914">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln915">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln916"> </a>
<a name="ln917"> </a>
<a name="ln918">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln919">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln920"> </a>
<a name="ln921">static inline int   __float_as_int(float x) { return *((int*)&amp;x); }</a>
<a name="ln922">static inline float __int_as_float(int x) { return *((float*)&amp;x); }</a>
<a name="ln923"> </a>
<a name="ln924">static inline int   as_int(float x) { return __float_as_int(x); }</a>
<a name="ln925">static inline float as_float(int x) { return __int_as_float(x); }</a>
<a name="ln926"> </a>
<a name="ln927">static inline void decodeNormal(unsigned int a_data, float a_norm[3])</a>
<a name="ln928">{</a>
<a name="ln929">  const float divInv = 1.0f / 32767.0f;</a>
<a name="ln930"> </a>
<a name="ln931">  short a_enc_x, a_enc_y;</a>
<a name="ln932"> </a>
<a name="ln933">  a_enc_x = (short)(a_data &amp; 0x0000FFFF);</a>
<a name="ln934">  a_enc_y = (short)((int)(a_data &amp; 0xFFFF0000) &gt;&gt; 16);</a>
<a name="ln935"> </a>
<a name="ln936">  float sign = (a_enc_x &amp; 0x0001) ? -1.0f : 1.0f;</a>
<a name="ln937"> </a>
<a name="ln938">  a_norm[0] = (short)(a_enc_x &amp; 0xfffe)*divInv;</a>
<a name="ln939">  a_norm[1] = (short)(a_enc_y &amp; 0xfffe)*divInv;</a>
<a name="ln940">  a_norm[2] = sign*sqrt(fmax(1.0f - a_norm[0] * a_norm[0] - a_norm[1] * a_norm[1], 0.0f));</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943"> </a>
<a name="ln944">static inline HRGBufferPixel UnpackGBuffer(const float a_input[4], const float a_input2[4])</a>
<a name="ln945">{</a>
<a name="ln946">  HRGBufferPixel res;</a>
<a name="ln947"> </a>
<a name="ln948">  res.depth = a_input[0];</a>
<a name="ln949">  res.matId = as_int(a_input[2]) &amp; 0x00FFFFFF;</a>
<a name="ln950">  decodeNormal(as_int(a_input[1]), res.norm);</a>
<a name="ln951"> </a>
<a name="ln952">  unsigned int rgba = as_int(a_input[3]);</a>
<a name="ln953">  res.rgba[0] = (rgba &amp; 0x000000FF)*(1.0f / 255.0f);</a>
<a name="ln954">  res.rgba[1] = ((rgba &amp; 0x0000FF00) &gt;&gt; 8)*(1.0f / 255.0f);</a>
<a name="ln955">  res.rgba[2] = ((rgba &amp; 0x00FF0000) &gt;&gt; 16)*(1.0f / 255.0f);</a>
<a name="ln956">  res.rgba[3] = ((rgba &amp; 0xFF000000) &gt;&gt; 24)*(1.0f / 255.0f);</a>
<a name="ln957"> </a>
<a name="ln958">  res.texc[0] = a_input2[0];</a>
<a name="ln959">  res.texc[1] = a_input2[1];</a>
<a name="ln960">  res.objId   = as_int(a_input2[2]);</a>
<a name="ln961">  res.instId  = as_int(a_input2[3]);</a>
<a name="ln962"> </a>
<a name="ln963">  const int compressedCoverage = (as_int(a_input[2]) &amp; 0xFF000000) &gt;&gt; 24;</a>
<a name="ln964">  res.coverage = ((float)compressedCoverage)*(1.0f / 255.0f);</a>
<a name="ln965">  res.shadow   = 0.0f;</a>
<a name="ln966"> </a>
<a name="ln967">  return res;</a>
<a name="ln968">}</a>
<a name="ln969"> </a>
<a name="ln970"> </a>
<a name="ln971">static inline float unpackAlpha(float a_input[4])</a>
<a name="ln972">{</a>
<a name="ln973">  const unsigned int rgba = as_int(a_input[3]);</a>
<a name="ln974">  return ((rgba &amp; 0xFF000000) &gt;&gt; 24)*(1.0f / 255.0f);</a>
<a name="ln975">}</a>
<a name="ln976"> </a>
<a name="ln977">static float ReadFloatParam(const char* message, const char* paramName)</a>
<a name="ln978">{</a>
<a name="ln979">  std::istringstream iss(message);</a>
<a name="ln980"> </a>
<a name="ln981">  float res = 0.0f;</a>
<a name="ln982"> </a>
<a name="ln983">  do</a>
<a name="ln984">  {</a>
<a name="ln985">    std::string name, val;</a>
<a name="ln986">    iss &gt;&gt; name &gt;&gt; val;</a>
<a name="ln987"> </a>
<a name="ln988">    if (name == paramName)</a>
<a name="ln989">    {</a>
<a name="ln990">      res = (float)(atof(val.c_str()));</a>
<a name="ln991">      break;</a>
<a name="ln992">    }</a>
<a name="ln993"> </a>
<a name="ln994">  } while (iss);</a>
<a name="ln995"> </a>
<a name="ln996">  return res;</a>
<a name="ln997">}</a>
<a name="ln998"> </a>
<a name="ln999">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1000">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1001"> </a>
<a name="ln1002">void RD_HydraConnection::GetFrameBufferLineHDR(int32_t a_xBegin, int32_t a_xEnd, int32_t y, float* a_out, const wchar_t* a_layerName)</a>
<a name="ln1003">{</a>
<a name="ln1004">  if (m_pSharedImage == nullptr)</a>
<a name="ln1005">    return;</a>
<a name="ln1006"> </a>
<a name="ln1007">  const float* data = m_pSharedImage-&gt;ImageData(0); // index depends on a_layerName</a>
<a name="ln1008">  if(m_enableMLT)</a>
<a name="ln1009">  {</a>
<a name="ln1010">    data = m_colorMLTFinalImage.data();</a>
<a name="ln1011">  }</a>
<a name="ln1012">  if (data == nullptr)</a>
<a name="ln1013">    return;</a>
<a name="ln1014"> </a>
<a name="ln1015">  if (m_pSharedImage-&gt;Header()-&gt;counterRcv == 0 || m_pSharedImage-&gt;Header()-&gt;spp &lt; 1e-5f)</a>
<a name="ln1016">    return;</a>
<a name="ln1017"> </a>
<a name="ln1018">  data = data + y*m_width*4;</a>
<a name="ln1019"> </a>
<a name="ln1020">  const float invSpp = m_enableMLT ? 1.0f : 1.0f / m_pSharedImage-&gt;Header()-&gt;spp;</a>
<a name="ln1021">  const cvex::vfloat4 mult = cvex::splat(invSpp);</a>
<a name="ln1022">  auto intptr        = reinterpret_cast&lt;std::uintptr_t&gt;(data);</a>
<a name="ln1023">  </a>
<a name="ln1024">  if (intptr % 16 == 0)</a>
<a name="ln1025">  {</a>
<a name="ln1026">    for (int i = a_xBegin*4; i &lt; a_xEnd*4; i += 4)</a>
<a name="ln1027">    {</a>
<a name="ln1028">      const cvex::vfloat4 color1 = cvex::load(data + i);</a>
<a name="ln1029">      const cvex::vfloat4 color2 = mult*color1;</a>
<a name="ln1030">      cvex::store(a_out + i - a_xBegin*4, color2);</a>
<a name="ln1031">    }</a>
<a name="ln1032">  }</a>
<a name="ln1033">  else</a>
<a name="ln1034">  {</a>
<a name="ln1035">    for (int i = a_xBegin * 4; i &lt; a_xEnd * 4; i += 4)</a>
<a name="ln1036">    {</a>
<a name="ln1037">      const cvex::vfloat4 color1 = cvex::load(data + i);</a>
<a name="ln1038">      const cvex::vfloat4 color2 = mult*color1;</a>
<a name="ln1039">      cvex::store_u(a_out + i - a_xBegin*4, color2);</a>
<a name="ln1040">    }</a>
<a name="ln1041">  }</a>
<a name="ln1042"> </a>
<a name="ln1043">  // if final update unlock image</a>
<a name="ln1044"> </a>
<a name="ln1045">}</a>
<a name="ln1046"> </a>
<a name="ln1047">static inline float clamp(float u, float a, float b) { float r = fmax(a, u); return fmin(r, b); }</a>
<a name="ln1048">static inline int   clamp(int u, int a, int b) { int r = (a &gt; u) ? a : u; return (r &lt; b) ? r : b; }</a>
<a name="ln1049"> </a>
<a name="ln1050">static inline int RealColorToUint32(const float real_color[4])</a>
<a name="ln1051">{</a>
<a name="ln1052">  float  r = clamp(real_color[0] * 255.0f, 0.0f, 255.0f);</a>
<a name="ln1053">  float  g = clamp(real_color[1] * 255.0f, 0.0f, 255.0f);</a>
<a name="ln1054">  float  b = clamp(real_color[2] * 255.0f, 0.0f, 255.0f);</a>
<a name="ln1055">  float  a = clamp(real_color[3] * 255.0f, 0.0f, 255.0f);</a>
<a name="ln1056"> </a>
<a name="ln1057">  unsigned char red   = (unsigned char)r;</a>
<a name="ln1058">  unsigned char green = (unsigned char)g;</a>
<a name="ln1059">  unsigned char blue  = (unsigned char)b;</a>
<a name="ln1060">  unsigned char alpha = (unsigned char)a;</a>
<a name="ln1061"> </a>
<a name="ln1062">  return red | (green &lt;&lt; 8) | (blue &lt;&lt; 16) | (alpha &lt;&lt; 24);</a>
<a name="ln1063">}</a>
<a name="ln1064"> </a>
<a name="ln1065"> </a>
<a name="ln1066">void RD_HydraConnection::GetFrameBufferLineLDR(int32_t a_xBegin, int32_t a_xEnd, int32_t y, int32_t* a_out)</a>
<a name="ln1067">{</a>
<a name="ln1068">  if (m_pSharedImage == nullptr)</a>
<a name="ln1069">    return;</a>
<a name="ln1070"> </a>
<a name="ln1071">  const float* data = m_pSharedImage-&gt;ImageData(0); // index depends on a_layerName</a>
<a name="ln1072">  if(m_enableMLT)</a>
<a name="ln1073">    data = m_colorMLTFinalImage.data();</a>
<a name="ln1074">  if (data == nullptr)</a>
<a name="ln1075">    return;</a>
<a name="ln1076"> </a>
<a name="ln1077">  if (m_pSharedImage-&gt;Header()-&gt;counterRcv == 0 || m_pSharedImage-&gt;Header()-&gt;spp &lt; 1e-5f)</a>
<a name="ln1078">    return;</a>
<a name="ln1079"> </a>
<a name="ln1080">  data = data + y * m_width * 4;</a>
<a name="ln1081">  typedef HydraLiteMath::float4 float4;</a>
<a name="ln1082"> </a>
<a name="ln1083">  const float4* dataHDR = (const float4*)data;</a>
<a name="ln1084"> </a>
<a name="ln1085">  const float invGamma  = 1.0f / 2.2f;</a>
<a name="ln1086">  const float normConst = m_enableMLT ? 1.0f : 1.0f / m_pSharedImage-&gt;Header()-&gt;spp;</a>
<a name="ln1087"> </a>
<a name="ln1088">  // not sse version</a>
<a name="ln1089">  //</a>
<a name="ln1090">  if (!HydraSSE::g_useSSE)</a>
<a name="ln1091">  {</a>
<a name="ln1092">    for (int i = a_xBegin; i &lt; a_xEnd; i++)  // #TODO: use sse and fast pow</a>
<a name="ln1093">    {</a>
<a name="ln1094">      const float4 color = dataHDR[i];</a>
<a name="ln1095">      float color2[4];</a>
<a name="ln1096">      color2[0] = powf(color.x*normConst, invGamma);</a>
<a name="ln1097">      color2[1] = powf(color.y*normConst, invGamma);</a>
<a name="ln1098">      color2[2] = powf(color.z*normConst, invGamma);</a>
<a name="ln1099">      color2[3] = 1.0f;</a>
<a name="ln1100">      a_out[i - a_xBegin] = RealColorToUint32(color2);</a>
<a name="ln1101">    }</a>
<a name="ln1102">  }</a>
<a name="ln1103">  else // sse version</a>
<a name="ln1104">  {</a>
<a name="ln1105">    const __m128 powerf4 = _mm_set_ps1(invGamma);</a>
<a name="ln1106">    const __m128 normc   = _mm_set_ps1(normConst);</a>
<a name="ln1107"> </a>
<a name="ln1108">    for (int i = a_xBegin; i &lt; a_xEnd; i++)  </a>
<a name="ln1109">      a_out[i - a_xBegin] = HydraSSE::gammaCorr((const float*)(dataHDR + i), normc, powerf4);</a>
<a name="ln1110">  }</a>
<a name="ln1111"> </a>
<a name="ln1112">}</a>
<a name="ln1113"> </a>
<a name="ln1114">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1115">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1116"> </a>
<a name="ln1117">void RD_HydraConnection::LockFrameBufferUpdate()</a>
<a name="ln1118">{</a>
<a name="ln1119">  while(m_colorImageIsLocked); // wait for some fb update thread to set 'm_colorImageIsLocked' to false</a>
<a name="ln1120">  m_colorImageIsLocked = true;</a>
<a name="ln1121">}</a>
<a name="ln1122"> </a>
<a name="ln1123">void RD_HydraConnection::UnlockFrameBufferUpdate()</a>
<a name="ln1124">{</a>
<a name="ln1125">  m_colorImageIsLocked = false;</a>
<a name="ln1126">}</a>
<a name="ln1127"> </a>
<a name="ln1128">void RD_HydraConnection::GetFrameBufferHDR(int32_t w, int32_t h, float* a_out, const wchar_t* a_layerName)</a>
<a name="ln1129">{</a>
<a name="ln1130">  #pragma omp parallel for</a>
<a name="ln1131">  for (int y = 0; y &lt; h; y++)</a>
<a name="ln1132">    GetFrameBufferLineHDR(0, w, y, a_out + y * w * 4, a_layerName);</a>
<a name="ln1133">}</a>
<a name="ln1134"> </a>
<a name="ln1135">void RD_HydraConnection::GetFrameBufferLDR(int32_t w, int32_t h, int32_t* a_out)</a>
<a name="ln1136">{</a>
<a name="ln1137">  #pragma omp parallel for</a>
<a name="ln1138">  for (int y = 0; y &lt; h; y++)</a>
<a name="ln1139">    GetFrameBufferLineLDR(0, w, y, a_out + y * w);</a>
<a name="ln1140">}</a>
<a name="ln1141"> </a>
<a name="ln1142"> </a>
<a name="ln1143">void RD_HydraConnection::GetGBufferLine(int32_t a_lineNumber, HRGBufferPixel* a_lineData, int32_t a_startX, int32_t a_endX, const std::unordered_set&lt;int32_t&gt;&amp; a_shadowCatchers)</a>
<a name="ln1144">{</a>
<a name="ln1145">  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// #TODO: Refactor this</a>
<a name="ln1146">  float* data0 = nullptr;</a>
<a name="ln1147">  float* data1 = nullptr;</a>
<a name="ln1148">  float* data2 = nullptr;</a>
<a name="ln1149">  if (m_pSharedImage == nullptr)</a>
<a name="ln1150">    return;</a>
<a name="ln1151">  </a>
<a name="ln1152">  data0 = m_pSharedImage-&gt;ImageData(0);</a>
<a name="ln1153">  if (m_pSharedImage-&gt;Header()-&gt;depth == 4) // some other process already have computed gbuffer</a>
<a name="ln1154">  {</a>
<a name="ln1155">    data1 = m_pSharedImage-&gt;ImageData(2);</a>
<a name="ln1156">    data2 = m_pSharedImage-&gt;ImageData(3);</a>
<a name="ln1157">  }</a>
<a name="ln1158">  else if (m_pSharedImage-&gt;Header()-&gt;depth == 3) // some other process already have computed gbuffer</a>
<a name="ln1159">  {</a>
<a name="ln1160">    data1 = m_pSharedImage-&gt;ImageData(1);</a>
<a name="ln1161">    data2 = m_pSharedImage-&gt;ImageData(2);</a>
<a name="ln1162">  }</a>
<a name="ln1163">  else</a>
<a name="ln1164">    return;</a>
<a name="ln1165">  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// #TODO: Refactor this</a>
<a name="ln1166"> </a>
<a name="ln1167">  if (a_endX &gt; m_width)</a>
<a name="ln1168">    a_endX = m_width;</a>
<a name="ln1169"> </a>
<a name="ln1170">  const int32_t lineOffset = (a_lineNumber*m_width + a_startX);</a>
<a name="ln1171">  const int32_t lineSize   = (a_endX - a_startX);</a>
<a name="ln1172"> </a>
<a name="ln1173">  const float normC = 1.0f / m_pSharedImage-&gt;Header()-&gt;spp;</a>
<a name="ln1174"> </a>
<a name="ln1175">  for (int32_t x = 0; x &lt; lineSize; x++)</a>
<a name="ln1176">  {</a>
<a name="ln1177">    const float* data11  = &amp;data1[(lineOffset + x) * 4];</a>
<a name="ln1178">    const float* data22  = &amp;data2[(lineOffset + x) * 4];</a>
<a name="ln1179">    a_lineData[x]        = UnpackGBuffer(data11, data22);                // store main gbuffer data</a>
<a name="ln1180">    a_lineData[x].shadow = 1.0f - data0[(lineOffset + x) * 4 + 3]*normC; // get shadow from the fourthm channel</a>
<a name="ln1181"> </a>
<a name="ln1182">    //#TODO: move this code outside of API. to 3ds max or utility or else;</a>
<a name="ln1183"> </a>
<a name="ln1184">    // kill borders alpha for pixels that are neighbours to background </a>
<a name="ln1185">    //</a>
<a name="ln1186">    //if (a_lineData[x].rgba[3] &lt; 0.85f &amp;&amp; a_lineData[x].coverage &lt; 0.85f)</a>
<a name="ln1187">    //{</a>
<a name="ln1188">    //  // set up search window</a>
<a name="ln1189">    //  //</a>
<a name="ln1190">    //  constexpr int WINDOW_SIZE = 2;</a>
<a name="ln1191"> </a>
<a name="ln1192">    //  int minY = a_lineNumber - WINDOW_SIZE;</a>
<a name="ln1193">    //  int maxY = a_lineNumber + WINDOW_SIZE;</a>
<a name="ln1194"> </a>
<a name="ln1195">    //  int minX = x - WINDOW_SIZE;</a>
<a name="ln1196">    //  int maxX = x + WINDOW_SIZE;</a>
<a name="ln1197">    //  </a>
<a name="ln1198">    //  if (minY &lt; 0) </a>
<a name="ln1199">    //    minY = 0;</a>
<a name="ln1200">    //  if (maxY &gt;= m_height)</a>
<a name="ln1201">    //    maxY = m_height - 1;</a>
<a name="ln1202"> </a>
<a name="ln1203">    //  if (minX &lt; 0)</a>
<a name="ln1204">    //    minX = 0;</a>
<a name="ln1205">    //  if (maxX &gt;= m_width)</a>
<a name="ln1206">    //    maxX = m_width - 1;</a>
<a name="ln1207"> </a>
<a name="ln1208">    //  // locate background in nearby pixels</a>
<a name="ln1209">    //  //</a>
<a name="ln1210">    //  bool foundBack = false;</a>
<a name="ln1211">    //  for (int y1 = minY; y1 &lt;= maxY; y1++)</a>
<a name="ln1212">    //  {</a>
<a name="ln1213">    //    for (int x1 = minX; x1 &lt;= maxX; x1++)</a>
<a name="ln1214">    //    {</a>
<a name="ln1215">    //      //const int instId = as_int(data2[(y1*m_width + x1) * 4 + 3]);</a>
<a name="ln1216">    //      const int matId = as_int(data1[(y1*m_width + x1) * 4 + 2])&amp; 0x00FFFFFF;</a>
<a name="ln1217">    //      if (matId &lt; 0 || matId &gt;= int(0x00FFFFFF) || a_shadowCatchers.find(matId) != a_shadowCatchers.end())</a>
<a name="ln1218">    //      {</a>
<a name="ln1219">    //        foundBack = true;</a>
<a name="ln1220">    //        goto BREAK_BOTH;</a>
<a name="ln1221">    //      }</a>
<a name="ln1222">    //    }</a>
<a name="ln1223">    //  }</a>
<a name="ln1224">    //  BREAK_BOTH:</a>
<a name="ln1225">    //  </a>
<a name="ln1226">    //  // now finally kill alpha</a>
<a name="ln1227">    //  //</a>
<a name="ln1228">    //  if (foundBack)</a>
<a name="ln1229">    //    a_lineData[x].rgba[3] = 0.0f;</a>
<a name="ln1230">    //}</a>
<a name="ln1231"> </a>
<a name="ln1232">  }</a>
<a name="ln1233"> </a>
<a name="ln1234">}</a>
<a name="ln1235"> </a>
<a name="ln1236">void RD_HydraConnection::ExecuteCommand(const wchar_t* a_cmd, wchar_t* a_out)</a>
<a name="ln1237">{</a>
<a name="ln1238">  std::string inputA = ws2s(a_cmd);</a>
<a name="ln1239"> </a>
<a name="ln1240">  std::wstringstream inputStream(a_cmd);</a>
<a name="ln1241">  std::wstring name, value;</a>
<a name="ln1242">  inputStream &gt;&gt; name &gt;&gt; value;</a>
<a name="ln1243">  </a>
<a name="ln1244">  bool needToRunProcess  = false;</a>
<a name="ln1245">  bool needToStopProcess = false;</a>
<a name="ln1246"> </a>
<a name="ln1247">  if (name == L&quot;runhydra&quot; &amp;&amp; m_width != 0) // this is special command to run _single_ hydra process</a>
<a name="ln1248">  {</a>
<a name="ln1249">    if(m_pSharedImage == nullptr)</a>
<a name="ln1250">      CreateAndClearSharedImage();</a>
<a name="ln1251">    </a>
<a name="ln1252">    auto* header = m_pSharedImage-&gt;Header();</a>
<a name="ln1253">    header-&gt;counterSnd++;</a>
<a name="ln1254"> </a>
<a name="ln1255">    std::stringstream strOut;</a>
<a name="ln1256">    strOut &lt;&lt; (inputA.c_str() + 9) &lt;&lt; &quot; -boxmode 1&quot;; // &lt;&lt; &quot; -mid &quot; &lt;&lt; header-&gt;counterSnd;</a>
<a name="ln1257">    const std::string cmdArgs = strOut.str();</a>
<a name="ln1258">    RunSingleHydraHead(cmdArgs.c_str());</a>
<a name="ln1259">    return;</a>
<a name="ln1260">  }</a>
<a name="ln1261">  else if (name == L&quot;clearcolor&quot;)</a>
<a name="ln1262">  {</a>
<a name="ln1263">    delete m_pSharedImage;</a>
<a name="ln1264">    m_pSharedImage = nullptr;</a>
<a name="ln1265">    return;</a>
<a name="ln1266">  }</a>
<a name="ln1267">  else if (name == L&quot;exitnow&quot;)</a>
<a name="ln1268">  {</a>
<a name="ln1269">    needToStopProcess = true;</a>
<a name="ln1270">    m_mltFrameBufferUpdate_ExitNow = true;</a>
<a name="ln1271">  }</a>
<a name="ln1272">  else if (name == L&quot;pause&quot;)</a>
<a name="ln1273">  {</a>
<a name="ln1274">    if (m_pConnection == nullptr || m_pSharedImage == nullptr)</a>
<a name="ln1275">      return;</a>
<a name="ln1276"> </a>
<a name="ln1277">    auto posSpace = inputA.find(&quot;pause &quot;);</a>
<a name="ln1278">    std::string path = inputA.substr(posSpace + 6, inputA.size());</a>
<a name="ln1279"> </a>
<a name="ln1280">    // (1) save imageA</a>
<a name="ln1281">    //</a>
<a name="ln1282">    if(!path.empty())</a>
<a name="ln1283">    {</a>
<a name="ln1284">      std::ofstream fout(path.c_str(), std::ios::binary);</a>
<a name="ln1285">      fout.write((const char*)m_pSharedImage-&gt;Header(), sizeof(HRSharedBufferHeader));</a>
<a name="ln1286">    </a>
<a name="ln1287">      const size_t size = size_t(m_pSharedImage-&gt;Header()-&gt;width*m_pSharedImage-&gt;Header()-&gt;height)*sizeof(float)*4;</a>
<a name="ln1288">      for(int layer=0; layer &lt; m_pSharedImage-&gt;Header()-&gt;depth; layer++)</a>
<a name="ln1289">        fout.write((const char*)m_pSharedImage-&gt;ImageData(layer), size);</a>
<a name="ln1290">    </a>
<a name="ln1291">      fout.close();</a>
<a name="ln1292">    }</a>
<a name="ln1293"> </a>
<a name="ln1294">    // (2) finish all render processes</a>
<a name="ln1295">    //</a>
<a name="ln1296">    inputA = &quot;exitnow&quot;;</a>
<a name="ln1297">    needToStopProcess = true;</a>
<a name="ln1298">    m_mltFrameBufferUpdate_ExitNow = true;</a>
<a name="ln1299">  }</a>
<a name="ln1300">  else if (name == L&quot;resume&quot;)</a>
<a name="ln1301">  {</a>
<a name="ln1302">    // (1) load imageA</a>
<a name="ln1303">    //</a>
<a name="ln1304">    auto posSpace = inputA.find(&quot;resume &quot;);</a>
<a name="ln1305">    std::string path = inputA.substr(posSpace + 7, inputA.size());</a>
<a name="ln1306">    if (!path.empty())</a>
<a name="ln1307">    {</a>
<a name="ln1308">      std::ifstream fin(path.c_str(), std::ios::binary);</a>
<a name="ln1309">      if (fin.is_open())</a>
<a name="ln1310">      {</a>
<a name="ln1311">        fin.read((char*)m_pSharedImage-&gt;Header(), sizeof(HRSharedBufferHeader));</a>
<a name="ln1312">        const size_t size = size_t(m_pSharedImage-&gt;Header()-&gt;width*m_pSharedImage-&gt;Header()-&gt;height) * sizeof(float) * 4;</a>
<a name="ln1313">        for (int layer = 0; layer &lt; m_pSharedImage-&gt;Header()-&gt;depth; layer++)</a>
<a name="ln1314">          fin.read((char*)m_pSharedImage-&gt;ImageData(layer), size);</a>
<a name="ln1315">        fin.close();</a>
<a name="ln1316">      }</a>
<a name="ln1317">    }</a>
<a name="ln1318"> </a>
<a name="ln1319">    // (2) start rendering</a>
<a name="ln1320">    //</a>
<a name="ln1321">    inputA = &quot;start&quot;;</a>
<a name="ln1322">  }</a>
<a name="ln1323">  else if (name == L&quot;continue&quot;)</a>
<a name="ln1324">  {</a>
<a name="ln1325">    inputA.replace(inputA.begin(), inputA.begin()+8,&quot;start&quot;);</a>
<a name="ln1326">    needToRunProcess = true;</a>
<a name="ln1327">  }</a>
<a name="ln1328"> </a>
<a name="ln1329">  if (m_pConnection == nullptr)</a>
<a name="ln1330">    return;</a>
<a name="ln1331"> </a>
<a name="ln1332">  </a>
<a name="ln1333">  if(m_pSharedImage != nullptr)</a>
<a name="ln1334">  {</a>
<a name="ln1335">    auto *header = m_pSharedImage-&gt;Header();</a>
<a name="ln1336">  </a>
<a name="ln1337">    std::stringstream sout2;</a>
<a name="ln1338">    sout2 &lt;&lt; &quot;-node_t A&quot; &lt;&lt; &quot; -sid 0 -layer color -action &quot; &lt;&lt; inputA.c_str();</a>
<a name="ln1339">  </a>
<a name="ln1340">    std::string message = sout2.str();</a>
<a name="ln1341">    strncpy(m_pSharedImage-&gt;MessageSendData(), message.c_str(), 256);</a>
<a name="ln1342">    header-&gt;counterSnd++;</a>
<a name="ln1343">  </a>
<a name="ln1344">    if (needToRunProcess)</a>
<a name="ln1345">    {</a>
<a name="ln1346">      RunAllHydraHeads();  // #NOTE: we don't call CreateAndClearSharedImage();</a>
<a name="ln1347">      strncpy(m_pSharedImage-&gt;MessageSendData(), message.c_str(), 256);</a>
<a name="ln1348">      header-&gt;counterSnd++;</a>
<a name="ln1349">    }</a>
<a name="ln1350">  }</a>
<a name="ln1351">  </a>
<a name="ln1352">  if(needToStopProcess &amp;&amp; m_pConnection != nullptr)</a>
<a name="ln1353">  {</a>
<a name="ln1354">    std::this_thread::sleep_for(std::chrono::milliseconds(250));</a>
<a name="ln1355">    m_pConnection-&gt;stopAllRenderProcesses();</a>
<a name="ln1356">  }</a>
<a name="ln1357">}</a>
<a name="ln1358"> </a>
<a name="ln1359">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1360">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1361">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1362">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1363"> </a>
<a name="ln1364"> </a>
<a name="ln1365"> </a>
<a name="ln1366"> </a>
<a name="ln1367"> </a>

</code></pre>
<div class="balloon" rel="1287"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands, not the result.</p></div>
<div class="balloon" rel="1312"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands, not the result.</p></div>
<div class="balloon" rel="375"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> It is possible that not all members of a class are initialized inside the constructor. Consider inspecting: m_presets, m_mltFrameBufferUpdate_ExitNow, m_lastMaxRaysPerPixel.</p></div>
<div class="balloon" rel="736"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1024/" target="_blank">V1024</a> The 'strIn' stream is checked for EOF before reading from it, but is not checked after reading. Potential use of invalid data.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
