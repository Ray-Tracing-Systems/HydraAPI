
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>VirtualBuffer.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#include &quot;HydraInternal.h&quot;</a>
<a name="ln2">#include &quot;HydraObjectManager.h&quot;</a>
<a name="ln3"> </a>
<a name="ln4">#include &quot;HydraVSGFCompress.h&quot;</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;algorithm&gt;</a>
<a name="ln7">#include &lt;fstream&gt;</a>
<a name="ln8">#include &lt;sstream&gt;</a>
<a name="ln9">#include &lt;iomanip&gt;</a>
<a name="ln10"> </a>
<a name="ln11">#if (_POSIX_C_SOURCE &gt;= 200112L || _XOPEN_SOURCE &gt;= 600)</a>
<a name="ln12">#include &lt;sys/mman.h&gt;</a>
<a name="ln13">#include &lt;fcntl.h&gt;</a>
<a name="ln14">#include &lt;sys/stat.h&gt;</a>
<a name="ln15">#include &lt;unistd.h&gt;</a>
<a name="ln16">#endif</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;cmath&gt;</a>
<a name="ln19"> </a>
<a name="ln20">static constexpr bool gDebugMode     = true;</a>
<a name="ln21">static constexpr bool gCopyCollector = false;</a>
<a name="ln22"> </a>
<a name="ln23">bool SharedVirtualBufferIsEnabled() { return (gDebugMode == false); }</a>
<a name="ln24"> </a>
<a name="ln25">///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln26">///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln27"> </a>
<a name="ln28">inline uint64_t blocksST(uint64_t elems, int threadsPerBlock)</a>
<a name="ln29">{</a>
<a name="ln30">  if (elems % threadsPerBlock == 0 &amp;&amp; elems &gt;= threadsPerBlock)</a>
<a name="ln31">    return elems / threadsPerBlock;</a>
<a name="ln32">  else</a>
<a name="ln33">    return (elems / threadsPerBlock) + 1;</a>
<a name="ln34">}</a>
<a name="ln35"> </a>
<a name="ln36">inline uint64_t roundBlocks(uint64_t elems, int threadsPerBlock)</a>
<a name="ln37">{</a>
<a name="ln38">  if (elems &lt; threadsPerBlock)</a>
<a name="ln39">    return (uint64_t)threadsPerBlock;</a>
<a name="ln40">  else</a>
<a name="ln41">    return blocksST(elems, threadsPerBlock) * threadsPerBlock;</a>
<a name="ln42">}</a>
<a name="ln43"> </a>
<a name="ln44">///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln45">///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln46"> </a>
<a name="ln47"> </a>
<a name="ln48">bool VirtualBuffer::Init(uint64_t a_sizeInBytes, const char* a_shmemName, std::vector&lt;int&gt;* a_pTempBuffer, HRSystemMutex* a_mutex)</a>
<a name="ln49">{</a>
<a name="ln50">  m_pVBMutex = a_mutex;</a>
<a name="ln51">  </a>
<a name="ln52">  if (a_sizeInBytes % 1024 != 0)</a>
<a name="ln53">  {</a>
<a name="ln54">    HrError(L&quot;VirtualBuffer::FATAL ERROR: bad virtual buffer size&quot;);</a>
<a name="ln55">    return false;</a>
<a name="ln56">  }</a>
<a name="ln57"> </a>
<a name="ln58">#ifdef WIN32</a>
<a name="ln59">  unsigned long long totalMem;</a>
<a name="ln60">  GetPhysicallyInstalledSystemMemory(&amp;totalMem);</a>
<a name="ln61">  totalMem *= size_t(1024);</a>
<a name="ln62">  </a>
<a name="ln63">  if (totalMem / 4 &lt; a_sizeInBytes)</a>
<a name="ln64">    a_sizeInBytes = totalMem / 4;</a>
<a name="ln65">#endif</a>
<a name="ln66">  </a>
<a name="ln67">  </a>
<a name="ln68">  m_totalSize   = a_sizeInBytes;</a>
<a name="ln69">  </a>
<a name="ln70">  if(a_sizeInBytes &gt; 4096)                                        // don't init table if single page wa allocated, dummy virtual buffer.</a>
<a name="ln71">    a_sizeInBytes += (VB_CHUNK_TABLE_OFFS + VB_CHUNK_TABLE_SIZE); // alloc memory for both virtual buffer and chunks table</a>
<a name="ln72"> </a>
<a name="ln73">#ifdef WIN32</a>
<a name="ln74">  DWORD imageSizeL = a_sizeInBytes &amp; 0x00000000FFFFFFFF;</a>
<a name="ln75">  DWORD imageSizeH = (a_sizeInBytes &amp; 0xFFFFFFFF00000000) &gt;&gt; 32;</a>
<a name="ln76"> </a>
<a name="ln77">  if (gDebugMode)</a>
<a name="ln78">  {</a>
<a name="ln79">    m_data = malloc(size_t(a_sizeInBytes));</a>
<a name="ln80">  }</a>
<a name="ln81">  else</a>
<a name="ln82">  {</a>
<a name="ln83">    m_fileHandle = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, imageSizeH, imageSizeL, a_shmemName);</a>
<a name="ln84">    </a>
<a name="ln85">    if (m_fileHandle == NULL)</a>
<a name="ln86">    {</a>
<a name="ln87">      HrError(L&quot;VirtualBuffer::FATAL ERROR: shmem file can not be created&quot;);</a>
<a name="ln88">      return false;</a>
<a name="ln89">    }</a>
<a name="ln90"> </a>
<a name="ln91">    m_data = MapViewOfFile(m_fileHandle, FILE_MAP_WRITE | FILE_MAP_READ, 0, 0, 0);</a>
<a name="ln92"> </a>
<a name="ln93">    if (m_data == nullptr)</a>
<a name="ln94">    {</a>
<a name="ln95">      CloseHandle(m_fileHandle); m_fileHandle = NULL;</a>
<a name="ln96">      HrError(L&quot;VirtualBuffer::FATAL ERROR: shmem file can not be maped&quot;);</a>
<a name="ln97">      return false;</a>
<a name="ln98">    }</a>
<a name="ln99">  }</a>
<a name="ln100"> </a>
<a name="ln101">#else</a>
<a name="ln102"> </a>
<a name="ln103">  shmemName = std::string(a_shmemName);</a>
<a name="ln104">  if (gDebugMode)</a>
<a name="ln105">  {</a>
<a name="ln106">    m_data = malloc(size_t(a_sizeInBytes));</a>
<a name="ln107">    memset(m_data, 0, size_t(a_sizeInBytes));</a>
<a name="ln108">  }</a>
<a name="ln109">  else</a>
<a name="ln110">  {</a>
<a name="ln111">    m_fileDescriptor = shm_open(a_shmemName, O_CREAT | O_RDWR | O_TRUNC, 0777);</a>
<a name="ln112">    if(ftruncate(m_fileDescriptor, a_sizeInBytes) == -1)</a>
<a name="ln113">      HrError(L&quot;VirtualBuffer::FATAL ERROR: shmem file can not be resized (ftruncate error)&quot;);</a>
<a name="ln114"> </a>
<a name="ln115">    m_data = mmap(nullptr, a_sizeInBytes, PROT_READ | PROT_WRITE, MAP_SHARED, m_fileDescriptor, 0);</a>
<a name="ln116">    if(m_data == MAP_FAILED)</a>
<a name="ln117">    {</a>
<a name="ln118">      HrError(L&quot;VirtualBuffer::FATAL ERROR: shmem file can not be created&quot;);</a>
<a name="ln119">      close(m_fileDescriptor);</a>
<a name="ln120">      return false;</a>
<a name="ln121">    }</a>
<a name="ln122">  }</a>
<a name="ln123">  if (m_data == nullptr)</a>
<a name="ln124">  {</a>
<a name="ln125">    HrError(L&quot;VirtualBuffer::FATAL ERROR: shmem file can not be mapped&quot;);</a>
<a name="ln126">    return false;</a>
<a name="ln127">  }</a>
<a name="ln128">#endif</a>
<a name="ln129">  </a>
<a name="ln130">  if(a_sizeInBytes &gt; 4096) // don't init table if single page was allocated only, dummy virtual buffer.</a>
<a name="ln131">  {</a>
<a name="ln132">    m_chunkTable = (int64_t *) (((char *) m_data) + m_totalSize + VB_CHUNK_TABLE_OFFS);</a>
<a name="ln133">    memset(m_chunkTable, 0, VB_CHUNK_TABLE_SIZE);</a>
<a name="ln134">  }</a>
<a name="ln135">  </a>
<a name="ln136">  Clear();</a>
<a name="ln137">  m_pTempBuffer = a_pTempBuffer;</a>
<a name="ln138">  m_owner       = true;</a>
<a name="ln139">  return true;</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142"> </a>
<a name="ln143">bool VirtualBuffer::Attach(uint64_t a_sizeInBytes, const char* a_shmemName, std::vector&lt;int&gt;* a_pTempBuffer)</a>
<a name="ln144">{</a>
<a name="ln145">  if (a_sizeInBytes % 1024 != 0)</a>
<a name="ln146">  {</a>
<a name="ln147">    HrError(L&quot;VirtualBuffer::FATAL ERROR: bad virtual buffer size&quot;);</a>
<a name="ln148">    return false;</a>
<a name="ln149">  }</a>
<a name="ln150">  </a>
<a name="ln151">  m_totalSize = a_sizeInBytes;</a>
<a name="ln152">  if(a_sizeInBytes &gt; 4096)                                        // don't init table if single page wa allocated, dummy virtual buffer.</a>
<a name="ln153">    a_sizeInBytes += (VB_CHUNK_TABLE_OFFS + VB_CHUNK_TABLE_SIZE); // alloc memory for both virtual buffer and chunks table</a>
<a name="ln154"> </a>
<a name="ln155">#ifdef WIN32</a>
<a name="ln156"> </a>
<a name="ln157">  m_fileHandle = OpenFileMappingA(FILE_MAP_READ | FILE_MAP_WRITE, 0, a_shmemName);</a>
<a name="ln158">  if (m_fileHandle == NULL)</a>
<a name="ln159">  {</a>
<a name="ln160">    HrError(L&quot;VirtualBuffer::FATAL ERROR: shmem file can not attach (OpenFileMappingA)&quot;);</a>
<a name="ln161">    return false;</a>
<a name="ln162">  }</a>
<a name="ln163"> </a>
<a name="ln164">  m_data = MapViewOfFile(m_fileHandle, FILE_MAP_WRITE | FILE_MAP_READ, 0, 0, 0);</a>
<a name="ln165">  if (m_data == nullptr)</a>
<a name="ln166">  {</a>
<a name="ln167">    CloseHandle(m_fileHandle); m_fileHandle = NULL;</a>
<a name="ln168">    HrError(L&quot;VirtualBuffer::FATAL ERROR: shmem file can not be maped (MapViewOfFile)&quot;);</a>
<a name="ln169">    return false;</a>
<a name="ln170">  }</a>
<a name="ln171"> </a>
<a name="ln172">#else</a>
<a name="ln173">  </a>
<a name="ln174">  shmemName = std::string(a_shmemName);</a>
<a name="ln175">  if (gDebugMode)</a>
<a name="ln176">    return false;</a>
<a name="ln177">  else</a>
<a name="ln178">  {</a>
<a name="ln179">    m_fileDescriptor = shm_open(a_shmemName, O_RDONLY, 0777);</a>
<a name="ln180">    if(m_fileDescriptor == -1)</a>
<a name="ln181">    {</a>
<a name="ln182">      HrError(L&quot;VirtualBuffer::FATAL ERROR: can not attach to shmem file (shm_open)&quot;);</a>
<a name="ln183">      return false;</a>
<a name="ln184">    }</a>
<a name="ln185">    </a>
<a name="ln186">    m_data = mmap(nullptr, a_sizeInBytes, PROT_READ, MAP_SHARED, m_fileDescriptor, 0);</a>
<a name="ln187">    if(m_data == MAP_FAILED)</a>
<a name="ln188">    {</a>
<a name="ln189">      HrError(L&quot;VirtualBuffer::FATAL ERROR: can not attach to shmem file (mmap)&quot;);</a>
<a name="ln190">      close(m_fileDescriptor);</a>
<a name="ln191">      return false;</a>
<a name="ln192">    }</a>
<a name="ln193">  }</a>
<a name="ln194">  </a>
<a name="ln195">  if (m_data == nullptr)</a>
<a name="ln196">  {</a>
<a name="ln197">    HrError(L&quot;VirtualBuffer::FATAL ERROR: shmem file can not be mapped&quot;);</a>
<a name="ln198">    return false;</a>
<a name="ln199">  }</a>
<a name="ln200">  </a>
<a name="ln201">#endif</a>
<a name="ln202">  </a>
<a name="ln203">  if(a_sizeInBytes &gt; 4096) // don't init table if single page was allocated only, dummy virtual buffer.</a>
<a name="ln204">  {</a>
<a name="ln205">    m_chunkTable = (int64_t *) (((char *) m_data) + m_totalSize + VB_CHUNK_TABLE_OFFS);</a>
<a name="ln206">  }</a>
<a name="ln207">  </a>
<a name="ln208">  Clear();</a>
<a name="ln209">  m_pTempBuffer = a_pTempBuffer;</a>
<a name="ln210">  m_owner       = false;</a>
<a name="ln211">  return true;</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">void VirtualBuffer::RestoreChunks()</a>
<a name="ln215">{</a>
<a name="ln216">  const int64_t* table = ChunksTablePtr();</a>
<a name="ln217">  if(table == nullptr)</a>
<a name="ln218">    return;</a>
<a name="ln219"> </a>
<a name="ln220">  // (1) scan table to find last chunk</a>
<a name="ln221">  //</a>
<a name="ln222">  const auto maxChunks = (VB_CHUNK_TABLE_SIZE)/sizeof(int64_t) - 2;</a>
<a name="ln223"> </a>
<a name="ln224">  int chunksNum = 0;</a>
<a name="ln225">  int64_t chunkOffset = 1;</a>
<a name="ln226">  do </a>
<a name="ln227">  {</a>
<a name="ln228">    chunksNum++;</a>
<a name="ln229">    chunkOffset = table[chunksNum];</a>
<a name="ln230">  } while(chunksNum &lt; maxChunks &amp;&amp; chunkOffset != 0);</a>
<a name="ln231"> </a>
<a name="ln232">  // (2) restore chunk pointers (their localAddresses)</a>
<a name="ln233">  //</a>
<a name="ln234">  m_allChunks.resize(chunksNum);</a>
<a name="ln235">  </a>
<a name="ln236">  for(size_t j=0;j&lt;m_allChunks.size()-1;j++)</a>
<a name="ln237">  {</a>
<a name="ln238">    m_allChunks[j].id           = j;</a>
<a name="ln239">    m_allChunks[j].localAddress = uint64_t(table[j]);</a>
<a name="ln240">    m_allChunks[j].sizeInBytes  = table[j+1] - table[j];</a>
<a name="ln241">    </a>
<a name="ln242">    if(m_allChunks[j].localAddress == uint64_t(-1))</a>
<a name="ln243">      m_allChunks[j].pVB = nullptr;</a>
<a name="ln244">    else</a>
<a name="ln245">      m_allChunks[j].pVB = this;</a>
<a name="ln246">  }</a>
<a name="ln247"> </a>
<a name="ln248">  auto last = m_allChunks.size()-1;</a>
<a name="ln249">  </a>
<a name="ln250">  m_allChunks[last].id           = last;</a>
<a name="ln251">  m_allChunks[last].localAddress = uint64_t(table[last]);</a>
<a name="ln252">  m_allChunks[last].sizeInBytes  = 0;</a>
<a name="ln253">  if(m_allChunks[last].localAddress == uint64_t(-1))</a>
<a name="ln254">    m_allChunks[last].pVB = nullptr;</a>
<a name="ln255">  else</a>
<a name="ln256">    m_allChunks[last].pVB = this;</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">void VirtualBuffer::Destroy()</a>
<a name="ln260">{</a>
<a name="ln261">  if (m_data == nullptr)</a>
<a name="ln262">    return;</a>
<a name="ln263"> </a>
<a name="ln264">  if (gDebugMode)</a>
<a name="ln265">    free(m_data);</a>
<a name="ln266"> </a>
<a name="ln267">#ifdef WIN32</a>
<a name="ln268">  if (!gDebugMode)</a>
<a name="ln269">  {</a>
<a name="ln270">    UnmapViewOfFile(m_data);    m_data       = nullptr;</a>
<a name="ln271">    CloseHandle(m_fileHandle);  m_fileHandle = NULL;</a>
<a name="ln272">  }</a>
<a name="ln273">#else</a>
<a name="ln274">  if (!gDebugMode)</a>
<a name="ln275">  {</a>
<a name="ln276">    munmap(m_data, m_totalSizeAllocated);</a>
<a name="ln277">    //if(m_owner)</a>
<a name="ln278">    shm_unlink(shmemName.c_str());</a>
<a name="ln279">    close(m_fileDescriptor);</a>
<a name="ln280">  }</a>
<a name="ln281">#endif</a>
<a name="ln282"> </a>
<a name="ln283">  m_data = nullptr;</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">void VirtualBuffer::Clear()</a>
<a name="ln287">{</a>
<a name="ln288">  m_dataHalfCurr = (char*)m_data;</a>
<a name="ln289">  m_dataHalfFree = m_dataHalfCurr + m_totalSize/2;</a>
<a name="ln290"> </a>
<a name="ln291">  m_currTop  = 0;</a>
<a name="ln292">  m_currSize = m_totalSize / 2;</a>
<a name="ln293">  m_totalSizeAllocated = 0;</a>
<a name="ln294"> </a>
<a name="ln295">  m_allChunks.clear();</a>
<a name="ln296">  m_chunksIdInMemory.clear();</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">char* VirtualBuffer::AllocInCacheNow(uint64_t a_sizeInBytes)</a>
<a name="ln300">{</a>
<a name="ln301">  char* objectMem = m_dataHalfCurr + m_currTop;</a>
<a name="ln302">  m_currTop            += a_sizeInBytes;</a>
<a name="ln303">  m_totalSizeAllocated += a_sizeInBytes;</a>
<a name="ln304">  return objectMem;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">void* VirtualBuffer::AllocInCache(uint64_t a_sizeInBytes)</a>
<a name="ln308">{</a>
<a name="ln309">  const uint64_t freeSize = gCopyCollector ? (m_currSize - m_currTop) : (m_totalSize - m_currTop);</a>
<a name="ln310"> </a>
<a name="ln311">  if (a_sizeInBytes &lt; freeSize) // alloc </a>
<a name="ln312">  {</a>
<a name="ln313">    return AllocInCacheNow(a_sizeInBytes);</a>
<a name="ln314">  }</a>
<a name="ln315">  else if (gCopyCollector)</a>
<a name="ln316">  {</a>
<a name="ln317">    const uint64_t maxAllowedSize = m_currSize - maxAccumulatedSize();</a>
<a name="ln318">    </a>
<a name="ln319">    if (a_sizeInBytes &lt; maxAllowedSize) // swap old objects to disc and put a new object to free memory </a>
<a name="ln320">    {</a>
<a name="ln321">      if(m_pVBMutex!=nullptr)</a>
<a name="ln322">        hr_lock_system_mutex(m_pVBMutex, VB_LOCK_WAIT_TIME_MS);</a>
<a name="ln323">      </a>
<a name="ln324">      RunCopyingCollector();</a>
<a name="ln325">      </a>
<a name="ln326">      int64_t* chunkTable = ChunksTablePtr(); // we need to clear table right after collector works, because old data is invalid!</a>
<a name="ln327">      if(chunkTable != nullptr)               // we can do better of cource here, but clearing should be enought to work corretcly</a>
<a name="ln328">      {</a>
<a name="ln329">        for(size_t i=0;i&lt;size();i++)</a>
<a name="ln330">          chunkTable[i] = int64_t(-1);</a>
<a name="ln331">      }</a>
<a name="ln332"> </a>
<a name="ln333">      if(m_pVBMutex!=nullptr)</a>
<a name="ln334">        hr_unlock_system_mutex(m_pVBMutex);</a>
<a name="ln335">      return AllocInCacheNow(a_sizeInBytes);</a>
<a name="ln336">    }</a>
<a name="ln337">    else // this object is too big. We can not allocate memory here. Need to store it on disk.</a>
<a name="ln338">    {</a>
<a name="ln339">      std::cerr &lt;&lt; &quot;VirtualBuffer::AllocInCache : the object is too big! gCopyCollector = &quot; &lt;&lt; int(gCopyCollector) &lt;&lt; std::endl;</a>
<a name="ln340">      return nullptr;</a>
<a name="ln341">    }</a>
<a name="ln342">  }</a>
<a name="ln343">  else</a>
<a name="ln344">  { </a>
<a name="ln345">    constexpr int div = 8;</a>
<a name="ln346">    const uint64_t maxAllowedSize = (m_totalSize*(div-1))/div - 1024;</a>
<a name="ln347">    </a>
<a name="ln348">    if (a_sizeInBytes &lt; maxAllowedSize) // swap old objects to disc and put a new object to free memory </a>
<a name="ln349">    {</a>
<a name="ln350">      if(m_pVBMutex!=nullptr)</a>
<a name="ln351">        hr_lock_system_mutex(m_pVBMutex, VB_LOCK_WAIT_TIME_MS);</a>
<a name="ln352">      </a>
<a name="ln353">      RunCollector(div);</a>
<a name="ln354">  </a>
<a name="ln355">      int64_t* chunkTable = ChunksTablePtr(); // we need to clear table right after collector works, because old data is invalid!</a>
<a name="ln356">      if(chunkTable != nullptr)               // we can do better of cource here, but clearing should be enought to work corretcly</a>
<a name="ln357">      {</a>
<a name="ln358">        for(size_t i=0;i&lt;size();i++)</a>
<a name="ln359">          chunkTable[i] = int64_t(-1);</a>
<a name="ln360">      }</a>
<a name="ln361">      </a>
<a name="ln362">      if(m_pVBMutex!=nullptr)</a>
<a name="ln363">        hr_unlock_system_mutex(m_pVBMutex);</a>
<a name="ln364"> </a>
<a name="ln365">      return AllocInCacheNow(a_sizeInBytes);</a>
<a name="ln366">    }</a>
<a name="ln367">    else // this object is too big. We can not allocate memory here. Need to store it on disk.</a>
<a name="ln368">    {</a>
<a name="ln369">      std::cerr &lt;&lt; &quot;VirtualBuffer::AllocInCache : the object is too big! gCopyCollector = &quot; &lt;&lt; int(gCopyCollector) &lt;&lt; std::endl;</a>
<a name="ln370">      return nullptr;</a>
<a name="ln371">    }</a>
<a name="ln372">    </a>
<a name="ln373">  }</a>
<a name="ln374"> </a>
<a name="ln375"> </a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378">void VirtualBuffer::ResizeAndAllocEmptyChunks(uint64_t a_ckunksNum)</a>
<a name="ln379">{</a>
<a name="ln380">  m_allChunks.resize(a_ckunksNum);</a>
<a name="ln381"> </a>
<a name="ln382">  for (size_t i = 0; i &lt; m_allChunks.size(); i++)</a>
<a name="ln383">  {</a>
<a name="ln384">    m_allChunks[i].id           = uint64_t(i);</a>
<a name="ln385">    m_allChunks[i].localAddress = uint64_t(-1);</a>
<a name="ln386">    m_allChunks[i].sizeInBytes  = 0;</a>
<a name="ln387">    m_allChunks[i].useCounter   = 0;</a>
<a name="ln388">    m_allChunks[i].inUse        = false;</a>
<a name="ln389">  }</a>
<a name="ln390"> </a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393">size_t VirtualBuffer::AllocChunk(uint64_t a_dataSizeInBytes, uint64_t a_objId)</a>
<a name="ln394">{</a>
<a name="ln395">  ChunkPointer result(this);</a>
<a name="ln396">  result.id = m_allChunks.size();</a>
<a name="ln397"> </a>
<a name="ln398">  void* memory = AllocInCache(a_dataSizeInBytes);</a>
<a name="ln399">  if (memory == nullptr) </a>
<a name="ln400">  {</a>
<a name="ln401">    result.inUse      = true;</a>
<a name="ln402">    result.useCounter = 0;</a>
<a name="ln403">    return size_t(-1);</a>
<a name="ln404">  }</a>
<a name="ln405"> </a>
<a name="ln406">  float startCounter   = fmaxf(100.0f/fmax(log(float(a_dataSizeInBytes)), 1.0f), 0.0f); // we want small objects to be mostly in cache</a>
<a name="ln407"> </a>
<a name="ln408">  result.localAddress  = ((char*)memory) - m_dataHalfCurr;</a>
<a name="ln409">  result.sizeInBytes   = a_dataSizeInBytes;</a>
<a name="ln410">  result.useCounter    = (uint32_t)(startCounter*100.0f);</a>
<a name="ln411">  result.inUse         = true;</a>
<a name="ln412"> </a>
<a name="ln413">  m_chunksIdInMemory.push_back(result.id);</a>
<a name="ln414">  m_allChunks.push_back(result);</a>
<a name="ln415"> </a>
<a name="ln416">  return result.id;</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419">void VirtualBuffer::RunCopyingCollector()</a>
<a name="ln420">{</a>
<a name="ln421">  // (1)  we must decide wich objects we can handle in memory</a>
<a name="ln422">  // sort currChunksInMemory by m_allChunks[i].useCounter</a>
<a name="ln423">  //</a>
<a name="ln424">  struct CompareIds</a>
<a name="ln425">  {</a>
<a name="ln426">    CompareIds(VirtualBuffer* a_pVB) : pVB(a_pVB) { }</a>
<a name="ln427">    bool operator()(size_t a, size_t b) const { return pVB-&gt;chunk_at(a).useCounter &gt; pVB-&gt;chunk_at(b).useCounter; }</a>
<a name="ln428">    VirtualBuffer* pVB;</a>
<a name="ln429">  };</a>
<a name="ln430"> </a>
<a name="ln431">  std::sort(m_chunksIdInMemory.begin(), m_chunksIdInMemory.end(), CompareIds(this));</a>
<a name="ln432"> </a>
<a name="ln433">  std::vector&lt;size_t&gt; currChunksInMemory = m_chunksIdInMemory;</a>
<a name="ln434">  m_chunksIdInMemory.clear();</a>
<a name="ln435"> </a>
<a name="ln436">  // (2) sweep throught currChunksInMemory to copy half of them (i.e. half of memory they used) to secondary location</a>
<a name="ln437">  //</a>
<a name="ln438"> </a>
<a name="ln439">  size_t top = 0;</a>
<a name="ln440">  size_t curAccumulatedMemory = 0;</a>
<a name="ln441">  size_t maxAccumulatedMemory = maxAccumulatedSize()/2; // half of buffer size div by 4</a>
<a name="ln442"> </a>
<a name="ln443">  size_t i = 0;</a>
<a name="ln444">  for (; i &lt; currChunksInMemory.size(); i++)</a>
<a name="ln445">  {</a>
<a name="ln446">    size_t id = currChunksInMemory[i];</a>
<a name="ln447">    uint64_t totalSizeInBytes = m_allChunks[id].sizeInBytes;</a>
<a name="ln448"> </a>
<a name="ln449">    curAccumulatedMemory += totalSizeInBytes;</a>
<a name="ln450">     </a>
<a name="ln451">    if (curAccumulatedMemory &gt; maxAccumulatedMemory)</a>
<a name="ln452">      break;</a>
<a name="ln453"> </a>
<a name="ln454">    memcpy(m_dataHalfFree + top, </a>
<a name="ln455">           m_dataHalfCurr + m_allChunks[id].localAddress, totalSizeInBytes);  // copy chunk from m_dataHalfCurr to m_dataHalfFree</a>
<a name="ln456"> </a>
<a name="ln457">    m_allChunks[id].localAddress = top;                                       // alternate it's address because now this chunk is in different location;</a>
<a name="ln458">    m_chunksIdInMemory.push_back(id);</a>
<a name="ln459">    top += totalSizeInBytes;</a>
<a name="ln460">  }</a>
<a name="ln461"> </a>
<a name="ln462">  // (3) swap other chunks to disk</a>
<a name="ln463">  //</a>
<a name="ln464">  for (; i &lt; currChunksInMemory.size(); i++)</a>
<a name="ln465">  {</a>
<a name="ln466">    size_t id = currChunksInMemory[i];</a>
<a name="ln467">    m_allChunks[id].SwapToDisk();</a>
<a name="ln468">    m_allChunks[id].localAddress = uint64_t(-1);</a>
<a name="ln469">  }</a>
<a name="ln470"> </a>
<a name="ln471"> </a>
<a name="ln472">  // (4) swap pointers</a>
<a name="ln473">  //</a>
<a name="ln474">  char* temp     = m_dataHalfCurr;</a>
<a name="ln475">  m_dataHalfCurr = m_dataHalfFree;</a>
<a name="ln476">  m_dataHalfFree = temp;</a>
<a name="ln477">  m_currTop      = top;</a>
<a name="ln478">}</a>
<a name="ln479"> </a>
<a name="ln480">void VirtualBuffer::RunCollector(int a_divisor)</a>
<a name="ln481">{</a>
<a name="ln482">  // (1)  we must decide wich objects we can handle in memory</a>
<a name="ln483">  // sort currChunksInMemory by m_allChunks[i].useCounter</a>
<a name="ln484">  //</a>
<a name="ln485">  struct CompareIds</a>
<a name="ln486">  {</a>
<a name="ln487">    CompareIds(VirtualBuffer* a_pVB) : pVB(a_pVB) { }</a>
<a name="ln488">    bool operator()(size_t a, size_t b) const { return pVB-&gt;chunk_at(a).useCounter &gt; pVB-&gt;chunk_at(b).useCounter; }</a>
<a name="ln489">    VirtualBuffer* pVB;</a>
<a name="ln490">  };</a>
<a name="ln491"> </a>
<a name="ln492">  std::sort(m_chunksIdInMemory.begin(), m_chunksIdInMemory.end(), CompareIds(this));</a>
<a name="ln493"> </a>
<a name="ln494">  std::vector&lt;size_t&gt; currChunksInMemory = m_chunksIdInMemory;</a>
<a name="ln495">  m_chunksIdInMemory.clear();</a>
<a name="ln496"> </a>
<a name="ln497">  // (2) sweep throught currChunksInMemory to copy 1/8 of the buffer size to tempBuffer</a>
<a name="ln498">  //</a>
<a name="ln499">  size_t top = 0;</a>
<a name="ln500">  size_t curAccumulatedMemory = 0;</a>
<a name="ln501">  size_t maxAccumulatedMemory = m_totalSize / a_divisor;</a>
<a name="ln502"> </a>
<a name="ln503">  if (m_pTempBuffer-&gt;size() &lt; maxAccumulatedMemory)</a>
<a name="ln504">    m_pTempBuffer-&gt;resize( maxAccumulatedMemory/sizeof(int) + 1);</a>
<a name="ln505"> </a>
<a name="ln506">  char* dataTemp = (char*)m_pTempBuffer-&gt;data();</a>
<a name="ln507"> </a>
<a name="ln508">  size_t i = 0;</a>
<a name="ln509">  for (; i &lt; currChunksInMemory.size(); i++)</a>
<a name="ln510">  {</a>
<a name="ln511">    size_t id = currChunksInMemory[i];</a>
<a name="ln512">    uint64_t totalSizeInBytes = m_allChunks[id].sizeInBytes;</a>
<a name="ln513"> </a>
<a name="ln514">    curAccumulatedMemory += totalSizeInBytes; </a>
<a name="ln515">    if (curAccumulatedMemory &gt; maxAccumulatedMemory)</a>
<a name="ln516">      break;</a>
<a name="ln517">    </a>
<a name="ln518">    memcpy(dataTemp + top, m_dataHalfCurr + m_allChunks[id].localAddress, totalSizeInBytes);  // copy chunk from m_dataHalfCurr to m_dataHalfFree</a>
<a name="ln519">    </a>
<a name="ln520">    m_allChunks[id].localAddress = top; // alternate it's address because now this chunk is in different location;</a>
<a name="ln521">    m_chunksIdInMemory.push_back(id);</a>
<a name="ln522">    top += totalSizeInBytes;</a>
<a name="ln523">  }</a>
<a name="ln524"> </a>
<a name="ln525">  // (3) swap other chunks to disk</a>
<a name="ln526">  //</a>
<a name="ln527">  for (; i &lt; currChunksInMemory.size(); i++)</a>
<a name="ln528">  {</a>
<a name="ln529">    size_t id = currChunksInMemory[i];</a>
<a name="ln530">    m_allChunks[id].SwapToDisk();</a>
<a name="ln531">    m_allChunks[id].localAddress = uint64_t(-1);</a>
<a name="ln532">  }</a>
<a name="ln533"> </a>
<a name="ln534">  // (4) copy chunks from tempBuffer to </a>
<a name="ln535">  //</a>
<a name="ln536">  memcpy(m_dataHalfCurr, dataTemp, top);</a>
<a name="ln537"> </a>
<a name="ln538">  if (m_pTempBuffer-&gt;size() &gt; maxAccumulatedMemory) // free unneccesary memory of tempBuffer it it was allocated previously too much</a>
<a name="ln539">    (*m_pTempBuffer) = std::vector&lt;int&gt;();</a>
<a name="ln540"> </a>
<a name="ln541">  m_currTop = top;</a>
<a name="ln542">}</a>
<a name="ln543"> </a>
<a name="ln544">void VirtualBuffer::FlushToDisc()</a>
<a name="ln545">{</a>
<a name="ln546">  for (size_t id : m_chunksIdInMemory)</a>
<a name="ln547">    m_allChunks[id].SwapToDisk();</a>
<a name="ln548">}</a>
<a name="ln549"> </a>
<a name="ln550">///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln551">///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln552"> </a>
<a name="ln553"> </a>
<a name="ln554">void* ChunkPointer::GetMemoryNow()</a>
<a name="ln555">{</a>
<a name="ln556">  if (InMemory())</a>
<a name="ln557">  {</a>
<a name="ln558">    return pVB-&gt;m_dataHalfCurr + localAddress;</a>
<a name="ln559">  }</a>
<a name="ln560">  else</a>
<a name="ln561">  {</a>
<a name="ln562">    return nullptr; // #TODO: Swap chunk to memory (m_tempBuffer) and get fucking pointer</a>
<a name="ln563">  }</a>
<a name="ln564">}</a>
<a name="ln565"> </a>
<a name="ln566">const void* ChunkPointer::GetMemoryNow() const</a>
<a name="ln567">{</a>
<a name="ln568">  if (InMemory())</a>
<a name="ln569">  {</a>
<a name="ln570">    return pVB-&gt;m_dataHalfCurr + localAddress;</a>
<a name="ln571">  }</a>
<a name="ln572">  else</a>
<a name="ln573">  {</a>
<a name="ln574">    return nullptr; // #TODO: Swap chunk to memory (m_tempBuffer) and get fucking pointer</a>
<a name="ln575">  }</a>
<a name="ln576">}</a>
<a name="ln577"> </a>
<a name="ln578">extern HRObjectManager g_objManager;</a>
<a name="ln579"> </a>
<a name="ln580">std::wstring LocalDataPathOfCurrentSceneLibrary()</a>
<a name="ln581">{</a>
<a name="ln582">  return g_objManager.scnData.m_path + L&quot;/data/&quot;;</a>
<a name="ln583">}</a>
<a name="ln584"> </a>
<a name="ln585">std::wstring ChunkName(const ChunkPointer&amp; a_chunk)</a>
<a name="ln586">{</a>
<a name="ln587">  std::wstringstream namestream;</a>
<a name="ln588">  namestream &lt;&lt; g_objManager.scnData.m_path.c_str() &lt;&lt; L&quot;/data/chunk_&quot; &lt;&lt; std::setfill(L&quot;0&quot;[0]) &lt;&lt; std::setw(5) &lt;&lt; a_chunk.id;</a>
<a name="ln589"> </a>
<a name="ln590">  switch (a_chunk.type)</a>
<a name="ln591">  {</a>
<a name="ln592">  case CHUNK_TYPE_UNKNOWN:   namestream &lt;&lt; L&quot;.bin&quot;;      break;</a>
<a name="ln593">  case CHUNK_TYPE_ARRAY1F:   namestream &lt;&lt; L&quot;.array1f&quot;;  break;</a>
<a name="ln594">  case CHUNK_TYPE_ARRAY1UI:  namestream &lt;&lt; L&quot;.array1ui&quot;; break;</a>
<a name="ln595">  case CHUNK_TYPE_ARRAY2F:   namestream &lt;&lt; L&quot;.array2f&quot;;  break;</a>
<a name="ln596">  case CHUNK_TYPE_ARRAY4F:   namestream &lt;&lt; L&quot;.array4f&quot;;  break;</a>
<a name="ln597">  case CHUNK_TYPE_IMAGE4UB:  namestream &lt;&lt; L&quot;.image4ub&quot;; break;</a>
<a name="ln598">  case CHUNK_TYPE_IMAGE4F:   namestream &lt;&lt; L&quot;.image4f&quot;;  break;</a>
<a name="ln599">  case CHUNK_TYPE_IMAGE4HF:  namestream &lt;&lt; L&quot;.image4hf&quot;; break;</a>
<a name="ln600">  case CHUNK_TYPE_VSGF:      namestream &lt;&lt; L&quot;.vsgf&quot;;     break;</a>
<a name="ln601">  default:                   namestream &lt;&lt; L&quot;.bin&quot;;      break;</a>
<a name="ln602">  };</a>
<a name="ln603"> </a>
<a name="ln604">  return namestream.str();</a>
<a name="ln605">}</a>
<a name="ln606"> </a>
<a name="ln607">size_t HR_SaveVSGFCompressed(int a_objId, const void* vsgfData, size_t a_vsgfSize, const wchar_t* a_outfileName);</a>
<a name="ln608">extern HRObjectManager g_objManager;</a>
<a name="ln609">void PrintMaterialListNames(std::ostream&amp; strOut, HRMesh* pMesh);</a>
<a name="ln610"> </a>
<a name="ln611">void ChunkPointer::SwapToDisk()</a>
<a name="ln612">{</a>
<a name="ln613">  if (!inUse || !InMemory())</a>
<a name="ln614">  {</a>
<a name="ln615">    //localAddress = -1;</a>
<a name="ln616">    return;</a>
<a name="ln617">  }</a>
<a name="ln618"> </a>
<a name="ln619">  if (wasSaved)</a>
<a name="ln620">    return;</a>
<a name="ln621">  </a>
<a name="ln622">  const std::wstring name = ChunkName(*this);</a>
<a name="ln623">  </a>
<a name="ln624">  if(saveCompressed &amp;&amp; type == CHUNK_TYPE_VSGF)</a>
<a name="ln625">  {</a>
<a name="ln626">    const std::wstring name2 = name + L&quot;c&quot;;</a>
<a name="ln627">    std::wcout &lt;&lt; L&quot;save chunk &quot; &lt;&lt; name2.c_str() &lt;&lt; &quot; to compressed format&quot; &lt;&lt; std::endl;</a>
<a name="ln628">  </a>
<a name="ln629">    std::stringstream strOut;</a>
<a name="ln630">    </a>
<a name="ln631">    bool placeToOrigin = false;</a>
<a name="ln632">    if(this-&gt;sysObjectId &gt;= 0 &amp;&amp; this-&gt;sysObjectId &lt; g_objManager.scnData.meshes.size())</a>
<a name="ln633">    {</a>
<a name="ln634">      auto* pMesh = &amp;g_objManager.scnData.meshes[this-&gt;sysObjectId];</a>
<a name="ln635">      PrintMaterialListNames(strOut, pMesh);</a>
<a name="ln636">      placeToOrigin = pMesh-&gt;m_input.m_placeToOrigin;</a>
<a name="ln637">    }</a>
<a name="ln638">    std::string matnames = strOut.str();</a>
<a name="ln639">    </a>
<a name="ln640">    HR_SaveVSGFCompressed(pVB-&gt;m_dataHalfCurr + localAddress, sizeInBytes, name2.c_str(), matnames.c_str(), matnames.size(), placeToOrigin);</a>
<a name="ln641">  }</a>
<a name="ln642">  else</a>
<a name="ln643">  {</a>
<a name="ln644">    std::ofstream fout;</a>
<a name="ln645">    hr_ofstream_open(fout, name.c_str());</a>
<a name="ln646">    fout.write(pVB-&gt;m_dataHalfCurr + localAddress, sizeInBytes);</a>
<a name="ln647">    fout.close();</a>
<a name="ln648">  }</a>
<a name="ln649">  </a>
<a name="ln650">  wasSaved = true;</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653"> </a>

</code></pre>
<div class="balloon" rel="132"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The '((char *) m_data)' pointer in the '((char *) m_data) + m_totalSize' expression could be nullptr. In such case, resulting value will be senseless and it should not be used. Check lines: 132, 79.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
