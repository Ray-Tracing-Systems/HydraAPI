
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>cstream.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">Corto</a>
<a name="ln3"> </a>
<a name="ln4">Copyright(C) 2017 - Federico Ponchio</a>
<a name="ln5">ISTI - Italian National Research Council - Visual Computing Lab</a>
<a name="ln6"> </a>
<a name="ln7">This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">it under the terms of the GNU Lesser General Public License as published by</a>
<a name="ln9">the Free Software Foundation; either version 3 of the License, or</a>
<a name="ln10">(at your option) any later version.</a>
<a name="ln11"> </a>
<a name="ln12">This program is distributed in the hope that it will be useful,</a>
<a name="ln13">but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  You should have received </a>
<a name="ln15">a copy of the GNU General Public License along with Corto.</a>
<a name="ln16">If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#ifndef CRT_CSTREAM_H</a>
<a name="ln20">#define CRT_CSTREAM_H</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;assert.h&gt;</a>
<a name="ln23">#include &lt;stdlib.h&gt;</a>
<a name="ln24">#include &lt;string.h&gt;</a>
<a name="ln25">#include &lt;iostream&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;bitstream.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29">typedef unsigned char uchar;</a>
<a name="ln30"> </a>
<a name="ln31">using namespace std;</a>
<a name="ln32"> </a>
<a name="ln33">namespace crt {</a>
<a name="ln34"> </a>
<a name="ln35">int ilog2(uint64_t p);</a>
<a name="ln36"> </a>
<a name="ln37">class Stream {</a>
<a name="ln38">public:</a>
<a name="ln39">	enum Entropy { NONE = 0, TUNSTALL = 1, HUFFMAN = 2, ZLIB = 3, LZ4 = 4 };</a>
<a name="ln40">	Entropy entropy;</a>
<a name="ln41">	Stream(): entropy(TUNSTALL) {}</a>
<a name="ln42">};</a>
<a name="ln43"> </a>
<a name="ln44">class OutStream: public Stream {</a>
<a name="ln45">protected:</a>
<a name="ln46">	std::vector&lt;uchar&gt; buffer;</a>
<a name="ln47">	size_t stopwatch; //used to measure stream partial size.</a>
<a name="ln48"> </a>
<a name="ln49">public:</a>
<a name="ln50">	OutStream(size_t r = 0): stopwatch(0) { buffer.reserve(r); }</a>
<a name="ln51">	uint32_t size() { return buffer.size(); }</a>
<a name="ln52">	uchar *data() { return buffer.data(); }</a>
<a name="ln53">	void reserve(size_t r) { buffer.reserve(r); }</a>
<a name="ln54">	void restart() { stopwatch = buffer.size(); }</a>
<a name="ln55">	uint32_t elapsed() {</a>
<a name="ln56">		size_t e = size() - stopwatch; stopwatch = size();</a>
<a name="ln57">		return (uint32_t)e;</a>
<a name="ln58">	}</a>
<a name="ln59">	int  compress(uint32_t size, uchar *data);</a>
<a name="ln60">	int  tunstall_compress(unsigned char *data, int size);</a>
<a name="ln61"> </a>
<a name="ln62">#ifdef ENTROPY_TESTS</a>
<a name="ln63">	int  zlib_compress(uchar *data, int size);</a>
<a name="ln64">	int  lz4_compress(uchar *data, int size);</a>
<a name="ln65">#endif</a>
<a name="ln66"> </a>
<a name="ln67">	template&lt;class T&gt; void write(T c) {</a>
<a name="ln68">		uchar *pos = grow(sizeof(T));</a>
<a name="ln69">		*(T *)pos = c;</a>
<a name="ln70">	}</a>
<a name="ln71">	template&lt;class T&gt; void writeArray(int count, T *c) {</a>
<a name="ln72">		push(c, count*sizeof(T));</a>
<a name="ln73">	}</a>
<a name="ln74"> </a>
<a name="ln75">	void writeString(const char *str) {</a>
<a name="ln76">		uint16_t bytes = (uint16_t)(strlen(str)+1);</a>
<a name="ln77">		write&lt;uint16_t&gt;(bytes);</a>
<a name="ln78">		push(str, bytes);</a>
<a name="ln79">	}</a>
<a name="ln80"> </a>
<a name="ln81">	void write(BitStream &amp;stream) {</a>
<a name="ln82">		stream.flush();</a>
<a name="ln83">		write&lt;int&gt;((int)stream.size);</a>
<a name="ln84"> </a>
<a name="ln85">		//padding to 32 bit is needed for javascript reading (which uses int words.), mem needs to be aligned.</a>
<a name="ln86">		int pad = size() &amp; 0x3;</a>
<a name="ln87">		if(pad != 0)</a>
<a name="ln88">			pad = 4 - pad;</a>
<a name="ln89">		grow(pad);</a>
<a name="ln90">		push(stream.buffer, stream.size*sizeof(uint32_t));</a>
<a name="ln91">	}</a>
<a name="ln92"> </a>
<a name="ln93">	uchar *grow(size_t s) {</a>
<a name="ln94">		size_t len = buffer.size();</a>
<a name="ln95">		buffer.resize(len + s);</a>
<a name="ln96">		//padding to 32 bit is needed for javascript reading (which uses int words.), mem needs to be aligned.</a>
<a name="ln97">		assert((((uintptr_t)buffer.data()) &amp; 0x3) == 0);</a>
<a name="ln98">		return buffer.data() + len;</a>
<a name="ln99">	}</a>
<a name="ln100"> </a>
<a name="ln101">	void push(const void *b, size_t s) {</a>
<a name="ln102">		uchar *pos = grow(s);</a>
<a name="ln103">		memcpy(pos, b, s);</a>
<a name="ln104">	}</a>
<a name="ln105"> </a>
<a name="ln106"> </a>
<a name="ln107">	static int needed(int a) {</a>
<a name="ln108">		if(a == 0) return 0;</a>
<a name="ln109">		if(a == -1) return 1;</a>
<a name="ln110">		if(a &lt; 0) a = -a - 1;</a>
<a name="ln111">		int n = 2;</a>
<a name="ln112">		while(a &gt;&gt;= 1) n++;</a>
<a name="ln113">		return n;</a>
<a name="ln114">	}</a>
<a name="ln115"> </a>
<a name="ln116">	//encode differences of vectors (assuming no correlation between components)</a>
<a name="ln117">	template &lt;class T&gt; void encodeValues(uint32_t size, T *values, int N) {</a>
<a name="ln118">		BitStream bitstream(size);</a>
<a name="ln119">		//Storing bitstream before logs, allows in decompression to allocate only 1 logs array and reuse it.</a>
<a name="ln120">		std::vector&lt;std::vector&lt;uchar&gt; &gt; clogs((size_t)N);</a>
<a name="ln121"> </a>
<a name="ln122">		for(int c = 0; c &lt; N; c++) {</a>
<a name="ln123">			auto &amp;logs = clogs[c];</a>
<a name="ln124">			logs.resize(size);</a>
<a name="ln125">			for(uint32_t i = 0; i &lt; size; i++) {</a>
<a name="ln126">				int val = values[i*N + c];</a>
<a name="ln127"> </a>
<a name="ln128">				if(val == 0) {</a>
<a name="ln129">					logs[i] = 0;</a>
<a name="ln130">					continue;</a>
<a name="ln131">				}</a>
<a name="ln132">				int ret = ilog2(abs(val)) + 1;  //0 -&gt; 0, [1,-1] -&gt; 1 [-2,-3,2,3] -&gt; 2</a>
<a name="ln133">				logs[i] = (uchar)ret;</a>
<a name="ln134">				int middle = (1&lt;&lt;ret)&gt;&gt;1;</a>
<a name="ln135">				if(val &lt; 0) val = -val -middle;</a>
<a name="ln136">				bitstream.write(val, ret);</a>
<a name="ln137">			}</a>
<a name="ln138">		}</a>
<a name="ln139"> </a>
<a name="ln140">		write(bitstream);</a>
<a name="ln141">		for(int c = 0; c &lt; N; c++)</a>
<a name="ln142">			compress((uint32_t)clogs[c].size(), clogs[c].data());</a>
<a name="ln143">	}</a>
<a name="ln144">	//encode differences of vectors (assuming correlation between components)</a>
<a name="ln145">	template &lt;class T&gt; void encodeArray(uint32_t size, T *values, int N) {</a>
<a name="ln146">		BitStream bitstream(size);</a>
<a name="ln147">		std::vector&lt;uchar&gt; logs(size);</a>
<a name="ln148"> </a>
<a name="ln149">		for(uint32_t i = 0; i &lt; size; i++) {</a>
<a name="ln150">			T *p = values + i*N;</a>
<a name="ln151">			int diff = needed(p[0]);</a>
<a name="ln152">			for(int c = 1; c &lt; N; c++) {</a>
<a name="ln153">				int d = needed(p[c]);</a>
<a name="ln154">				if(diff &lt; d) diff = d;</a>
<a name="ln155">			}</a>
<a name="ln156">			logs[i] = diff;</a>
<a name="ln157">			if(diff == 0) continue;</a>
<a name="ln158"> </a>
<a name="ln159">			int max = 1&lt;&lt;(diff-1);</a>
<a name="ln160">			for(int c = 0; c &lt; N; c++)</a>
<a name="ln161">				bitstream.write(p[c] + max, diff);</a>
<a name="ln162">		}</a>
<a name="ln163"> </a>
<a name="ln164">		write(bitstream);</a>
<a name="ln165">		compress(logs.size(), logs.data());</a>
<a name="ln166">	}</a>
<a name="ln167">	</a>
<a name="ln168">	//encode DIFFS</a>
<a name="ln169">	template &lt;class T&gt; void encodeDiffs(uint32_t size, T *values) {</a>
<a name="ln170">		BitStream bitstream(size);</a>
<a name="ln171">		std::vector&lt;uchar&gt; logs(size);</a>
<a name="ln172">		for(uint32_t i = 0; i &lt; size; i++) {</a>
<a name="ln173">			T val = values[i];</a>
<a name="ln174">			if(val == 0) {</a>
<a name="ln175">				logs[i] = 0;</a>
<a name="ln176">				continue;</a>
<a name="ln177">			}</a>
<a name="ln178">			int ret = ilog2(abs(val)) + 1;  //0 -&gt; 0, [1,-1] -&gt; 1 [-2,-3,2,3] -&gt; 2</a>
<a name="ln179">			logs[i] = (uchar)ret;</a>
<a name="ln180">			</a>
<a name="ln181">			int middle = (1&lt;&lt;ret)&gt;&gt;1;</a>
<a name="ln182">			if(val &lt; 0) val = -val -middle;</a>
<a name="ln183">			bitstream.write(val, ret);</a>
<a name="ln184">		}</a>
<a name="ln185">		write(bitstream);</a>
<a name="ln186">		compress(logs.size(), logs.data());</a>
<a name="ln187">	}</a>
<a name="ln188">	</a>
<a name="ln189">	//encode POSITIVE values</a>
<a name="ln190">	template &lt;class T&gt; void encodeIndices(uint32_t size, T *values) {</a>
<a name="ln191">		BitStream bitstream(size);</a>
<a name="ln192">		std::vector&lt;uchar&gt; logs(size);</a>
<a name="ln193">		for(uint32_t i = 0; i &lt; size; i++) {</a>
<a name="ln194">			T val = values[i] + 1;</a>
<a name="ln195">			if(val == 1) {</a>
<a name="ln196">				logs[i] = 0;</a>
<a name="ln197">				continue;</a>
<a name="ln198">			}</a>
<a name="ln199">			</a>
<a name="ln200">			int ret = logs[i] = ilog2(val);</a>
<a name="ln201">			bitstream.write(val -(1&lt;&lt;ret), ret);</a>
<a name="ln202">		}</a>
<a name="ln203">		write(bitstream);</a>
<a name="ln204">		compress(logs.size(), logs.data());</a>
<a name="ln205">	}</a>
<a name="ln206">};</a>
<a name="ln207"> </a>
<a name="ln208">class InStream: public Stream {</a>
<a name="ln209">protected:</a>
<a name="ln210">	const uchar *buffer;</a>
<a name="ln211">	const uchar *pos; //for reading.</a>
<a name="ln212"> </a>
<a name="ln213">public:</a>
<a name="ln214"> </a>
<a name="ln215">	InStream(): buffer(NULL), pos(NULL) {}</a>
<a name="ln216">	InStream(int _size, uchar *_buffer) {</a>
<a name="ln217">		init(_size, _buffer);</a>
<a name="ln218">	}</a>
<a name="ln219"> </a>
<a name="ln220">	void decompress(std::vector&lt;uchar&gt; &amp;data);</a>
<a name="ln221">	void tunstall_decompress(std::vector&lt;uchar&gt; &amp;data);</a>
<a name="ln222"> </a>
<a name="ln223">#ifdef ENTROPY_TESTS</a>
<a name="ln224">	int  zlib_compress(uchar *data, int size);</a>
<a name="ln225">	int  lz4_compress(uchar *data, int size);</a>
<a name="ln226">#endif</a>
<a name="ln227"> </a>
<a name="ln228">	void init(int /*_size*/, const uchar *_buffer) {</a>
<a name="ln229">		buffer = _buffer; //I'm not lying, I won't touch it.</a>
<a name="ln230">		pos = buffer;</a>
<a name="ln231">	}</a>
<a name="ln232"> </a>
<a name="ln233">	void rewind() { pos = buffer; }</a>
<a name="ln234"> </a>
<a name="ln235">/*	template&lt;class T&gt; T read() {</a>
<a name="ln236">		T c;</a>
<a name="ln237">		c = *(T *)pos;</a>
<a name="ln238">		pos += sizeof(T);</a>
<a name="ln239">		return c;</a>
<a name="ln240">	} */</a>
<a name="ln241"> </a>
<a name="ln242">	template&lt;class T&gt; T *readArray(uint32_t s) {</a>
<a name="ln243">		T *buffer = (T *)pos;</a>
<a name="ln244">		pos += s*sizeof(T);</a>
<a name="ln245">		return buffer;</a>
<a name="ln246">	}</a>
<a name="ln247"> </a>
<a name="ln248">	uint8_t readUint8() {</a>
<a name="ln249">		return *pos++;</a>
<a name="ln250">	}</a>
<a name="ln251"> </a>
<a name="ln252">	uint16_t readUint16() {</a>
<a name="ln253">		uint16_t c;</a>
<a name="ln254">		c = pos[1];</a>
<a name="ln255">		c&lt;&lt;=8;</a>
<a name="ln256">		c += pos[0];</a>
<a name="ln257">		pos += 2;</a>
<a name="ln258">		return c;</a>
<a name="ln259">	}</a>
<a name="ln260"> </a>
<a name="ln261">	uint32_t readUint32() {</a>
<a name="ln262">		uint32_t c;</a>
<a name="ln263">		c = pos[3];</a>
<a name="ln264">		c&lt;&lt;=8;</a>
<a name="ln265">		c += pos[2];</a>
<a name="ln266">		c&lt;&lt;=8;</a>
<a name="ln267">		c += pos[1];</a>
<a name="ln268">		c&lt;&lt;=8;</a>
<a name="ln269">		c += pos[0];</a>
<a name="ln270">		pos += 4;</a>
<a name="ln271">		return c;</a>
<a name="ln272">	}</a>
<a name="ln273"> </a>
<a name="ln274">	float readFloat() {</a>
<a name="ln275">		uint32_t c = readUint32();</a>
<a name="ln276">		return *(float *)&amp;c;</a>
<a name="ln277">	}</a>
<a name="ln278"> </a>
<a name="ln279">	char *readString() {</a>
<a name="ln280">		uint16_t bytes = readUint16();</a>
<a name="ln281">		return readArray&lt;char&gt;(bytes);</a>
<a name="ln282">	}</a>
<a name="ln283"> </a>
<a name="ln284"> </a>
<a name="ln285">	void read(BitStream &amp;stream) {</a>
<a name="ln286">		int s = readUint32();</a>
<a name="ln287">		//padding to 32 bit is needed for javascript reading (which uses int words.), mem needs to be aligned.</a>
<a name="ln288">		int pad = (pos - buffer) &amp; 0x3;</a>
<a name="ln289">		if(pad != 0)</a>
<a name="ln290">			pos += 4 - pad;</a>
<a name="ln291">		stream.init(s, (uint32_t *)pos);</a>
<a name="ln292">		pos += s*sizeof(uint32_t);</a>
<a name="ln293">	}</a>
<a name="ln294"> </a>
<a name="ln295"> </a>
<a name="ln296">	template &lt;class T&gt; int decodeValues(T *values, int N) {</a>
<a name="ln297">		BitStream bitstream;</a>
<a name="ln298">		read(bitstream);</a>
<a name="ln299"> </a>
<a name="ln300">		std::vector&lt;uchar&gt; logs;</a>
<a name="ln301"> </a>
<a name="ln302">		for(int c = 0; c &lt; N; c++) {</a>
<a name="ln303">			decompress(logs);</a>
<a name="ln304">			if(!values) continue;</a>
<a name="ln305"> </a>
<a name="ln306">			for(uint32_t i = 0; i &lt; logs.size(); i++) {</a>
<a name="ln307">				uchar &amp;diff = logs[i];</a>
<a name="ln308">				if(diff == 0) {</a>
<a name="ln309">					values[i*N + c] = 0;</a>
<a name="ln310">					continue;</a>
<a name="ln311">				}</a>
<a name="ln312"> </a>
<a name="ln313">				int val = (int)bitstream.read(diff);</a>
<a name="ln314">				int middle = 1&lt;&lt;(diff-1);</a>
<a name="ln315">				if(val &lt; middle)</a>
<a name="ln316">					val = -val -middle;</a>
<a name="ln317">				values[i*N + c] = (T)val;</a>
<a name="ln318">			}</a>
<a name="ln319">		}</a>
<a name="ln320">		return logs.size();</a>
<a name="ln321">	}</a>
<a name="ln322"> </a>
<a name="ln323"> </a>
<a name="ln324"> </a>
<a name="ln325"> </a>
<a name="ln326">	template &lt;class T&gt; uint32_t decodeArray(T *values, int N) {</a>
<a name="ln327">		BitStream bitstream;</a>
<a name="ln328">		read(bitstream);</a>
<a name="ln329"> </a>
<a name="ln330">		std::vector&lt;uchar&gt; logs;</a>
<a name="ln331">		decompress(logs);</a>
<a name="ln332"> </a>
<a name="ln333">		if(!values) //just skip and return number of readed</a>
<a name="ln334">			return (uint32_t)logs.size();</a>
<a name="ln335"> </a>
<a name="ln336">		for(uint32_t i =0; i &lt; logs.size(); i++) {</a>
<a name="ln337">			T *p = values + i*N;</a>
<a name="ln338">			uchar &amp;diff = logs[i];</a>
<a name="ln339">			if(diff == 0) {</a>
<a name="ln340">				for(int c = 0; c &lt; N; c++)</a>
<a name="ln341">					p[c] = 0;</a>
<a name="ln342">				continue;</a>
<a name="ln343">			}</a>
<a name="ln344">			//making a single read is 2/3 faster</a>
<a name="ln345">			//uint64_t &amp;max = bmax[diff];</a>
<a name="ln346">			const uint64_t max = (1&lt;&lt;diff)&gt;&gt;1;</a>
<a name="ln347">			if(0 &amp;&amp; diff &lt; 22) {</a>
<a name="ln348">				//uint64_t &amp;mask = bmask[diff]; //using table is 4% faster</a>
<a name="ln349">				const uint64_t mask = (1&lt;&lt;diff)-1;</a>
<a name="ln350">				uint64_t bits = bitstream.read(N*diff);</a>
<a name="ln351">				for(uint32_t c = N-1; c &gt; 0; c--) {</a>
<a name="ln352">					p[c] = (T)((bits &amp; mask) - max);</a>
<a name="ln353">					bits &gt;&gt;= diff;</a>
<a name="ln354">				}</a>
<a name="ln355">				p[0] = (T)(bits - max);</a>
<a name="ln356">			} else {</a>
<a name="ln357">				for(int c = 0; c &lt; N; c++)</a>
<a name="ln358">					p[c] = (T)(bitstream.read(diff) - max);</a>
<a name="ln359">			}</a>
<a name="ln360">		}</a>
<a name="ln361">		return (uint32_t)logs.size();</a>
<a name="ln362">	}</a>
<a name="ln363">	</a>
<a name="ln364">	//decode POSITIVE values</a>
<a name="ln365">	template &lt;class T&gt; uint32_t decodeIndices(T *values) {</a>
<a name="ln366">		BitStream bitstream;</a>
<a name="ln367">		read(bitstream);</a>
<a name="ln368"> </a>
<a name="ln369">		std::vector&lt;uchar&gt; logs;</a>
<a name="ln370">		decompress(logs);</a>
<a name="ln371">		</a>
<a name="ln372">		if(!values)</a>
<a name="ln373">			return (uint32_t)logs.size();</a>
<a name="ln374">		</a>
<a name="ln375">		for(uint32_t i =0; i &lt; logs.size(); i++) {</a>
<a name="ln376">			T &amp;p = values[i];</a>
<a name="ln377">			uchar &amp;ret = logs[i];</a>
<a name="ln378">			if(ret == 0) {</a>
<a name="ln379">				p = 0;</a>
<a name="ln380">				continue;</a>
<a name="ln381">			}</a>
<a name="ln382">			p = (1&lt;&lt;ret) + (T)bitstream.read(ret) -1;</a>
<a name="ln383">		}</a>
<a name="ln384">		return (uint32_t)logs.size();</a>
<a name="ln385">	}</a>
<a name="ln386">	</a>
<a name="ln387">	//decode DIFFERENCES</a>
<a name="ln388">	template &lt;class T&gt; uint32_t decodeDiffs(T *values) {</a>
<a name="ln389">		BitStream bitstream;</a>
<a name="ln390">		read(bitstream);</a>
<a name="ln391"> </a>
<a name="ln392">		std::vector&lt;uchar&gt; logs;</a>
<a name="ln393">		decompress(logs);</a>
<a name="ln394">		</a>
<a name="ln395">		if(!values)</a>
<a name="ln396">			return (uint32_t)logs.size();</a>
<a name="ln397">		</a>
<a name="ln398">		for(uint32_t i =0; i &lt; logs.size(); i++) {</a>
<a name="ln399">			</a>
<a name="ln400">			uchar &amp;diff = logs[i];</a>
<a name="ln401">			if(diff == 0) {</a>
<a name="ln402">				values[i] = 0;</a>
<a name="ln403">				continue;</a>
<a name="ln404">			}</a>
<a name="ln405"> </a>
<a name="ln406">/*</a>
<a name="ln407"> *  Is this faster (and correct)?</a>
<a name="ln408">			int max = (1&lt;&lt;diff)&gt;&gt;1;</a>
<a name="ln409">			values[i] = (int)bitstream.read(diff) - ((1&lt;&lt;(diff)&gt;&gt;1);</a>
<a name="ln410">*/</a>
<a name="ln411">					</a>
<a name="ln412">			int val = (int)bitstream.read(diff);</a>
<a name="ln413">			int middle = 1&lt;&lt;(diff-1);</a>
<a name="ln414">			if(val &lt; middle)</a>
<a name="ln415">				val = -val -middle;</a>
<a name="ln416">			values[i] = (T)val; </a>
<a name="ln417">		}</a>
<a name="ln418">		return (uint32_t)logs.size();</a>
<a name="ln419">	}</a>
<a name="ln420">};</a>
<a name="ln421"> </a>
<a name="ln422">} //namespace</a>
<a name="ln423">#endif // CRT_CSTREAM_H</a>

</code></pre>
<div class="balloon" rel="349"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v629/" target="_blank">V629</a> Consider inspecting the '1 << diff' expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type.</p></div>
<div class="balloon" rel="346"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v629/" target="_blank">V629</a> Consider inspecting the '1 << diff' expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
