
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pugixml.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * pugixml parser - version 1.8</a>
<a name="ln3"> * --------------------------------------------------------</a>
<a name="ln4"> * Copyright (C) 2006-2016, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)</a>
<a name="ln5"> * Report bugs and download new versions at http://pugixml.org/</a>
<a name="ln6"> *</a>
<a name="ln7"> * This library is distributed under the MIT License. See notice at the end</a>
<a name="ln8"> * of this file.</a>
<a name="ln9"> *</a>
<a name="ln10"> * This work is based on the pugxml parser, which is:</a>
<a name="ln11"> * Copyright (C) 2003, by Kristen Wegner (kristen@tima.net)</a>
<a name="ln12"> */</a>
<a name="ln13"> </a>
<a name="ln14">#ifndef SOURCE_PUGIXML_CPP</a>
<a name="ln15">#define SOURCE_PUGIXML_CPP</a>
<a name="ln16"> </a>
<a name="ln17">#include &quot;pugixml.hpp&quot;</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;stdlib.h&gt;</a>
<a name="ln20">#include &lt;stdio.h&gt;</a>
<a name="ln21">#include &lt;string.h&gt;</a>
<a name="ln22">#include &lt;assert.h&gt;</a>
<a name="ln23">#include &lt;limits.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#ifdef PUGIXML_WCHAR_MODE</a>
<a name="ln26">#	include &lt;wchar.h&gt;</a>
<a name="ln27">#endif</a>
<a name="ln28"> </a>
<a name="ln29">#ifndef PUGIXML_NO_XPATH</a>
<a name="ln30">#	include &lt;math.h&gt;</a>
<a name="ln31">#	include &lt;float.h&gt;</a>
<a name="ln32">#	ifdef PUGIXML_NO_EXCEPTIONS</a>
<a name="ln33">#		include &lt;setjmp.h&gt;</a>
<a name="ln34">#	endif</a>
<a name="ln35">#endif</a>
<a name="ln36"> </a>
<a name="ln37">#ifndef PUGIXML_NO_STL</a>
<a name="ln38">#	include &lt;istream&gt;</a>
<a name="ln39">#	include &lt;ostream&gt;</a>
<a name="ln40">#	include &lt;string&gt;</a>
<a name="ln41">#endif</a>
<a name="ln42"> </a>
<a name="ln43">// For placement new</a>
<a name="ln44">#include &lt;new&gt;</a>
<a name="ln45"> </a>
<a name="ln46">#ifdef _MSC_VER</a>
<a name="ln47">#	pragma warning(push)</a>
<a name="ln48">#	pragma warning(disable: 4127) // conditional expression is constant</a>
<a name="ln49">#	pragma warning(disable: 4324) // structure was padded due to __declspec(align())</a>
<a name="ln50">#	pragma warning(disable: 4611) // interaction between '_setjmp' and C++ object destruction is non-portable</a>
<a name="ln51">#	pragma warning(disable: 4702) // unreachable code</a>
<a name="ln52">#	pragma warning(disable: 4996) // this function or variable may be unsafe</a>
<a name="ln53">#	pragma warning(disable: 4793) // function compiled as native: presence of '_setjmp' makes a function unmanaged</a>
<a name="ln54">#endif</a>
<a name="ln55"> </a>
<a name="ln56">#ifdef __INTEL_COMPILER</a>
<a name="ln57">#	pragma warning(disable: 177) // function was declared but never referenced</a>
<a name="ln58">#	pragma warning(disable: 279) // controlling expression is constant</a>
<a name="ln59">#	pragma warning(disable: 1478 1786) // function was declared &quot;deprecated&quot;</a>
<a name="ln60">#	pragma warning(disable: 1684) // conversion from pointer to same-sized integral type</a>
<a name="ln61">#endif</a>
<a name="ln62"> </a>
<a name="ln63">#if defined(__BORLANDC__) &amp;&amp; defined(PUGIXML_HEADER_ONLY)</a>
<a name="ln64">#	pragma warn -8080 // symbol is declared but never used; disabling this inside push/pop bracket does not make the warning go away</a>
<a name="ln65">#endif</a>
<a name="ln66"> </a>
<a name="ln67">#ifdef __BORLANDC__</a>
<a name="ln68">#	pragma option push</a>
<a name="ln69">#	pragma warn -8008 // condition is always false</a>
<a name="ln70">#	pragma warn -8066 // unreachable code</a>
<a name="ln71">#endif</a>
<a name="ln72"> </a>
<a name="ln73">#ifdef __SNC__</a>
<a name="ln74">// Using diag_push/diag_pop does not disable the warnings inside templates due to a compiler bug</a>
<a name="ln75">#	pragma diag_suppress=178 // function was declared but never referenced</a>
<a name="ln76">#	pragma diag_suppress=237 // controlling expression is constant</a>
<a name="ln77">#endif</a>
<a name="ln78"> </a>
<a name="ln79">// Inlining controls</a>
<a name="ln80">#if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1300</a>
<a name="ln81">#	define PUGI__NO_INLINE __declspec(noinline)</a>
<a name="ln82">#elif defined(__GNUC__)</a>
<a name="ln83">#	define PUGI__NO_INLINE __attribute__((noinline))</a>
<a name="ln84">#else</a>
<a name="ln85">#	define PUGI__NO_INLINE</a>
<a name="ln86">#endif</a>
<a name="ln87"> </a>
<a name="ln88">// Branch weight controls</a>
<a name="ln89">#if defined(__GNUC__)</a>
<a name="ln90">#	define PUGI__UNLIKELY(cond) __builtin_expect(cond, 0)</a>
<a name="ln91">#else</a>
<a name="ln92">#	define PUGI__UNLIKELY(cond) (cond)</a>
<a name="ln93">#endif</a>
<a name="ln94"> </a>
<a name="ln95">// Simple static assertion</a>
<a name="ln96">#define PUGI__STATIC_ASSERT(cond) { static const char condition_failed[(cond) ? 1 : -1] = {0}; (void)condition_failed[0]; }</a>
<a name="ln97"> </a>
<a name="ln98">// Digital Mars C++ bug workaround for passing char loaded from memory via stack</a>
<a name="ln99">#ifdef __DMC__</a>
<a name="ln100">#	define PUGI__DMC_VOLATILE volatile</a>
<a name="ln101">#else</a>
<a name="ln102">#	define PUGI__DMC_VOLATILE</a>
<a name="ln103">#endif</a>
<a name="ln104"> </a>
<a name="ln105">// Borland C++ bug workaround for not defining ::memcpy depending on header include order (can't always use std::memcpy because some compilers don't have it at all)</a>
<a name="ln106">#if defined(__BORLANDC__) &amp;&amp; !defined(__MEM_H_USING_LIST)</a>
<a name="ln107">using std::memcpy;</a>
<a name="ln108">using std::memmove;</a>
<a name="ln109">using std::memset;</a>
<a name="ln110">#endif</a>
<a name="ln111"> </a>
<a name="ln112">// Some MinGW versions have headers that erroneously omit LLONG_MIN/LLONG_MAX/ULLONG_MAX definitions in strict ANSI mode</a>
<a name="ln113">#if defined(PUGIXML_HAS_LONG_LONG) &amp;&amp; defined(__MINGW32__) &amp;&amp; defined(__STRICT_ANSI__) &amp;&amp; !defined(LLONG_MAX) &amp;&amp; !defined(LLONG_MIN) &amp;&amp; !defined(ULLONG_MAX)</a>
<a name="ln114">#	define LLONG_MAX 9223372036854775807LL</a>
<a name="ln115">#	define LLONG_MIN (-LLONG_MAX-1)</a>
<a name="ln116">#	define ULLONG_MAX (2ULL*LLONG_MAX+1)</a>
<a name="ln117">#endif</a>
<a name="ln118"> </a>
<a name="ln119">// In some environments MSVC is a compiler but the CRT lacks certain MSVC-specific features</a>
<a name="ln120">#if defined(_MSC_VER) &amp;&amp; !defined(__S3E__)</a>
<a name="ln121">#	define PUGI__MSVC_CRT_VERSION _MSC_VER</a>
<a name="ln122">#endif</a>
<a name="ln123"> </a>
<a name="ln124">#ifdef PUGIXML_HEADER_ONLY</a>
<a name="ln125">#	define PUGI__NS_BEGIN namespace pugi { namespace impl {</a>
<a name="ln126">#	define PUGI__NS_END } }</a>
<a name="ln127">#	define PUGI__FN inline</a>
<a name="ln128">#	define PUGI__FN_NO_INLINE inline</a>
<a name="ln129">#else</a>
<a name="ln130">#	if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1300 // MSVC6 seems to have an amusing bug with anonymous namespaces inside namespaces</a>
<a name="ln131">#		define PUGI__NS_BEGIN namespace pugi { namespace impl {</a>
<a name="ln132">#		define PUGI__NS_END } }</a>
<a name="ln133">#	else</a>
<a name="ln134">#		define PUGI__NS_BEGIN namespace pugi { namespace impl { namespace {</a>
<a name="ln135">#		define PUGI__NS_END } } }</a>
<a name="ln136">#	endif</a>
<a name="ln137">#	define PUGI__FN</a>
<a name="ln138">#	define PUGI__FN_NO_INLINE PUGI__NO_INLINE</a>
<a name="ln139">#endif</a>
<a name="ln140"> </a>
<a name="ln141">// uintptr_t</a>
<a name="ln142">#if (defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1600) || (defined(__BORLANDC__) &amp;&amp; __BORLANDC__ &lt; 0x561)</a>
<a name="ln143">namespace pugi</a>
<a name="ln144">{</a>
<a name="ln145">#	ifndef _UINTPTR_T_DEFINED</a>
<a name="ln146">	typedef size_t uintptr_t;</a>
<a name="ln147">#	endif</a>
<a name="ln148"> </a>
<a name="ln149">	typedef unsigned __int8 uint8_t;</a>
<a name="ln150">	typedef unsigned __int16 uint16_t;</a>
<a name="ln151">	typedef unsigned __int32 uint32_t;</a>
<a name="ln152">}</a>
<a name="ln153">#else</a>
<a name="ln154">#	include &lt;stdint.h&gt;</a>
<a name="ln155">#endif</a>
<a name="ln156"> </a>
<a name="ln157">// Memory allocation</a>
<a name="ln158">PUGI__NS_BEGIN</a>
<a name="ln159">	PUGI__FN void* default_allocate(size_t size)</a>
<a name="ln160">	{</a>
<a name="ln161">		return malloc(size);</a>
<a name="ln162">	}</a>
<a name="ln163"> </a>
<a name="ln164">	PUGI__FN void default_deallocate(void* ptr)</a>
<a name="ln165">	{</a>
<a name="ln166">		free(ptr);</a>
<a name="ln167">	}</a>
<a name="ln168"> </a>
<a name="ln169">	template &lt;typename T&gt;</a>
<a name="ln170">	struct xml_memory_management_function_storage</a>
<a name="ln171">	{</a>
<a name="ln172">		static allocation_function allocate;</a>
<a name="ln173">		static deallocation_function deallocate;</a>
<a name="ln174">	};</a>
<a name="ln175"> </a>
<a name="ln176">	// Global allocation functions are stored in class statics so that in header mode linker deduplicates them</a>
<a name="ln177">	// Without a template&lt;&gt; we'll get multiple definitions of the same static</a>
<a name="ln178">	template &lt;typename T&gt; allocation_function xml_memory_management_function_storage&lt;T&gt;::allocate = default_allocate;</a>
<a name="ln179">	template &lt;typename T&gt; deallocation_function xml_memory_management_function_storage&lt;T&gt;::deallocate = default_deallocate;</a>
<a name="ln180"> </a>
<a name="ln181">	typedef xml_memory_management_function_storage&lt;int&gt; xml_memory;</a>
<a name="ln182">PUGI__NS_END</a>
<a name="ln183"> </a>
<a name="ln184">// String utilities</a>
<a name="ln185">PUGI__NS_BEGIN</a>
<a name="ln186">	// Get string length</a>
<a name="ln187">	PUGI__FN size_t strlength(const char_t* s)</a>
<a name="ln188">	{</a>
<a name="ln189">		assert(s);</a>
<a name="ln190"> </a>
<a name="ln191">	#ifdef PUGIXML_WCHAR_MODE</a>
<a name="ln192">		return wcslen(s);</a>
<a name="ln193">	#else</a>
<a name="ln194">		return strlen(s);</a>
<a name="ln195">	#endif</a>
<a name="ln196">	}</a>
<a name="ln197"> </a>
<a name="ln198">	// Compare two strings</a>
<a name="ln199">	PUGI__FN bool strequal(const char_t* src, const char_t* dst)</a>
<a name="ln200">	{</a>
<a name="ln201">		assert(src &amp;&amp; dst);</a>
<a name="ln202"> </a>
<a name="ln203">	#ifdef PUGIXML_WCHAR_MODE</a>
<a name="ln204">		return wcscmp(src, dst) == 0;</a>
<a name="ln205">	#else</a>
<a name="ln206">		return strcmp(src, dst) == 0;</a>
<a name="ln207">	#endif</a>
<a name="ln208">	}</a>
<a name="ln209"> </a>
<a name="ln210">	// Compare lhs with [rhs_begin, rhs_end)</a>
<a name="ln211">	PUGI__FN bool strequalrange(const char_t* lhs, const char_t* rhs, size_t count)</a>
<a name="ln212">	{</a>
<a name="ln213">		for (size_t i = 0; i &lt; count; ++i)</a>
<a name="ln214">			if (lhs[i] != rhs[i])</a>
<a name="ln215">				return false;</a>
<a name="ln216"> </a>
<a name="ln217">		return lhs[count] == 0;</a>
<a name="ln218">	}</a>
<a name="ln219"> </a>
<a name="ln220">	// Get length of wide string, even if CRT lacks wide character support</a>
<a name="ln221">	PUGI__FN size_t strlength_wide(const wchar_t* s)</a>
<a name="ln222">	{</a>
<a name="ln223">		assert(s);</a>
<a name="ln224"> </a>
<a name="ln225">	#ifdef PUGIXML_WCHAR_MODE</a>
<a name="ln226">		return wcslen(s);</a>
<a name="ln227">	#else</a>
<a name="ln228">		const wchar_t* end = s;</a>
<a name="ln229">		while (*end) end++;</a>
<a name="ln230">		return static_cast&lt;size_t&gt;(end - s);</a>
<a name="ln231">	#endif</a>
<a name="ln232">	}</a>
<a name="ln233">PUGI__NS_END</a>
<a name="ln234"> </a>
<a name="ln235">// auto_ptr-like object for exception recovery</a>
<a name="ln236">PUGI__NS_BEGIN</a>
<a name="ln237">	template &lt;typename T&gt; struct auto_deleter</a>
<a name="ln238">	{</a>
<a name="ln239">		typedef void (*D)(T*);</a>
<a name="ln240"> </a>
<a name="ln241">		T* data;</a>
<a name="ln242">		D deleter;</a>
<a name="ln243"> </a>
<a name="ln244">		auto_deleter(T* data_, D deleter_): data(data_), deleter(deleter_)</a>
<a name="ln245">		{</a>
<a name="ln246">		}</a>
<a name="ln247"> </a>
<a name="ln248">		~auto_deleter()</a>
<a name="ln249">		{</a>
<a name="ln250">			if (data) deleter(data);</a>
<a name="ln251">		}</a>
<a name="ln252"> </a>
<a name="ln253">		T* release()</a>
<a name="ln254">		{</a>
<a name="ln255">			T* result = data;</a>
<a name="ln256">			data = 0;</a>
<a name="ln257">			return result;</a>
<a name="ln258">		}</a>
<a name="ln259">	};</a>
<a name="ln260">PUGI__NS_END</a>
<a name="ln261"> </a>
<a name="ln262">#ifdef PUGIXML_COMPACT</a>
<a name="ln263">PUGI__NS_BEGIN</a>
<a name="ln264">	class compact_hash_table</a>
<a name="ln265">	{</a>
<a name="ln266">	public:</a>
<a name="ln267">		compact_hash_table(): _items(0), _capacity(0), _count(0)</a>
<a name="ln268">		{</a>
<a name="ln269">		}</a>
<a name="ln270"> </a>
<a name="ln271">		void clear()</a>
<a name="ln272">		{</a>
<a name="ln273">			if (_items)</a>
<a name="ln274">			{</a>
<a name="ln275">				xml_memory::deallocate(_items);</a>
<a name="ln276">				_items = 0;</a>
<a name="ln277">				_capacity = 0;</a>
<a name="ln278">				_count = 0;</a>
<a name="ln279">			}</a>
<a name="ln280">		}</a>
<a name="ln281"> </a>
<a name="ln282">		void** find(const void* key)</a>
<a name="ln283">		{</a>
<a name="ln284">			assert(key);</a>
<a name="ln285"> </a>
<a name="ln286">			if (_capacity == 0) return 0;</a>
<a name="ln287"> </a>
<a name="ln288">			size_t hashmod = _capacity - 1;</a>
<a name="ln289">			size_t bucket = hash(key) &amp; hashmod;</a>
<a name="ln290"> </a>
<a name="ln291">			for (size_t probe = 0; probe &lt;= hashmod; ++probe)</a>
<a name="ln292">			{</a>
<a name="ln293">				item_t&amp; probe_item = _items[bucket];</a>
<a name="ln294"> </a>
<a name="ln295">				if (probe_item.key == key)</a>
<a name="ln296">					return &amp;probe_item.value;</a>
<a name="ln297"> </a>
<a name="ln298">				if (probe_item.key == 0)</a>
<a name="ln299">					return 0;</a>
<a name="ln300"> </a>
<a name="ln301">				// hash collision, quadratic probing</a>
<a name="ln302">				bucket = (bucket + probe + 1) &amp; hashmod;</a>
<a name="ln303">			}</a>
<a name="ln304"> </a>
<a name="ln305">			assert(false &amp;&amp; &quot;Hash table is full&quot;);</a>
<a name="ln306">			return 0;</a>
<a name="ln307">		}</a>
<a name="ln308"> </a>
<a name="ln309">		void** insert(const void* key)</a>
<a name="ln310">		{</a>
<a name="ln311">			assert(key);</a>
<a name="ln312">			assert(_capacity != 0 &amp;&amp; _count &lt; _capacity - _capacity / 4);</a>
<a name="ln313"> </a>
<a name="ln314">			size_t hashmod = _capacity - 1;</a>
<a name="ln315">			size_t bucket = hash(key) &amp; hashmod;</a>
<a name="ln316"> </a>
<a name="ln317">			for (size_t probe = 0; probe &lt;= hashmod; ++probe)</a>
<a name="ln318">			{</a>
<a name="ln319">				item_t&amp; probe_item = _items[bucket];</a>
<a name="ln320"> </a>
<a name="ln321">				if (probe_item.key == 0)</a>
<a name="ln322">				{</a>
<a name="ln323">					probe_item.key = key;</a>
<a name="ln324">					_count++;</a>
<a name="ln325">					return &amp;probe_item.value;</a>
<a name="ln326">				}</a>
<a name="ln327"> </a>
<a name="ln328">				if (probe_item.key == key)</a>
<a name="ln329">					return &amp;probe_item.value;</a>
<a name="ln330"> </a>
<a name="ln331">				// hash collision, quadratic probing</a>
<a name="ln332">				bucket = (bucket + probe + 1) &amp; hashmod;</a>
<a name="ln333">			}</a>
<a name="ln334"> </a>
<a name="ln335">			assert(false &amp;&amp; &quot;Hash table is full&quot;);</a>
<a name="ln336">			return 0;</a>
<a name="ln337">		}</a>
<a name="ln338"> </a>
<a name="ln339">		bool reserve()</a>
<a name="ln340">		{</a>
<a name="ln341">			if (_count + 16 &gt;= _capacity - _capacity / 4)</a>
<a name="ln342">				return rehash();</a>
<a name="ln343"> </a>
<a name="ln344">			return true;</a>
<a name="ln345">		}</a>
<a name="ln346"> </a>
<a name="ln347">	private:</a>
<a name="ln348">		struct item_t</a>
<a name="ln349">		{</a>
<a name="ln350">			const void* key;</a>
<a name="ln351">			void* value;</a>
<a name="ln352">		};</a>
<a name="ln353"> </a>
<a name="ln354">		item_t* _items;</a>
<a name="ln355">		size_t _capacity;</a>
<a name="ln356"> </a>
<a name="ln357">		size_t _count;</a>
<a name="ln358"> </a>
<a name="ln359">		bool rehash();</a>
<a name="ln360"> </a>
<a name="ln361">		static unsigned int hash(const void* key)</a>
<a name="ln362">		{</a>
<a name="ln363">			unsigned int h = static_cast&lt;unsigned int&gt;(reinterpret_cast&lt;uintptr_t&gt;(key));</a>
<a name="ln364"> </a>
<a name="ln365">			// MurmurHash3 32-bit finalizer</a>
<a name="ln366">			h ^= h &gt;&gt; 16;</a>
<a name="ln367">			h *= 0x85ebca6bu;</a>
<a name="ln368">			h ^= h &gt;&gt; 13;</a>
<a name="ln369">			h *= 0xc2b2ae35u;</a>
<a name="ln370">			h ^= h &gt;&gt; 16;</a>
<a name="ln371"> </a>
<a name="ln372">			return h;</a>
<a name="ln373">		}</a>
<a name="ln374">	};</a>
<a name="ln375"> </a>
<a name="ln376">	PUGI__FN_NO_INLINE bool compact_hash_table::rehash()</a>
<a name="ln377">	{</a>
<a name="ln378">		compact_hash_table rt;</a>
<a name="ln379">		rt._capacity = (_capacity == 0) ? 32 : _capacity * 2;</a>
<a name="ln380">		rt._items = static_cast&lt;item_t*&gt;(xml_memory::allocate(sizeof(item_t) * rt._capacity));</a>
<a name="ln381"> </a>
<a name="ln382">		if (!rt._items)</a>
<a name="ln383">			return false;</a>
<a name="ln384"> </a>
<a name="ln385">		memset(rt._items, 0, sizeof(item_t) * rt._capacity);</a>
<a name="ln386"> </a>
<a name="ln387">		for (size_t i = 0; i &lt; _capacity; ++i)</a>
<a name="ln388">			if (_items[i].key)</a>
<a name="ln389">				*rt.insert(_items[i].key) = _items[i].value;</a>
<a name="ln390"> </a>
<a name="ln391">		if (_items)</a>
<a name="ln392">			xml_memory::deallocate(_items);</a>
<a name="ln393"> </a>
<a name="ln394">		_capacity = rt._capacity;</a>
<a name="ln395">		_items = rt._items;</a>
<a name="ln396"> </a>
<a name="ln397">		assert(_count == rt._count);</a>
<a name="ln398"> </a>
<a name="ln399">		return true;</a>
<a name="ln400">	}</a>
<a name="ln401"> </a>
<a name="ln402">PUGI__NS_END</a>
<a name="ln403">#endif</a>
<a name="ln404"> </a>
<a name="ln405">PUGI__NS_BEGIN</a>
<a name="ln406">#ifdef PUGIXML_COMPACT</a>
<a name="ln407">	static const uintptr_t xml_memory_block_alignment = 4;</a>
<a name="ln408">#else</a>
<a name="ln409">	static const uintptr_t xml_memory_block_alignment = sizeof(void*);</a>
<a name="ln410">#endif</a>
<a name="ln411"> </a>
<a name="ln412">	// extra metadata bits</a>
<a name="ln413">	static const uintptr_t xml_memory_page_contents_shared_mask = 64;</a>
<a name="ln414">	static const uintptr_t xml_memory_page_name_allocated_mask = 32;</a>
<a name="ln415">	static const uintptr_t xml_memory_page_value_allocated_mask = 16;</a>
<a name="ln416">	static const uintptr_t xml_memory_page_type_mask = 15;</a>
<a name="ln417"> </a>
<a name="ln418">	// combined masks for string uniqueness</a>
<a name="ln419">	static const uintptr_t xml_memory_page_name_allocated_or_shared_mask = xml_memory_page_name_allocated_mask | xml_memory_page_contents_shared_mask;</a>
<a name="ln420">	static const uintptr_t xml_memory_page_value_allocated_or_shared_mask = xml_memory_page_value_allocated_mask | xml_memory_page_contents_shared_mask;</a>
<a name="ln421"> </a>
<a name="ln422">#ifdef PUGIXML_COMPACT</a>
<a name="ln423">	#define PUGI__GETHEADER_IMPL(object, page, flags) // unused</a>
<a name="ln424">	#define PUGI__GETPAGE_IMPL(header) (header).get_page()</a>
<a name="ln425">#else</a>
<a name="ln426">	#define PUGI__GETHEADER_IMPL(object, page, flags) (((reinterpret_cast&lt;char*&gt;(object) - reinterpret_cast&lt;char*&gt;(page)) &lt;&lt; 8) | (flags))</a>
<a name="ln427">	// this macro casts pointers through void* to avoid 'cast increases required alignment of target type' warnings</a>
<a name="ln428">	#define PUGI__GETPAGE_IMPL(header) static_cast&lt;impl::xml_memory_page*&gt;(const_cast&lt;void*&gt;(static_cast&lt;const void*&gt;(reinterpret_cast&lt;const char*&gt;(&amp;header) - (header &gt;&gt; 8))))</a>
<a name="ln429">#endif</a>
<a name="ln430"> </a>
<a name="ln431">	#define PUGI__GETPAGE(n) PUGI__GETPAGE_IMPL((n)-&gt;header)</a>
<a name="ln432">	#define PUGI__NODETYPE(n) static_cast&lt;xml_node_type&gt;((n)-&gt;header &amp; impl::xml_memory_page_type_mask)</a>
<a name="ln433"> </a>
<a name="ln434">	struct xml_allocator;</a>
<a name="ln435"> </a>
<a name="ln436">	struct xml_memory_page</a>
<a name="ln437">	{</a>
<a name="ln438">		static xml_memory_page* construct(void* memory)</a>
<a name="ln439">		{</a>
<a name="ln440">			xml_memory_page* result = static_cast&lt;xml_memory_page*&gt;(memory);</a>
<a name="ln441"> </a>
<a name="ln442">			result-&gt;allocator = 0;</a>
<a name="ln443">			result-&gt;prev = 0;</a>
<a name="ln444">			result-&gt;next = 0;</a>
<a name="ln445">			result-&gt;busy_size = 0;</a>
<a name="ln446">			result-&gt;freed_size = 0;</a>
<a name="ln447"> </a>
<a name="ln448">		#ifdef PUGIXML_COMPACT</a>
<a name="ln449">			result-&gt;compact_string_base = 0;</a>
<a name="ln450">			result-&gt;compact_shared_parent = 0;</a>
<a name="ln451">			result-&gt;compact_page_marker = 0;</a>
<a name="ln452">		#endif</a>
<a name="ln453"> </a>
<a name="ln454">			return result;</a>
<a name="ln455">		}</a>
<a name="ln456"> </a>
<a name="ln457">		xml_allocator* allocator;</a>
<a name="ln458"> </a>
<a name="ln459">		xml_memory_page* prev;</a>
<a name="ln460">		xml_memory_page* next;</a>
<a name="ln461"> </a>
<a name="ln462">		size_t busy_size;</a>
<a name="ln463">		size_t freed_size;</a>
<a name="ln464"> </a>
<a name="ln465">	#ifdef PUGIXML_COMPACT</a>
<a name="ln466">		char_t* compact_string_base;</a>
<a name="ln467">		void* compact_shared_parent;</a>
<a name="ln468">		uint32_t* compact_page_marker;</a>
<a name="ln469">	#endif</a>
<a name="ln470">	};</a>
<a name="ln471"> </a>
<a name="ln472">	static const size_t xml_memory_page_size =</a>
<a name="ln473">	#ifdef PUGIXML_MEMORY_PAGE_SIZE</a>
<a name="ln474">		(PUGIXML_MEMORY_PAGE_SIZE)</a>
<a name="ln475">	#else</a>
<a name="ln476">		32768</a>
<a name="ln477">	#endif</a>
<a name="ln478">		- sizeof(xml_memory_page);</a>
<a name="ln479"> </a>
<a name="ln480">	struct xml_memory_string_header</a>
<a name="ln481">	{</a>
<a name="ln482">		uint16_t page_offset; // offset from page-&gt;data</a>
<a name="ln483">		uint16_t full_size; // 0 if string occupies whole page</a>
<a name="ln484">	};</a>
<a name="ln485"> </a>
<a name="ln486">	struct xml_allocator</a>
<a name="ln487">	{</a>
<a name="ln488">		xml_allocator(xml_memory_page* root): _root(root), _busy_size(root-&gt;busy_size)</a>
<a name="ln489">		{</a>
<a name="ln490">		#ifdef PUGIXML_COMPACT</a>
<a name="ln491">			_hash = 0;</a>
<a name="ln492">		#endif</a>
<a name="ln493">		}</a>
<a name="ln494"> </a>
<a name="ln495">		xml_memory_page* allocate_page(size_t data_size)</a>
<a name="ln496">		{</a>
<a name="ln497">			size_t size = sizeof(xml_memory_page) + data_size;</a>
<a name="ln498"> </a>
<a name="ln499">			// allocate block with some alignment, leaving memory for worst-case padding</a>
<a name="ln500">			void* memory = xml_memory::allocate(size);</a>
<a name="ln501">			if (!memory) return 0;</a>
<a name="ln502"> </a>
<a name="ln503">			// prepare page structure</a>
<a name="ln504">			xml_memory_page* page = xml_memory_page::construct(memory);</a>
<a name="ln505">			assert(page);</a>
<a name="ln506"> </a>
<a name="ln507">			page-&gt;allocator = _root-&gt;allocator;</a>
<a name="ln508"> </a>
<a name="ln509">			return page;</a>
<a name="ln510">		}</a>
<a name="ln511"> </a>
<a name="ln512">		static void deallocate_page(xml_memory_page* page)</a>
<a name="ln513">		{</a>
<a name="ln514">			xml_memory::deallocate(page);</a>
<a name="ln515">		}</a>
<a name="ln516"> </a>
<a name="ln517">		void* allocate_memory_oob(size_t size, xml_memory_page*&amp; out_page);</a>
<a name="ln518"> </a>
<a name="ln519">		void* allocate_memory(size_t size, xml_memory_page*&amp; out_page)</a>
<a name="ln520">		{</a>
<a name="ln521">			if (PUGI__UNLIKELY(_busy_size + size &gt; xml_memory_page_size))</a>
<a name="ln522">				return allocate_memory_oob(size, out_page);</a>
<a name="ln523"> </a>
<a name="ln524">			void* buf = reinterpret_cast&lt;char*&gt;(_root) + sizeof(xml_memory_page) + _busy_size;</a>
<a name="ln525"> </a>
<a name="ln526">			_busy_size += size;</a>
<a name="ln527"> </a>
<a name="ln528">			out_page = _root;</a>
<a name="ln529"> </a>
<a name="ln530">			return buf;</a>
<a name="ln531">		}</a>
<a name="ln532"> </a>
<a name="ln533">	#ifdef PUGIXML_COMPACT</a>
<a name="ln534">		void* allocate_object(size_t size, xml_memory_page*&amp; out_page)</a>
<a name="ln535">		{</a>
<a name="ln536">			void* result = allocate_memory(size + sizeof(uint32_t), out_page);</a>
<a name="ln537">			if (!result) return 0;</a>
<a name="ln538"> </a>
<a name="ln539">			// adjust for marker</a>
<a name="ln540">			ptrdiff_t offset = static_cast&lt;char*&gt;(result) - reinterpret_cast&lt;char*&gt;(out_page-&gt;compact_page_marker);</a>
<a name="ln541"> </a>
<a name="ln542">			if (PUGI__UNLIKELY(static_cast&lt;uintptr_t&gt;(offset) &gt;= 256 * xml_memory_block_alignment))</a>
<a name="ln543">			{</a>
<a name="ln544">				// AppendToTheEnd new marker</a>
<a name="ln545">				uint32_t* marker = static_cast&lt;uint32_t*&gt;(result);</a>
<a name="ln546"> </a>
<a name="ln547">				*marker = static_cast&lt;uint32_t&gt;(reinterpret_cast&lt;char*&gt;(marker) - reinterpret_cast&lt;char*&gt;(out_page));</a>
<a name="ln548">				out_page-&gt;compact_page_marker = marker;</a>
<a name="ln549"> </a>
<a name="ln550">				// since we don't reuse the page space until we reallocate it, we can just pretend that we freed the marker block</a>
<a name="ln551">				// this will make sure deallocate_memory correctly tracks the size</a>
<a name="ln552">				out_page-&gt;freed_size += sizeof(uint32_t);</a>
<a name="ln553"> </a>
<a name="ln554">				return marker + 1;</a>
<a name="ln555">			}</a>
<a name="ln556">			else</a>
<a name="ln557">			{</a>
<a name="ln558">				// roll back uint32_t part</a>
<a name="ln559">				_busy_size -= sizeof(uint32_t);</a>
<a name="ln560"> </a>
<a name="ln561">				return result;</a>
<a name="ln562">			}</a>
<a name="ln563">		}</a>
<a name="ln564">	#else</a>
<a name="ln565">		void* allocate_object(size_t size, xml_memory_page*&amp; out_page)</a>
<a name="ln566">		{</a>
<a name="ln567">			return allocate_memory(size, out_page);</a>
<a name="ln568">		}</a>
<a name="ln569">	#endif</a>
<a name="ln570"> </a>
<a name="ln571">		void deallocate_memory(void* ptr, size_t size, xml_memory_page* page)</a>
<a name="ln572">		{</a>
<a name="ln573">			if (page == _root) page-&gt;busy_size = _busy_size;</a>
<a name="ln574"> </a>
<a name="ln575">			assert(ptr &gt;= reinterpret_cast&lt;char*&gt;(page) + sizeof(xml_memory_page) &amp;&amp; ptr &lt; reinterpret_cast&lt;char*&gt;(page) + sizeof(xml_memory_page) + page-&gt;busy_size);</a>
<a name="ln576">			(void)!ptr;</a>
<a name="ln577"> </a>
<a name="ln578">			page-&gt;freed_size += size;</a>
<a name="ln579">			assert(page-&gt;freed_size &lt;= page-&gt;busy_size);</a>
<a name="ln580"> </a>
<a name="ln581">			if (page-&gt;freed_size == page-&gt;busy_size)</a>
<a name="ln582">			{</a>
<a name="ln583">				if (page-&gt;next == 0)</a>
<a name="ln584">				{</a>
<a name="ln585">					assert(_root == page);</a>
<a name="ln586"> </a>
<a name="ln587">					// top page freed, just reset sizes</a>
<a name="ln588">					page-&gt;busy_size = 0;</a>
<a name="ln589">					page-&gt;freed_size = 0;</a>
<a name="ln590"> </a>
<a name="ln591">				#ifdef PUGIXML_COMPACT</a>
<a name="ln592">					// reset compact state to maximize efficiency</a>
<a name="ln593">					page-&gt;compact_string_base = 0;</a>
<a name="ln594">					page-&gt;compact_shared_parent = 0;</a>
<a name="ln595">					page-&gt;compact_page_marker = 0;</a>
<a name="ln596">				#endif</a>
<a name="ln597"> </a>
<a name="ln598">					_busy_size = 0;</a>
<a name="ln599">				}</a>
<a name="ln600">				else</a>
<a name="ln601">				{</a>
<a name="ln602">					assert(_root != page);</a>
<a name="ln603">					assert(page-&gt;prev);</a>
<a name="ln604"> </a>
<a name="ln605">					// remove from the list</a>
<a name="ln606">					page-&gt;prev-&gt;next = page-&gt;next;</a>
<a name="ln607">					page-&gt;next-&gt;prev = page-&gt;prev;</a>
<a name="ln608"> </a>
<a name="ln609">					// deallocate</a>
<a name="ln610">					deallocate_page(page);</a>
<a name="ln611">				}</a>
<a name="ln612">			}</a>
<a name="ln613">		}</a>
<a name="ln614"> </a>
<a name="ln615">		char_t* allocate_string(size_t length)</a>
<a name="ln616">		{</a>
<a name="ln617">			static const size_t max_encoded_offset = (1 &lt;&lt; 16) * xml_memory_block_alignment;</a>
<a name="ln618"> </a>
<a name="ln619">			PUGI__STATIC_ASSERT(xml_memory_page_size &lt;= max_encoded_offset);</a>
<a name="ln620"> </a>
<a name="ln621">			// allocate memory for string and header block</a>
<a name="ln622">			size_t size = sizeof(xml_memory_string_header) + length * sizeof(char_t);</a>
<a name="ln623"> </a>
<a name="ln624">			// round size up to block alignment boundary</a>
<a name="ln625">			size_t full_size = (size + (xml_memory_block_alignment - 1)) &amp; ~(xml_memory_block_alignment - 1);</a>
<a name="ln626"> </a>
<a name="ln627">			xml_memory_page* page;</a>
<a name="ln628">			xml_memory_string_header* header = static_cast&lt;xml_memory_string_header*&gt;(allocate_memory(full_size, page));</a>
<a name="ln629"> </a>
<a name="ln630">			if (!header) return 0;</a>
<a name="ln631"> </a>
<a name="ln632">			// setup header</a>
<a name="ln633">			ptrdiff_t page_offset = reinterpret_cast&lt;char*&gt;(header) - reinterpret_cast&lt;char*&gt;(page) - sizeof(xml_memory_page);</a>
<a name="ln634"> </a>
<a name="ln635">			assert(page_offset % xml_memory_block_alignment == 0);</a>
<a name="ln636">			assert(page_offset &gt;= 0 &amp;&amp; static_cast&lt;size_t&gt;(page_offset) &lt; max_encoded_offset);</a>
<a name="ln637">			header-&gt;page_offset = static_cast&lt;uint16_t&gt;(static_cast&lt;size_t&gt;(page_offset) / xml_memory_block_alignment);</a>
<a name="ln638"> </a>
<a name="ln639">			// full_size == 0 for large strings that occupy the whole page</a>
<a name="ln640">			assert(full_size % xml_memory_block_alignment == 0);</a>
<a name="ln641">			assert(full_size &lt; max_encoded_offset || (page-&gt;busy_size == full_size &amp;&amp; page_offset == 0));</a>
<a name="ln642">			header-&gt;full_size = static_cast&lt;uint16_t&gt;(full_size &lt; max_encoded_offset ? full_size / xml_memory_block_alignment : 0);</a>
<a name="ln643"> </a>
<a name="ln644">			// round-trip through void* to avoid 'cast increases required alignment of target type' warning</a>
<a name="ln645">			// header is guaranteed a pointer-sized alignment, which should be enough for char_t</a>
<a name="ln646">			return static_cast&lt;char_t*&gt;(static_cast&lt;void*&gt;(header + 1));</a>
<a name="ln647">		}</a>
<a name="ln648"> </a>
<a name="ln649">		void deallocate_string(char_t* string)</a>
<a name="ln650">		{</a>
<a name="ln651">			// this function casts pointers through void* to avoid 'cast increases required alignment of target type' warnings</a>
<a name="ln652">			// we're guaranteed the proper (pointer-sized) alignment on the input string if it was allocated via allocate_string</a>
<a name="ln653"> </a>
<a name="ln654">			// get header</a>
<a name="ln655">			xml_memory_string_header* header = static_cast&lt;xml_memory_string_header*&gt;(static_cast&lt;void*&gt;(string)) - 1;</a>
<a name="ln656">			assert(header);</a>
<a name="ln657"> </a>
<a name="ln658">			// deallocate</a>
<a name="ln659">			size_t page_offset = sizeof(xml_memory_page) + header-&gt;page_offset * xml_memory_block_alignment;</a>
<a name="ln660">			xml_memory_page* page = reinterpret_cast&lt;xml_memory_page*&gt;(static_cast&lt;void*&gt;(reinterpret_cast&lt;char*&gt;(header) - page_offset));</a>
<a name="ln661"> </a>
<a name="ln662">			// if full_size == 0 then this string occupies the whole page</a>
<a name="ln663">			size_t full_size = header-&gt;full_size == 0 ? page-&gt;busy_size : header-&gt;full_size * xml_memory_block_alignment;</a>
<a name="ln664"> </a>
<a name="ln665">			deallocate_memory(header, full_size, page);</a>
<a name="ln666">		}</a>
<a name="ln667"> </a>
<a name="ln668">		bool reserve()</a>
<a name="ln669">		{</a>
<a name="ln670">		#ifdef PUGIXML_COMPACT</a>
<a name="ln671">			return _hash-&gt;reserve();</a>
<a name="ln672">		#else</a>
<a name="ln673">			return true;</a>
<a name="ln674">		#endif</a>
<a name="ln675">		}</a>
<a name="ln676"> </a>
<a name="ln677">		xml_memory_page* _root;</a>
<a name="ln678">		size_t _busy_size;</a>
<a name="ln679"> </a>
<a name="ln680">	#ifdef PUGIXML_COMPACT</a>
<a name="ln681">		compact_hash_table* _hash;</a>
<a name="ln682">	#endif</a>
<a name="ln683">	};</a>
<a name="ln684"> </a>
<a name="ln685">	PUGI__FN_NO_INLINE void* xml_allocator::allocate_memory_oob(size_t size, xml_memory_page*&amp; out_page)</a>
<a name="ln686">	{</a>
<a name="ln687">		const size_t large_allocation_threshold = xml_memory_page_size / 4;</a>
<a name="ln688"> </a>
<a name="ln689">		xml_memory_page* page = allocate_page(size &lt;= large_allocation_threshold ? xml_memory_page_size : size);</a>
<a name="ln690">		out_page = page;</a>
<a name="ln691"> </a>
<a name="ln692">		if (!page) return 0;</a>
<a name="ln693"> </a>
<a name="ln694">		if (size &lt;= large_allocation_threshold)</a>
<a name="ln695">		{</a>
<a name="ln696">			_root-&gt;busy_size = _busy_size;</a>
<a name="ln697"> </a>
<a name="ln698">			// AppendToTheEnd page at the end of linked list</a>
<a name="ln699">			page-&gt;prev = _root;</a>
<a name="ln700">			_root-&gt;next = page;</a>
<a name="ln701">			_root = page;</a>
<a name="ln702"> </a>
<a name="ln703">			_busy_size = size;</a>
<a name="ln704">		}</a>
<a name="ln705">		else</a>
<a name="ln706">		{</a>
<a name="ln707">			// AppendToTheEnd page before the end of linked list, so that it is deleted as soon as possible</a>
<a name="ln708">			// the last page is not deleted even if it's empty (see deallocate_memory)</a>
<a name="ln709">			assert(_root-&gt;prev);</a>
<a name="ln710"> </a>
<a name="ln711">			page-&gt;prev = _root-&gt;prev;</a>
<a name="ln712">			page-&gt;next = _root;</a>
<a name="ln713"> </a>
<a name="ln714">			_root-&gt;prev-&gt;next = page;</a>
<a name="ln715">			_root-&gt;prev = page;</a>
<a name="ln716"> </a>
<a name="ln717">			page-&gt;busy_size = size;</a>
<a name="ln718">		}</a>
<a name="ln719"> </a>
<a name="ln720">		return reinterpret_cast&lt;char*&gt;(page) + sizeof(xml_memory_page);</a>
<a name="ln721">	}</a>
<a name="ln722">PUGI__NS_END</a>
<a name="ln723"> </a>
<a name="ln724">#ifdef PUGIXML_COMPACT</a>
<a name="ln725">PUGI__NS_BEGIN</a>
<a name="ln726">	static const uintptr_t compact_alignment_log2 = 2;</a>
<a name="ln727">	static const uintptr_t compact_alignment = 1 &lt;&lt; compact_alignment_log2;</a>
<a name="ln728"> </a>
<a name="ln729">	class compact_header</a>
<a name="ln730">	{</a>
<a name="ln731">	public:</a>
<a name="ln732">		compact_header(xml_memory_page* page, unsigned int flags)</a>
<a name="ln733">		{</a>
<a name="ln734">			PUGI__STATIC_ASSERT(xml_memory_block_alignment == compact_alignment);</a>
<a name="ln735"> </a>
<a name="ln736">			ptrdiff_t offset = (reinterpret_cast&lt;char*&gt;(this) - reinterpret_cast&lt;char*&gt;(page-&gt;compact_page_marker));</a>
<a name="ln737">			assert(offset % compact_alignment == 0 &amp;&amp; static_cast&lt;uintptr_t&gt;(offset) &lt; 256 * compact_alignment);</a>
<a name="ln738"> </a>
<a name="ln739">			_page = static_cast&lt;unsigned char&gt;(offset &gt;&gt; compact_alignment_log2);</a>
<a name="ln740">			_flags = static_cast&lt;unsigned char&gt;(flags);</a>
<a name="ln741">		}</a>
<a name="ln742"> </a>
<a name="ln743">		void operator&amp;=(uintptr_t mod)</a>
<a name="ln744">		{</a>
<a name="ln745">			_flags &amp;= static_cast&lt;unsigned char&gt;(mod);</a>
<a name="ln746">		}</a>
<a name="ln747"> </a>
<a name="ln748">		void operator|=(uintptr_t mod)</a>
<a name="ln749">		{</a>
<a name="ln750">			_flags |= static_cast&lt;unsigned char&gt;(mod);</a>
<a name="ln751">		}</a>
<a name="ln752"> </a>
<a name="ln753">		uintptr_t operator&amp;(uintptr_t mod) const</a>
<a name="ln754">		{</a>
<a name="ln755">			return _flags &amp; mod;</a>
<a name="ln756">		}</a>
<a name="ln757"> </a>
<a name="ln758">		xml_memory_page* get_page() const</a>
<a name="ln759">		{</a>
<a name="ln760">			// round-trip through void* to silence 'cast increases required alignment of target type' warnings</a>
<a name="ln761">			const char* page_marker = reinterpret_cast&lt;const char*&gt;(this) - (_page &lt;&lt; compact_alignment_log2);</a>
<a name="ln762">			const char* page = page_marker - *reinterpret_cast&lt;const uint32_t*&gt;(static_cast&lt;const void*&gt;(page_marker));</a>
<a name="ln763"> </a>
<a name="ln764">			return const_cast&lt;xml_memory_page*&gt;(reinterpret_cast&lt;const xml_memory_page*&gt;(static_cast&lt;const void*&gt;(page)));</a>
<a name="ln765">		}</a>
<a name="ln766"> </a>
<a name="ln767">	private:</a>
<a name="ln768">		unsigned char _page;</a>
<a name="ln769">		unsigned char _flags;</a>
<a name="ln770">	};</a>
<a name="ln771"> </a>
<a name="ln772">	PUGI__FN xml_memory_page* compact_get_page(const void* object, int header_offset)</a>
<a name="ln773">	{</a>
<a name="ln774">		const compact_header* header = reinterpret_cast&lt;const compact_header*&gt;(static_cast&lt;const char*&gt;(object) - header_offset);</a>
<a name="ln775"> </a>
<a name="ln776">		return header-&gt;get_page();</a>
<a name="ln777">	}</a>
<a name="ln778"> </a>
<a name="ln779">	template &lt;int header_offset, typename T&gt; PUGI__FN_NO_INLINE T* compact_get_value(const void* object)</a>
<a name="ln780">	{</a>
<a name="ln781">		return static_cast&lt;T*&gt;(*compact_get_page(object, header_offset)-&gt;allocator-&gt;_hash-&gt;find(object));</a>
<a name="ln782">	}</a>
<a name="ln783"> </a>
<a name="ln784">	template &lt;int header_offset, typename T&gt; PUGI__FN_NO_INLINE void compact_set_value(const void* object, T* value)</a>
<a name="ln785">	{</a>
<a name="ln786">		*compact_get_page(object, header_offset)-&gt;allocator-&gt;_hash-&gt;insert(object) = value;</a>
<a name="ln787">	}</a>
<a name="ln788"> </a>
<a name="ln789">	template &lt;typename T, int header_offset, int start = -126&gt; class compact_pointer</a>
<a name="ln790">	{</a>
<a name="ln791">	public:</a>
<a name="ln792">		compact_pointer(): _data(0)</a>
<a name="ln793">		{</a>
<a name="ln794">		}</a>
<a name="ln795"> </a>
<a name="ln796">		void operator=(const compact_pointer&amp; rhs)</a>
<a name="ln797">		{</a>
<a name="ln798">			*this = rhs + 0;</a>
<a name="ln799">		}</a>
<a name="ln800"> </a>
<a name="ln801">		void operator=(T* value)</a>
<a name="ln802">		{</a>
<a name="ln803">			if (value)</a>
<a name="ln804">			{</a>
<a name="ln805">				// value is guaranteed to be compact-aligned; 'this' is not</a>
<a name="ln806">				// our decoding is based on 'this' aligned to compact alignment downwards (see operator T*)</a>
<a name="ln807">				// so for negative offsets (e.g. -3) we need to adjust the diff by compact_alignment - 1 to</a>
<a name="ln808">				// compensate for arithmetic shift rounding for negative values</a>
<a name="ln809">				ptrdiff_t diff = reinterpret_cast&lt;char*&gt;(value) - reinterpret_cast&lt;char*&gt;(this);</a>
<a name="ln810">				ptrdiff_t offset = ((diff + int(compact_alignment - 1)) &gt;&gt; compact_alignment_log2) - start;</a>
<a name="ln811"> </a>
<a name="ln812">				if (static_cast&lt;uintptr_t&gt;(offset) &lt;= 253)</a>
<a name="ln813">					_data = static_cast&lt;unsigned char&gt;(offset + 1);</a>
<a name="ln814">				else</a>
<a name="ln815">				{</a>
<a name="ln816">					compact_set_value&lt;header_offset&gt;(this, value);</a>
<a name="ln817"> </a>
<a name="ln818">					_data = 255;</a>
<a name="ln819">				}</a>
<a name="ln820">			}</a>
<a name="ln821">			else</a>
<a name="ln822">				_data = 0;</a>
<a name="ln823">		}</a>
<a name="ln824"> </a>
<a name="ln825">		operator T*() const</a>
<a name="ln826">		{</a>
<a name="ln827">			if (_data)</a>
<a name="ln828">			{</a>
<a name="ln829">				if (_data &lt; 255)</a>
<a name="ln830">				{</a>
<a name="ln831">					uintptr_t base = reinterpret_cast&lt;uintptr_t&gt;(this) &amp; ~(compact_alignment - 1);</a>
<a name="ln832"> </a>
<a name="ln833">					return reinterpret_cast&lt;T*&gt;(base + ((_data - 1 + start) &lt;&lt; compact_alignment_log2));</a>
<a name="ln834">				}</a>
<a name="ln835">				else</a>
<a name="ln836">					return compact_get_value&lt;header_offset, T&gt;(this);</a>
<a name="ln837">			}</a>
<a name="ln838">			else</a>
<a name="ln839">				return 0;</a>
<a name="ln840">		}</a>
<a name="ln841"> </a>
<a name="ln842">		T* operator-&gt;() const</a>
<a name="ln843">		{</a>
<a name="ln844">			return *this;</a>
<a name="ln845">		}</a>
<a name="ln846"> </a>
<a name="ln847">	private:</a>
<a name="ln848">		unsigned char _data;</a>
<a name="ln849">	};</a>
<a name="ln850"> </a>
<a name="ln851">	template &lt;typename T, int header_offset&gt; class compact_pointer_parent</a>
<a name="ln852">	{</a>
<a name="ln853">	public:</a>
<a name="ln854">		compact_pointer_parent(): _data(0)</a>
<a name="ln855">		{</a>
<a name="ln856">		}</a>
<a name="ln857"> </a>
<a name="ln858">		void operator=(const compact_pointer_parent&amp; rhs)</a>
<a name="ln859">		{</a>
<a name="ln860">			*this = rhs + 0;</a>
<a name="ln861">		}</a>
<a name="ln862"> </a>
<a name="ln863">		void operator=(T* value)</a>
<a name="ln864">		{</a>
<a name="ln865">			if (value)</a>
<a name="ln866">			{</a>
<a name="ln867">				// value is guaranteed to be compact-aligned; 'this' is not</a>
<a name="ln868">				// our decoding is based on 'this' aligned to compact alignment downwards (see operator T*)</a>
<a name="ln869">				// so for negative offsets (e.g. -3) we need to adjust the diff by compact_alignment - 1 to</a>
<a name="ln870">				// compensate for arithmetic shift behavior for negative values</a>
<a name="ln871">				ptrdiff_t diff = reinterpret_cast&lt;char*&gt;(value) - reinterpret_cast&lt;char*&gt;(this);</a>
<a name="ln872">				ptrdiff_t offset = ((diff + int(compact_alignment - 1)) &gt;&gt; compact_alignment_log2) + 65533;</a>
<a name="ln873"> </a>
<a name="ln874">				if (static_cast&lt;uintptr_t&gt;(offset) &lt;= 65533)</a>
<a name="ln875">				{</a>
<a name="ln876">					_data = static_cast&lt;unsigned short&gt;(offset + 1);</a>
<a name="ln877">				}</a>
<a name="ln878">				else</a>
<a name="ln879">				{</a>
<a name="ln880">					xml_memory_page* page = compact_get_page(this, header_offset);</a>
<a name="ln881"> </a>
<a name="ln882">					if (PUGI__UNLIKELY(page-&gt;compact_shared_parent == 0))</a>
<a name="ln883">						page-&gt;compact_shared_parent = value;</a>
<a name="ln884"> </a>
<a name="ln885">					if (page-&gt;compact_shared_parent == value)</a>
<a name="ln886">					{</a>
<a name="ln887">						_data = 65534;</a>
<a name="ln888">					}</a>
<a name="ln889">					else</a>
<a name="ln890">					{</a>
<a name="ln891">						compact_set_value&lt;header_offset&gt;(this, value);</a>
<a name="ln892"> </a>
<a name="ln893">						_data = 65535;</a>
<a name="ln894">					}</a>
<a name="ln895">				}</a>
<a name="ln896">			}</a>
<a name="ln897">			else</a>
<a name="ln898">			{</a>
<a name="ln899">				_data = 0;</a>
<a name="ln900">			}</a>
<a name="ln901">		}</a>
<a name="ln902"> </a>
<a name="ln903">		operator T*() const</a>
<a name="ln904">		{</a>
<a name="ln905">			if (_data)</a>
<a name="ln906">			{</a>
<a name="ln907">				if (_data &lt; 65534)</a>
<a name="ln908">				{</a>
<a name="ln909">					uintptr_t base = reinterpret_cast&lt;uintptr_t&gt;(this) &amp; ~(compact_alignment - 1);</a>
<a name="ln910"> </a>
<a name="ln911">					return reinterpret_cast&lt;T*&gt;(base + ((_data - 1 - 65533) &lt;&lt; compact_alignment_log2));</a>
<a name="ln912">				}</a>
<a name="ln913">				else if (_data == 65534)</a>
<a name="ln914">					return static_cast&lt;T*&gt;(compact_get_page(this, header_offset)-&gt;compact_shared_parent);</a>
<a name="ln915">				else</a>
<a name="ln916">					return compact_get_value&lt;header_offset, T&gt;(this);</a>
<a name="ln917">			}</a>
<a name="ln918">			else</a>
<a name="ln919">				return 0;</a>
<a name="ln920">		}</a>
<a name="ln921"> </a>
<a name="ln922">		T* operator-&gt;() const</a>
<a name="ln923">		{</a>
<a name="ln924">			return *this;</a>
<a name="ln925">		}</a>
<a name="ln926"> </a>
<a name="ln927">	private:</a>
<a name="ln928">		uint16_t _data;</a>
<a name="ln929">	};</a>
<a name="ln930"> </a>
<a name="ln931">	template &lt;int header_offset, int base_offset&gt; class compact_string</a>
<a name="ln932">	{</a>
<a name="ln933">	public:</a>
<a name="ln934">		compact_string(): _data(0)</a>
<a name="ln935">		{</a>
<a name="ln936">		}</a>
<a name="ln937"> </a>
<a name="ln938">		void operator=(const compact_string&amp; rhs)</a>
<a name="ln939">		{</a>
<a name="ln940">			*this = rhs + 0;</a>
<a name="ln941">		}</a>
<a name="ln942"> </a>
<a name="ln943">		void operator=(char_t* value)</a>
<a name="ln944">		{</a>
<a name="ln945">			if (value)</a>
<a name="ln946">			{</a>
<a name="ln947">				xml_memory_page* page = compact_get_page(this, header_offset);</a>
<a name="ln948"> </a>
<a name="ln949">				if (PUGI__UNLIKELY(page-&gt;compact_string_base == 0))</a>
<a name="ln950">					page-&gt;compact_string_base = value;</a>
<a name="ln951"> </a>
<a name="ln952">				ptrdiff_t offset = value - page-&gt;compact_string_base;</a>
<a name="ln953"> </a>
<a name="ln954">				if (static_cast&lt;uintptr_t&gt;(offset) &lt; (65535 &lt;&lt; 7))</a>
<a name="ln955">				{</a>
<a name="ln956">					// round-trip through void* to silence 'cast increases required alignment of target type' warnings</a>
<a name="ln957">					uint16_t* base = reinterpret_cast&lt;uint16_t*&gt;(static_cast&lt;void*&gt;(reinterpret_cast&lt;char*&gt;(this) - base_offset));</a>
<a name="ln958"> </a>
<a name="ln959">					if (*base == 0)</a>
<a name="ln960">					{</a>
<a name="ln961">						*base = static_cast&lt;uint16_t&gt;((offset &gt;&gt; 7) + 1);</a>
<a name="ln962">						_data = static_cast&lt;unsigned char&gt;((offset &amp; 127) + 1);</a>
<a name="ln963">					}</a>
<a name="ln964">					else</a>
<a name="ln965">					{</a>
<a name="ln966">						ptrdiff_t remainder = offset - ((*base - 1) &lt;&lt; 7);</a>
<a name="ln967"> </a>
<a name="ln968">						if (static_cast&lt;uintptr_t&gt;(remainder) &lt;= 253)</a>
<a name="ln969">						{</a>
<a name="ln970">							_data = static_cast&lt;unsigned char&gt;(remainder + 1);</a>
<a name="ln971">						}</a>
<a name="ln972">						else</a>
<a name="ln973">						{</a>
<a name="ln974">							compact_set_value&lt;header_offset&gt;(this, value);</a>
<a name="ln975"> </a>
<a name="ln976">							_data = 255;</a>
<a name="ln977">						}</a>
<a name="ln978">					}</a>
<a name="ln979">				}</a>
<a name="ln980">				else</a>
<a name="ln981">				{</a>
<a name="ln982">					compact_set_value&lt;header_offset&gt;(this, value);</a>
<a name="ln983"> </a>
<a name="ln984">					_data = 255;</a>
<a name="ln985">				}</a>
<a name="ln986">			}</a>
<a name="ln987">			else</a>
<a name="ln988">			{</a>
<a name="ln989">				_data = 0;</a>
<a name="ln990">			}</a>
<a name="ln991">		}</a>
<a name="ln992"> </a>
<a name="ln993">		operator char_t*() const</a>
<a name="ln994">		{</a>
<a name="ln995">			if (_data)</a>
<a name="ln996">			{</a>
<a name="ln997">				if (_data &lt; 255)</a>
<a name="ln998">				{</a>
<a name="ln999">					xml_memory_page* page = compact_get_page(this, header_offset);</a>
<a name="ln1000"> </a>
<a name="ln1001">					// round-trip through void* to silence 'cast increases required alignment of target type' warnings</a>
<a name="ln1002">					const uint16_t* base = reinterpret_cast&lt;const uint16_t*&gt;(static_cast&lt;const void*&gt;(reinterpret_cast&lt;const char*&gt;(this) - base_offset));</a>
<a name="ln1003">					assert(*base);</a>
<a name="ln1004"> </a>
<a name="ln1005">					ptrdiff_t offset = ((*base - 1) &lt;&lt; 7) + (_data - 1);</a>
<a name="ln1006"> </a>
<a name="ln1007">					return page-&gt;compact_string_base + offset;</a>
<a name="ln1008">				}</a>
<a name="ln1009">				else</a>
<a name="ln1010">				{</a>
<a name="ln1011">					return compact_get_value&lt;header_offset, char_t&gt;(this);</a>
<a name="ln1012">				}</a>
<a name="ln1013">			}</a>
<a name="ln1014">			else</a>
<a name="ln1015">				return 0;</a>
<a name="ln1016">		}</a>
<a name="ln1017"> </a>
<a name="ln1018">	private:</a>
<a name="ln1019">		unsigned char _data;</a>
<a name="ln1020">	};</a>
<a name="ln1021">PUGI__NS_END</a>
<a name="ln1022">#endif</a>
<a name="ln1023"> </a>
<a name="ln1024">#ifdef PUGIXML_COMPACT</a>
<a name="ln1025">namespace pugi</a>
<a name="ln1026">{</a>
<a name="ln1027">	struct xml_attribute_struct</a>
<a name="ln1028">	{</a>
<a name="ln1029">		xml_attribute_struct(impl::xml_memory_page* page): header(page, 0), namevalue_base(0)</a>
<a name="ln1030">		{</a>
<a name="ln1031">			PUGI__STATIC_ASSERT(sizeof(xml_attribute_struct) == 8);</a>
<a name="ln1032">		}</a>
<a name="ln1033"> </a>
<a name="ln1034">		impl::compact_header header;</a>
<a name="ln1035"> </a>
<a name="ln1036">		uint16_t namevalue_base;</a>
<a name="ln1037"> </a>
<a name="ln1038">		impl::compact_string&lt;4, 2&gt; name;</a>
<a name="ln1039">		impl::compact_string&lt;5, 3&gt; value;</a>
<a name="ln1040"> </a>
<a name="ln1041">		impl::compact_pointer&lt;xml_attribute_struct, 6&gt; prev_attribute_c;</a>
<a name="ln1042">		impl::compact_pointer&lt;xml_attribute_struct, 7, 0&gt; next_attribute;</a>
<a name="ln1043">	};</a>
<a name="ln1044"> </a>
<a name="ln1045">	struct xml_node_struct</a>
<a name="ln1046">	{</a>
<a name="ln1047">		xml_node_struct(impl::xml_memory_page* page, xml_node_type type): header(page, type), namevalue_base(0)</a>
<a name="ln1048">		{</a>
<a name="ln1049">			PUGI__STATIC_ASSERT(sizeof(xml_node_struct) == 12);</a>
<a name="ln1050">		}</a>
<a name="ln1051"> </a>
<a name="ln1052">		impl::compact_header header;</a>
<a name="ln1053"> </a>
<a name="ln1054">		uint16_t namevalue_base;</a>
<a name="ln1055"> </a>
<a name="ln1056">		impl::compact_string&lt;4, 2&gt; name;</a>
<a name="ln1057">		impl::compact_string&lt;5, 3&gt; value;</a>
<a name="ln1058"> </a>
<a name="ln1059">		impl::compact_pointer_parent&lt;xml_node_struct, 6&gt; parent;</a>
<a name="ln1060"> </a>
<a name="ln1061">		impl::compact_pointer&lt;xml_node_struct, 8, 0&gt; first_child;</a>
<a name="ln1062"> </a>
<a name="ln1063">		impl::compact_pointer&lt;xml_node_struct,  9&gt;    prev_sibling_c;</a>
<a name="ln1064">		impl::compact_pointer&lt;xml_node_struct, 10, 0&gt; next_sibling;</a>
<a name="ln1065"> </a>
<a name="ln1066">		impl::compact_pointer&lt;xml_attribute_struct, 11, 0&gt; first_attribute;</a>
<a name="ln1067">	};</a>
<a name="ln1068">}</a>
<a name="ln1069">#else</a>
<a name="ln1070">namespace pugi</a>
<a name="ln1071">{</a>
<a name="ln1072">	struct xml_attribute_struct</a>
<a name="ln1073">	{</a>
<a name="ln1074">		xml_attribute_struct(impl::xml_memory_page* page): name(0), value(0), prev_attribute_c(0), next_attribute(0)</a>
<a name="ln1075">		{</a>
<a name="ln1076">			header = PUGI__GETHEADER_IMPL(this, page, 0);</a>
<a name="ln1077">		}</a>
<a name="ln1078"> </a>
<a name="ln1079">		uintptr_t header;</a>
<a name="ln1080"> </a>
<a name="ln1081">		char_t*	name;</a>
<a name="ln1082">		char_t*	value;</a>
<a name="ln1083"> </a>
<a name="ln1084">		xml_attribute_struct* prev_attribute_c;</a>
<a name="ln1085">		xml_attribute_struct* next_attribute;</a>
<a name="ln1086">	};</a>
<a name="ln1087"> </a>
<a name="ln1088">	struct xml_node_struct</a>
<a name="ln1089">	{</a>
<a name="ln1090">		xml_node_struct(impl::xml_memory_page* page, xml_node_type type): name(0), value(0), parent(0), first_child(0), prev_sibling_c(0), next_sibling(0), first_attribute(0)</a>
<a name="ln1091">		{</a>
<a name="ln1092">			header = PUGI__GETHEADER_IMPL(this, page, type);</a>
<a name="ln1093">		}</a>
<a name="ln1094"> </a>
<a name="ln1095">		uintptr_t header;</a>
<a name="ln1096"> </a>
<a name="ln1097">		char_t* name;</a>
<a name="ln1098">		char_t* value;</a>
<a name="ln1099"> </a>
<a name="ln1100">		xml_node_struct* parent;</a>
<a name="ln1101"> </a>
<a name="ln1102">		xml_node_struct* first_child;</a>
<a name="ln1103"> </a>
<a name="ln1104">		xml_node_struct* prev_sibling_c;</a>
<a name="ln1105">		xml_node_struct* next_sibling;</a>
<a name="ln1106"> </a>
<a name="ln1107">		xml_attribute_struct* first_attribute;</a>
<a name="ln1108">	};</a>
<a name="ln1109">}</a>
<a name="ln1110">#endif</a>
<a name="ln1111"> </a>
<a name="ln1112">PUGI__NS_BEGIN</a>
<a name="ln1113">	struct xml_extra_buffer</a>
<a name="ln1114">	{</a>
<a name="ln1115">		char_t* buffer;</a>
<a name="ln1116">		xml_extra_buffer* next;</a>
<a name="ln1117">	};</a>
<a name="ln1118"> </a>
<a name="ln1119">	struct xml_document_struct: public xml_node_struct, public xml_allocator</a>
<a name="ln1120">	{</a>
<a name="ln1121">		xml_document_struct(xml_memory_page* page): xml_node_struct(page, node_document), xml_allocator(page), buffer(0), extra_buffers(0)</a>
<a name="ln1122">		{</a>
<a name="ln1123">		}</a>
<a name="ln1124"> </a>
<a name="ln1125">		const char_t* buffer;</a>
<a name="ln1126"> </a>
<a name="ln1127">		xml_extra_buffer* extra_buffers;</a>
<a name="ln1128"> </a>
<a name="ln1129">	#ifdef PUGIXML_COMPACT</a>
<a name="ln1130">		compact_hash_table hash;</a>
<a name="ln1131">	#endif</a>
<a name="ln1132">	};</a>
<a name="ln1133"> </a>
<a name="ln1134">	template &lt;typename Object&gt; inline xml_allocator&amp; get_allocator(const Object* object)</a>
<a name="ln1135">	{</a>
<a name="ln1136">		assert(object);</a>
<a name="ln1137"> </a>
<a name="ln1138">		return *PUGI__GETPAGE(object)-&gt;allocator;</a>
<a name="ln1139">	}</a>
<a name="ln1140"> </a>
<a name="ln1141">	template &lt;typename Object&gt; inline xml_document_struct&amp; get_document(const Object* object)</a>
<a name="ln1142">	{</a>
<a name="ln1143">		assert(object);</a>
<a name="ln1144"> </a>
<a name="ln1145">		return *static_cast&lt;xml_document_struct*&gt;(PUGI__GETPAGE(object)-&gt;allocator);</a>
<a name="ln1146">	}</a>
<a name="ln1147">PUGI__NS_END</a>
<a name="ln1148"> </a>
<a name="ln1149">// Low-level DOM operations</a>
<a name="ln1150">PUGI__NS_BEGIN</a>
<a name="ln1151">	inline xml_attribute_struct* allocate_attribute(xml_allocator&amp; alloc)</a>
<a name="ln1152">	{</a>
<a name="ln1153">		xml_memory_page* page;</a>
<a name="ln1154">		void* memory = alloc.allocate_object(sizeof(xml_attribute_struct), page);</a>
<a name="ln1155">		if (!memory) return 0;</a>
<a name="ln1156"> </a>
<a name="ln1157">		return new (memory) xml_attribute_struct(page);</a>
<a name="ln1158">	}</a>
<a name="ln1159"> </a>
<a name="ln1160">	inline xml_node_struct* allocate_node(xml_allocator&amp; alloc, xml_node_type type)</a>
<a name="ln1161">	{</a>
<a name="ln1162">		xml_memory_page* page;</a>
<a name="ln1163">		void* memory = alloc.allocate_object(sizeof(xml_node_struct), page);</a>
<a name="ln1164">		if (!memory) return 0;</a>
<a name="ln1165"> </a>
<a name="ln1166">		return new (memory) xml_node_struct(page, type);</a>
<a name="ln1167">	}</a>
<a name="ln1168"> </a>
<a name="ln1169">	inline void destroy_attribute(xml_attribute_struct* a, xml_allocator&amp; alloc)</a>
<a name="ln1170">	{</a>
<a name="ln1171">		if (a-&gt;header &amp; impl::xml_memory_page_name_allocated_mask)</a>
<a name="ln1172">			alloc.deallocate_string(a-&gt;name);</a>
<a name="ln1173"> </a>
<a name="ln1174">		if (a-&gt;header &amp; impl::xml_memory_page_value_allocated_mask)</a>
<a name="ln1175">			alloc.deallocate_string(a-&gt;value);</a>
<a name="ln1176"> </a>
<a name="ln1177">		alloc.deallocate_memory(a, sizeof(xml_attribute_struct), PUGI__GETPAGE(a));</a>
<a name="ln1178">	}</a>
<a name="ln1179"> </a>
<a name="ln1180">	inline void destroy_node(xml_node_struct* n, xml_allocator&amp; alloc)</a>
<a name="ln1181">	{</a>
<a name="ln1182">		if (n-&gt;header &amp; impl::xml_memory_page_name_allocated_mask)</a>
<a name="ln1183">			alloc.deallocate_string(n-&gt;name);</a>
<a name="ln1184"> </a>
<a name="ln1185">		if (n-&gt;header &amp; impl::xml_memory_page_value_allocated_mask)</a>
<a name="ln1186">			alloc.deallocate_string(n-&gt;value);</a>
<a name="ln1187"> </a>
<a name="ln1188">		for (xml_attribute_struct* attr = n-&gt;first_attribute; attr; )</a>
<a name="ln1189">		{</a>
<a name="ln1190">			xml_attribute_struct* next = attr-&gt;next_attribute;</a>
<a name="ln1191"> </a>
<a name="ln1192">			destroy_attribute(attr, alloc);</a>
<a name="ln1193"> </a>
<a name="ln1194">			attr = next;</a>
<a name="ln1195">		}</a>
<a name="ln1196"> </a>
<a name="ln1197">		for (xml_node_struct* child = n-&gt;first_child; child; )</a>
<a name="ln1198">		{</a>
<a name="ln1199">			xml_node_struct* next = child-&gt;next_sibling;</a>
<a name="ln1200"> </a>
<a name="ln1201">			destroy_node(child, alloc);</a>
<a name="ln1202"> </a>
<a name="ln1203">			child = next;</a>
<a name="ln1204">		}</a>
<a name="ln1205"> </a>
<a name="ln1206">		alloc.deallocate_memory(n, sizeof(xml_node_struct), PUGI__GETPAGE(n));</a>
<a name="ln1207">	}</a>
<a name="ln1208"> </a>
<a name="ln1209">	inline void append_node(xml_node_struct* child, xml_node_struct* node)</a>
<a name="ln1210">	{</a>
<a name="ln1211">		child-&gt;parent = node;</a>
<a name="ln1212"> </a>
<a name="ln1213">		xml_node_struct* head = node-&gt;first_child;</a>
<a name="ln1214"> </a>
<a name="ln1215">		if (head)</a>
<a name="ln1216">		{</a>
<a name="ln1217">			xml_node_struct* tail = head-&gt;prev_sibling_c;</a>
<a name="ln1218"> </a>
<a name="ln1219">			tail-&gt;next_sibling = child;</a>
<a name="ln1220">			child-&gt;prev_sibling_c = tail;</a>
<a name="ln1221">			head-&gt;prev_sibling_c = child;</a>
<a name="ln1222">		}</a>
<a name="ln1223">		else</a>
<a name="ln1224">		{</a>
<a name="ln1225">			node-&gt;first_child = child;</a>
<a name="ln1226">			child-&gt;prev_sibling_c = child;</a>
<a name="ln1227">		}</a>
<a name="ln1228">	}</a>
<a name="ln1229"> </a>
<a name="ln1230">	inline void prepend_node(xml_node_struct* child, xml_node_struct* node)</a>
<a name="ln1231">	{</a>
<a name="ln1232">		child-&gt;parent = node;</a>
<a name="ln1233"> </a>
<a name="ln1234">		xml_node_struct* head = node-&gt;first_child;</a>
<a name="ln1235"> </a>
<a name="ln1236">		if (head)</a>
<a name="ln1237">		{</a>
<a name="ln1238">			child-&gt;prev_sibling_c = head-&gt;prev_sibling_c;</a>
<a name="ln1239">			head-&gt;prev_sibling_c = child;</a>
<a name="ln1240">		}</a>
<a name="ln1241">		else</a>
<a name="ln1242">			child-&gt;prev_sibling_c = child;</a>
<a name="ln1243"> </a>
<a name="ln1244">		child-&gt;next_sibling = head;</a>
<a name="ln1245">		node-&gt;first_child = child;</a>
<a name="ln1246">	}</a>
<a name="ln1247"> </a>
<a name="ln1248">	inline void insert_node_after(xml_node_struct* child, xml_node_struct* node)</a>
<a name="ln1249">	{</a>
<a name="ln1250">		xml_node_struct* parent = node-&gt;parent;</a>
<a name="ln1251"> </a>
<a name="ln1252">		child-&gt;parent = parent;</a>
<a name="ln1253"> </a>
<a name="ln1254">		if (node-&gt;next_sibling)</a>
<a name="ln1255">			node-&gt;next_sibling-&gt;prev_sibling_c = child;</a>
<a name="ln1256">		else</a>
<a name="ln1257">			parent-&gt;first_child-&gt;prev_sibling_c = child;</a>
<a name="ln1258"> </a>
<a name="ln1259">		child-&gt;next_sibling = node-&gt;next_sibling;</a>
<a name="ln1260">		child-&gt;prev_sibling_c = node;</a>
<a name="ln1261"> </a>
<a name="ln1262">		node-&gt;next_sibling = child;</a>
<a name="ln1263">	}</a>
<a name="ln1264"> </a>
<a name="ln1265">	inline void insert_node_before(xml_node_struct* child, xml_node_struct* node)</a>
<a name="ln1266">	{</a>
<a name="ln1267">		xml_node_struct* parent = node-&gt;parent;</a>
<a name="ln1268"> </a>
<a name="ln1269">		child-&gt;parent = parent;</a>
<a name="ln1270"> </a>
<a name="ln1271">		if (node-&gt;prev_sibling_c-&gt;next_sibling)</a>
<a name="ln1272">			node-&gt;prev_sibling_c-&gt;next_sibling = child;</a>
<a name="ln1273">		else</a>
<a name="ln1274">			parent-&gt;first_child = child;</a>
<a name="ln1275"> </a>
<a name="ln1276">		child-&gt;prev_sibling_c = node-&gt;prev_sibling_c;</a>
<a name="ln1277">		child-&gt;next_sibling = node;</a>
<a name="ln1278"> </a>
<a name="ln1279">		node-&gt;prev_sibling_c = child;</a>
<a name="ln1280">	}</a>
<a name="ln1281"> </a>
<a name="ln1282">	inline void remove_node(xml_node_struct* node)</a>
<a name="ln1283">	{</a>
<a name="ln1284">		xml_node_struct* parent = node-&gt;parent;</a>
<a name="ln1285"> </a>
<a name="ln1286">		if (node-&gt;next_sibling)</a>
<a name="ln1287">			node-&gt;next_sibling-&gt;prev_sibling_c = node-&gt;prev_sibling_c;</a>
<a name="ln1288">		else</a>
<a name="ln1289">			parent-&gt;first_child-&gt;prev_sibling_c = node-&gt;prev_sibling_c;</a>
<a name="ln1290"> </a>
<a name="ln1291">		if (node-&gt;prev_sibling_c-&gt;next_sibling)</a>
<a name="ln1292">			node-&gt;prev_sibling_c-&gt;next_sibling = node-&gt;next_sibling;</a>
<a name="ln1293">		else</a>
<a name="ln1294">			parent-&gt;first_child = node-&gt;next_sibling;</a>
<a name="ln1295"> </a>
<a name="ln1296">		node-&gt;parent = 0;</a>
<a name="ln1297">		node-&gt;prev_sibling_c = 0;</a>
<a name="ln1298">		node-&gt;next_sibling = 0;</a>
<a name="ln1299">	}</a>
<a name="ln1300"> </a>
<a name="ln1301">	inline void append_attribute(xml_attribute_struct* attr, xml_node_struct* node)</a>
<a name="ln1302">	{</a>
<a name="ln1303">		xml_attribute_struct* head = node-&gt;first_attribute;</a>
<a name="ln1304"> </a>
<a name="ln1305">		if (head)</a>
<a name="ln1306">		{</a>
<a name="ln1307">			xml_attribute_struct* tail = head-&gt;prev_attribute_c;</a>
<a name="ln1308"> </a>
<a name="ln1309">			tail-&gt;next_attribute = attr;</a>
<a name="ln1310">			attr-&gt;prev_attribute_c = tail;</a>
<a name="ln1311">			head-&gt;prev_attribute_c = attr;</a>
<a name="ln1312">		}</a>
<a name="ln1313">		else</a>
<a name="ln1314">		{</a>
<a name="ln1315">			node-&gt;first_attribute = attr;</a>
<a name="ln1316">			attr-&gt;prev_attribute_c = attr;</a>
<a name="ln1317">		}</a>
<a name="ln1318">	}</a>
<a name="ln1319"> </a>
<a name="ln1320">	inline void prepend_attribute(xml_attribute_struct* attr, xml_node_struct* node)</a>
<a name="ln1321">	{</a>
<a name="ln1322">		xml_attribute_struct* head = node-&gt;first_attribute;</a>
<a name="ln1323"> </a>
<a name="ln1324">		if (head)</a>
<a name="ln1325">		{</a>
<a name="ln1326">			attr-&gt;prev_attribute_c = head-&gt;prev_attribute_c;</a>
<a name="ln1327">			head-&gt;prev_attribute_c = attr;</a>
<a name="ln1328">		}</a>
<a name="ln1329">		else</a>
<a name="ln1330">			attr-&gt;prev_attribute_c = attr;</a>
<a name="ln1331"> </a>
<a name="ln1332">		attr-&gt;next_attribute = head;</a>
<a name="ln1333">		node-&gt;first_attribute = attr;</a>
<a name="ln1334">	}</a>
<a name="ln1335"> </a>
<a name="ln1336">	inline void insert_attribute_after(xml_attribute_struct* attr, xml_attribute_struct* place, xml_node_struct* node)</a>
<a name="ln1337">	{</a>
<a name="ln1338">		if (place-&gt;next_attribute)</a>
<a name="ln1339">			place-&gt;next_attribute-&gt;prev_attribute_c = attr;</a>
<a name="ln1340">		else</a>
<a name="ln1341">			node-&gt;first_attribute-&gt;prev_attribute_c = attr;</a>
<a name="ln1342"> </a>
<a name="ln1343">		attr-&gt;next_attribute = place-&gt;next_attribute;</a>
<a name="ln1344">		attr-&gt;prev_attribute_c = place;</a>
<a name="ln1345">		place-&gt;next_attribute = attr;</a>
<a name="ln1346">	}</a>
<a name="ln1347"> </a>
<a name="ln1348">	inline void insert_attribute_before(xml_attribute_struct* attr, xml_attribute_struct* place, xml_node_struct* node)</a>
<a name="ln1349">	{</a>
<a name="ln1350">		if (place-&gt;prev_attribute_c-&gt;next_attribute)</a>
<a name="ln1351">			place-&gt;prev_attribute_c-&gt;next_attribute = attr;</a>
<a name="ln1352">		else</a>
<a name="ln1353">			node-&gt;first_attribute = attr;</a>
<a name="ln1354"> </a>
<a name="ln1355">		attr-&gt;prev_attribute_c = place-&gt;prev_attribute_c;</a>
<a name="ln1356">		attr-&gt;next_attribute = place;</a>
<a name="ln1357">		place-&gt;prev_attribute_c = attr;</a>
<a name="ln1358">	}</a>
<a name="ln1359"> </a>
<a name="ln1360">	inline void remove_attribute(xml_attribute_struct* attr, xml_node_struct* node)</a>
<a name="ln1361">	{</a>
<a name="ln1362">		if (attr-&gt;next_attribute)</a>
<a name="ln1363">			attr-&gt;next_attribute-&gt;prev_attribute_c = attr-&gt;prev_attribute_c;</a>
<a name="ln1364">		else</a>
<a name="ln1365">			node-&gt;first_attribute-&gt;prev_attribute_c = attr-&gt;prev_attribute_c;</a>
<a name="ln1366"> </a>
<a name="ln1367">		if (attr-&gt;prev_attribute_c-&gt;next_attribute)</a>
<a name="ln1368">			attr-&gt;prev_attribute_c-&gt;next_attribute = attr-&gt;next_attribute;</a>
<a name="ln1369">		else</a>
<a name="ln1370">			node-&gt;first_attribute = attr-&gt;next_attribute;</a>
<a name="ln1371"> </a>
<a name="ln1372">		attr-&gt;prev_attribute_c = 0;</a>
<a name="ln1373">		attr-&gt;next_attribute = 0;</a>
<a name="ln1374">	}</a>
<a name="ln1375"> </a>
<a name="ln1376">	PUGI__FN_NO_INLINE xml_node_struct* append_new_node(xml_node_struct* node, xml_allocator&amp; alloc, xml_node_type type = node_element)</a>
<a name="ln1377">	{</a>
<a name="ln1378">		if (!alloc.reserve()) return 0;</a>
<a name="ln1379"> </a>
<a name="ln1380">		xml_node_struct* child = allocate_node(alloc, type);</a>
<a name="ln1381">		if (!child) return 0;</a>
<a name="ln1382"> </a>
<a name="ln1383">		append_node(child, node);</a>
<a name="ln1384"> </a>
<a name="ln1385">		return child;</a>
<a name="ln1386">	}</a>
<a name="ln1387"> </a>
<a name="ln1388">	PUGI__FN_NO_INLINE xml_attribute_struct* append_new_attribute(xml_node_struct* node, xml_allocator&amp; alloc)</a>
<a name="ln1389">	{</a>
<a name="ln1390">		if (!alloc.reserve()) return 0;</a>
<a name="ln1391"> </a>
<a name="ln1392">		xml_attribute_struct* attr = allocate_attribute(alloc);</a>
<a name="ln1393">		if (!attr) return 0;</a>
<a name="ln1394"> </a>
<a name="ln1395">		append_attribute(attr, node);</a>
<a name="ln1396"> </a>
<a name="ln1397">		return attr;</a>
<a name="ln1398">	}</a>
<a name="ln1399">PUGI__NS_END</a>
<a name="ln1400"> </a>
<a name="ln1401">// Helper classes for code generation</a>
<a name="ln1402">PUGI__NS_BEGIN</a>
<a name="ln1403">	struct opt_false</a>
<a name="ln1404">	{</a>
<a name="ln1405">		enum { value = 0 };</a>
<a name="ln1406">	};</a>
<a name="ln1407"> </a>
<a name="ln1408">	struct opt_true</a>
<a name="ln1409">	{</a>
<a name="ln1410">		enum { value = 1 };</a>
<a name="ln1411">	};</a>
<a name="ln1412">PUGI__NS_END</a>
<a name="ln1413"> </a>
<a name="ln1414">// Unicode utilities</a>
<a name="ln1415">PUGI__NS_BEGIN</a>
<a name="ln1416">	inline uint16_t endian_swap(uint16_t value)</a>
<a name="ln1417">	{</a>
<a name="ln1418">		return static_cast&lt;uint16_t&gt;(((value &amp; 0xff) &lt;&lt; 8) | (value &gt;&gt; 8));</a>
<a name="ln1419">	}</a>
<a name="ln1420"> </a>
<a name="ln1421">	inline uint32_t endian_swap(uint32_t value)</a>
<a name="ln1422">	{</a>
<a name="ln1423">		return ((value &amp; 0xff) &lt;&lt; 24) | ((value &amp; 0xff00) &lt;&lt; 8) | ((value &amp; 0xff0000) &gt;&gt; 8) | (value &gt;&gt; 24);</a>
<a name="ln1424">	}</a>
<a name="ln1425"> </a>
<a name="ln1426">	struct utf8_counter</a>
<a name="ln1427">	{</a>
<a name="ln1428">		typedef size_t value_type;</a>
<a name="ln1429"> </a>
<a name="ln1430">		static value_type low(value_type result, uint32_t ch)</a>
<a name="ln1431">		{</a>
<a name="ln1432">			// U+0000..U+007F</a>
<a name="ln1433">			if (ch &lt; 0x80) return result + 1;</a>
<a name="ln1434">			// U+0080..U+07FF</a>
<a name="ln1435">			else if (ch &lt; 0x800) return result + 2;</a>
<a name="ln1436">			// U+0800..U+FFFF</a>
<a name="ln1437">			else return result + 3;</a>
<a name="ln1438">		}</a>
<a name="ln1439"> </a>
<a name="ln1440">		static value_type high(value_type result, uint32_t)</a>
<a name="ln1441">		{</a>
<a name="ln1442">			// U+10000..U+10FFFF</a>
<a name="ln1443">			return result + 4;</a>
<a name="ln1444">		}</a>
<a name="ln1445">	};</a>
<a name="ln1446"> </a>
<a name="ln1447">	struct utf8_writer</a>
<a name="ln1448">	{</a>
<a name="ln1449">		typedef uint8_t* value_type;</a>
<a name="ln1450"> </a>
<a name="ln1451">		static value_type low(value_type result, uint32_t ch)</a>
<a name="ln1452">		{</a>
<a name="ln1453">			// U+0000..U+007F</a>
<a name="ln1454">			if (ch &lt; 0x80)</a>
<a name="ln1455">			{</a>
<a name="ln1456">				*result = static_cast&lt;uint8_t&gt;(ch);</a>
<a name="ln1457">				return result + 1;</a>
<a name="ln1458">			}</a>
<a name="ln1459">			// U+0080..U+07FF</a>
<a name="ln1460">			else if (ch &lt; 0x800)</a>
<a name="ln1461">			{</a>
<a name="ln1462">				result[0] = static_cast&lt;uint8_t&gt;(0xC0 | (ch &gt;&gt; 6));</a>
<a name="ln1463">				result[1] = static_cast&lt;uint8_t&gt;(0x80 | (ch &amp; 0x3F));</a>
<a name="ln1464">				return result + 2;</a>
<a name="ln1465">			}</a>
<a name="ln1466">			// U+0800..U+FFFF</a>
<a name="ln1467">			else</a>
<a name="ln1468">			{</a>
<a name="ln1469">				result[0] = static_cast&lt;uint8_t&gt;(0xE0 | (ch &gt;&gt; 12));</a>
<a name="ln1470">				result[1] = static_cast&lt;uint8_t&gt;(0x80 | ((ch &gt;&gt; 6) &amp; 0x3F));</a>
<a name="ln1471">				result[2] = static_cast&lt;uint8_t&gt;(0x80 | (ch &amp; 0x3F));</a>
<a name="ln1472">				return result + 3;</a>
<a name="ln1473">			}</a>
<a name="ln1474">		}</a>
<a name="ln1475"> </a>
<a name="ln1476">		static value_type high(value_type result, uint32_t ch)</a>
<a name="ln1477">		{</a>
<a name="ln1478">			// U+10000..U+10FFFF</a>
<a name="ln1479">			result[0] = static_cast&lt;uint8_t&gt;(0xF0 | (ch &gt;&gt; 18));</a>
<a name="ln1480">			result[1] = static_cast&lt;uint8_t&gt;(0x80 | ((ch &gt;&gt; 12) &amp; 0x3F));</a>
<a name="ln1481">			result[2] = static_cast&lt;uint8_t&gt;(0x80 | ((ch &gt;&gt; 6) &amp; 0x3F));</a>
<a name="ln1482">			result[3] = static_cast&lt;uint8_t&gt;(0x80 | (ch &amp; 0x3F));</a>
<a name="ln1483">			return result + 4;</a>
<a name="ln1484">		}</a>
<a name="ln1485"> </a>
<a name="ln1486">		static value_type any(value_type result, uint32_t ch)</a>
<a name="ln1487">		{</a>
<a name="ln1488">			return (ch &lt; 0x10000) ? low(result, ch) : high(result, ch);</a>
<a name="ln1489">		}</a>
<a name="ln1490">	};</a>
<a name="ln1491"> </a>
<a name="ln1492">	struct utf16_counter</a>
<a name="ln1493">	{</a>
<a name="ln1494">		typedef size_t value_type;</a>
<a name="ln1495"> </a>
<a name="ln1496">		static value_type low(value_type result, uint32_t)</a>
<a name="ln1497">		{</a>
<a name="ln1498">			return result + 1;</a>
<a name="ln1499">		}</a>
<a name="ln1500"> </a>
<a name="ln1501">		static value_type high(value_type result, uint32_t)</a>
<a name="ln1502">		{</a>
<a name="ln1503">			return result + 2;</a>
<a name="ln1504">		}</a>
<a name="ln1505">	};</a>
<a name="ln1506"> </a>
<a name="ln1507">	struct utf16_writer</a>
<a name="ln1508">	{</a>
<a name="ln1509">		typedef uint16_t* value_type;</a>
<a name="ln1510"> </a>
<a name="ln1511">		static value_type low(value_type result, uint32_t ch)</a>
<a name="ln1512">		{</a>
<a name="ln1513">			*result = static_cast&lt;uint16_t&gt;(ch);</a>
<a name="ln1514"> </a>
<a name="ln1515">			return result + 1;</a>
<a name="ln1516">		}</a>
<a name="ln1517"> </a>
<a name="ln1518">		static value_type high(value_type result, uint32_t ch)</a>
<a name="ln1519">		{</a>
<a name="ln1520">			uint32_t msh = static_cast&lt;uint32_t&gt;(ch - 0x10000) &gt;&gt; 10;</a>
<a name="ln1521">			uint32_t lsh = static_cast&lt;uint32_t&gt;(ch - 0x10000) &amp; 0x3ff;</a>
<a name="ln1522"> </a>
<a name="ln1523">			result[0] = static_cast&lt;uint16_t&gt;(0xD800 + msh);</a>
<a name="ln1524">			result[1] = static_cast&lt;uint16_t&gt;(0xDC00 + lsh);</a>
<a name="ln1525"> </a>
<a name="ln1526">			return result + 2;</a>
<a name="ln1527">		}</a>
<a name="ln1528"> </a>
<a name="ln1529">		static value_type any(value_type result, uint32_t ch)</a>
<a name="ln1530">		{</a>
<a name="ln1531">			return (ch &lt; 0x10000) ? low(result, ch) : high(result, ch);</a>
<a name="ln1532">		}</a>
<a name="ln1533">	};</a>
<a name="ln1534"> </a>
<a name="ln1535">	struct utf32_counter</a>
<a name="ln1536">	{</a>
<a name="ln1537">		typedef size_t value_type;</a>
<a name="ln1538"> </a>
<a name="ln1539">		static value_type low(value_type result, uint32_t)</a>
<a name="ln1540">		{</a>
<a name="ln1541">			return result + 1;</a>
<a name="ln1542">		}</a>
<a name="ln1543"> </a>
<a name="ln1544">		static value_type high(value_type result, uint32_t)</a>
<a name="ln1545">		{</a>
<a name="ln1546">			return result + 1;</a>
<a name="ln1547">		}</a>
<a name="ln1548">	};</a>
<a name="ln1549"> </a>
<a name="ln1550">	struct utf32_writer</a>
<a name="ln1551">	{</a>
<a name="ln1552">		typedef uint32_t* value_type;</a>
<a name="ln1553"> </a>
<a name="ln1554">		static value_type low(value_type result, uint32_t ch)</a>
<a name="ln1555">		{</a>
<a name="ln1556">			*result = ch;</a>
<a name="ln1557"> </a>
<a name="ln1558">			return result + 1;</a>
<a name="ln1559">		}</a>
<a name="ln1560"> </a>
<a name="ln1561">		static value_type high(value_type result, uint32_t ch)</a>
<a name="ln1562">		{</a>
<a name="ln1563">			*result = ch;</a>
<a name="ln1564"> </a>
<a name="ln1565">			return result + 1;</a>
<a name="ln1566">		}</a>
<a name="ln1567"> </a>
<a name="ln1568">		static value_type any(value_type result, uint32_t ch)</a>
<a name="ln1569">		{</a>
<a name="ln1570">			*result = ch;</a>
<a name="ln1571"> </a>
<a name="ln1572">			return result + 1;</a>
<a name="ln1573">		}</a>
<a name="ln1574">	};</a>
<a name="ln1575"> </a>
<a name="ln1576">	struct latin1_writer</a>
<a name="ln1577">	{</a>
<a name="ln1578">		typedef uint8_t* value_type;</a>
<a name="ln1579"> </a>
<a name="ln1580">		static value_type low(value_type result, uint32_t ch)</a>
<a name="ln1581">		{</a>
<a name="ln1582">			*result = static_cast&lt;uint8_t&gt;(ch &gt; 255 ? '?' : ch);</a>
<a name="ln1583"> </a>
<a name="ln1584">			return result + 1;</a>
<a name="ln1585">		}</a>
<a name="ln1586"> </a>
<a name="ln1587">		static value_type high(value_type result, uint32_t ch)</a>
<a name="ln1588">		{</a>
<a name="ln1589">			(void)ch;</a>
<a name="ln1590"> </a>
<a name="ln1591">			*result = '?';</a>
<a name="ln1592"> </a>
<a name="ln1593">			return result + 1;</a>
<a name="ln1594">		}</a>
<a name="ln1595">	};</a>
<a name="ln1596"> </a>
<a name="ln1597">	struct utf8_decoder</a>
<a name="ln1598">	{</a>
<a name="ln1599">		typedef uint8_t type;</a>
<a name="ln1600"> </a>
<a name="ln1601">		template &lt;typename Traits&gt; static inline typename Traits::value_type process(const uint8_t* data, size_t size, typename Traits::value_type result, Traits)</a>
<a name="ln1602">		{</a>
<a name="ln1603">			const uint8_t utf8_byte_mask = 0x3f;</a>
<a name="ln1604"> </a>
<a name="ln1605">			while (size)</a>
<a name="ln1606">			{</a>
<a name="ln1607">				uint8_t lead = *data;</a>
<a name="ln1608"> </a>
<a name="ln1609">				// 0xxxxxxx -&gt; U+0000..U+007F</a>
<a name="ln1610">				if (lead &lt; 0x80)</a>
<a name="ln1611">				{</a>
<a name="ln1612">					result = Traits::low(result, lead);</a>
<a name="ln1613">					data += 1;</a>
<a name="ln1614">					size -= 1;</a>
<a name="ln1615"> </a>
<a name="ln1616">					// process aligned single-byte (ascii) blocks</a>
<a name="ln1617">					if ((reinterpret_cast&lt;uintptr_t&gt;(data) &amp; 3) == 0)</a>
<a name="ln1618">					{</a>
<a name="ln1619">						// round-trip through void* to silence 'cast increases required alignment of target type' warnings</a>
<a name="ln1620">						while (size &gt;= 4 &amp;&amp; (*static_cast&lt;const uint32_t*&gt;(static_cast&lt;const void*&gt;(data)) &amp; 0x80808080) == 0)</a>
<a name="ln1621">						{</a>
<a name="ln1622">							result = Traits::low(result, data[0]);</a>
<a name="ln1623">							result = Traits::low(result, data[1]);</a>
<a name="ln1624">							result = Traits::low(result, data[2]);</a>
<a name="ln1625">							result = Traits::low(result, data[3]);</a>
<a name="ln1626">							data += 4;</a>
<a name="ln1627">							size -= 4;</a>
<a name="ln1628">						}</a>
<a name="ln1629">					}</a>
<a name="ln1630">				}</a>
<a name="ln1631">				// 110xxxxx -&gt; U+0080..U+07FF</a>
<a name="ln1632">				else if (static_cast&lt;unsigned int&gt;(lead - 0xC0) &lt; 0x20 &amp;&amp; size &gt;= 2 &amp;&amp; (data[1] &amp; 0xc0) == 0x80)</a>
<a name="ln1633">				{</a>
<a name="ln1634">					result = Traits::low(result, ((lead &amp; ~0xC0) &lt;&lt; 6) | (data[1] &amp; utf8_byte_mask));</a>
<a name="ln1635">					data += 2;</a>
<a name="ln1636">					size -= 2;</a>
<a name="ln1637">				}</a>
<a name="ln1638">				// 1110xxxx -&gt; U+0800-U+FFFF</a>
<a name="ln1639">				else if (static_cast&lt;unsigned int&gt;(lead - 0xE0) &lt; 0x10 &amp;&amp; size &gt;= 3 &amp;&amp; (data[1] &amp; 0xc0) == 0x80 &amp;&amp; (data[2] &amp; 0xc0) == 0x80)</a>
<a name="ln1640">				{</a>
<a name="ln1641">					result = Traits::low(result, ((lead &amp; ~0xE0) &lt;&lt; 12) | ((data[1] &amp; utf8_byte_mask) &lt;&lt; 6) | (data[2] &amp; utf8_byte_mask));</a>
<a name="ln1642">					data += 3;</a>
<a name="ln1643">					size -= 3;</a>
<a name="ln1644">				}</a>
<a name="ln1645">				// 11110xxx -&gt; U+10000..U+10FFFF</a>
<a name="ln1646">				else if (static_cast&lt;unsigned int&gt;(lead - 0xF0) &lt; 0x08 &amp;&amp; size &gt;= 4 &amp;&amp; (data[1] &amp; 0xc0) == 0x80 &amp;&amp; (data[2] &amp; 0xc0) == 0x80 &amp;&amp; (data[3] &amp; 0xc0) == 0x80)</a>
<a name="ln1647">				{</a>
<a name="ln1648">					result = Traits::high(result, ((lead &amp; ~0xF0) &lt;&lt; 18) | ((data[1] &amp; utf8_byte_mask) &lt;&lt; 12) | ((data[2] &amp; utf8_byte_mask) &lt;&lt; 6) | (data[3] &amp; utf8_byte_mask));</a>
<a name="ln1649">					data += 4;</a>
<a name="ln1650">					size -= 4;</a>
<a name="ln1651">				}</a>
<a name="ln1652">				// 10xxxxxx or 11111xxx -&gt; invalid</a>
<a name="ln1653">				else</a>
<a name="ln1654">				{</a>
<a name="ln1655">					data += 1;</a>
<a name="ln1656">					size -= 1;</a>
<a name="ln1657">				}</a>
<a name="ln1658">			}</a>
<a name="ln1659"> </a>
<a name="ln1660">			return result;</a>
<a name="ln1661">		}</a>
<a name="ln1662">	};</a>
<a name="ln1663"> </a>
<a name="ln1664">	template &lt;typename opt_swap&gt; struct utf16_decoder</a>
<a name="ln1665">	{</a>
<a name="ln1666">		typedef uint16_t type;</a>
<a name="ln1667"> </a>
<a name="ln1668">		template &lt;typename Traits&gt; static inline typename Traits::value_type process(const uint16_t* data, size_t size, typename Traits::value_type result, Traits)</a>
<a name="ln1669">		{</a>
<a name="ln1670">			while (size)</a>
<a name="ln1671">			{</a>
<a name="ln1672">				uint16_t lead = opt_swap::value ? endian_swap(*data) : *data;</a>
<a name="ln1673"> </a>
<a name="ln1674">				// U+0000..U+D7FF</a>
<a name="ln1675">				if (lead &lt; 0xD800)</a>
<a name="ln1676">				{</a>
<a name="ln1677">					result = Traits::low(result, lead);</a>
<a name="ln1678">					data += 1;</a>
<a name="ln1679">					size -= 1;</a>
<a name="ln1680">				}</a>
<a name="ln1681">				// U+E000..U+FFFF</a>
<a name="ln1682">				else if (static_cast&lt;unsigned int&gt;(lead - 0xE000) &lt; 0x2000)</a>
<a name="ln1683">				{</a>
<a name="ln1684">					result = Traits::low(result, lead);</a>
<a name="ln1685">					data += 1;</a>
<a name="ln1686">					size -= 1;</a>
<a name="ln1687">				}</a>
<a name="ln1688">				// surrogate pair lead</a>
<a name="ln1689">				else if (static_cast&lt;unsigned int&gt;(lead - 0xD800) &lt; 0x400 &amp;&amp; size &gt;= 2)</a>
<a name="ln1690">				{</a>
<a name="ln1691">					uint16_t next = opt_swap::value ? endian_swap(data[1]) : data[1];</a>
<a name="ln1692"> </a>
<a name="ln1693">					if (static_cast&lt;unsigned int&gt;(next - 0xDC00) &lt; 0x400)</a>
<a name="ln1694">					{</a>
<a name="ln1695">						result = Traits::high(result, 0x10000 + ((lead &amp; 0x3ff) &lt;&lt; 10) + (next &amp; 0x3ff));</a>
<a name="ln1696">						data += 2;</a>
<a name="ln1697">						size -= 2;</a>
<a name="ln1698">					}</a>
<a name="ln1699">					else</a>
<a name="ln1700">					{</a>
<a name="ln1701">						data += 1;</a>
<a name="ln1702">						size -= 1;</a>
<a name="ln1703">					}</a>
<a name="ln1704">				}</a>
<a name="ln1705">				else</a>
<a name="ln1706">				{</a>
<a name="ln1707">					data += 1;</a>
<a name="ln1708">					size -= 1;</a>
<a name="ln1709">				}</a>
<a name="ln1710">			}</a>
<a name="ln1711"> </a>
<a name="ln1712">			return result;</a>
<a name="ln1713">		}</a>
<a name="ln1714">	};</a>
<a name="ln1715"> </a>
<a name="ln1716">	template &lt;typename opt_swap&gt; struct utf32_decoder</a>
<a name="ln1717">	{</a>
<a name="ln1718">		typedef uint32_t type;</a>
<a name="ln1719"> </a>
<a name="ln1720">		template &lt;typename Traits&gt; static inline typename Traits::value_type process(const uint32_t* data, size_t size, typename Traits::value_type result, Traits)</a>
<a name="ln1721">		{</a>
<a name="ln1722">			while (size)</a>
<a name="ln1723">			{</a>
<a name="ln1724">				uint32_t lead = opt_swap::value ? endian_swap(*data) : *data;</a>
<a name="ln1725"> </a>
<a name="ln1726">				// U+0000..U+FFFF</a>
<a name="ln1727">				if (lead &lt; 0x10000)</a>
<a name="ln1728">				{</a>
<a name="ln1729">					result = Traits::low(result, lead);</a>
<a name="ln1730">					data += 1;</a>
<a name="ln1731">					size -= 1;</a>
<a name="ln1732">				}</a>
<a name="ln1733">				// U+10000..U+10FFFF</a>
<a name="ln1734">				else</a>
<a name="ln1735">				{</a>
<a name="ln1736">					result = Traits::high(result, lead);</a>
<a name="ln1737">					data += 1;</a>
<a name="ln1738">					size -= 1;</a>
<a name="ln1739">				}</a>
<a name="ln1740">			}</a>
<a name="ln1741"> </a>
<a name="ln1742">			return result;</a>
<a name="ln1743">		}</a>
<a name="ln1744">	};</a>
<a name="ln1745"> </a>
<a name="ln1746">	struct latin1_decoder</a>
<a name="ln1747">	{</a>
<a name="ln1748">		typedef uint8_t type;</a>
<a name="ln1749"> </a>
<a name="ln1750">		template &lt;typename Traits&gt; static inline typename Traits::value_type process(const uint8_t* data, size_t size, typename Traits::value_type result, Traits)</a>
<a name="ln1751">		{</a>
<a name="ln1752">			while (size)</a>
<a name="ln1753">			{</a>
<a name="ln1754">				result = Traits::low(result, *data);</a>
<a name="ln1755">				data += 1;</a>
<a name="ln1756">				size -= 1;</a>
<a name="ln1757">			}</a>
<a name="ln1758"> </a>
<a name="ln1759">			return result;</a>
<a name="ln1760">		}</a>
<a name="ln1761">	};</a>
<a name="ln1762"> </a>
<a name="ln1763">	template &lt;size_t size&gt; struct wchar_selector;</a>
<a name="ln1764"> </a>
<a name="ln1765">	template &lt;&gt; struct wchar_selector&lt;2&gt;</a>
<a name="ln1766">	{</a>
<a name="ln1767">		typedef uint16_t type;</a>
<a name="ln1768">		typedef utf16_counter counter;</a>
<a name="ln1769">		typedef utf16_writer writer;</a>
<a name="ln1770">		typedef utf16_decoder&lt;opt_false&gt; decoder;</a>
<a name="ln1771">	};</a>
<a name="ln1772"> </a>
<a name="ln1773">	template &lt;&gt; struct wchar_selector&lt;4&gt;</a>
<a name="ln1774">	{</a>
<a name="ln1775">		typedef uint32_t type;</a>
<a name="ln1776">		typedef utf32_counter counter;</a>
<a name="ln1777">		typedef utf32_writer writer;</a>
<a name="ln1778">		typedef utf32_decoder&lt;opt_false&gt; decoder;</a>
<a name="ln1779">	};</a>
<a name="ln1780"> </a>
<a name="ln1781">	typedef wchar_selector&lt;sizeof(wchar_t)&gt;::counter wchar_counter;</a>
<a name="ln1782">	typedef wchar_selector&lt;sizeof(wchar_t)&gt;::writer wchar_writer;</a>
<a name="ln1783"> </a>
<a name="ln1784">	struct wchar_decoder</a>
<a name="ln1785">	{</a>
<a name="ln1786">		typedef wchar_t type;</a>
<a name="ln1787"> </a>
<a name="ln1788">		template &lt;typename Traits&gt; static inline typename Traits::value_type process(const wchar_t* data, size_t size, typename Traits::value_type result, Traits traits)</a>
<a name="ln1789">		{</a>
<a name="ln1790">			typedef wchar_selector&lt;sizeof(wchar_t)&gt;::decoder decoder;</a>
<a name="ln1791"> </a>
<a name="ln1792">			return decoder::process(reinterpret_cast&lt;const typename decoder::type*&gt;(data), size, result, traits);</a>
<a name="ln1793">		}</a>
<a name="ln1794">	};</a>
<a name="ln1795"> </a>
<a name="ln1796">#ifdef PUGIXML_WCHAR_MODE</a>
<a name="ln1797">	PUGI__FN void convert_wchar_endian_swap(wchar_t* result, const wchar_t* data, size_t length)</a>
<a name="ln1798">	{</a>
<a name="ln1799">		for (size_t i = 0; i &lt; length; ++i)</a>
<a name="ln1800">			result[i] = static_cast&lt;wchar_t&gt;(endian_swap(static_cast&lt;wchar_selector&lt;sizeof(wchar_t)&gt;::type&gt;(data[i])));</a>
<a name="ln1801">	}</a>
<a name="ln1802">#endif</a>
<a name="ln1803">PUGI__NS_END</a>
<a name="ln1804"> </a>
<a name="ln1805">PUGI__NS_BEGIN</a>
<a name="ln1806">	enum chartype_t</a>
<a name="ln1807">	{</a>
<a name="ln1808">		ct_parse_pcdata = 1,	// \0, &amp;, \r, &lt;</a>
<a name="ln1809">		ct_parse_attr = 2,		// \0, &amp;, \r, ', &quot;</a>
<a name="ln1810">		ct_parse_attr_ws = 4,	// \0, &amp;, \r, ', &quot;, \n, tab</a>
<a name="ln1811">		ct_space = 8,			// \r, \n, space, tab</a>
<a name="ln1812">		ct_parse_cdata = 16,	// \0, ], &gt;, \r</a>
<a name="ln1813">		ct_parse_comment = 32,	// \0, -, &gt;, \r</a>
<a name="ln1814">		ct_symbol = 64,			// Any symbol &gt; 127, a-z, A-Z, 0-9, _, :, -, .</a>
<a name="ln1815">		ct_start_symbol = 128	// Any symbol &gt; 127, a-z, A-Z, _, :</a>
<a name="ln1816">	};</a>
<a name="ln1817"> </a>
<a name="ln1818">	static const unsigned char chartype_table[256] =</a>
<a name="ln1819">	{</a>
<a name="ln1820">		55,  0,   0,   0,   0,   0,   0,   0,      0,   12,  12,  0,   0,   63,  0,   0,   // 0-15</a>
<a name="ln1821">		0,   0,   0,   0,   0,   0,   0,   0,      0,   0,   0,   0,   0,   0,   0,   0,   // 16-31</a>
<a name="ln1822">		8,   0,   6,   0,   0,   0,   7,   6,      0,   0,   0,   0,   0,   96,  64,  0,   // 32-47</a>
<a name="ln1823">		64,  64,  64,  64,  64,  64,  64,  64,     64,  64,  192, 0,   1,   0,   48,  0,   // 48-63</a>
<a name="ln1824">		0,   192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192, // 64-79</a>
<a name="ln1825">		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 0,   0,   16,  0,   192, // 80-95</a>
<a name="ln1826">		0,   192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192, // 96-111</a>
<a name="ln1827">		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 0, 0, 0, 0, 0,           // 112-127</a>
<a name="ln1828"> </a>
<a name="ln1829">		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192, // 128+</a>
<a name="ln1830">		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,</a>
<a name="ln1831">		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,</a>
<a name="ln1832">		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,</a>
<a name="ln1833">		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,</a>
<a name="ln1834">		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,</a>
<a name="ln1835">		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,</a>
<a name="ln1836">		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192</a>
<a name="ln1837">	};</a>
<a name="ln1838"> </a>
<a name="ln1839">	enum chartypex_t</a>
<a name="ln1840">	{</a>
<a name="ln1841">		ctx_special_pcdata = 1,   // Any symbol &gt;= 0 and &lt; 32 (except \t, \r, \n), &amp;, &lt;, &gt;</a>
<a name="ln1842">		ctx_special_attr = 2,     // Any symbol &gt;= 0 and &lt; 32 (except \t), &amp;, &lt;, &gt;, &quot;</a>
<a name="ln1843">		ctx_start_symbol = 4,	  // Any symbol &gt; 127, a-z, A-Z, _</a>
<a name="ln1844">		ctx_digit = 8,			  // 0-9</a>
<a name="ln1845">		ctx_symbol = 16			  // Any symbol &gt; 127, a-z, A-Z, 0-9, _, -, .</a>
<a name="ln1846">	};</a>
<a name="ln1847"> </a>
<a name="ln1848">	static const unsigned char chartypex_table[256] =</a>
<a name="ln1849">	{</a>
<a name="ln1850">		3,  3,  3,  3,  3,  3,  3,  3,     3,  0,  2,  3,  3,  2,  3,  3,     // 0-15</a>
<a name="ln1851">		3,  3,  3,  3,  3,  3,  3,  3,     3,  3,  3,  3,  3,  3,  3,  3,     // 16-31</a>
<a name="ln1852">		0,  0,  2,  0,  0,  0,  3,  0,     0,  0,  0,  0,  0, 16, 16,  0,     // 32-47</a>
<a name="ln1853">		24, 24, 24, 24, 24, 24, 24, 24,    24, 24, 0,  0,  3,  0,  3,  0,     // 48-63</a>
<a name="ln1854"> </a>
<a name="ln1855">		0,  20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,    // 64-79</a>
<a name="ln1856">		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 0,  0,  0,  0,  20,    // 80-95</a>
<a name="ln1857">		0,  20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,    // 96-111</a>
<a name="ln1858">		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 0,  0,  0,  0,  0,     // 112-127</a>
<a name="ln1859"> </a>
<a name="ln1860">		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,    // 128+</a>
<a name="ln1861">		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,</a>
<a name="ln1862">		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,</a>
<a name="ln1863">		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,</a>
<a name="ln1864">		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,</a>
<a name="ln1865">		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,</a>
<a name="ln1866">		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,</a>
<a name="ln1867">		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20</a>
<a name="ln1868">	};</a>
<a name="ln1869"> </a>
<a name="ln1870">#ifdef PUGIXML_WCHAR_MODE</a>
<a name="ln1871">	#define PUGI__IS_CHARTYPE_IMPL(c, ct, table) ((static_cast&lt;unsigned int&gt;(c) &lt; 128 ? table[static_cast&lt;unsigned int&gt;(c)] : table[128]) &amp; (ct))</a>
<a name="ln1872">#else</a>
<a name="ln1873">	#define PUGI__IS_CHARTYPE_IMPL(c, ct, table) (table[static_cast&lt;unsigned char&gt;(c)] &amp; (ct))</a>
<a name="ln1874">#endif</a>
<a name="ln1875"> </a>
<a name="ln1876">	#define PUGI__IS_CHARTYPE(c, ct) PUGI__IS_CHARTYPE_IMPL(c, ct, chartype_table)</a>
<a name="ln1877">	#define PUGI__IS_CHARTYPEX(c, ct) PUGI__IS_CHARTYPE_IMPL(c, ct, chartypex_table)</a>
<a name="ln1878"> </a>
<a name="ln1879">	PUGI__FN bool is_little_endian()</a>
<a name="ln1880">	{</a>
<a name="ln1881">		unsigned int ui = 1;</a>
<a name="ln1882"> </a>
<a name="ln1883">		return *reinterpret_cast&lt;unsigned char*&gt;(&amp;ui) == 1;</a>
<a name="ln1884">	}</a>
<a name="ln1885"> </a>
<a name="ln1886">	PUGI__FN xml_encoding get_wchar_encoding()</a>
<a name="ln1887">	{</a>
<a name="ln1888">		PUGI__STATIC_ASSERT(sizeof(wchar_t) == 2 || sizeof(wchar_t) == 4);</a>
<a name="ln1889"> </a>
<a name="ln1890">		if (sizeof(wchar_t) == 2)</a>
<a name="ln1891">			return is_little_endian() ? encoding_utf16_le : encoding_utf16_be;</a>
<a name="ln1892">		else</a>
<a name="ln1893">			return is_little_endian() ? encoding_utf32_le : encoding_utf32_be;</a>
<a name="ln1894">	}</a>
<a name="ln1895"> </a>
<a name="ln1896">	PUGI__FN bool parse_declaration_encoding(const uint8_t* data, size_t size, const uint8_t*&amp; out_encoding, size_t&amp; out_length)</a>
<a name="ln1897">	{</a>
<a name="ln1898">	#define PUGI__SCANCHAR(ch) { if (offset &gt;= size || data[offset] != ch) return false; offset++; }</a>
<a name="ln1899">	#define PUGI__SCANCHARTYPE(ct) { while (offset &lt; size &amp;&amp; PUGI__IS_CHARTYPE(data[offset], ct)) offset++; }</a>
<a name="ln1900"> </a>
<a name="ln1901">		// check if we have a non-empty XML declaration</a>
<a name="ln1902">		if (size &lt; 6 || !((data[0] == '&lt;') &amp; (data[1] == '?') &amp; (data[2] == 'x') &amp; (data[3] == 'm') &amp; (data[4] == 'l') &amp;&amp; PUGI__IS_CHARTYPE(data[5], ct_space)))</a>
<a name="ln1903">			return false;</a>
<a name="ln1904"> </a>
<a name="ln1905">		// scan XML declaration until the encoding field</a>
<a name="ln1906">		for (size_t i = 6; i + 1 &lt; size; ++i)</a>
<a name="ln1907">		{</a>
<a name="ln1908">			// declaration can not contain ? in quoted values</a>
<a name="ln1909">			if (data[i] == '?')</a>
<a name="ln1910">				return false;</a>
<a name="ln1911"> </a>
<a name="ln1912">			if (data[i] == 'e' &amp;&amp; data[i + 1] == 'n')</a>
<a name="ln1913">			{</a>
<a name="ln1914">				size_t offset = i;</a>
<a name="ln1915"> </a>
<a name="ln1916">				// encoding follows the version field which can't contain 'en' so this has to be the encoding if XML is well formed</a>
<a name="ln1917">				PUGI__SCANCHAR('e'); PUGI__SCANCHAR('n'); PUGI__SCANCHAR('c'); PUGI__SCANCHAR('o');</a>
<a name="ln1918">				PUGI__SCANCHAR('d'); PUGI__SCANCHAR('i'); PUGI__SCANCHAR('n'); PUGI__SCANCHAR('g');</a>
<a name="ln1919"> </a>
<a name="ln1920">				// S? = S?</a>
<a name="ln1921">				PUGI__SCANCHARTYPE(ct_space);</a>
<a name="ln1922">				PUGI__SCANCHAR('=');</a>
<a name="ln1923">				PUGI__SCANCHARTYPE(ct_space);</a>
<a name="ln1924"> </a>
<a name="ln1925">				// the only two valid delimiters are ' and &quot;</a>
<a name="ln1926">				uint8_t delimiter = (offset &lt; size &amp;&amp; data[offset] == '&quot;') ? '&quot;' : '\'';</a>
<a name="ln1927"> </a>
<a name="ln1928">				PUGI__SCANCHAR(delimiter);</a>
<a name="ln1929"> </a>
<a name="ln1930">				size_t start = offset;</a>
<a name="ln1931"> </a>
<a name="ln1932">				out_encoding = data + offset;</a>
<a name="ln1933"> </a>
<a name="ln1934">				PUGI__SCANCHARTYPE(ct_symbol);</a>
<a name="ln1935"> </a>
<a name="ln1936">				out_length = offset - start;</a>
<a name="ln1937"> </a>
<a name="ln1938">				PUGI__SCANCHAR(delimiter);</a>
<a name="ln1939"> </a>
<a name="ln1940">				return true;</a>
<a name="ln1941">			}</a>
<a name="ln1942">		}</a>
<a name="ln1943"> </a>
<a name="ln1944">		return false;</a>
<a name="ln1945"> </a>
<a name="ln1946">	#undef PUGI__SCANCHAR</a>
<a name="ln1947">	#undef PUGI__SCANCHARTYPE</a>
<a name="ln1948">	}</a>
<a name="ln1949"> </a>
<a name="ln1950">	PUGI__FN xml_encoding guess_buffer_encoding(const uint8_t* data, size_t size)</a>
<a name="ln1951">	{</a>
<a name="ln1952">		// skip encoding autodetection if input buffer is too small</a>
<a name="ln1953">		if (size &lt; 4) return encoding_utf8;</a>
<a name="ln1954"> </a>
<a name="ln1955">		uint8_t d0 = data[0], d1 = data[1], d2 = data[2], d3 = data[3];</a>
<a name="ln1956"> </a>
<a name="ln1957">		// look for BOM in first few bytes</a>
<a name="ln1958">		if (d0 == 0 &amp;&amp; d1 == 0 &amp;&amp; d2 == 0xfe &amp;&amp; d3 == 0xff) return encoding_utf32_be;</a>
<a name="ln1959">		if (d0 == 0xff &amp;&amp; d1 == 0xfe &amp;&amp; d2 == 0 &amp;&amp; d3 == 0) return encoding_utf32_le;</a>
<a name="ln1960">		if (d0 == 0xfe &amp;&amp; d1 == 0xff) return encoding_utf16_be;</a>
<a name="ln1961">		if (d0 == 0xff &amp;&amp; d1 == 0xfe) return encoding_utf16_le;</a>
<a name="ln1962">		if (d0 == 0xef &amp;&amp; d1 == 0xbb &amp;&amp; d2 == 0xbf) return encoding_utf8;</a>
<a name="ln1963"> </a>
<a name="ln1964">		// look for &lt;, &lt;? or &lt;?xm in various encodings</a>
<a name="ln1965">		if (d0 == 0 &amp;&amp; d1 == 0 &amp;&amp; d2 == 0 &amp;&amp; d3 == 0x3c) return encoding_utf32_be;</a>
<a name="ln1966">		if (d0 == 0x3c &amp;&amp; d1 == 0 &amp;&amp; d2 == 0 &amp;&amp; d3 == 0) return encoding_utf32_le;</a>
<a name="ln1967">		if (d0 == 0 &amp;&amp; d1 == 0x3c &amp;&amp; d2 == 0 &amp;&amp; d3 == 0x3f) return encoding_utf16_be;</a>
<a name="ln1968">		if (d0 == 0x3c &amp;&amp; d1 == 0 &amp;&amp; d2 == 0x3f &amp;&amp; d3 == 0) return encoding_utf16_le;</a>
<a name="ln1969"> </a>
<a name="ln1970">		// look for utf16 &lt; followed by node name (this may fail, but is better than utf8 since it's zero terminated so early)</a>
<a name="ln1971">		if (d0 == 0 &amp;&amp; d1 == 0x3c) return encoding_utf16_be;</a>
<a name="ln1972">		if (d0 == 0x3c &amp;&amp; d1 == 0) return encoding_utf16_le;</a>
<a name="ln1973"> </a>
<a name="ln1974">		// no known BOM detected; parse declaration</a>
<a name="ln1975">		const uint8_t* enc = 0;</a>
<a name="ln1976">		size_t enc_length = 0;</a>
<a name="ln1977"> </a>
<a name="ln1978">		if (d0 == 0x3c &amp;&amp; d1 == 0x3f &amp;&amp; d2 == 0x78 &amp;&amp; d3 == 0x6d &amp;&amp; parse_declaration_encoding(data, size, enc, enc_length))</a>
<a name="ln1979">		{</a>
<a name="ln1980">			// iso-8859-1 (case-insensitive)</a>
<a name="ln1981">			if (enc_length == 10</a>
<a name="ln1982">				&amp;&amp; (enc[0] | ' ') == 'i' &amp;&amp; (enc[1] | ' ') == 's' &amp;&amp; (enc[2] | ' ') == 'o'</a>
<a name="ln1983">				&amp;&amp; enc[3] == '-' &amp;&amp; enc[4] == '8' &amp;&amp; enc[5] == '8' &amp;&amp; enc[6] == '5' &amp;&amp; enc[7] == '9'</a>
<a name="ln1984">				&amp;&amp; enc[8] == '-' &amp;&amp; enc[9] == '1')</a>
<a name="ln1985">				return encoding_latin1;</a>
<a name="ln1986"> </a>
<a name="ln1987">			// latin1 (case-insensitive)</a>
<a name="ln1988">			if (enc_length == 6</a>
<a name="ln1989">				&amp;&amp; (enc[0] | ' ') == 'l' &amp;&amp; (enc[1] | ' ') == 'a' &amp;&amp; (enc[2] | ' ') == 't'</a>
<a name="ln1990">				&amp;&amp; (enc[3] | ' ') == 'i' &amp;&amp; (enc[4] | ' ') == 'n'</a>
<a name="ln1991">				&amp;&amp; enc[5] == '1')</a>
<a name="ln1992">				return encoding_latin1;</a>
<a name="ln1993">		}</a>
<a name="ln1994"> </a>
<a name="ln1995">		return encoding_utf8;</a>
<a name="ln1996">	}</a>
<a name="ln1997"> </a>
<a name="ln1998">	PUGI__FN xml_encoding get_buffer_encoding(xml_encoding encoding, const void* contents, size_t size)</a>
<a name="ln1999">	{</a>
<a name="ln2000">		// replace wchar encoding with utf implementation</a>
<a name="ln2001">		if (encoding == encoding_wchar) return get_wchar_encoding();</a>
<a name="ln2002"> </a>
<a name="ln2003">		// replace utf16 encoding with utf16 with specific endianness</a>
<a name="ln2004">		if (encoding == encoding_utf16) return is_little_endian() ? encoding_utf16_le : encoding_utf16_be;</a>
<a name="ln2005"> </a>
<a name="ln2006">		// replace utf32 encoding with utf32 with specific endianness</a>
<a name="ln2007">		if (encoding == encoding_utf32) return is_little_endian() ? encoding_utf32_le : encoding_utf32_be;</a>
<a name="ln2008"> </a>
<a name="ln2009">		// only do autodetection if no explicit encoding is requested</a>
<a name="ln2010">		if (encoding != encoding_auto) return encoding;</a>
<a name="ln2011"> </a>
<a name="ln2012">		// try to guess encoding (based on XML specification, Appendix F.1)</a>
<a name="ln2013">		const uint8_t* data = static_cast&lt;const uint8_t*&gt;(contents);</a>
<a name="ln2014"> </a>
<a name="ln2015">		return guess_buffer_encoding(data, size);</a>
<a name="ln2016">	}</a>
<a name="ln2017"> </a>
<a name="ln2018">	PUGI__FN bool get_mutable_buffer(char_t*&amp; out_buffer, size_t&amp; out_length, const void* contents, size_t size, bool is_mutable)</a>
<a name="ln2019">	{</a>
<a name="ln2020">		size_t length = size / sizeof(char_t);</a>
<a name="ln2021"> </a>
<a name="ln2022">		if (is_mutable)</a>
<a name="ln2023">		{</a>
<a name="ln2024">			out_buffer = static_cast&lt;char_t*&gt;(const_cast&lt;void*&gt;(contents));</a>
<a name="ln2025">			out_length = length;</a>
<a name="ln2026">		}</a>
<a name="ln2027">		else</a>
<a name="ln2028">		{</a>
<a name="ln2029">			char_t* buffer = static_cast&lt;char_t*&gt;(xml_memory::allocate((length + 1) * sizeof(char_t)));</a>
<a name="ln2030">			if (!buffer) return false;</a>
<a name="ln2031"> </a>
<a name="ln2032">			if (contents)</a>
<a name="ln2033">				memcpy(buffer, contents, length * sizeof(char_t));</a>
<a name="ln2034">			else</a>
<a name="ln2035">				assert(length == 0);</a>
<a name="ln2036"> </a>
<a name="ln2037">			buffer[length] = 0;</a>
<a name="ln2038"> </a>
<a name="ln2039">			out_buffer = buffer;</a>
<a name="ln2040">			out_length = length + 1;</a>
<a name="ln2041">		}</a>
<a name="ln2042"> </a>
<a name="ln2043">		return true;</a>
<a name="ln2044">	}</a>
<a name="ln2045"> </a>
<a name="ln2046">#ifdef PUGIXML_WCHAR_MODE</a>
<a name="ln2047">	PUGI__FN bool need_endian_swap_utf(xml_encoding le, xml_encoding re)</a>
<a name="ln2048">	{</a>
<a name="ln2049">		return (le == encoding_utf16_be &amp;&amp; re == encoding_utf16_le) || (le == encoding_utf16_le &amp;&amp; re == encoding_utf16_be) ||</a>
<a name="ln2050">			   (le == encoding_utf32_be &amp;&amp; re == encoding_utf32_le) || (le == encoding_utf32_le &amp;&amp; re == encoding_utf32_be);</a>
<a name="ln2051">	}</a>
<a name="ln2052"> </a>
<a name="ln2053">	PUGI__FN bool convert_buffer_endian_swap(char_t*&amp; out_buffer, size_t&amp; out_length, const void* contents, size_t size, bool is_mutable)</a>
<a name="ln2054">	{</a>
<a name="ln2055">		const char_t* data = static_cast&lt;const char_t*&gt;(contents);</a>
<a name="ln2056">		size_t length = size / sizeof(char_t);</a>
<a name="ln2057"> </a>
<a name="ln2058">		if (is_mutable)</a>
<a name="ln2059">		{</a>
<a name="ln2060">			char_t* buffer = const_cast&lt;char_t*&gt;(data);</a>
<a name="ln2061"> </a>
<a name="ln2062">			convert_wchar_endian_swap(buffer, data, length);</a>
<a name="ln2063"> </a>
<a name="ln2064">			out_buffer = buffer;</a>
<a name="ln2065">			out_length = length;</a>
<a name="ln2066">		}</a>
<a name="ln2067">		else</a>
<a name="ln2068">		{</a>
<a name="ln2069">			char_t* buffer = static_cast&lt;char_t*&gt;(xml_memory::allocate((length + 1) * sizeof(char_t)));</a>
<a name="ln2070">			if (!buffer) return false;</a>
<a name="ln2071"> </a>
<a name="ln2072">			convert_wchar_endian_swap(buffer, data, length);</a>
<a name="ln2073">			buffer[length] = 0;</a>
<a name="ln2074"> </a>
<a name="ln2075">			out_buffer = buffer;</a>
<a name="ln2076">			out_length = length + 1;</a>
<a name="ln2077">		}</a>
<a name="ln2078"> </a>
<a name="ln2079">		return true;</a>
<a name="ln2080">	}</a>
<a name="ln2081"> </a>
<a name="ln2082">	template &lt;typename D&gt; PUGI__FN bool convert_buffer_generic(char_t*&amp; out_buffer, size_t&amp; out_length, const void* contents, size_t size, D)</a>
<a name="ln2083">	{</a>
<a name="ln2084">		const typename D::type* data = static_cast&lt;const typename D::type*&gt;(contents);</a>
<a name="ln2085">		size_t data_length = size / sizeof(typename D::type);</a>
<a name="ln2086"> </a>
<a name="ln2087">		// first pass: get length in wchar_t units</a>
<a name="ln2088">		size_t length = D::process(data, data_length, 0, wchar_counter());</a>
<a name="ln2089"> </a>
<a name="ln2090">		// allocate buffer of suitable length</a>
<a name="ln2091">		char_t* buffer = static_cast&lt;char_t*&gt;(xml_memory::allocate((length + 1) * sizeof(char_t)));</a>
<a name="ln2092">		if (!buffer) return false;</a>
<a name="ln2093"> </a>
<a name="ln2094">		// second pass: convert utf16 input to wchar_t</a>
<a name="ln2095">		wchar_writer::value_type obegin = reinterpret_cast&lt;wchar_writer::value_type&gt;(buffer);</a>
<a name="ln2096">		wchar_writer::value_type oend = D::process(data, data_length, obegin, wchar_writer());</a>
<a name="ln2097"> </a>
<a name="ln2098">		assert(oend == obegin + length);</a>
<a name="ln2099">		*oend = 0;</a>
<a name="ln2100"> </a>
<a name="ln2101">		out_buffer = buffer;</a>
<a name="ln2102">		out_length = length + 1;</a>
<a name="ln2103"> </a>
<a name="ln2104">		return true;</a>
<a name="ln2105">	}</a>
<a name="ln2106"> </a>
<a name="ln2107">	PUGI__FN bool convert_buffer(char_t*&amp; out_buffer, size_t&amp; out_length, xml_encoding encoding, const void* contents, size_t size, bool is_mutable)</a>
<a name="ln2108">	{</a>
<a name="ln2109">		// get native encoding</a>
<a name="ln2110">		xml_encoding wchar_encoding = get_wchar_encoding();</a>
<a name="ln2111"> </a>
<a name="ln2112">		// fast path: no conversion required</a>
<a name="ln2113">		if (encoding == wchar_encoding)</a>
<a name="ln2114">			return get_mutable_buffer(out_buffer, out_length, contents, size, is_mutable);</a>
<a name="ln2115"> </a>
<a name="ln2116">		// only endian-swapping is required</a>
<a name="ln2117">		if (need_endian_swap_utf(encoding, wchar_encoding))</a>
<a name="ln2118">			return convert_buffer_endian_swap(out_buffer, out_length, contents, size, is_mutable);</a>
<a name="ln2119"> </a>
<a name="ln2120">		// source encoding is utf8</a>
<a name="ln2121">		if (encoding == encoding_utf8)</a>
<a name="ln2122">			return convert_buffer_generic(out_buffer, out_length, contents, size, utf8_decoder());</a>
<a name="ln2123"> </a>
<a name="ln2124">		// source encoding is utf16</a>
<a name="ln2125">		if (encoding == encoding_utf16_be || encoding == encoding_utf16_le)</a>
<a name="ln2126">		{</a>
<a name="ln2127">			xml_encoding native_encoding = is_little_endian() ? encoding_utf16_le : encoding_utf16_be;</a>
<a name="ln2128"> </a>
<a name="ln2129">			return (native_encoding == encoding) ?</a>
<a name="ln2130">				convert_buffer_generic(out_buffer, out_length, contents, size, utf16_decoder&lt;opt_false&gt;()) :</a>
<a name="ln2131">				convert_buffer_generic(out_buffer, out_length, contents, size, utf16_decoder&lt;opt_true&gt;());</a>
<a name="ln2132">		}</a>
<a name="ln2133"> </a>
<a name="ln2134">		// source encoding is utf32</a>
<a name="ln2135">		if (encoding == encoding_utf32_be || encoding == encoding_utf32_le)</a>
<a name="ln2136">		{</a>
<a name="ln2137">			xml_encoding native_encoding = is_little_endian() ? encoding_utf32_le : encoding_utf32_be;</a>
<a name="ln2138"> </a>
<a name="ln2139">			return (native_encoding == encoding) ?</a>
<a name="ln2140">				convert_buffer_generic(out_buffer, out_length, contents, size, utf32_decoder&lt;opt_false&gt;()) :</a>
<a name="ln2141">				convert_buffer_generic(out_buffer, out_length, contents, size, utf32_decoder&lt;opt_true&gt;());</a>
<a name="ln2142">		}</a>
<a name="ln2143"> </a>
<a name="ln2144">		// source encoding is latin1</a>
<a name="ln2145">		if (encoding == encoding_latin1)</a>
<a name="ln2146">			return convert_buffer_generic(out_buffer, out_length, contents, size, latin1_decoder());</a>
<a name="ln2147"> </a>
<a name="ln2148">		assert(false &amp;&amp; &quot;Invalid encoding&quot;);</a>
<a name="ln2149">		return false;</a>
<a name="ln2150">	}</a>
<a name="ln2151">#else</a>
<a name="ln2152">	template &lt;typename D&gt; PUGI__FN bool convert_buffer_generic(char_t*&amp; out_buffer, size_t&amp; out_length, const void* contents, size_t size, D)</a>
<a name="ln2153">	{</a>
<a name="ln2154">		const typename D::type* data = static_cast&lt;const typename D::type*&gt;(contents);</a>
<a name="ln2155">		size_t data_length = size / sizeof(typename D::type);</a>
<a name="ln2156"> </a>
<a name="ln2157">		// first pass: get length in utf8 units</a>
<a name="ln2158">		size_t length = D::process(data, data_length, 0, utf8_counter());</a>
<a name="ln2159"> </a>
<a name="ln2160">		// allocate buffer of suitable length</a>
<a name="ln2161">		char_t* buffer = static_cast&lt;char_t*&gt;(xml_memory::allocate((length + 1) * sizeof(char_t)));</a>
<a name="ln2162">		if (!buffer) return false;</a>
<a name="ln2163"> </a>
<a name="ln2164">		// second pass: convert utf16 input to utf8</a>
<a name="ln2165">		uint8_t* obegin = reinterpret_cast&lt;uint8_t*&gt;(buffer);</a>
<a name="ln2166">		uint8_t* oend = D::process(data, data_length, obegin, utf8_writer());</a>
<a name="ln2167"> </a>
<a name="ln2168">		assert(oend == obegin + length);</a>
<a name="ln2169">		*oend = 0;</a>
<a name="ln2170"> </a>
<a name="ln2171">		out_buffer = buffer;</a>
<a name="ln2172">		out_length = length + 1;</a>
<a name="ln2173"> </a>
<a name="ln2174">		return true;</a>
<a name="ln2175">	}</a>
<a name="ln2176"> </a>
<a name="ln2177">	PUGI__FN size_t get_latin1_7bit_prefix_length(const uint8_t* data, size_t size)</a>
<a name="ln2178">	{</a>
<a name="ln2179">		for (size_t i = 0; i &lt; size; ++i)</a>
<a name="ln2180">			if (data[i] &gt; 127)</a>
<a name="ln2181">				return i;</a>
<a name="ln2182"> </a>
<a name="ln2183">		return size;</a>
<a name="ln2184">	}</a>
<a name="ln2185"> </a>
<a name="ln2186">	PUGI__FN bool convert_buffer_latin1(char_t*&amp; out_buffer, size_t&amp; out_length, const void* contents, size_t size, bool is_mutable)</a>
<a name="ln2187">	{</a>
<a name="ln2188">		const uint8_t* data = static_cast&lt;const uint8_t*&gt;(contents);</a>
<a name="ln2189">		size_t data_length = size;</a>
<a name="ln2190"> </a>
<a name="ln2191">		// get size of prefix that does not need utf8 conversion</a>
<a name="ln2192">		size_t prefix_length = get_latin1_7bit_prefix_length(data, data_length);</a>
<a name="ln2193">		assert(prefix_length &lt;= data_length);</a>
<a name="ln2194"> </a>
<a name="ln2195">		const uint8_t* postfix = data + prefix_length;</a>
<a name="ln2196">		size_t postfix_length = data_length - prefix_length;</a>
<a name="ln2197"> </a>
<a name="ln2198">		// if no conversion is needed, just return the original buffer</a>
<a name="ln2199">		if (postfix_length == 0) return get_mutable_buffer(out_buffer, out_length, contents, size, is_mutable);</a>
<a name="ln2200"> </a>
<a name="ln2201">		// first pass: get length in utf8 units</a>
<a name="ln2202">		size_t length = prefix_length + latin1_decoder::process(postfix, postfix_length, 0, utf8_counter());</a>
<a name="ln2203"> </a>
<a name="ln2204">		// allocate buffer of suitable length</a>
<a name="ln2205">		char_t* buffer = static_cast&lt;char_t*&gt;(xml_memory::allocate((length + 1) * sizeof(char_t)));</a>
<a name="ln2206">		if (!buffer) return false;</a>
<a name="ln2207"> </a>
<a name="ln2208">		// second pass: convert latin1 input to utf8</a>
<a name="ln2209">		memcpy(buffer, data, prefix_length);</a>
<a name="ln2210"> </a>
<a name="ln2211">		uint8_t* obegin = reinterpret_cast&lt;uint8_t*&gt;(buffer);</a>
<a name="ln2212">		uint8_t* oend = latin1_decoder::process(postfix, postfix_length, obegin + prefix_length, utf8_writer());</a>
<a name="ln2213"> </a>
<a name="ln2214">		assert(oend == obegin + length);</a>
<a name="ln2215">		*oend = 0;</a>
<a name="ln2216"> </a>
<a name="ln2217">		out_buffer = buffer;</a>
<a name="ln2218">		out_length = length + 1;</a>
<a name="ln2219"> </a>
<a name="ln2220">		return true;</a>
<a name="ln2221">	}</a>
<a name="ln2222"> </a>
<a name="ln2223">	PUGI__FN bool convert_buffer(char_t*&amp; out_buffer, size_t&amp; out_length, xml_encoding encoding, const void* contents, size_t size, bool is_mutable)</a>
<a name="ln2224">	{</a>
<a name="ln2225">		// fast path: no conversion required</a>
<a name="ln2226">		if (encoding == encoding_utf8)</a>
<a name="ln2227">			return get_mutable_buffer(out_buffer, out_length, contents, size, is_mutable);</a>
<a name="ln2228"> </a>
<a name="ln2229">		// source encoding is utf16</a>
<a name="ln2230">		if (encoding == encoding_utf16_be || encoding == encoding_utf16_le)</a>
<a name="ln2231">		{</a>
<a name="ln2232">			xml_encoding native_encoding = is_little_endian() ? encoding_utf16_le : encoding_utf16_be;</a>
<a name="ln2233"> </a>
<a name="ln2234">			return (native_encoding == encoding) ?</a>
<a name="ln2235">				convert_buffer_generic(out_buffer, out_length, contents, size, utf16_decoder&lt;opt_false&gt;()) :</a>
<a name="ln2236">				convert_buffer_generic(out_buffer, out_length, contents, size, utf16_decoder&lt;opt_true&gt;());</a>
<a name="ln2237">		}</a>
<a name="ln2238"> </a>
<a name="ln2239">		// source encoding is utf32</a>
<a name="ln2240">		if (encoding == encoding_utf32_be || encoding == encoding_utf32_le)</a>
<a name="ln2241">		{</a>
<a name="ln2242">			xml_encoding native_encoding = is_little_endian() ? encoding_utf32_le : encoding_utf32_be;</a>
<a name="ln2243"> </a>
<a name="ln2244">			return (native_encoding == encoding) ?</a>
<a name="ln2245">				convert_buffer_generic(out_buffer, out_length, contents, size, utf32_decoder&lt;opt_false&gt;()) :</a>
<a name="ln2246">				convert_buffer_generic(out_buffer, out_length, contents, size, utf32_decoder&lt;opt_true&gt;());</a>
<a name="ln2247">		}</a>
<a name="ln2248"> </a>
<a name="ln2249">		// source encoding is latin1</a>
<a name="ln2250">		if (encoding == encoding_latin1)</a>
<a name="ln2251">			return convert_buffer_latin1(out_buffer, out_length, contents, size, is_mutable);</a>
<a name="ln2252"> </a>
<a name="ln2253">		assert(false &amp;&amp; &quot;Invalid encoding&quot;);</a>
<a name="ln2254">		return false;</a>
<a name="ln2255">	}</a>
<a name="ln2256">#endif</a>
<a name="ln2257"> </a>
<a name="ln2258">	PUGI__FN size_t as_utf8_begin(const wchar_t* str, size_t length)</a>
<a name="ln2259">	{</a>
<a name="ln2260">		// get length in utf8 characters</a>
<a name="ln2261">		return wchar_decoder::process(str, length, 0, utf8_counter());</a>
<a name="ln2262">	}</a>
<a name="ln2263"> </a>
<a name="ln2264">	PUGI__FN void as_utf8_end(char* buffer, size_t size, const wchar_t* str, size_t length)</a>
<a name="ln2265">	{</a>
<a name="ln2266">		// convert to utf8</a>
<a name="ln2267">		uint8_t* begin = reinterpret_cast&lt;uint8_t*&gt;(buffer);</a>
<a name="ln2268">		uint8_t* end = wchar_decoder::process(str, length, begin, utf8_writer());</a>
<a name="ln2269"> </a>
<a name="ln2270">		assert(begin + size == end);</a>
<a name="ln2271">		(void)!end;</a>
<a name="ln2272">		(void)!size;</a>
<a name="ln2273">	}</a>
<a name="ln2274"> </a>
<a name="ln2275">#ifndef PUGIXML_NO_STL</a>
<a name="ln2276">	PUGI__FN std::string as_utf8_impl(const wchar_t* str, size_t length)</a>
<a name="ln2277">	{</a>
<a name="ln2278">		// first pass: get length in utf8 characters</a>
<a name="ln2279">		size_t size = as_utf8_begin(str, length);</a>
<a name="ln2280"> </a>
<a name="ln2281">		// allocate resulting string</a>
<a name="ln2282">		std::string result;</a>
<a name="ln2283">		result.resize(size);</a>
<a name="ln2284"> </a>
<a name="ln2285">		// second pass: convert to utf8</a>
<a name="ln2286">		if (size &gt; 0) as_utf8_end(&amp;result[0], size, str, length);</a>
<a name="ln2287"> </a>
<a name="ln2288">		return result;</a>
<a name="ln2289">	}</a>
<a name="ln2290"> </a>
<a name="ln2291">	PUGI__FN std::basic_string&lt;wchar_t&gt; as_wide_impl(const char* str, size_t size)</a>
<a name="ln2292">	{</a>
<a name="ln2293">		const uint8_t* data = reinterpret_cast&lt;const uint8_t*&gt;(str);</a>
<a name="ln2294"> </a>
<a name="ln2295">		// first pass: get length in wchar_t units</a>
<a name="ln2296">		size_t length = utf8_decoder::process(data, size, 0, wchar_counter());</a>
<a name="ln2297"> </a>
<a name="ln2298">		// allocate resulting string</a>
<a name="ln2299">		std::basic_string&lt;wchar_t&gt; result;</a>
<a name="ln2300">		result.resize(length);</a>
<a name="ln2301"> </a>
<a name="ln2302">		// second pass: convert to wchar_t</a>
<a name="ln2303">		if (length &gt; 0)</a>
<a name="ln2304">		{</a>
<a name="ln2305">			wchar_writer::value_type begin = reinterpret_cast&lt;wchar_writer::value_type&gt;(&amp;result[0]);</a>
<a name="ln2306">			wchar_writer::value_type end = utf8_decoder::process(data, size, begin, wchar_writer());</a>
<a name="ln2307"> </a>
<a name="ln2308">			assert(begin + length == end);</a>
<a name="ln2309">			(void)!end;</a>
<a name="ln2310">		}</a>
<a name="ln2311"> </a>
<a name="ln2312">		return result;</a>
<a name="ln2313">	}</a>
<a name="ln2314">#endif</a>
<a name="ln2315"> </a>
<a name="ln2316">	template &lt;typename Header&gt;</a>
<a name="ln2317">	inline bool strcpy_insitu_allow(size_t length, const Header&amp; header, uintptr_t header_mask, char_t* target)</a>
<a name="ln2318">	{</a>
<a name="ln2319">		// never reuse shared memory</a>
<a name="ln2320">		if (header &amp; xml_memory_page_contents_shared_mask) return false;</a>
<a name="ln2321"> </a>
<a name="ln2322">		size_t target_length = strlength(target);</a>
<a name="ln2323"> </a>
<a name="ln2324">		// always reuse document buffer memory if possible</a>
<a name="ln2325">		if ((header &amp; header_mask) == 0) return target_length &gt;= length;</a>
<a name="ln2326"> </a>
<a name="ln2327">		// reuse heap memory if waste is not too great</a>
<a name="ln2328">		const size_t reuse_threshold = 32;</a>
<a name="ln2329"> </a>
<a name="ln2330">		return target_length &gt;= length &amp;&amp; (target_length &lt; reuse_threshold || target_length - length &lt; target_length / 2);</a>
<a name="ln2331">	}</a>
<a name="ln2332"> </a>
<a name="ln2333">	template &lt;typename String, typename Header&gt;</a>
<a name="ln2334">	PUGI__FN bool strcpy_insitu(String&amp; dest, Header&amp; header, uintptr_t header_mask, const char_t* source, size_t source_length)</a>
<a name="ln2335">	{</a>
<a name="ln2336">		if (source_length == 0)</a>
<a name="ln2337">		{</a>
<a name="ln2338">			// empty string and null pointer are equivalent, so just deallocate old memory</a>
<a name="ln2339">			xml_allocator* alloc = PUGI__GETPAGE_IMPL(header)-&gt;allocator;</a>
<a name="ln2340"> </a>
<a name="ln2341">			if (header &amp; header_mask) alloc-&gt;deallocate_string(dest);</a>
<a name="ln2342"> </a>
<a name="ln2343">			// mark the string as not allocated</a>
<a name="ln2344">			dest = 0;</a>
<a name="ln2345">			header &amp;= ~header_mask;</a>
<a name="ln2346"> </a>
<a name="ln2347">			return true;</a>
<a name="ln2348">		}</a>
<a name="ln2349">		else if (dest &amp;&amp; strcpy_insitu_allow(source_length, header, header_mask, dest))</a>
<a name="ln2350">		{</a>
<a name="ln2351">			// we can reuse old buffer, so just copy the new data (including zero terminator)</a>
<a name="ln2352">			memcpy(dest, source, source_length * sizeof(char_t));</a>
<a name="ln2353">			dest[source_length] = 0;</a>
<a name="ln2354"> </a>
<a name="ln2355">			return true;</a>
<a name="ln2356">		}</a>
<a name="ln2357">		else</a>
<a name="ln2358">		{</a>
<a name="ln2359">			xml_allocator* alloc = PUGI__GETPAGE_IMPL(header)-&gt;allocator;</a>
<a name="ln2360"> </a>
<a name="ln2361">			if (!alloc-&gt;reserve()) return false;</a>
<a name="ln2362"> </a>
<a name="ln2363">			// allocate new buffer</a>
<a name="ln2364">			char_t* buf = alloc-&gt;allocate_string(source_length + 1);</a>
<a name="ln2365">			if (!buf) return false;</a>
<a name="ln2366"> </a>
<a name="ln2367">			// copy the string (including zero terminator)</a>
<a name="ln2368">			memcpy(buf, source, source_length * sizeof(char_t));</a>
<a name="ln2369">			buf[source_length] = 0;</a>
<a name="ln2370"> </a>
<a name="ln2371">			// deallocate old buffer (*after* the above to protect against overlapping memory and/or allocation failures)</a>
<a name="ln2372">			if (header &amp; header_mask) alloc-&gt;deallocate_string(dest);</a>
<a name="ln2373"> </a>
<a name="ln2374">			// the string is now allocated, so set the flag</a>
<a name="ln2375">			dest = buf;</a>
<a name="ln2376">			header |= header_mask;</a>
<a name="ln2377"> </a>
<a name="ln2378">			return true;</a>
<a name="ln2379">		}</a>
<a name="ln2380">	}</a>
<a name="ln2381"> </a>
<a name="ln2382">	struct gap</a>
<a name="ln2383">	{</a>
<a name="ln2384">		char_t* end;</a>
<a name="ln2385">		size_t size;</a>
<a name="ln2386"> </a>
<a name="ln2387">		gap(): end(0), size(0)</a>
<a name="ln2388">		{</a>
<a name="ln2389">		}</a>
<a name="ln2390"> </a>
<a name="ln2391">		// Push new gap, move s count bytes further (skipping the gap).</a>
<a name="ln2392">		// Collapse previous gap.</a>
<a name="ln2393">		void push(char_t*&amp; s, size_t count)</a>
<a name="ln2394">		{</a>
<a name="ln2395">			if (end) // there was a gap already; collapse it</a>
<a name="ln2396">			{</a>
<a name="ln2397">				// Move [old_gap_end, new_gap_start) to [old_gap_start, ...)</a>
<a name="ln2398">				assert(s &gt;= end);</a>
<a name="ln2399">				memmove(end - size, end, reinterpret_cast&lt;char*&gt;(s) - reinterpret_cast&lt;char*&gt;(end));</a>
<a name="ln2400">			}</a>
<a name="ln2401"> </a>
<a name="ln2402">			s += count; // end of current gap</a>
<a name="ln2403"> </a>
<a name="ln2404">			// &quot;merge&quot; two gaps</a>
<a name="ln2405">			end = s;</a>
<a name="ln2406">			size += count;</a>
<a name="ln2407">		}</a>
<a name="ln2408"> </a>
<a name="ln2409">		// Collapse all gaps, return past-the-end pointer</a>
<a name="ln2410">		char_t* flush(char_t* s)</a>
<a name="ln2411">		{</a>
<a name="ln2412">			if (end)</a>
<a name="ln2413">			{</a>
<a name="ln2414">				// Move [old_gap_end, current_pos) to [old_gap_start, ...)</a>
<a name="ln2415">				assert(s &gt;= end);</a>
<a name="ln2416">				memmove(end - size, end, reinterpret_cast&lt;char*&gt;(s) - reinterpret_cast&lt;char*&gt;(end));</a>
<a name="ln2417"> </a>
<a name="ln2418">				return s - size;</a>
<a name="ln2419">			}</a>
<a name="ln2420">			else return s;</a>
<a name="ln2421">		}</a>
<a name="ln2422">	};</a>
<a name="ln2423"> </a>
<a name="ln2424">	PUGI__FN char_t* strconv_escape(char_t* s, gap&amp; g)</a>
<a name="ln2425">	{</a>
<a name="ln2426">		char_t* stre = s + 1;</a>
<a name="ln2427"> </a>
<a name="ln2428">		switch (*stre)</a>
<a name="ln2429">		{</a>
<a name="ln2430">			case '#':	// &amp;#...</a>
<a name="ln2431">			{</a>
<a name="ln2432">				unsigned int ucsc = 0;</a>
<a name="ln2433"> </a>
<a name="ln2434">				if (stre[1] == 'x') // &amp;#x... (hex code)</a>
<a name="ln2435">				{</a>
<a name="ln2436">					stre += 2;</a>
<a name="ln2437"> </a>
<a name="ln2438">					char_t ch = *stre;</a>
<a name="ln2439"> </a>
<a name="ln2440">					if (ch == ';') return stre;</a>
<a name="ln2441"> </a>
<a name="ln2442">					for (;;)</a>
<a name="ln2443">					{</a>
<a name="ln2444">						if (static_cast&lt;unsigned int&gt;(ch - '0') &lt;= 9)</a>
<a name="ln2445">							ucsc = 16 * ucsc + (ch - '0');</a>
<a name="ln2446">						else if (static_cast&lt;unsigned int&gt;((ch | ' ') - 'a') &lt;= 5)</a>
<a name="ln2447">							ucsc = 16 * ucsc + ((ch | ' ') - 'a' + 10);</a>
<a name="ln2448">						else if (ch == ';')</a>
<a name="ln2449">							break;</a>
<a name="ln2450">						else // cancel</a>
<a name="ln2451">							return stre;</a>
<a name="ln2452"> </a>
<a name="ln2453">						ch = *++stre;</a>
<a name="ln2454">					}</a>
<a name="ln2455"> </a>
<a name="ln2456">					++stre;</a>
<a name="ln2457">				}</a>
<a name="ln2458">				else	// &amp;#... (dec code)</a>
<a name="ln2459">				{</a>
<a name="ln2460">					char_t ch = *++stre;</a>
<a name="ln2461"> </a>
<a name="ln2462">					if (ch == ';') return stre;</a>
<a name="ln2463"> </a>
<a name="ln2464">					for (;;)</a>
<a name="ln2465">					{</a>
<a name="ln2466">						if (static_cast&lt;unsigned int&gt;(static_cast&lt;unsigned int&gt;(ch) - '0') &lt;= 9)</a>
<a name="ln2467">							ucsc = 10 * ucsc + (ch - '0');</a>
<a name="ln2468">						else if (ch == ';')</a>
<a name="ln2469">							break;</a>
<a name="ln2470">						else // cancel</a>
<a name="ln2471">							return stre;</a>
<a name="ln2472"> </a>
<a name="ln2473">						ch = *++stre;</a>
<a name="ln2474">					}</a>
<a name="ln2475"> </a>
<a name="ln2476">					++stre;</a>
<a name="ln2477">				}</a>
<a name="ln2478"> </a>
<a name="ln2479">			#ifdef PUGIXML_WCHAR_MODE</a>
<a name="ln2480">				s = reinterpret_cast&lt;char_t*&gt;(wchar_writer::any(reinterpret_cast&lt;wchar_writer::value_type&gt;(s), ucsc));</a>
<a name="ln2481">			#else</a>
<a name="ln2482">				s = reinterpret_cast&lt;char_t*&gt;(utf8_writer::any(reinterpret_cast&lt;uint8_t*&gt;(s), ucsc));</a>
<a name="ln2483">			#endif</a>
<a name="ln2484"> </a>
<a name="ln2485">				g.push(s, stre - s);</a>
<a name="ln2486">				return stre;</a>
<a name="ln2487">			}</a>
<a name="ln2488"> </a>
<a name="ln2489">			case 'a':	// &amp;a</a>
<a name="ln2490">			{</a>
<a name="ln2491">				++stre;</a>
<a name="ln2492"> </a>
<a name="ln2493">				if (*stre == 'm') // &amp;am</a>
<a name="ln2494">				{</a>
<a name="ln2495">					if (*++stre == 'p' &amp;&amp; *++stre == ';') // &amp;amp;</a>
<a name="ln2496">					{</a>
<a name="ln2497">						*s++ = '&amp;';</a>
<a name="ln2498">						++stre;</a>
<a name="ln2499"> </a>
<a name="ln2500">						g.push(s, stre - s);</a>
<a name="ln2501">						return stre;</a>
<a name="ln2502">					}</a>
<a name="ln2503">				}</a>
<a name="ln2504">				else if (*stre == 'p') // &amp;ap</a>
<a name="ln2505">				{</a>
<a name="ln2506">					if (*++stre == 'o' &amp;&amp; *++stre == 's' &amp;&amp; *++stre == ';') // &amp;apos;</a>
<a name="ln2507">					{</a>
<a name="ln2508">						*s++ = '\'';</a>
<a name="ln2509">						++stre;</a>
<a name="ln2510"> </a>
<a name="ln2511">						g.push(s, stre - s);</a>
<a name="ln2512">						return stre;</a>
<a name="ln2513">					}</a>
<a name="ln2514">				}</a>
<a name="ln2515">				break;</a>
<a name="ln2516">			}</a>
<a name="ln2517"> </a>
<a name="ln2518">			case 'g': // &amp;g</a>
<a name="ln2519">			{</a>
<a name="ln2520">				if (*++stre == 't' &amp;&amp; *++stre == ';') // &amp;gt;</a>
<a name="ln2521">				{</a>
<a name="ln2522">					*s++ = '&gt;';</a>
<a name="ln2523">					++stre;</a>
<a name="ln2524"> </a>
<a name="ln2525">					g.push(s, stre - s);</a>
<a name="ln2526">					return stre;</a>
<a name="ln2527">				}</a>
<a name="ln2528">				break;</a>
<a name="ln2529">			}</a>
<a name="ln2530"> </a>
<a name="ln2531">			case 'l': // &amp;l</a>
<a name="ln2532">			{</a>
<a name="ln2533">				if (*++stre == 't' &amp;&amp; *++stre == ';') // &amp;lt;</a>
<a name="ln2534">				{</a>
<a name="ln2535">					*s++ = '&lt;';</a>
<a name="ln2536">					++stre;</a>
<a name="ln2537"> </a>
<a name="ln2538">					g.push(s, stre - s);</a>
<a name="ln2539">					return stre;</a>
<a name="ln2540">				}</a>
<a name="ln2541">				break;</a>
<a name="ln2542">			}</a>
<a name="ln2543"> </a>
<a name="ln2544">			case 'q': // &amp;q</a>
<a name="ln2545">			{</a>
<a name="ln2546">				if (*++stre == 'u' &amp;&amp; *++stre == 'o' &amp;&amp; *++stre == 't' &amp;&amp; *++stre == ';') // &amp;quot;</a>
<a name="ln2547">				{</a>
<a name="ln2548">					*s++ = '&quot;';</a>
<a name="ln2549">					++stre;</a>
<a name="ln2550"> </a>
<a name="ln2551">					g.push(s, stre - s);</a>
<a name="ln2552">					return stre;</a>
<a name="ln2553">				}</a>
<a name="ln2554">				break;</a>
<a name="ln2555">			}</a>
<a name="ln2556"> </a>
<a name="ln2557">			default:</a>
<a name="ln2558">				break;</a>
<a name="ln2559">		}</a>
<a name="ln2560"> </a>
<a name="ln2561">		return stre;</a>
<a name="ln2562">	}</a>
<a name="ln2563"> </a>
<a name="ln2564">	// Parser utilities</a>
<a name="ln2565">	#define PUGI__ENDSWITH(c, e)        ((c) == (e) || ((c) == 0 &amp;&amp; endch == (e)))</a>
<a name="ln2566">	#define PUGI__SKIPWS()              { while (PUGI__IS_CHARTYPE(*s, ct_space)) ++s; }</a>
<a name="ln2567">	#define PUGI__OPTSET(OPT)           ( optmsk &amp; (OPT) )</a>
<a name="ln2568">	#define PUGI__PUSHNODE(TYPE)        { cursor = append_new_node(cursor, *alloc, TYPE); if (!cursor) PUGI__THROW_ERROR(status_out_of_memory, s); }</a>
<a name="ln2569">	#define PUGI__POPNODE()             { cursor = cursor-&gt;parent; }</a>
<a name="ln2570">	#define PUGI__SCANFOR(X)            { while (*s != 0 &amp;&amp; !(X)) ++s; }</a>
<a name="ln2571">	#define PUGI__SCANWHILE(X)          { while (X) ++s; }</a>
<a name="ln2572">	#define PUGI__SCANWHILE_UNROLL(X)   { for (;;) { char_t ss = s[0]; if (PUGI__UNLIKELY(!(X))) { break; } ss = s[1]; if (PUGI__UNLIKELY(!(X))) { s += 1; break; } ss = s[2]; if (PUGI__UNLIKELY(!(X))) { s += 2; break; } ss = s[3]; if (PUGI__UNLIKELY(!(X))) { s += 3; break; } s += 4; } }</a>
<a name="ln2573">	#define PUGI__ENDSEG()              { ch = *s; *s = 0; ++s; }</a>
<a name="ln2574">	#define PUGI__THROW_ERROR(err, m)   return error_offset = m, error_status = err, static_cast&lt;char_t*&gt;(0)</a>
<a name="ln2575">	#define PUGI__CHECK_ERROR(err, m)   { if (*s == 0) PUGI__THROW_ERROR(err, m); }</a>
<a name="ln2576"> </a>
<a name="ln2577">	PUGI__FN char_t* strconv_comment(char_t* s, char_t endch)</a>
<a name="ln2578">	{</a>
<a name="ln2579">		gap g;</a>
<a name="ln2580"> </a>
<a name="ln2581">		while (true)</a>
<a name="ln2582">		{</a>
<a name="ln2583">			PUGI__SCANWHILE_UNROLL(!PUGI__IS_CHARTYPE(ss, ct_parse_comment));</a>
<a name="ln2584"> </a>
<a name="ln2585">			if (*s == '\r') // Either a single 0x0d or 0x0d 0x0a pair</a>
<a name="ln2586">			{</a>
<a name="ln2587">				*s++ = '\n'; // replace first one with 0x0a</a>
<a name="ln2588"> </a>
<a name="ln2589">				if (*s == '\n') g.push(s, 1);</a>
<a name="ln2590">			}</a>
<a name="ln2591">			else if (s[0] == '-' &amp;&amp; s[1] == '-' &amp;&amp; PUGI__ENDSWITH(s[2], '&gt;')) // comment ends here</a>
<a name="ln2592">			{</a>
<a name="ln2593">				*g.flush(s) = 0;</a>
<a name="ln2594"> </a>
<a name="ln2595">				return s + (s[2] == '&gt;' ? 3 : 2);</a>
<a name="ln2596">			}</a>
<a name="ln2597">			else if (*s == 0)</a>
<a name="ln2598">			{</a>
<a name="ln2599">				return 0;</a>
<a name="ln2600">			}</a>
<a name="ln2601">			else ++s;</a>
<a name="ln2602">		}</a>
<a name="ln2603">	}</a>
<a name="ln2604"> </a>
<a name="ln2605">	PUGI__FN char_t* strconv_cdata(char_t* s, char_t endch)</a>
<a name="ln2606">	{</a>
<a name="ln2607">		gap g;</a>
<a name="ln2608"> </a>
<a name="ln2609">		while (true)</a>
<a name="ln2610">		{</a>
<a name="ln2611">			PUGI__SCANWHILE_UNROLL(!PUGI__IS_CHARTYPE(ss, ct_parse_cdata));</a>
<a name="ln2612"> </a>
<a name="ln2613">			if (*s == '\r') // Either a single 0x0d or 0x0d 0x0a pair</a>
<a name="ln2614">			{</a>
<a name="ln2615">				*s++ = '\n'; // replace first one with 0x0a</a>
<a name="ln2616"> </a>
<a name="ln2617">				if (*s == '\n') g.push(s, 1);</a>
<a name="ln2618">			}</a>
<a name="ln2619">			else if (s[0] == ']' &amp;&amp; s[1] == ']' &amp;&amp; PUGI__ENDSWITH(s[2], '&gt;')) // CDATA ends here</a>
<a name="ln2620">			{</a>
<a name="ln2621">				*g.flush(s) = 0;</a>
<a name="ln2622"> </a>
<a name="ln2623">				return s + 1;</a>
<a name="ln2624">			}</a>
<a name="ln2625">			else if (*s == 0)</a>
<a name="ln2626">			{</a>
<a name="ln2627">				return 0;</a>
<a name="ln2628">			}</a>
<a name="ln2629">			else ++s;</a>
<a name="ln2630">		}</a>
<a name="ln2631">	}</a>
<a name="ln2632"> </a>
<a name="ln2633">	typedef char_t* (*strconv_pcdata_t)(char_t*);</a>
<a name="ln2634"> </a>
<a name="ln2635">	template &lt;typename opt_trim, typename opt_eol, typename opt_escape&gt; struct strconv_pcdata_impl</a>
<a name="ln2636">	{</a>
<a name="ln2637">		static char_t* parse(char_t* s)</a>
<a name="ln2638">		{</a>
<a name="ln2639">			gap g;</a>
<a name="ln2640"> </a>
<a name="ln2641">			char_t* begin = s;</a>
<a name="ln2642"> </a>
<a name="ln2643">			while (true)</a>
<a name="ln2644">			{</a>
<a name="ln2645">				PUGI__SCANWHILE_UNROLL(!PUGI__IS_CHARTYPE(ss, ct_parse_pcdata));</a>
<a name="ln2646"> </a>
<a name="ln2647">				if (*s == '&lt;') // PCDATA ends here</a>
<a name="ln2648">				{</a>
<a name="ln2649">					char_t* end = g.flush(s);</a>
<a name="ln2650"> </a>
<a name="ln2651">					if (opt_trim::value)</a>
<a name="ln2652">						while (end &gt; begin &amp;&amp; PUGI__IS_CHARTYPE(end[-1], ct_space))</a>
<a name="ln2653">							--end;</a>
<a name="ln2654"> </a>
<a name="ln2655">					*end = 0;</a>
<a name="ln2656"> </a>
<a name="ln2657">					return s + 1;</a>
<a name="ln2658">				}</a>
<a name="ln2659">				else if (opt_eol::value &amp;&amp; *s == '\r') // Either a single 0x0d or 0x0d 0x0a pair</a>
<a name="ln2660">				{</a>
<a name="ln2661">					*s++ = '\n'; // replace first one with 0x0a</a>
<a name="ln2662"> </a>
<a name="ln2663">					if (*s == '\n') g.push(s, 1);</a>
<a name="ln2664">				}</a>
<a name="ln2665">				else if (opt_escape::value &amp;&amp; *s == '&amp;')</a>
<a name="ln2666">				{</a>
<a name="ln2667">					s = strconv_escape(s, g);</a>
<a name="ln2668">				}</a>
<a name="ln2669">				else if (*s == 0)</a>
<a name="ln2670">				{</a>
<a name="ln2671">					char_t* end = g.flush(s);</a>
<a name="ln2672"> </a>
<a name="ln2673">					if (opt_trim::value)</a>
<a name="ln2674">						while (end &gt; begin &amp;&amp; PUGI__IS_CHARTYPE(end[-1], ct_space))</a>
<a name="ln2675">							--end;</a>
<a name="ln2676"> </a>
<a name="ln2677">					*end = 0;</a>
<a name="ln2678"> </a>
<a name="ln2679">					return s;</a>
<a name="ln2680">				}</a>
<a name="ln2681">				else ++s;</a>
<a name="ln2682">			}</a>
<a name="ln2683">		}</a>
<a name="ln2684">	};</a>
<a name="ln2685"> </a>
<a name="ln2686">	PUGI__FN strconv_pcdata_t get_strconv_pcdata(unsigned int optmask)</a>
<a name="ln2687">	{</a>
<a name="ln2688">		PUGI__STATIC_ASSERT(parse_escapes == 0x10 &amp;&amp; parse_eol == 0x20 &amp;&amp; parse_trim_pcdata == 0x0800);</a>
<a name="ln2689"> </a>
<a name="ln2690">		switch (((optmask &gt;&gt; 4) &amp; 3) | ((optmask &gt;&gt; 9) &amp; 4)) // get bitmask for flags (eol escapes trim)</a>
<a name="ln2691">		{</a>
<a name="ln2692">		case 0: return strconv_pcdata_impl&lt;opt_false, opt_false, opt_false&gt;::parse;</a>
<a name="ln2693">		case 1: return strconv_pcdata_impl&lt;opt_false, opt_false, opt_true&gt;::parse;</a>
<a name="ln2694">		case 2: return strconv_pcdata_impl&lt;opt_false, opt_true, opt_false&gt;::parse;</a>
<a name="ln2695">		case 3: return strconv_pcdata_impl&lt;opt_false, opt_true, opt_true&gt;::parse;</a>
<a name="ln2696">		case 4: return strconv_pcdata_impl&lt;opt_true, opt_false, opt_false&gt;::parse;</a>
<a name="ln2697">		case 5: return strconv_pcdata_impl&lt;opt_true, opt_false, opt_true&gt;::parse;</a>
<a name="ln2698">		case 6: return strconv_pcdata_impl&lt;opt_true, opt_true, opt_false&gt;::parse;</a>
<a name="ln2699">		case 7: return strconv_pcdata_impl&lt;opt_true, opt_true, opt_true&gt;::parse;</a>
<a name="ln2700">		default: assert(false); return 0; // should not get here</a>
<a name="ln2701">		}</a>
<a name="ln2702">	}</a>
<a name="ln2703"> </a>
<a name="ln2704">	typedef char_t* (*strconv_attribute_t)(char_t*, char_t);</a>
<a name="ln2705"> </a>
<a name="ln2706">	template &lt;typename opt_escape&gt; struct strconv_attribute_impl</a>
<a name="ln2707">	{</a>
<a name="ln2708">		static char_t* parse_wnorm(char_t* s, char_t end_quote)</a>
<a name="ln2709">		{</a>
<a name="ln2710">			gap g;</a>
<a name="ln2711"> </a>
<a name="ln2712">			// trim leading whitespaces</a>
<a name="ln2713">			if (PUGI__IS_CHARTYPE(*s, ct_space))</a>
<a name="ln2714">			{</a>
<a name="ln2715">				char_t* str = s;</a>
<a name="ln2716"> </a>
<a name="ln2717">				do ++str;</a>
<a name="ln2718">				while (PUGI__IS_CHARTYPE(*str, ct_space));</a>
<a name="ln2719"> </a>
<a name="ln2720">				g.push(s, str - s);</a>
<a name="ln2721">			}</a>
<a name="ln2722"> </a>
<a name="ln2723">			while (true)</a>
<a name="ln2724">			{</a>
<a name="ln2725">				PUGI__SCANWHILE_UNROLL(!PUGI__IS_CHARTYPE(ss, ct_parse_attr_ws | ct_space));</a>
<a name="ln2726"> </a>
<a name="ln2727">				if (*s == end_quote)</a>
<a name="ln2728">				{</a>
<a name="ln2729">					char_t* str = g.flush(s);</a>
<a name="ln2730"> </a>
<a name="ln2731">					do *str-- = 0;</a>
<a name="ln2732">					while (PUGI__IS_CHARTYPE(*str, ct_space));</a>
<a name="ln2733"> </a>
<a name="ln2734">					return s + 1;</a>
<a name="ln2735">				}</a>
<a name="ln2736">				else if (PUGI__IS_CHARTYPE(*s, ct_space))</a>
<a name="ln2737">				{</a>
<a name="ln2738">					*s++ = ' ';</a>
<a name="ln2739"> </a>
<a name="ln2740">					if (PUGI__IS_CHARTYPE(*s, ct_space))</a>
<a name="ln2741">					{</a>
<a name="ln2742">						char_t* str = s + 1;</a>
<a name="ln2743">						while (PUGI__IS_CHARTYPE(*str, ct_space)) ++str;</a>
<a name="ln2744"> </a>
<a name="ln2745">						g.push(s, str - s);</a>
<a name="ln2746">					}</a>
<a name="ln2747">				}</a>
<a name="ln2748">				else if (opt_escape::value &amp;&amp; *s == '&amp;')</a>
<a name="ln2749">				{</a>
<a name="ln2750">					s = strconv_escape(s, g);</a>
<a name="ln2751">				}</a>
<a name="ln2752">				else if (!*s)</a>
<a name="ln2753">				{</a>
<a name="ln2754">					return 0;</a>
<a name="ln2755">				}</a>
<a name="ln2756">				else ++s;</a>
<a name="ln2757">			}</a>
<a name="ln2758">		}</a>
<a name="ln2759"> </a>
<a name="ln2760">		static char_t* parse_wconv(char_t* s, char_t end_quote)</a>
<a name="ln2761">		{</a>
<a name="ln2762">			gap g;</a>
<a name="ln2763"> </a>
<a name="ln2764">			while (true)</a>
<a name="ln2765">			{</a>
<a name="ln2766">				PUGI__SCANWHILE_UNROLL(!PUGI__IS_CHARTYPE(ss, ct_parse_attr_ws));</a>
<a name="ln2767"> </a>
<a name="ln2768">				if (*s == end_quote)</a>
<a name="ln2769">				{</a>
<a name="ln2770">					*g.flush(s) = 0;</a>
<a name="ln2771"> </a>
<a name="ln2772">					return s + 1;</a>
<a name="ln2773">				}</a>
<a name="ln2774">				else if (PUGI__IS_CHARTYPE(*s, ct_space))</a>
<a name="ln2775">				{</a>
<a name="ln2776">					if (*s == '\r')</a>
<a name="ln2777">					{</a>
<a name="ln2778">						*s++ = ' ';</a>
<a name="ln2779"> </a>
<a name="ln2780">						if (*s == '\n') g.push(s, 1);</a>
<a name="ln2781">					}</a>
<a name="ln2782">					else *s++ = ' ';</a>
<a name="ln2783">				}</a>
<a name="ln2784">				else if (opt_escape::value &amp;&amp; *s == '&amp;')</a>
<a name="ln2785">				{</a>
<a name="ln2786">					s = strconv_escape(s, g);</a>
<a name="ln2787">				}</a>
<a name="ln2788">				else if (!*s)</a>
<a name="ln2789">				{</a>
<a name="ln2790">					return 0;</a>
<a name="ln2791">				}</a>
<a name="ln2792">				else ++s;</a>
<a name="ln2793">			}</a>
<a name="ln2794">		}</a>
<a name="ln2795"> </a>
<a name="ln2796">		static char_t* parse_eol(char_t* s, char_t end_quote)</a>
<a name="ln2797">		{</a>
<a name="ln2798">			gap g;</a>
<a name="ln2799"> </a>
<a name="ln2800">			while (true)</a>
<a name="ln2801">			{</a>
<a name="ln2802">				PUGI__SCANWHILE_UNROLL(!PUGI__IS_CHARTYPE(ss, ct_parse_attr));</a>
<a name="ln2803"> </a>
<a name="ln2804">				if (*s == end_quote)</a>
<a name="ln2805">				{</a>
<a name="ln2806">					*g.flush(s) = 0;</a>
<a name="ln2807"> </a>
<a name="ln2808">					return s + 1;</a>
<a name="ln2809">				}</a>
<a name="ln2810">				else if (*s == '\r')</a>
<a name="ln2811">				{</a>
<a name="ln2812">					*s++ = '\n';</a>
<a name="ln2813"> </a>
<a name="ln2814">					if (*s == '\n') g.push(s, 1);</a>
<a name="ln2815">				}</a>
<a name="ln2816">				else if (opt_escape::value &amp;&amp; *s == '&amp;')</a>
<a name="ln2817">				{</a>
<a name="ln2818">					s = strconv_escape(s, g);</a>
<a name="ln2819">				}</a>
<a name="ln2820">				else if (!*s)</a>
<a name="ln2821">				{</a>
<a name="ln2822">					return 0;</a>
<a name="ln2823">				}</a>
<a name="ln2824">				else ++s;</a>
<a name="ln2825">			}</a>
<a name="ln2826">		}</a>
<a name="ln2827"> </a>
<a name="ln2828">		static char_t* parse_simple(char_t* s, char_t end_quote)</a>
<a name="ln2829">		{</a>
<a name="ln2830">			gap g;</a>
<a name="ln2831"> </a>
<a name="ln2832">			while (true)</a>
<a name="ln2833">			{</a>
<a name="ln2834">				PUGI__SCANWHILE_UNROLL(!PUGI__IS_CHARTYPE(ss, ct_parse_attr));</a>
<a name="ln2835"> </a>
<a name="ln2836">				if (*s == end_quote)</a>
<a name="ln2837">				{</a>
<a name="ln2838">					*g.flush(s) = 0;</a>
<a name="ln2839"> </a>
<a name="ln2840">					return s + 1;</a>
<a name="ln2841">				}</a>
<a name="ln2842">				else if (opt_escape::value &amp;&amp; *s == '&amp;')</a>
<a name="ln2843">				{</a>
<a name="ln2844">					s = strconv_escape(s, g);</a>
<a name="ln2845">				}</a>
<a name="ln2846">				else if (!*s)</a>
<a name="ln2847">				{</a>
<a name="ln2848">					return 0;</a>
<a name="ln2849">				}</a>
<a name="ln2850">				else ++s;</a>
<a name="ln2851">			}</a>
<a name="ln2852">		}</a>
<a name="ln2853">	};</a>
<a name="ln2854"> </a>
<a name="ln2855">	PUGI__FN strconv_attribute_t get_strconv_attribute(unsigned int optmask)</a>
<a name="ln2856">	{</a>
<a name="ln2857">		PUGI__STATIC_ASSERT(parse_escapes == 0x10 &amp;&amp; parse_eol == 0x20 &amp;&amp; parse_wconv_attribute == 0x40 &amp;&amp; parse_wnorm_attribute == 0x80);</a>
<a name="ln2858"> </a>
<a name="ln2859">		switch ((optmask &gt;&gt; 4) &amp; 15) // get bitmask for flags (wconv wnorm eol escapes)</a>
<a name="ln2860">		{</a>
<a name="ln2861">		case 0:  return strconv_attribute_impl&lt;opt_false&gt;::parse_simple;</a>
<a name="ln2862">		case 1:  return strconv_attribute_impl&lt;opt_true&gt;::parse_simple;</a>
<a name="ln2863">		case 2:  return strconv_attribute_impl&lt;opt_false&gt;::parse_eol;</a>
<a name="ln2864">		case 3:  return strconv_attribute_impl&lt;opt_true&gt;::parse_eol;</a>
<a name="ln2865">		case 4:  return strconv_attribute_impl&lt;opt_false&gt;::parse_wconv;</a>
<a name="ln2866">		case 5:  return strconv_attribute_impl&lt;opt_true&gt;::parse_wconv;</a>
<a name="ln2867">		case 6:  return strconv_attribute_impl&lt;opt_false&gt;::parse_wconv;</a>
<a name="ln2868">		case 7:  return strconv_attribute_impl&lt;opt_true&gt;::parse_wconv;</a>
<a name="ln2869">		case 8:  return strconv_attribute_impl&lt;opt_false&gt;::parse_wnorm;</a>
<a name="ln2870">		case 9:  return strconv_attribute_impl&lt;opt_true&gt;::parse_wnorm;</a>
<a name="ln2871">		case 10: return strconv_attribute_impl&lt;opt_false&gt;::parse_wnorm;</a>
<a name="ln2872">		case 11: return strconv_attribute_impl&lt;opt_true&gt;::parse_wnorm;</a>
<a name="ln2873">		case 12: return strconv_attribute_impl&lt;opt_false&gt;::parse_wnorm;</a>
<a name="ln2874">		case 13: return strconv_attribute_impl&lt;opt_true&gt;::parse_wnorm;</a>
<a name="ln2875">		case 14: return strconv_attribute_impl&lt;opt_false&gt;::parse_wnorm;</a>
<a name="ln2876">		case 15: return strconv_attribute_impl&lt;opt_true&gt;::parse_wnorm;</a>
<a name="ln2877">		default: assert(false); return 0; // should not get here</a>
<a name="ln2878">		}</a>
<a name="ln2879">	}</a>
<a name="ln2880"> </a>
<a name="ln2881">	inline xml_parse_result make_parse_result(xml_parse_status status, ptrdiff_t offset = 0)</a>
<a name="ln2882">	{</a>
<a name="ln2883">		xml_parse_result result;</a>
<a name="ln2884">		result.status = status;</a>
<a name="ln2885">		result.offset = offset;</a>
<a name="ln2886"> </a>
<a name="ln2887">		return result;</a>
<a name="ln2888">	}</a>
<a name="ln2889"> </a>
<a name="ln2890">	struct xml_parser</a>
<a name="ln2891">	{</a>
<a name="ln2892">		xml_allocator* alloc;</a>
<a name="ln2893">		char_t* error_offset;</a>
<a name="ln2894">		xml_parse_status error_status;</a>
<a name="ln2895"> </a>
<a name="ln2896">		xml_parser(xml_allocator* alloc_): alloc(alloc_), error_offset(0), error_status(status_ok)</a>
<a name="ln2897">		{</a>
<a name="ln2898">		}</a>
<a name="ln2899"> </a>
<a name="ln2900">		// DOCTYPE consists of nested sections of the following possible types:</a>
<a name="ln2901">		// &lt;!-- ... --&gt;, &lt;? ... ?&gt;, &quot;...&quot;, '...'</a>
<a name="ln2902">		// &lt;![...]]&gt;</a>
<a name="ln2903">		// &lt;!...&gt;</a>
<a name="ln2904">		// First group can not contain nested groups</a>
<a name="ln2905">		// Second group can contain nested groups of the same type</a>
<a name="ln2906">		// Third group can contain all other groups</a>
<a name="ln2907">		char_t* parse_doctype_primitive(char_t* s)</a>
<a name="ln2908">		{</a>
<a name="ln2909">			if (*s == '&quot;' || *s == '\'')</a>
<a name="ln2910">			{</a>
<a name="ln2911">				// quoted string</a>
<a name="ln2912">				char_t ch = *s++;</a>
<a name="ln2913">				PUGI__SCANFOR(*s == ch);</a>
<a name="ln2914">				if (!*s) PUGI__THROW_ERROR(status_bad_doctype, s);</a>
<a name="ln2915"> </a>
<a name="ln2916">				s++;</a>
<a name="ln2917">			}</a>
<a name="ln2918">			else if (s[0] == '&lt;' &amp;&amp; s[1] == '?')</a>
<a name="ln2919">			{</a>
<a name="ln2920">				// &lt;? ... ?&gt;</a>
<a name="ln2921">				s += 2;</a>
<a name="ln2922">				PUGI__SCANFOR(s[0] == '?' &amp;&amp; s[1] == '&gt;'); // no need for ENDSWITH because ?&gt; can't terminate proper doctype</a>
<a name="ln2923">				if (!*s) PUGI__THROW_ERROR(status_bad_doctype, s);</a>
<a name="ln2924"> </a>
<a name="ln2925">				s += 2;</a>
<a name="ln2926">			}</a>
<a name="ln2927">			else if (s[0] == '&lt;' &amp;&amp; s[1] == '!' &amp;&amp; s[2] == '-' &amp;&amp; s[3] == '-')</a>
<a name="ln2928">			{</a>
<a name="ln2929">				s += 4;</a>
<a name="ln2930">				PUGI__SCANFOR(s[0] == '-' &amp;&amp; s[1] == '-' &amp;&amp; s[2] == '&gt;'); // no need for ENDSWITH because --&gt; can't terminate proper doctype</a>
<a name="ln2931">				if (!*s) PUGI__THROW_ERROR(status_bad_doctype, s);</a>
<a name="ln2932"> </a>
<a name="ln2933">				s += 3;</a>
<a name="ln2934">			}</a>
<a name="ln2935">			else PUGI__THROW_ERROR(status_bad_doctype, s);</a>
<a name="ln2936"> </a>
<a name="ln2937">			return s;</a>
<a name="ln2938">		}</a>
<a name="ln2939"> </a>
<a name="ln2940">		char_t* parse_doctype_ignore(char_t* s)</a>
<a name="ln2941">		{</a>
<a name="ln2942">			size_t depth = 0;</a>
<a name="ln2943"> </a>
<a name="ln2944">			assert(s[0] == '&lt;' &amp;&amp; s[1] == '!' &amp;&amp; s[2] == '[');</a>
<a name="ln2945">			s += 3;</a>
<a name="ln2946"> </a>
<a name="ln2947">			while (*s)</a>
<a name="ln2948">			{</a>
<a name="ln2949">				if (s[0] == '&lt;' &amp;&amp; s[1] == '!' &amp;&amp; s[2] == '[')</a>
<a name="ln2950">				{</a>
<a name="ln2951">					// nested ignore section</a>
<a name="ln2952">					s += 3;</a>
<a name="ln2953">					depth++;</a>
<a name="ln2954">				}</a>
<a name="ln2955">				else if (s[0] == ']' &amp;&amp; s[1] == ']' &amp;&amp; s[2] == '&gt;')</a>
<a name="ln2956">				{</a>
<a name="ln2957">					// ignore section end</a>
<a name="ln2958">					s += 3;</a>
<a name="ln2959"> </a>
<a name="ln2960">					if (depth == 0)</a>
<a name="ln2961">						return s;</a>
<a name="ln2962"> </a>
<a name="ln2963">					depth--;</a>
<a name="ln2964">				}</a>
<a name="ln2965">				else s++;</a>
<a name="ln2966">			}</a>
<a name="ln2967"> </a>
<a name="ln2968">			PUGI__THROW_ERROR(status_bad_doctype, s);</a>
<a name="ln2969">		}</a>
<a name="ln2970"> </a>
<a name="ln2971">		char_t* parse_doctype_group(char_t* s, char_t endch)</a>
<a name="ln2972">		{</a>
<a name="ln2973">			size_t depth = 0;</a>
<a name="ln2974"> </a>
<a name="ln2975">			assert((s[0] == '&lt;' || s[0] == 0) &amp;&amp; s[1] == '!');</a>
<a name="ln2976">			s += 2;</a>
<a name="ln2977"> </a>
<a name="ln2978">			while (*s)</a>
<a name="ln2979">			{</a>
<a name="ln2980">				if (s[0] == '&lt;' &amp;&amp; s[1] == '!' &amp;&amp; s[2] != '-')</a>
<a name="ln2981">				{</a>
<a name="ln2982">					if (s[2] == '[')</a>
<a name="ln2983">					{</a>
<a name="ln2984">						// ignore</a>
<a name="ln2985">						s = parse_doctype_ignore(s);</a>
<a name="ln2986">						if (!s) return s;</a>
<a name="ln2987">					}</a>
<a name="ln2988">					else</a>
<a name="ln2989">					{</a>
<a name="ln2990">						// some control group</a>
<a name="ln2991">						s += 2;</a>
<a name="ln2992">						depth++;</a>
<a name="ln2993">					}</a>
<a name="ln2994">				}</a>
<a name="ln2995">				else if (s[0] == '&lt;' || s[0] == '&quot;' || s[0] == '\'')</a>
<a name="ln2996">				{</a>
<a name="ln2997">					// unknown tag (forbidden), or some primitive group</a>
<a name="ln2998">					s = parse_doctype_primitive(s);</a>
<a name="ln2999">					if (!s) return s;</a>
<a name="ln3000">				}</a>
<a name="ln3001">				else if (*s == '&gt;')</a>
<a name="ln3002">				{</a>
<a name="ln3003">					if (depth == 0)</a>
<a name="ln3004">						return s;</a>
<a name="ln3005"> </a>
<a name="ln3006">					depth--;</a>
<a name="ln3007">					s++;</a>
<a name="ln3008">				}</a>
<a name="ln3009">				else s++;</a>
<a name="ln3010">			}</a>
<a name="ln3011"> </a>
<a name="ln3012">			if (depth != 0 || endch != '&gt;') PUGI__THROW_ERROR(status_bad_doctype, s);</a>
<a name="ln3013"> </a>
<a name="ln3014">			return s;</a>
<a name="ln3015">		}</a>
<a name="ln3016"> </a>
<a name="ln3017">		char_t* parse_exclamation(char_t* s, xml_node_struct* cursor, unsigned int optmsk, char_t endch)</a>
<a name="ln3018">		{</a>
<a name="ln3019">			// parse node contents, starting with exclamation mark</a>
<a name="ln3020">			++s;</a>
<a name="ln3021"> </a>
<a name="ln3022">			if (*s == '-') // '&lt;!-...'</a>
<a name="ln3023">			{</a>
<a name="ln3024">				++s;</a>
<a name="ln3025"> </a>
<a name="ln3026">				if (*s == '-') // '&lt;!--...'</a>
<a name="ln3027">				{</a>
<a name="ln3028">					++s;</a>
<a name="ln3029"> </a>
<a name="ln3030">					if (PUGI__OPTSET(parse_comments))</a>
<a name="ln3031">					{</a>
<a name="ln3032">						PUGI__PUSHNODE(node_comment); // Append a new node on the tree.</a>
<a name="ln3033">						cursor-&gt;value = s; // Save the offset.</a>
<a name="ln3034">					}</a>
<a name="ln3035"> </a>
<a name="ln3036">					if (PUGI__OPTSET(parse_eol) &amp;&amp; PUGI__OPTSET(parse_comments))</a>
<a name="ln3037">					{</a>
<a name="ln3038">						s = strconv_comment(s, endch);</a>
<a name="ln3039"> </a>
<a name="ln3040">						if (!s) PUGI__THROW_ERROR(status_bad_comment, cursor-&gt;value);</a>
<a name="ln3041">					}</a>
<a name="ln3042">					else</a>
<a name="ln3043">					{</a>
<a name="ln3044">						// Scan for terminating '--&gt;'.</a>
<a name="ln3045">						PUGI__SCANFOR(s[0] == '-' &amp;&amp; s[1] == '-' &amp;&amp; PUGI__ENDSWITH(s[2], '&gt;'));</a>
<a name="ln3046">						PUGI__CHECK_ERROR(status_bad_comment, s);</a>
<a name="ln3047"> </a>
<a name="ln3048">						if (PUGI__OPTSET(parse_comments))</a>
<a name="ln3049">							*s = 0; // Zero-terminate this segment at the first terminating '-'.</a>
<a name="ln3050"> </a>
<a name="ln3051">						s += (s[2] == '&gt;' ? 3 : 2); // Step over the '\0-&gt;'.</a>
<a name="ln3052">					}</a>
<a name="ln3053">				}</a>
<a name="ln3054">				else PUGI__THROW_ERROR(status_bad_comment, s);</a>
<a name="ln3055">			}</a>
<a name="ln3056">			else if (*s == '[')</a>
<a name="ln3057">			{</a>
<a name="ln3058">				// '&lt;![CDATA[...'</a>
<a name="ln3059">				if (*++s=='C' &amp;&amp; *++s=='D' &amp;&amp; *++s=='A' &amp;&amp; *++s=='T' &amp;&amp; *++s=='A' &amp;&amp; *++s == '[')</a>
<a name="ln3060">				{</a>
<a name="ln3061">					++s;</a>
<a name="ln3062"> </a>
<a name="ln3063">					if (PUGI__OPTSET(parse_cdata))</a>
<a name="ln3064">					{</a>
<a name="ln3065">						PUGI__PUSHNODE(node_cdata); // Append a new node on the tree.</a>
<a name="ln3066">						cursor-&gt;value = s; // Save the offset.</a>
<a name="ln3067"> </a>
<a name="ln3068">						if (PUGI__OPTSET(parse_eol))</a>
<a name="ln3069">						{</a>
<a name="ln3070">							s = strconv_cdata(s, endch);</a>
<a name="ln3071"> </a>
<a name="ln3072">							if (!s) PUGI__THROW_ERROR(status_bad_cdata, cursor-&gt;value);</a>
<a name="ln3073">						}</a>
<a name="ln3074">						else</a>
<a name="ln3075">						{</a>
<a name="ln3076">							// Scan for terminating ']]&gt;'.</a>
<a name="ln3077">							PUGI__SCANFOR(s[0] == ']' &amp;&amp; s[1] == ']' &amp;&amp; PUGI__ENDSWITH(s[2], '&gt;'));</a>
<a name="ln3078">							PUGI__CHECK_ERROR(status_bad_cdata, s);</a>
<a name="ln3079"> </a>
<a name="ln3080">							*s++ = 0; // Zero-terminate this segment.</a>
<a name="ln3081">						}</a>
<a name="ln3082">					}</a>
<a name="ln3083">					else // Flagged for discard, but we still have to scan for the terminator.</a>
<a name="ln3084">					{</a>
<a name="ln3085">						// Scan for terminating ']]&gt;'.</a>
<a name="ln3086">						PUGI__SCANFOR(s[0] == ']' &amp;&amp; s[1] == ']' &amp;&amp; PUGI__ENDSWITH(s[2], '&gt;'));</a>
<a name="ln3087">						PUGI__CHECK_ERROR(status_bad_cdata, s);</a>
<a name="ln3088"> </a>
<a name="ln3089">						++s;</a>
<a name="ln3090">					}</a>
<a name="ln3091"> </a>
<a name="ln3092">					s += (s[1] == '&gt;' ? 2 : 1); // Step over the last ']&gt;'.</a>
<a name="ln3093">				}</a>
<a name="ln3094">				else PUGI__THROW_ERROR(status_bad_cdata, s);</a>
<a name="ln3095">			}</a>
<a name="ln3096">			else if (s[0] == 'D' &amp;&amp; s[1] == 'O' &amp;&amp; s[2] == 'C' &amp;&amp; s[3] == 'T' &amp;&amp; s[4] == 'Y' &amp;&amp; s[5] == 'P' &amp;&amp; PUGI__ENDSWITH(s[6], 'E'))</a>
<a name="ln3097">			{</a>
<a name="ln3098">				s -= 2;</a>
<a name="ln3099"> </a>
<a name="ln3100">				if (cursor-&gt;parent) PUGI__THROW_ERROR(status_bad_doctype, s);</a>
<a name="ln3101"> </a>
<a name="ln3102">				char_t* mark = s + 9;</a>
<a name="ln3103"> </a>
<a name="ln3104">				s = parse_doctype_group(s, endch);</a>
<a name="ln3105">				if (!s) return s;</a>
<a name="ln3106"> </a>
<a name="ln3107">				assert((*s == 0 &amp;&amp; endch == '&gt;') || *s == '&gt;');</a>
<a name="ln3108">				if (*s) *s++ = 0;</a>
<a name="ln3109"> </a>
<a name="ln3110">				if (PUGI__OPTSET(parse_doctype))</a>
<a name="ln3111">				{</a>
<a name="ln3112">					while (PUGI__IS_CHARTYPE(*mark, ct_space)) ++mark;</a>
<a name="ln3113"> </a>
<a name="ln3114">					PUGI__PUSHNODE(node_doctype);</a>
<a name="ln3115"> </a>
<a name="ln3116">					cursor-&gt;value = mark;</a>
<a name="ln3117">				}</a>
<a name="ln3118">			}</a>
<a name="ln3119">			else if (*s == 0 &amp;&amp; endch == '-') PUGI__THROW_ERROR(status_bad_comment, s);</a>
<a name="ln3120">			else if (*s == 0 &amp;&amp; endch == '[') PUGI__THROW_ERROR(status_bad_cdata, s);</a>
<a name="ln3121">			else PUGI__THROW_ERROR(status_unrecognized_tag, s);</a>
<a name="ln3122"> </a>
<a name="ln3123">			return s;</a>
<a name="ln3124">		}</a>
<a name="ln3125"> </a>
<a name="ln3126">		char_t* parse_question(char_t* s, xml_node_struct*&amp; ref_cursor, unsigned int optmsk, char_t endch)</a>
<a name="ln3127">		{</a>
<a name="ln3128">			// load into registers</a>
<a name="ln3129">			xml_node_struct* cursor = ref_cursor;</a>
<a name="ln3130">			char_t ch = 0;</a>
<a name="ln3131"> </a>
<a name="ln3132">			// parse node contents, starting with question mark</a>
<a name="ln3133">			++s;</a>
<a name="ln3134"> </a>
<a name="ln3135">			// read PI target</a>
<a name="ln3136">			char_t* target = s;</a>
<a name="ln3137"> </a>
<a name="ln3138">			if (!PUGI__IS_CHARTYPE(*s, ct_start_symbol)) PUGI__THROW_ERROR(status_bad_pi, s);</a>
<a name="ln3139"> </a>
<a name="ln3140">			PUGI__SCANWHILE(PUGI__IS_CHARTYPE(*s, ct_symbol));</a>
<a name="ln3141">			PUGI__CHECK_ERROR(status_bad_pi, s);</a>
<a name="ln3142"> </a>
<a name="ln3143">			// determine node type; stricmp / strcasecmp is not portable</a>
<a name="ln3144">			bool declaration = (target[0] | ' ') == 'x' &amp;&amp; (target[1] | ' ') == 'm' &amp;&amp; (target[2] | ' ') == 'l' &amp;&amp; target + 3 == s;</a>
<a name="ln3145"> </a>
<a name="ln3146">			if (declaration ? PUGI__OPTSET(parse_declaration) : PUGI__OPTSET(parse_pi))</a>
<a name="ln3147">			{</a>
<a name="ln3148">				if (declaration)</a>
<a name="ln3149">				{</a>
<a name="ln3150">					// disallow non top-level declarations</a>
<a name="ln3151">					if (cursor-&gt;parent) PUGI__THROW_ERROR(status_bad_pi, s);</a>
<a name="ln3152"> </a>
<a name="ln3153">					PUGI__PUSHNODE(node_declaration);</a>
<a name="ln3154">				}</a>
<a name="ln3155">				else</a>
<a name="ln3156">				{</a>
<a name="ln3157">					PUGI__PUSHNODE(node_pi);</a>
<a name="ln3158">				}</a>
<a name="ln3159"> </a>
<a name="ln3160">				cursor-&gt;name = target;</a>
<a name="ln3161"> </a>
<a name="ln3162">				PUGI__ENDSEG();</a>
<a name="ln3163"> </a>
<a name="ln3164">				// parse value/attributes</a>
<a name="ln3165">				if (ch == '?')</a>
<a name="ln3166">				{</a>
<a name="ln3167">					// empty node</a>
<a name="ln3168">					if (!PUGI__ENDSWITH(*s, '&gt;')) PUGI__THROW_ERROR(status_bad_pi, s);</a>
<a name="ln3169">					s += (*s == '&gt;');</a>
<a name="ln3170"> </a>
<a name="ln3171">					PUGI__POPNODE();</a>
<a name="ln3172">				}</a>
<a name="ln3173">				else if (PUGI__IS_CHARTYPE(ch, ct_space))</a>
<a name="ln3174">				{</a>
<a name="ln3175">					PUGI__SKIPWS();</a>
<a name="ln3176"> </a>
<a name="ln3177">					// scan for tag end</a>
<a name="ln3178">					char_t* value = s;</a>
<a name="ln3179"> </a>
<a name="ln3180">					PUGI__SCANFOR(s[0] == '?' &amp;&amp; PUGI__ENDSWITH(s[1], '&gt;'));</a>
<a name="ln3181">					PUGI__CHECK_ERROR(status_bad_pi, s);</a>
<a name="ln3182"> </a>
<a name="ln3183">					if (declaration)</a>
<a name="ln3184">					{</a>
<a name="ln3185">						// replace ending ? with / so that 'element' terminates properly</a>
<a name="ln3186">						*s = '/';</a>
<a name="ln3187"> </a>
<a name="ln3188">						// we exit from this function with cursor at node_declaration, which is a signal to parse() to go to LOC_ATTRIBUTES</a>
<a name="ln3189">						s = value;</a>
<a name="ln3190">					}</a>
<a name="ln3191">					else</a>
<a name="ln3192">					{</a>
<a name="ln3193">						// store value and step over &gt;</a>
<a name="ln3194">						cursor-&gt;value = value;</a>
<a name="ln3195"> </a>
<a name="ln3196">						PUGI__POPNODE();</a>
<a name="ln3197"> </a>
<a name="ln3198">						PUGI__ENDSEG();</a>
<a name="ln3199"> </a>
<a name="ln3200">						s += (*s == '&gt;');</a>
<a name="ln3201">					}</a>
<a name="ln3202">				}</a>
<a name="ln3203">				else PUGI__THROW_ERROR(status_bad_pi, s);</a>
<a name="ln3204">			}</a>
<a name="ln3205">			else</a>
<a name="ln3206">			{</a>
<a name="ln3207">				// scan for tag end</a>
<a name="ln3208">				PUGI__SCANFOR(s[0] == '?' &amp;&amp; PUGI__ENDSWITH(s[1], '&gt;'));</a>
<a name="ln3209">				PUGI__CHECK_ERROR(status_bad_pi, s);</a>
<a name="ln3210"> </a>
<a name="ln3211">				s += (s[1] == '&gt;' ? 2 : 1);</a>
<a name="ln3212">			}</a>
<a name="ln3213"> </a>
<a name="ln3214">			// store from registers</a>
<a name="ln3215">			ref_cursor = cursor;</a>
<a name="ln3216"> </a>
<a name="ln3217">			return s;</a>
<a name="ln3218">		}</a>
<a name="ln3219"> </a>
<a name="ln3220">		char_t* parse_tree(char_t* s, xml_node_struct* root, unsigned int optmsk, char_t endch)</a>
<a name="ln3221">		{</a>
<a name="ln3222">			strconv_attribute_t strconv_attribute = get_strconv_attribute(optmsk);</a>
<a name="ln3223">			strconv_pcdata_t strconv_pcdata = get_strconv_pcdata(optmsk);</a>
<a name="ln3224"> </a>
<a name="ln3225">			char_t ch = 0;</a>
<a name="ln3226">			xml_node_struct* cursor = root;</a>
<a name="ln3227">			char_t* mark = s;</a>
<a name="ln3228"> </a>
<a name="ln3229">			while (*s != 0)</a>
<a name="ln3230">			{</a>
<a name="ln3231">				if (*s == '&lt;')</a>
<a name="ln3232">				{</a>
<a name="ln3233">					++s;</a>
<a name="ln3234"> </a>
<a name="ln3235">				LOC_TAG:</a>
<a name="ln3236">					if (PUGI__IS_CHARTYPE(*s, ct_start_symbol)) // '&lt;#...'</a>
<a name="ln3237">					{</a>
<a name="ln3238">						PUGI__PUSHNODE(node_element); // Append a new node to the tree.</a>
<a name="ln3239"> </a>
<a name="ln3240">						cursor-&gt;name = s;</a>
<a name="ln3241"> </a>
<a name="ln3242">						PUGI__SCANWHILE_UNROLL(PUGI__IS_CHARTYPE(ss, ct_symbol)); // Scan for a terminator.</a>
<a name="ln3243">						PUGI__ENDSEG(); // Save char in 'ch', terminate &amp; step over.</a>
<a name="ln3244"> </a>
<a name="ln3245">						if (ch == '&gt;')</a>
<a name="ln3246">						{</a>
<a name="ln3247">							// end of tag</a>
<a name="ln3248">						}</a>
<a name="ln3249">						else if (PUGI__IS_CHARTYPE(ch, ct_space))</a>
<a name="ln3250">						{</a>
<a name="ln3251">						LOC_ATTRIBUTES:</a>
<a name="ln3252">							while (true)</a>
<a name="ln3253">							{</a>
<a name="ln3254">								PUGI__SKIPWS(); // Eat any whitespace.</a>
<a name="ln3255"> </a>
<a name="ln3256">								if (PUGI__IS_CHARTYPE(*s, ct_start_symbol)) // &lt;... #...</a>
<a name="ln3257">								{</a>
<a name="ln3258">									xml_attribute_struct* a = append_new_attribute(cursor, *alloc); // Make space for this attribute.</a>
<a name="ln3259">									if (!a) PUGI__THROW_ERROR(status_out_of_memory, s);</a>
<a name="ln3260"> </a>
<a name="ln3261">									a-&gt;name = s; // Save the offset.</a>
<a name="ln3262"> </a>
<a name="ln3263">									PUGI__SCANWHILE_UNROLL(PUGI__IS_CHARTYPE(ss, ct_symbol)); // Scan for a terminator.</a>
<a name="ln3264">									PUGI__ENDSEG(); // Save char in 'ch', terminate &amp; step over.</a>
<a name="ln3265"> </a>
<a name="ln3266">									if (PUGI__IS_CHARTYPE(ch, ct_space))</a>
<a name="ln3267">									{</a>
<a name="ln3268">										PUGI__SKIPWS(); // Eat any whitespace.</a>
<a name="ln3269"> </a>
<a name="ln3270">										ch = *s;</a>
<a name="ln3271">										++s;</a>
<a name="ln3272">									}</a>
<a name="ln3273"> </a>
<a name="ln3274">									if (ch == '=') // '&lt;... #=...'</a>
<a name="ln3275">									{</a>
<a name="ln3276">										PUGI__SKIPWS(); // Eat any whitespace.</a>
<a name="ln3277"> </a>
<a name="ln3278">										if (*s == '&quot;' || *s == '\'') // '&lt;... #=&quot;...'</a>
<a name="ln3279">										{</a>
<a name="ln3280">											ch = *s; // Save quote char to avoid breaking on &quot;''&quot; -or- '&quot;&quot;'.</a>
<a name="ln3281">											++s; // Step over the quote.</a>
<a name="ln3282">											a-&gt;value = s; // Save the offset.</a>
<a name="ln3283"> </a>
<a name="ln3284">											s = strconv_attribute(s, ch);</a>
<a name="ln3285"> </a>
<a name="ln3286">											if (!s) PUGI__THROW_ERROR(status_bad_attribute, a-&gt;value);</a>
<a name="ln3287"> </a>
<a name="ln3288">											// After this line the loop continues from the start;</a>
<a name="ln3289">											// Whitespaces, / and &gt; are ok, symbols and EOF are wrong,</a>
<a name="ln3290">											// everything else will be detected</a>
<a name="ln3291">											if (PUGI__IS_CHARTYPE(*s, ct_start_symbol)) PUGI__THROW_ERROR(status_bad_attribute, s);</a>
<a name="ln3292">										}</a>
<a name="ln3293">										else PUGI__THROW_ERROR(status_bad_attribute, s);</a>
<a name="ln3294">									}</a>
<a name="ln3295">									else PUGI__THROW_ERROR(status_bad_attribute, s);</a>
<a name="ln3296">								}</a>
<a name="ln3297">								else if (*s == '/')</a>
<a name="ln3298">								{</a>
<a name="ln3299">									++s;</a>
<a name="ln3300"> </a>
<a name="ln3301">									if (*s == '&gt;')</a>
<a name="ln3302">									{</a>
<a name="ln3303">										PUGI__POPNODE();</a>
<a name="ln3304">										s++;</a>
<a name="ln3305">										break;</a>
<a name="ln3306">									}</a>
<a name="ln3307">									else if (*s == 0 &amp;&amp; endch == '&gt;')</a>
<a name="ln3308">									{</a>
<a name="ln3309">										PUGI__POPNODE();</a>
<a name="ln3310">										break;</a>
<a name="ln3311">									}</a>
<a name="ln3312">									else PUGI__THROW_ERROR(status_bad_start_element, s);</a>
<a name="ln3313">								}</a>
<a name="ln3314">								else if (*s == '&gt;')</a>
<a name="ln3315">								{</a>
<a name="ln3316">									++s;</a>
<a name="ln3317"> </a>
<a name="ln3318">									break;</a>
<a name="ln3319">								}</a>
<a name="ln3320">								else if (*s == 0 &amp;&amp; endch == '&gt;')</a>
<a name="ln3321">								{</a>
<a name="ln3322">									break;</a>
<a name="ln3323">								}</a>
<a name="ln3324">								else PUGI__THROW_ERROR(status_bad_start_element, s);</a>
<a name="ln3325">							}</a>
<a name="ln3326"> </a>
<a name="ln3327">							// !!!</a>
<a name="ln3328">						}</a>
<a name="ln3329">						else if (ch == '/') // '&lt;#.../'</a>
<a name="ln3330">						{</a>
<a name="ln3331">							if (!PUGI__ENDSWITH(*s, '&gt;')) PUGI__THROW_ERROR(status_bad_start_element, s);</a>
<a name="ln3332"> </a>
<a name="ln3333">							PUGI__POPNODE(); // Pop.</a>
<a name="ln3334"> </a>
<a name="ln3335">							s += (*s == '&gt;');</a>
<a name="ln3336">						}</a>
<a name="ln3337">						else if (ch == 0)</a>
<a name="ln3338">						{</a>
<a name="ln3339">							// we stepped over null terminator, backtrack &amp; handle closing tag</a>
<a name="ln3340">							--s;</a>
<a name="ln3341"> </a>
<a name="ln3342">							if (endch != '&gt;') PUGI__THROW_ERROR(status_bad_start_element, s);</a>
<a name="ln3343">						}</a>
<a name="ln3344">						else PUGI__THROW_ERROR(status_bad_start_element, s);</a>
<a name="ln3345">					}</a>
<a name="ln3346">					else if (*s == '/')</a>
<a name="ln3347">					{</a>
<a name="ln3348">						++s;</a>
<a name="ln3349"> </a>
<a name="ln3350">						mark = s;</a>
<a name="ln3351"> </a>
<a name="ln3352">						char_t* name = cursor-&gt;name;</a>
<a name="ln3353">						if (!name) PUGI__THROW_ERROR(status_end_element_mismatch, mark);</a>
<a name="ln3354"> </a>
<a name="ln3355">						while (PUGI__IS_CHARTYPE(*s, ct_symbol))</a>
<a name="ln3356">						{</a>
<a name="ln3357">							if (*s++ != *name++) PUGI__THROW_ERROR(status_end_element_mismatch, mark);</a>
<a name="ln3358">						}</a>
<a name="ln3359"> </a>
<a name="ln3360">						if (*name)</a>
<a name="ln3361">						{</a>
<a name="ln3362">							if (*s == 0 &amp;&amp; name[0] == endch &amp;&amp; name[1] == 0) PUGI__THROW_ERROR(status_bad_end_element, s);</a>
<a name="ln3363">							else PUGI__THROW_ERROR(status_end_element_mismatch, mark);</a>
<a name="ln3364">						}</a>
<a name="ln3365"> </a>
<a name="ln3366">						PUGI__POPNODE(); // Pop.</a>
<a name="ln3367"> </a>
<a name="ln3368">						PUGI__SKIPWS();</a>
<a name="ln3369"> </a>
<a name="ln3370">						if (*s == 0)</a>
<a name="ln3371">						{</a>
<a name="ln3372">							if (endch != '&gt;') PUGI__THROW_ERROR(status_bad_end_element, s);</a>
<a name="ln3373">						}</a>
<a name="ln3374">						else</a>
<a name="ln3375">						{</a>
<a name="ln3376">							if (*s != '&gt;') PUGI__THROW_ERROR(status_bad_end_element, s);</a>
<a name="ln3377">							++s;</a>
<a name="ln3378">						}</a>
<a name="ln3379">					}</a>
<a name="ln3380">					else if (*s == '?') // '&lt;?...'</a>
<a name="ln3381">					{</a>
<a name="ln3382">						s = parse_question(s, cursor, optmsk, endch);</a>
<a name="ln3383">						if (!s) return s;</a>
<a name="ln3384"> </a>
<a name="ln3385">						assert(cursor);</a>
<a name="ln3386">						if (PUGI__NODETYPE(cursor) == node_declaration) goto LOC_ATTRIBUTES;</a>
<a name="ln3387">					}</a>
<a name="ln3388">					else if (*s == '!') // '&lt;!...'</a>
<a name="ln3389">					{</a>
<a name="ln3390">						s = parse_exclamation(s, cursor, optmsk, endch);</a>
<a name="ln3391">						if (!s) return s;</a>
<a name="ln3392">					}</a>
<a name="ln3393">					else if (*s == 0 &amp;&amp; endch == '?') PUGI__THROW_ERROR(status_bad_pi, s);</a>
<a name="ln3394">					else PUGI__THROW_ERROR(status_unrecognized_tag, s);</a>
<a name="ln3395">				}</a>
<a name="ln3396">				else</a>
<a name="ln3397">				{</a>
<a name="ln3398">					mark = s; // Save this offset while searching for a terminator.</a>
<a name="ln3399"> </a>
<a name="ln3400">					PUGI__SKIPWS(); // Eat whitespace if no genuine PCDATA here.</a>
<a name="ln3401"> </a>
<a name="ln3402">					if (*s == '&lt;' || !*s)</a>
<a name="ln3403">					{</a>
<a name="ln3404">						// We skipped some whitespace characters because otherwise we would take the tag branch instead of PCDATA one</a>
<a name="ln3405">						assert(mark != s);</a>
<a name="ln3406"> </a>
<a name="ln3407">						if (!PUGI__OPTSET(parse_ws_pcdata | parse_ws_pcdata_single) || PUGI__OPTSET(parse_trim_pcdata))</a>
<a name="ln3408">						{</a>
<a name="ln3409">							continue;</a>
<a name="ln3410">						}</a>
<a name="ln3411">						else if (PUGI__OPTSET(parse_ws_pcdata_single))</a>
<a name="ln3412">						{</a>
<a name="ln3413">							if (s[0] != '&lt;' || s[1] != '/' || cursor-&gt;first_child) continue;</a>
<a name="ln3414">						}</a>
<a name="ln3415">					}</a>
<a name="ln3416"> </a>
<a name="ln3417">					if (!PUGI__OPTSET(parse_trim_pcdata))</a>
<a name="ln3418">						s = mark;</a>
<a name="ln3419"> </a>
<a name="ln3420">					if (cursor-&gt;parent || PUGI__OPTSET(parse_fragment))</a>
<a name="ln3421">					{</a>
<a name="ln3422">						if (PUGI__OPTSET(parse_embed_pcdata) &amp;&amp; cursor-&gt;parent &amp;&amp; !cursor-&gt;first_child &amp;&amp; !cursor-&gt;value)</a>
<a name="ln3423">						{</a>
<a name="ln3424">							cursor-&gt;value = s; // Save the offset.</a>
<a name="ln3425">						}</a>
<a name="ln3426">						else</a>
<a name="ln3427">						{</a>
<a name="ln3428">							PUGI__PUSHNODE(node_pcdata); // Append a new node on the tree.</a>
<a name="ln3429"> </a>
<a name="ln3430">							cursor-&gt;value = s; // Save the offset.</a>
<a name="ln3431"> </a>
<a name="ln3432">							PUGI__POPNODE(); // Pop since this is a standalone.</a>
<a name="ln3433">						}</a>
<a name="ln3434"> </a>
<a name="ln3435">						s = strconv_pcdata(s);</a>
<a name="ln3436"> </a>
<a name="ln3437">						if (!*s) break;</a>
<a name="ln3438">					}</a>
<a name="ln3439">					else</a>
<a name="ln3440">					{</a>
<a name="ln3441">						PUGI__SCANFOR(*s == '&lt;'); // '...&lt;'</a>
<a name="ln3442">						if (!*s) break;</a>
<a name="ln3443"> </a>
<a name="ln3444">						++s;</a>
<a name="ln3445">					}</a>
<a name="ln3446"> </a>
<a name="ln3447">					// We're after '&lt;'</a>
<a name="ln3448">					goto LOC_TAG;</a>
<a name="ln3449">				}</a>
<a name="ln3450">			}</a>
<a name="ln3451"> </a>
<a name="ln3452">			// check that last tag is closed</a>
<a name="ln3453">			if (cursor != root) PUGI__THROW_ERROR(status_end_element_mismatch, s);</a>
<a name="ln3454"> </a>
<a name="ln3455">			return s;</a>
<a name="ln3456">		}</a>
<a name="ln3457"> </a>
<a name="ln3458">	#ifdef PUGIXML_WCHAR_MODE</a>
<a name="ln3459">		static char_t* parse_skip_bom(char_t* s)</a>
<a name="ln3460">		{</a>
<a name="ln3461">			unsigned int bom = 0xfeff;</a>
<a name="ln3462">			return (s[0] == static_cast&lt;wchar_t&gt;(bom)) ? s + 1 : s;</a>
<a name="ln3463">		}</a>
<a name="ln3464">	#else</a>
<a name="ln3465">		static char_t* parse_skip_bom(char_t* s)</a>
<a name="ln3466">		{</a>
<a name="ln3467">			return (s[0] == '\xef' &amp;&amp; s[1] == '\xbb' &amp;&amp; s[2] == '\xbf') ? s + 3 : s;</a>
<a name="ln3468">		}</a>
<a name="ln3469">	#endif</a>
<a name="ln3470"> </a>
<a name="ln3471">		static bool has_element_node_siblings(xml_node_struct* node)</a>
<a name="ln3472">		{</a>
<a name="ln3473">			while (node)</a>
<a name="ln3474">			{</a>
<a name="ln3475">				if (PUGI__NODETYPE(node) == node_element) return true;</a>
<a name="ln3476"> </a>
<a name="ln3477">				node = node-&gt;next_sibling;</a>
<a name="ln3478">			}</a>
<a name="ln3479"> </a>
<a name="ln3480">			return false;</a>
<a name="ln3481">		}</a>
<a name="ln3482"> </a>
<a name="ln3483">		static xml_parse_result parse(char_t* buffer, size_t length, xml_document_struct* xmldoc, xml_node_struct* root, unsigned int optmsk)</a>
<a name="ln3484">		{</a>
<a name="ln3485">			// early-out for empty documents</a>
<a name="ln3486">			if (length == 0)</a>
<a name="ln3487">				return make_parse_result(PUGI__OPTSET(parse_fragment) ? status_ok : status_no_document_element);</a>
<a name="ln3488"> </a>
<a name="ln3489">			// get last child of the root before parsing</a>
<a name="ln3490">			xml_node_struct* last_root_child = root-&gt;first_child ? root-&gt;first_child-&gt;prev_sibling_c + 0 : 0;</a>
<a name="ln3491"> </a>
<a name="ln3492">			// create parser on stack</a>
<a name="ln3493">			xml_parser parser(static_cast&lt;xml_allocator*&gt;(xmldoc));</a>
<a name="ln3494"> </a>
<a name="ln3495">			// save last character and make buffer zero-terminated (speeds up parsing)</a>
<a name="ln3496">			char_t endch = buffer[length - 1];</a>
<a name="ln3497">			buffer[length - 1] = 0;</a>
<a name="ln3498"> </a>
<a name="ln3499">			// skip BOM to make sure it does not end up as part of parse output</a>
<a name="ln3500">			char_t* buffer_data = parse_skip_bom(buffer);</a>
<a name="ln3501"> </a>
<a name="ln3502">			// perform actual parsing</a>
<a name="ln3503">			parser.parse_tree(buffer_data, root, optmsk, endch);</a>
<a name="ln3504"> </a>
<a name="ln3505">			xml_parse_result result = make_parse_result(parser.error_status, parser.error_offset ? parser.error_offset - buffer : 0);</a>
<a name="ln3506">			assert(result.offset &gt;= 0 &amp;&amp; static_cast&lt;size_t&gt;(result.offset) &lt;= length);</a>
<a name="ln3507"> </a>
<a name="ln3508">			if (result)</a>
<a name="ln3509">			{</a>
<a name="ln3510">				// since we removed last character, we have to handle the only possible false positive (stray &lt;)</a>
<a name="ln3511">				if (endch == '&lt;')</a>
<a name="ln3512">					return make_parse_result(status_unrecognized_tag, length - 1);</a>
<a name="ln3513"> </a>
<a name="ln3514">				// check if there are any element nodes parsed</a>
<a name="ln3515">				xml_node_struct* first_root_child_parsed = last_root_child ? last_root_child-&gt;next_sibling + 0 : root-&gt;first_child+ 0;</a>
<a name="ln3516"> </a>
<a name="ln3517">				if (!PUGI__OPTSET(parse_fragment) &amp;&amp; !has_element_node_siblings(first_root_child_parsed))</a>
<a name="ln3518">					return make_parse_result(status_no_document_element, length - 1);</a>
<a name="ln3519">			}</a>
<a name="ln3520">			else</a>
<a name="ln3521">			{</a>
<a name="ln3522">				// roll back offset if it occurs on a null terminator in the source buffer</a>
<a name="ln3523">				if (result.offset &gt; 0 &amp;&amp; static_cast&lt;size_t&gt;(result.offset) == length - 1 &amp;&amp; endch == 0)</a>
<a name="ln3524">					result.offset--;</a>
<a name="ln3525">			}</a>
<a name="ln3526"> </a>
<a name="ln3527">			return result;</a>
<a name="ln3528">		}</a>
<a name="ln3529">	};</a>
<a name="ln3530"> </a>
<a name="ln3531">	// Output facilities</a>
<a name="ln3532">	PUGI__FN xml_encoding get_write_native_encoding()</a>
<a name="ln3533">	{</a>
<a name="ln3534">	#ifdef PUGIXML_WCHAR_MODE</a>
<a name="ln3535">		return get_wchar_encoding();</a>
<a name="ln3536">	#else</a>
<a name="ln3537">		return encoding_utf8;</a>
<a name="ln3538">	#endif</a>
<a name="ln3539">	}</a>
<a name="ln3540"> </a>
<a name="ln3541">	PUGI__FN xml_encoding get_write_encoding(xml_encoding encoding)</a>
<a name="ln3542">	{</a>
<a name="ln3543">		// replace wchar encoding with utf implementation</a>
<a name="ln3544">		if (encoding == encoding_wchar) return get_wchar_encoding();</a>
<a name="ln3545"> </a>
<a name="ln3546">		// replace utf16 encoding with utf16 with specific endianness</a>
<a name="ln3547">		if (encoding == encoding_utf16) return is_little_endian() ? encoding_utf16_le : encoding_utf16_be;</a>
<a name="ln3548"> </a>
<a name="ln3549">		// replace utf32 encoding with utf32 with specific endianness</a>
<a name="ln3550">		if (encoding == encoding_utf32) return is_little_endian() ? encoding_utf32_le : encoding_utf32_be;</a>
<a name="ln3551"> </a>
<a name="ln3552">		// only do autodetection if no explicit encoding is requested</a>
<a name="ln3553">		if (encoding != encoding_auto) return encoding;</a>
<a name="ln3554"> </a>
<a name="ln3555">		// assume utf8 encoding</a>
<a name="ln3556">		return encoding_utf8;</a>
<a name="ln3557">	}</a>
<a name="ln3558"> </a>
<a name="ln3559">	template &lt;typename D, typename T&gt; PUGI__FN size_t convert_buffer_output_generic(typename T::value_type dest, const char_t* data, size_t length, D, T)</a>
<a name="ln3560">	{</a>
<a name="ln3561">		PUGI__STATIC_ASSERT(sizeof(char_t) == sizeof(typename D::type));</a>
<a name="ln3562"> </a>
<a name="ln3563">		typename T::value_type end = D::process(reinterpret_cast&lt;const typename D::type*&gt;(data), length, dest, T());</a>
<a name="ln3564"> </a>
<a name="ln3565">		return static_cast&lt;size_t&gt;(end - dest) * sizeof(*dest);</a>
<a name="ln3566">	}</a>
<a name="ln3567"> </a>
<a name="ln3568">	template &lt;typename D, typename T&gt; PUGI__FN size_t convert_buffer_output_generic(typename T::value_type dest, const char_t* data, size_t length, D, T, bool opt_swap)</a>
<a name="ln3569">	{</a>
<a name="ln3570">		PUGI__STATIC_ASSERT(sizeof(char_t) == sizeof(typename D::type));</a>
<a name="ln3571"> </a>
<a name="ln3572">		typename T::value_type end = D::process(reinterpret_cast&lt;const typename D::type*&gt;(data), length, dest, T());</a>
<a name="ln3573"> </a>
<a name="ln3574">		if (opt_swap)</a>
<a name="ln3575">		{</a>
<a name="ln3576">			for (typename T::value_type i = dest; i != end; ++i)</a>
<a name="ln3577">				*i = endian_swap(*i);</a>
<a name="ln3578">		}</a>
<a name="ln3579"> </a>
<a name="ln3580">		return static_cast&lt;size_t&gt;(end - dest) * sizeof(*dest);</a>
<a name="ln3581">	}</a>
<a name="ln3582"> </a>
<a name="ln3583">#ifdef PUGIXML_WCHAR_MODE</a>
<a name="ln3584">	PUGI__FN size_t get_valid_length(const char_t* data, size_t length)</a>
<a name="ln3585">	{</a>
<a name="ln3586">		if (length &lt; 1) return 0;</a>
<a name="ln3587"> </a>
<a name="ln3588">		// discard last character if it's the lead of a surrogate pair</a>
<a name="ln3589">		return (sizeof(wchar_t) == 2 &amp;&amp; static_cast&lt;unsigned int&gt;(static_cast&lt;uint16_t&gt;(data[length - 1]) - 0xD800) &lt; 0x400) ? length - 1 : length;</a>
<a name="ln3590">	}</a>
<a name="ln3591"> </a>
<a name="ln3592">	PUGI__FN size_t convert_buffer_output(char_t* r_char, uint8_t* r_u8, uint16_t* r_u16, uint32_t* r_u32, const char_t* data, size_t length, xml_encoding encoding)</a>
<a name="ln3593">	{</a>
<a name="ln3594">		// only endian-swapping is required</a>
<a name="ln3595">		if (need_endian_swap_utf(encoding, get_wchar_encoding()))</a>
<a name="ln3596">		{</a>
<a name="ln3597">			convert_wchar_endian_swap(r_char, data, length);</a>
<a name="ln3598"> </a>
<a name="ln3599">			return length * sizeof(char_t);</a>
<a name="ln3600">		}</a>
<a name="ln3601"> </a>
<a name="ln3602">		// convert to utf8</a>
<a name="ln3603">		if (encoding == encoding_utf8)</a>
<a name="ln3604">			return convert_buffer_output_generic(r_u8, data, length, wchar_decoder(), utf8_writer());</a>
<a name="ln3605"> </a>
<a name="ln3606">		// convert to utf16</a>
<a name="ln3607">		if (encoding == encoding_utf16_be || encoding == encoding_utf16_le)</a>
<a name="ln3608">		{</a>
<a name="ln3609">			xml_encoding native_encoding = is_little_endian() ? encoding_utf16_le : encoding_utf16_be;</a>
<a name="ln3610"> </a>
<a name="ln3611">			return convert_buffer_output_generic(r_u16, data, length, wchar_decoder(), utf16_writer(), native_encoding != encoding);</a>
<a name="ln3612">		}</a>
<a name="ln3613"> </a>
<a name="ln3614">		// convert to utf32</a>
<a name="ln3615">		if (encoding == encoding_utf32_be || encoding == encoding_utf32_le)</a>
<a name="ln3616">		{</a>
<a name="ln3617">			xml_encoding native_encoding = is_little_endian() ? encoding_utf32_le : encoding_utf32_be;</a>
<a name="ln3618"> </a>
<a name="ln3619">			return convert_buffer_output_generic(r_u32, data, length, wchar_decoder(), utf32_writer(), native_encoding != encoding);</a>
<a name="ln3620">		}</a>
<a name="ln3621"> </a>
<a name="ln3622">		// convert to latin1</a>
<a name="ln3623">		if (encoding == encoding_latin1)</a>
<a name="ln3624">			return convert_buffer_output_generic(r_u8, data, length, wchar_decoder(), latin1_writer());</a>
<a name="ln3625"> </a>
<a name="ln3626">		assert(false &amp;&amp; &quot;Invalid encoding&quot;);</a>
<a name="ln3627">		return 0;</a>
<a name="ln3628">	}</a>
<a name="ln3629">#else</a>
<a name="ln3630">	PUGI__FN size_t get_valid_length(const char_t* data, size_t length)</a>
<a name="ln3631">	{</a>
<a name="ln3632">		if (length &lt; 5) return 0;</a>
<a name="ln3633"> </a>
<a name="ln3634">		for (size_t i = 1; i &lt;= 4; ++i)</a>
<a name="ln3635">		{</a>
<a name="ln3636">			uint8_t ch = static_cast&lt;uint8_t&gt;(data[length - i]);</a>
<a name="ln3637"> </a>
<a name="ln3638">			// either a standalone character or a leading one</a>
<a name="ln3639">			if ((ch &amp; 0xc0) != 0x80) return length - i;</a>
<a name="ln3640">		}</a>
<a name="ln3641"> </a>
<a name="ln3642">		// there are four non-leading characters at the end, sequence tail is broken so might as well process the whole chunk</a>
<a name="ln3643">		return length;</a>
<a name="ln3644">	}</a>
<a name="ln3645"> </a>
<a name="ln3646">	PUGI__FN size_t convert_buffer_output(char_t* /* r_char */, uint8_t* r_u8, uint16_t* r_u16, uint32_t* r_u32, const char_t* data, size_t length, xml_encoding encoding)</a>
<a name="ln3647">	{</a>
<a name="ln3648">		if (encoding == encoding_utf16_be || encoding == encoding_utf16_le)</a>
<a name="ln3649">		{</a>
<a name="ln3650">			xml_encoding native_encoding = is_little_endian() ? encoding_utf16_le : encoding_utf16_be;</a>
<a name="ln3651"> </a>
<a name="ln3652">			return convert_buffer_output_generic(r_u16, data, length, utf8_decoder(), utf16_writer(), native_encoding != encoding);</a>
<a name="ln3653">		}</a>
<a name="ln3654"> </a>
<a name="ln3655">		if (encoding == encoding_utf32_be || encoding == encoding_utf32_le)</a>
<a name="ln3656">		{</a>
<a name="ln3657">			xml_encoding native_encoding = is_little_endian() ? encoding_utf32_le : encoding_utf32_be;</a>
<a name="ln3658"> </a>
<a name="ln3659">			return convert_buffer_output_generic(r_u32, data, length, utf8_decoder(), utf32_writer(), native_encoding != encoding);</a>
<a name="ln3660">		}</a>
<a name="ln3661"> </a>
<a name="ln3662">		if (encoding == encoding_latin1)</a>
<a name="ln3663">			return convert_buffer_output_generic(r_u8, data, length, utf8_decoder(), latin1_writer());</a>
<a name="ln3664"> </a>
<a name="ln3665">		assert(false &amp;&amp; &quot;Invalid encoding&quot;);</a>
<a name="ln3666">		return 0;</a>
<a name="ln3667">	}</a>
<a name="ln3668">#endif</a>
<a name="ln3669"> </a>
<a name="ln3670">	class xml_buffered_writer</a>
<a name="ln3671">	{</a>
<a name="ln3672">		xml_buffered_writer(const xml_buffered_writer&amp;);</a>
<a name="ln3673">		xml_buffered_writer&amp; operator=(const xml_buffered_writer&amp;);</a>
<a name="ln3674"> </a>
<a name="ln3675">	public:</a>
<a name="ln3676">		xml_buffered_writer(xml_writer&amp; writer_, xml_encoding user_encoding): writer(writer_), bufsize(0), encoding(get_write_encoding(user_encoding))</a>
<a name="ln3677">		{</a>
<a name="ln3678">			PUGI__STATIC_ASSERT(bufcapacity &gt;= 8);</a>
<a name="ln3679">		}</a>
<a name="ln3680"> </a>
<a name="ln3681">		size_t flush()</a>
<a name="ln3682">		{</a>
<a name="ln3683">			flush(buffer, bufsize);</a>
<a name="ln3684">			bufsize = 0;</a>
<a name="ln3685">			return 0;</a>
<a name="ln3686">		}</a>
<a name="ln3687"> </a>
<a name="ln3688">		void flush(const char_t* data, size_t size)</a>
<a name="ln3689">		{</a>
<a name="ln3690">			if (size == 0) return;</a>
<a name="ln3691"> </a>
<a name="ln3692">			// fast path, just write data</a>
<a name="ln3693">			if (encoding == get_write_native_encoding())</a>
<a name="ln3694">				writer.write(data, size * sizeof(char_t));</a>
<a name="ln3695">			else</a>
<a name="ln3696">			{</a>
<a name="ln3697">				// convert chunk</a>
<a name="ln3698">				size_t result = convert_buffer_output(scratch.data_char, scratch.data_u8, scratch.data_u16, scratch.data_u32, data, size, encoding);</a>
<a name="ln3699">				assert(result &lt;= sizeof(scratch));</a>
<a name="ln3700"> </a>
<a name="ln3701">				// write data</a>
<a name="ln3702">				writer.write(scratch.data_u8, result);</a>
<a name="ln3703">			}</a>
<a name="ln3704">		}</a>
<a name="ln3705"> </a>
<a name="ln3706">		void write_direct(const char_t* data, size_t length)</a>
<a name="ln3707">		{</a>
<a name="ln3708">			// flush the remaining buffer contents</a>
<a name="ln3709">			flush();</a>
<a name="ln3710"> </a>
<a name="ln3711">			// handle large chunks</a>
<a name="ln3712">			if (length &gt; bufcapacity)</a>
<a name="ln3713">			{</a>
<a name="ln3714">				if (encoding == get_write_native_encoding())</a>
<a name="ln3715">				{</a>
<a name="ln3716">					// fast path, can just write data chunk</a>
<a name="ln3717">					writer.write(data, length * sizeof(char_t));</a>
<a name="ln3718">					return;</a>
<a name="ln3719">				}</a>
<a name="ln3720"> </a>
<a name="ln3721">				// need to convert in suitable chunks</a>
<a name="ln3722">				while (length &gt; bufcapacity)</a>
<a name="ln3723">				{</a>
<a name="ln3724">					// get chunk size by selecting such number of characters that are guaranteed to fit into scratch buffer</a>
<a name="ln3725">					// and form a complete codepoint sequence (i.e. discard start of last codepoint if necessary)</a>
<a name="ln3726">					size_t chunk_size = get_valid_length(data, bufcapacity);</a>
<a name="ln3727">					assert(chunk_size);</a>
<a name="ln3728"> </a>
<a name="ln3729">					// convert chunk and write</a>
<a name="ln3730">					flush(data, chunk_size);</a>
<a name="ln3731"> </a>
<a name="ln3732">					// iterate</a>
<a name="ln3733">					data += chunk_size;</a>
<a name="ln3734">					length -= chunk_size;</a>
<a name="ln3735">				}</a>
<a name="ln3736"> </a>
<a name="ln3737">				// small tail is copied below</a>
<a name="ln3738">				bufsize = 0;</a>
<a name="ln3739">			}</a>
<a name="ln3740"> </a>
<a name="ln3741">			memcpy(buffer + bufsize, data, length * sizeof(char_t));</a>
<a name="ln3742">			bufsize += length;</a>
<a name="ln3743">		}</a>
<a name="ln3744"> </a>
<a name="ln3745">		void write_buffer(const char_t* data, size_t length)</a>
<a name="ln3746">		{</a>
<a name="ln3747">			size_t offset = bufsize;</a>
<a name="ln3748"> </a>
<a name="ln3749">			if (offset + length &lt;= bufcapacity)</a>
<a name="ln3750">			{</a>
<a name="ln3751">				memcpy(buffer + offset, data, length * sizeof(char_t));</a>
<a name="ln3752">				bufsize = offset + length;</a>
<a name="ln3753">			}</a>
<a name="ln3754">			else</a>
<a name="ln3755">			{</a>
<a name="ln3756">				write_direct(data, length);</a>
<a name="ln3757">			}</a>
<a name="ln3758">		}</a>
<a name="ln3759"> </a>
<a name="ln3760">		void write_string(const char_t* data)</a>
<a name="ln3761">		{</a>
<a name="ln3762">			// write the part of the string that fits in the buffer</a>
<a name="ln3763">			size_t offset = bufsize;</a>
<a name="ln3764"> </a>
<a name="ln3765">			while (*data &amp;&amp; offset &lt; bufcapacity)</a>
<a name="ln3766">				buffer[offset++] = *data++;</a>
<a name="ln3767"> </a>
<a name="ln3768">			// write the rest</a>
<a name="ln3769">			if (offset &lt; bufcapacity)</a>
<a name="ln3770">			{</a>
<a name="ln3771">				bufsize = offset;</a>
<a name="ln3772">			}</a>
<a name="ln3773">			else</a>
<a name="ln3774">			{</a>
<a name="ln3775">				// backtrack a bit if we have split the codepoint</a>
<a name="ln3776">				size_t length = offset - bufsize;</a>
<a name="ln3777">				size_t extra = length - get_valid_length(data - length, length);</a>
<a name="ln3778"> </a>
<a name="ln3779">				bufsize = offset - extra;</a>
<a name="ln3780"> </a>
<a name="ln3781">				write_direct(data - extra, strlength(data) + extra);</a>
<a name="ln3782">			}</a>
<a name="ln3783">		}</a>
<a name="ln3784"> </a>
<a name="ln3785">		void write(char_t d0)</a>
<a name="ln3786">		{</a>
<a name="ln3787">			size_t offset = bufsize;</a>
<a name="ln3788">			if (offset &gt; bufcapacity - 1) offset = flush();</a>
<a name="ln3789"> </a>
<a name="ln3790">			buffer[offset + 0] = d0;</a>
<a name="ln3791">			bufsize = offset + 1;</a>
<a name="ln3792">		}</a>
<a name="ln3793"> </a>
<a name="ln3794">		void write(char_t d0, char_t d1)</a>
<a name="ln3795">		{</a>
<a name="ln3796">			size_t offset = bufsize;</a>
<a name="ln3797">			if (offset &gt; bufcapacity - 2) offset = flush();</a>
<a name="ln3798"> </a>
<a name="ln3799">			buffer[offset + 0] = d0;</a>
<a name="ln3800">			buffer[offset + 1] = d1;</a>
<a name="ln3801">			bufsize = offset + 2;</a>
<a name="ln3802">		}</a>
<a name="ln3803"> </a>
<a name="ln3804">		void write(char_t d0, char_t d1, char_t d2)</a>
<a name="ln3805">		{</a>
<a name="ln3806">			size_t offset = bufsize;</a>
<a name="ln3807">			if (offset &gt; bufcapacity - 3) offset = flush();</a>
<a name="ln3808"> </a>
<a name="ln3809">			buffer[offset + 0] = d0;</a>
<a name="ln3810">			buffer[offset + 1] = d1;</a>
<a name="ln3811">			buffer[offset + 2] = d2;</a>
<a name="ln3812">			bufsize = offset + 3;</a>
<a name="ln3813">		}</a>
<a name="ln3814"> </a>
<a name="ln3815">		void write(char_t d0, char_t d1, char_t d2, char_t d3)</a>
<a name="ln3816">		{</a>
<a name="ln3817">			size_t offset = bufsize;</a>
<a name="ln3818">			if (offset &gt; bufcapacity - 4) offset = flush();</a>
<a name="ln3819"> </a>
<a name="ln3820">			buffer[offset + 0] = d0;</a>
<a name="ln3821">			buffer[offset + 1] = d1;</a>
<a name="ln3822">			buffer[offset + 2] = d2;</a>
<a name="ln3823">			buffer[offset + 3] = d3;</a>
<a name="ln3824">			bufsize = offset + 4;</a>
<a name="ln3825">		}</a>
<a name="ln3826"> </a>
<a name="ln3827">		void write(char_t d0, char_t d1, char_t d2, char_t d3, char_t d4)</a>
<a name="ln3828">		{</a>
<a name="ln3829">			size_t offset = bufsize;</a>
<a name="ln3830">			if (offset &gt; bufcapacity - 5) offset = flush();</a>
<a name="ln3831"> </a>
<a name="ln3832">			buffer[offset + 0] = d0;</a>
<a name="ln3833">			buffer[offset + 1] = d1;</a>
<a name="ln3834">			buffer[offset + 2] = d2;</a>
<a name="ln3835">			buffer[offset + 3] = d3;</a>
<a name="ln3836">			buffer[offset + 4] = d4;</a>
<a name="ln3837">			bufsize = offset + 5;</a>
<a name="ln3838">		}</a>
<a name="ln3839"> </a>
<a name="ln3840">		void write(char_t d0, char_t d1, char_t d2, char_t d3, char_t d4, char_t d5)</a>
<a name="ln3841">		{</a>
<a name="ln3842">			size_t offset = bufsize;</a>
<a name="ln3843">			if (offset &gt; bufcapacity - 6) offset = flush();</a>
<a name="ln3844"> </a>
<a name="ln3845">			buffer[offset + 0] = d0;</a>
<a name="ln3846">			buffer[offset + 1] = d1;</a>
<a name="ln3847">			buffer[offset + 2] = d2;</a>
<a name="ln3848">			buffer[offset + 3] = d3;</a>
<a name="ln3849">			buffer[offset + 4] = d4;</a>
<a name="ln3850">			buffer[offset + 5] = d5;</a>
<a name="ln3851">			bufsize = offset + 6;</a>
<a name="ln3852">		}</a>
<a name="ln3853"> </a>
<a name="ln3854">		// utf8 maximum expansion: x4 (-&gt; utf32)</a>
<a name="ln3855">		// utf16 maximum expansion: x2 (-&gt; utf32)</a>
<a name="ln3856">		// utf32 maximum expansion: x1</a>
<a name="ln3857">		enum</a>
<a name="ln3858">		{</a>
<a name="ln3859">			bufcapacitybytes =</a>
<a name="ln3860">			#ifdef PUGIXML_MEMORY_OUTPUT_STACK</a>
<a name="ln3861">				PUGIXML_MEMORY_OUTPUT_STACK</a>
<a name="ln3862">			#else</a>
<a name="ln3863">				10240</a>
<a name="ln3864">			#endif</a>
<a name="ln3865">			,</a>
<a name="ln3866">			bufcapacity = bufcapacitybytes / (sizeof(char_t) + 4)</a>
<a name="ln3867">		};</a>
<a name="ln3868"> </a>
<a name="ln3869">		char_t buffer[bufcapacity];</a>
<a name="ln3870"> </a>
<a name="ln3871">		union</a>
<a name="ln3872">		{</a>
<a name="ln3873">			uint8_t data_u8[4 * bufcapacity];</a>
<a name="ln3874">			uint16_t data_u16[2 * bufcapacity];</a>
<a name="ln3875">			uint32_t data_u32[bufcapacity];</a>
<a name="ln3876">			char_t data_char[bufcapacity];</a>
<a name="ln3877">		} scratch;</a>
<a name="ln3878"> </a>
<a name="ln3879">		xml_writer&amp; writer;</a>
<a name="ln3880">		size_t bufsize;</a>
<a name="ln3881">		xml_encoding encoding;</a>
<a name="ln3882">	};</a>
<a name="ln3883"> </a>
<a name="ln3884">	PUGI__FN void text_output_escaped(xml_buffered_writer&amp; writer, const char_t* s, chartypex_t type)</a>
<a name="ln3885">	{</a>
<a name="ln3886">		while (*s)</a>
<a name="ln3887">		{</a>
<a name="ln3888">			const char_t* prev = s;</a>
<a name="ln3889"> </a>
<a name="ln3890">			// While *s is a usual symbol</a>
<a name="ln3891">			PUGI__SCANWHILE_UNROLL(!PUGI__IS_CHARTYPEX(ss, type));</a>
<a name="ln3892"> </a>
<a name="ln3893">			writer.write_buffer(prev, static_cast&lt;size_t&gt;(s - prev));</a>
<a name="ln3894"> </a>
<a name="ln3895">			switch (*s)</a>
<a name="ln3896">			{</a>
<a name="ln3897">				case 0: break;</a>
<a name="ln3898">				case '&amp;':</a>
<a name="ln3899">					writer.write('&amp;', 'a', 'm', 'p', ';');</a>
<a name="ln3900">					++s;</a>
<a name="ln3901">					break;</a>
<a name="ln3902">				case '&lt;':</a>
<a name="ln3903">					writer.write('&amp;', 'l', 't', ';');</a>
<a name="ln3904">					++s;</a>
<a name="ln3905">					break;</a>
<a name="ln3906">				case '&gt;':</a>
<a name="ln3907">					writer.write('&amp;', 'g', 't', ';');</a>
<a name="ln3908">					++s;</a>
<a name="ln3909">					break;</a>
<a name="ln3910">				case '&quot;':</a>
<a name="ln3911">					writer.write('&amp;', 'q', 'u', 'o', 't', ';');</a>
<a name="ln3912">					++s;</a>
<a name="ln3913">					break;</a>
<a name="ln3914">				default: // s is not a usual symbol</a>
<a name="ln3915">				{</a>
<a name="ln3916">					unsigned int ch = static_cast&lt;unsigned int&gt;(*s++);</a>
<a name="ln3917">					assert(ch &lt; 32);</a>
<a name="ln3918"> </a>
<a name="ln3919">					writer.write('&amp;', '#', static_cast&lt;char_t&gt;((ch / 10) + '0'), static_cast&lt;char_t&gt;((ch % 10) + '0'), ';');</a>
<a name="ln3920">				}</a>
<a name="ln3921">			}</a>
<a name="ln3922">		}</a>
<a name="ln3923">	}</a>
<a name="ln3924"> </a>
<a name="ln3925">	PUGI__FN void text_output(xml_buffered_writer&amp; writer, const char_t* s, chartypex_t type, unsigned int flags)</a>
<a name="ln3926">	{</a>
<a name="ln3927">		if (flags &amp; format_no_escapes)</a>
<a name="ln3928">			writer.write_string(s);</a>
<a name="ln3929">		else</a>
<a name="ln3930">			text_output_escaped(writer, s, type);</a>
<a name="ln3931">	}</a>
<a name="ln3932"> </a>
<a name="ln3933">	PUGI__FN void text_output_cdata(xml_buffered_writer&amp; writer, const char_t* s)</a>
<a name="ln3934">	{</a>
<a name="ln3935">		do</a>
<a name="ln3936">		{</a>
<a name="ln3937">			writer.write('&lt;', '!', '[', 'C', 'D');</a>
<a name="ln3938">			writer.write('A', 'T', 'A', '[');</a>
<a name="ln3939"> </a>
<a name="ln3940">			const char_t* prev = s;</a>
<a name="ln3941"> </a>
<a name="ln3942">			// look for ]]&gt; sequence - we can't output it as is since it terminates CDATA</a>
<a name="ln3943">			while (*s &amp;&amp; !(s[0] == ']' &amp;&amp; s[1] == ']' &amp;&amp; s[2] == '&gt;')) ++s;</a>
<a name="ln3944"> </a>
<a name="ln3945">			// skip ]] if we stopped at ]]&gt;, &gt; will go to the next CDATA section</a>
<a name="ln3946">			if (*s) s += 2;</a>
<a name="ln3947"> </a>
<a name="ln3948">			writer.write_buffer(prev, static_cast&lt;size_t&gt;(s - prev));</a>
<a name="ln3949"> </a>
<a name="ln3950">			writer.write(']', ']', '&gt;');</a>
<a name="ln3951">		}</a>
<a name="ln3952">		while (*s);</a>
<a name="ln3953">	}</a>
<a name="ln3954"> </a>
<a name="ln3955">	PUGI__FN void text_output_indent(xml_buffered_writer&amp; writer, const char_t* indent, size_t indent_length, unsigned int depth)</a>
<a name="ln3956">	{</a>
<a name="ln3957">		switch (indent_length)</a>
<a name="ln3958">		{</a>
<a name="ln3959">		case 1:</a>
<a name="ln3960">		{</a>
<a name="ln3961">			for (unsigned int i = 0; i &lt; depth; ++i)</a>
<a name="ln3962">				writer.write(indent[0]);</a>
<a name="ln3963">			break;</a>
<a name="ln3964">		}</a>
<a name="ln3965"> </a>
<a name="ln3966">		case 2:</a>
<a name="ln3967">		{</a>
<a name="ln3968">			for (unsigned int i = 0; i &lt; depth; ++i)</a>
<a name="ln3969">				writer.write(indent[0], indent[1]);</a>
<a name="ln3970">			break;</a>
<a name="ln3971">		}</a>
<a name="ln3972"> </a>
<a name="ln3973">		case 3:</a>
<a name="ln3974">		{</a>
<a name="ln3975">			for (unsigned int i = 0; i &lt; depth; ++i)</a>
<a name="ln3976">				writer.write(indent[0], indent[1], indent[2]);</a>
<a name="ln3977">			break;</a>
<a name="ln3978">		}</a>
<a name="ln3979"> </a>
<a name="ln3980">		case 4:</a>
<a name="ln3981">		{</a>
<a name="ln3982">			for (unsigned int i = 0; i &lt; depth; ++i)</a>
<a name="ln3983">				writer.write(indent[0], indent[1], indent[2], indent[3]);</a>
<a name="ln3984">			break;</a>
<a name="ln3985">		}</a>
<a name="ln3986"> </a>
<a name="ln3987">		default:</a>
<a name="ln3988">		{</a>
<a name="ln3989">			for (unsigned int i = 0; i &lt; depth; ++i)</a>
<a name="ln3990">				writer.write_buffer(indent, indent_length);</a>
<a name="ln3991">		}</a>
<a name="ln3992">		}</a>
<a name="ln3993">	}</a>
<a name="ln3994"> </a>
<a name="ln3995">	PUGI__FN void node_output_comment(xml_buffered_writer&amp; writer, const char_t* s)</a>
<a name="ln3996">	{</a>
<a name="ln3997">		writer.write('&lt;', '!', '-', '-');</a>
<a name="ln3998"> </a>
<a name="ln3999">		while (*s)</a>
<a name="ln4000">		{</a>
<a name="ln4001">			const char_t* prev = s;</a>
<a name="ln4002"> </a>
<a name="ln4003">			// look for -\0 or -- sequence - we can't output it since -- is illegal in comment body</a>
<a name="ln4004">			while (*s &amp;&amp; !(s[0] == '-' &amp;&amp; (s[1] == '-' || s[1] == 0))) ++s;</a>
<a name="ln4005"> </a>
<a name="ln4006">			writer.write_buffer(prev, static_cast&lt;size_t&gt;(s - prev));</a>
<a name="ln4007"> </a>
<a name="ln4008">			if (*s)</a>
<a name="ln4009">			{</a>
<a name="ln4010">				assert(*s == '-');</a>
<a name="ln4011"> </a>
<a name="ln4012">				writer.write('-', ' ');</a>
<a name="ln4013">				++s;</a>
<a name="ln4014">			}</a>
<a name="ln4015">		}</a>
<a name="ln4016"> </a>
<a name="ln4017">		writer.write('-', '-', '&gt;');</a>
<a name="ln4018">	}</a>
<a name="ln4019"> </a>
<a name="ln4020">	PUGI__FN void node_output_pi_value(xml_buffered_writer&amp; writer, const char_t* s)</a>
<a name="ln4021">	{</a>
<a name="ln4022">		while (*s)</a>
<a name="ln4023">		{</a>
<a name="ln4024">			const char_t* prev = s;</a>
<a name="ln4025"> </a>
<a name="ln4026">			// look for ?&gt; sequence - we can't output it since ?&gt; terminates PI</a>
<a name="ln4027">			while (*s &amp;&amp; !(s[0] == '?' &amp;&amp; s[1] == '&gt;')) ++s;</a>
<a name="ln4028"> </a>
<a name="ln4029">			writer.write_buffer(prev, static_cast&lt;size_t&gt;(s - prev));</a>
<a name="ln4030"> </a>
<a name="ln4031">			if (*s)</a>
<a name="ln4032">			{</a>
<a name="ln4033">				assert(s[0] == '?' &amp;&amp; s[1] == '&gt;');</a>
<a name="ln4034"> </a>
<a name="ln4035">				writer.write('?', ' ', '&gt;');</a>
<a name="ln4036">				s += 2;</a>
<a name="ln4037">			}</a>
<a name="ln4038">		}</a>
<a name="ln4039">	}</a>
<a name="ln4040"> </a>
<a name="ln4041">	PUGI__FN void node_output_attributes(xml_buffered_writer&amp; writer, xml_node_struct* node, const char_t* indent, size_t indent_length, unsigned int flags, unsigned int depth)</a>
<a name="ln4042">	{</a>
<a name="ln4043">		const char_t* default_name = PUGIXML_TEXT(&quot;:anonymous&quot;);</a>
<a name="ln4044"> </a>
<a name="ln4045">		for (xml_attribute_struct* a = node-&gt;first_attribute; a; a = a-&gt;next_attribute)</a>
<a name="ln4046">		{</a>
<a name="ln4047">			if ((flags &amp; (format_indent_attributes | format_raw)) == format_indent_attributes)</a>
<a name="ln4048">			{</a>
<a name="ln4049">				writer.write('\n');</a>
<a name="ln4050"> </a>
<a name="ln4051">				text_output_indent(writer, indent, indent_length, depth + 1);</a>
<a name="ln4052">			}</a>
<a name="ln4053">			else</a>
<a name="ln4054">			{</a>
<a name="ln4055">				writer.write(' ');</a>
<a name="ln4056">			}</a>
<a name="ln4057"> </a>
<a name="ln4058">			writer.write_string(a-&gt;name ? a-&gt;name + 0 : default_name);</a>
<a name="ln4059">			writer.write('=', '&quot;');</a>
<a name="ln4060"> </a>
<a name="ln4061">			if (a-&gt;value)</a>
<a name="ln4062">				text_output(writer, a-&gt;value, ctx_special_attr, flags);</a>
<a name="ln4063"> </a>
<a name="ln4064">			writer.write('&quot;');</a>
<a name="ln4065">		}</a>
<a name="ln4066">	}</a>
<a name="ln4067"> </a>
<a name="ln4068">	PUGI__FN bool node_output_start(xml_buffered_writer&amp; writer, xml_node_struct* node, const char_t* indent, size_t indent_length, unsigned int flags, unsigned int depth)</a>
<a name="ln4069">	{</a>
<a name="ln4070">		const char_t* default_name = PUGIXML_TEXT(&quot;:anonymous&quot;);</a>
<a name="ln4071">		const char_t* name = node-&gt;name ? node-&gt;name + 0 : default_name;</a>
<a name="ln4072"> </a>
<a name="ln4073">		writer.write('&lt;');</a>
<a name="ln4074">		writer.write_string(name);</a>
<a name="ln4075"> </a>
<a name="ln4076">		if (node-&gt;first_attribute)</a>
<a name="ln4077">			node_output_attributes(writer, node, indent, indent_length, flags, depth);</a>
<a name="ln4078"> </a>
<a name="ln4079">		// element nodes can have value if parse_embed_pcdata was used</a>
<a name="ln4080">		if (!node-&gt;value)</a>
<a name="ln4081">		{</a>
<a name="ln4082">			if (!node-&gt;first_child)</a>
<a name="ln4083">			{</a>
<a name="ln4084">				if (flags &amp; format_no_empty_element_tags)</a>
<a name="ln4085">				{</a>
<a name="ln4086">					writer.write('&gt;', '&lt;', '/');</a>
<a name="ln4087">					writer.write_string(name);</a>
<a name="ln4088">					writer.write('&gt;');</a>
<a name="ln4089"> </a>
<a name="ln4090">					return false;</a>
<a name="ln4091">				}</a>
<a name="ln4092">				else</a>
<a name="ln4093">				{</a>
<a name="ln4094">					if ((flags &amp; format_raw) == 0)</a>
<a name="ln4095">						writer.write(' ');</a>
<a name="ln4096"> </a>
<a name="ln4097">					writer.write('/', '&gt;');</a>
<a name="ln4098"> </a>
<a name="ln4099">					return false;</a>
<a name="ln4100">				}</a>
<a name="ln4101">			}</a>
<a name="ln4102">			else</a>
<a name="ln4103">			{</a>
<a name="ln4104">				writer.write('&gt;');</a>
<a name="ln4105"> </a>
<a name="ln4106">				return true;</a>
<a name="ln4107">			}</a>
<a name="ln4108">		}</a>
<a name="ln4109">		else</a>
<a name="ln4110">		{</a>
<a name="ln4111">			writer.write('&gt;');</a>
<a name="ln4112"> </a>
<a name="ln4113">			text_output(writer, node-&gt;value, ctx_special_pcdata, flags);</a>
<a name="ln4114"> </a>
<a name="ln4115">			if (!node-&gt;first_child)</a>
<a name="ln4116">			{</a>
<a name="ln4117">				writer.write('&lt;', '/');</a>
<a name="ln4118">				writer.write_string(name);</a>
<a name="ln4119">				writer.write('&gt;');</a>
<a name="ln4120"> </a>
<a name="ln4121">				return false;</a>
<a name="ln4122">			}</a>
<a name="ln4123">			else</a>
<a name="ln4124">			{</a>
<a name="ln4125">				return true;</a>
<a name="ln4126">			}</a>
<a name="ln4127">		}</a>
<a name="ln4128">	}</a>
<a name="ln4129"> </a>
<a name="ln4130">	PUGI__FN void node_output_end(xml_buffered_writer&amp; writer, xml_node_struct* node)</a>
<a name="ln4131">	{</a>
<a name="ln4132">		const char_t* default_name = PUGIXML_TEXT(&quot;:anonymous&quot;);</a>
<a name="ln4133">		const char_t* name = node-&gt;name ? node-&gt;name + 0 : default_name;</a>
<a name="ln4134"> </a>
<a name="ln4135">		writer.write('&lt;', '/');</a>
<a name="ln4136">		writer.write_string(name);</a>
<a name="ln4137">		writer.write('&gt;');</a>
<a name="ln4138">	}</a>
<a name="ln4139"> </a>
<a name="ln4140">	PUGI__FN void node_output_simple(xml_buffered_writer&amp; writer, xml_node_struct* node, unsigned int flags)</a>
<a name="ln4141">	{</a>
<a name="ln4142">		const char_t* default_name = PUGIXML_TEXT(&quot;:anonymous&quot;);</a>
<a name="ln4143"> </a>
<a name="ln4144">		switch (PUGI__NODETYPE(node))</a>
<a name="ln4145">		{</a>
<a name="ln4146">			case node_pcdata:</a>
<a name="ln4147">				text_output(writer, node-&gt;value ? node-&gt;value + 0 : PUGIXML_TEXT(&quot;&quot;), ctx_special_pcdata, flags);</a>
<a name="ln4148">				break;</a>
<a name="ln4149"> </a>
<a name="ln4150">			case node_cdata:</a>
<a name="ln4151">				text_output_cdata(writer, node-&gt;value ? node-&gt;value + 0 : PUGIXML_TEXT(&quot;&quot;));</a>
<a name="ln4152">				break;</a>
<a name="ln4153"> </a>
<a name="ln4154">			case node_comment:</a>
<a name="ln4155">				node_output_comment(writer, node-&gt;value ? node-&gt;value + 0 : PUGIXML_TEXT(&quot;&quot;));</a>
<a name="ln4156">				break;</a>
<a name="ln4157"> </a>
<a name="ln4158">			case node_pi:</a>
<a name="ln4159">				writer.write('&lt;', '?');</a>
<a name="ln4160">				writer.write_string(node-&gt;name ? node-&gt;name + 0 : default_name);</a>
<a name="ln4161"> </a>
<a name="ln4162">				if (node-&gt;value)</a>
<a name="ln4163">				{</a>
<a name="ln4164">					writer.write(' ');</a>
<a name="ln4165">					node_output_pi_value(writer, node-&gt;value);</a>
<a name="ln4166">				}</a>
<a name="ln4167"> </a>
<a name="ln4168">				writer.write('?', '&gt;');</a>
<a name="ln4169">				break;</a>
<a name="ln4170"> </a>
<a name="ln4171">			case node_declaration:</a>
<a name="ln4172">				writer.write('&lt;', '?');</a>
<a name="ln4173">				writer.write_string(node-&gt;name ? node-&gt;name + 0 : default_name);</a>
<a name="ln4174">				node_output_attributes(writer, node, PUGIXML_TEXT(&quot;&quot;), 0, flags | format_raw, 0);</a>
<a name="ln4175">				writer.write('?', '&gt;');</a>
<a name="ln4176">				break;</a>
<a name="ln4177"> </a>
<a name="ln4178">			case node_doctype:</a>
<a name="ln4179">				writer.write('&lt;', '!', 'D', 'O', 'C');</a>
<a name="ln4180">				writer.write('T', 'Y', 'P', 'E');</a>
<a name="ln4181"> </a>
<a name="ln4182">				if (node-&gt;value)</a>
<a name="ln4183">				{</a>
<a name="ln4184">					writer.write(' ');</a>
<a name="ln4185">					writer.write_string(node-&gt;value);</a>
<a name="ln4186">				}</a>
<a name="ln4187"> </a>
<a name="ln4188">				writer.write('&gt;');</a>
<a name="ln4189">				break;</a>
<a name="ln4190"> </a>
<a name="ln4191">			default:</a>
<a name="ln4192">				assert(false &amp;&amp; &quot;Invalid node type&quot;);</a>
<a name="ln4193">		}</a>
<a name="ln4194">	}</a>
<a name="ln4195"> </a>
<a name="ln4196">	enum indent_flags_t</a>
<a name="ln4197">	{</a>
<a name="ln4198">		indent_newline = 1,</a>
<a name="ln4199">		indent_indent = 2</a>
<a name="ln4200">	};</a>
<a name="ln4201"> </a>
<a name="ln4202">	PUGI__FN void node_output(xml_buffered_writer&amp; writer, xml_node_struct* root, const char_t* indent, unsigned int flags, unsigned int depth)</a>
<a name="ln4203">	{</a>
<a name="ln4204">		size_t indent_length = ((flags &amp; (format_indent | format_indent_attributes)) &amp;&amp; (flags &amp; format_raw) == 0) ? strlength(indent) : 0;</a>
<a name="ln4205">		unsigned int indent_flags = indent_indent;</a>
<a name="ln4206"> </a>
<a name="ln4207">		xml_node_struct* node = root;</a>
<a name="ln4208"> </a>
<a name="ln4209">		do</a>
<a name="ln4210">		{</a>
<a name="ln4211">			assert(node);</a>
<a name="ln4212"> </a>
<a name="ln4213">			// begin writing current node</a>
<a name="ln4214">			if (PUGI__NODETYPE(node) == node_pcdata || PUGI__NODETYPE(node) == node_cdata)</a>
<a name="ln4215">			{</a>
<a name="ln4216">				node_output_simple(writer, node, flags);</a>
<a name="ln4217"> </a>
<a name="ln4218">				indent_flags = 0;</a>
<a name="ln4219">			}</a>
<a name="ln4220">			else</a>
<a name="ln4221">			{</a>
<a name="ln4222">				if ((indent_flags &amp; indent_newline) &amp;&amp; (flags &amp; format_raw) == 0)</a>
<a name="ln4223">					writer.write('\n');</a>
<a name="ln4224"> </a>
<a name="ln4225">				if ((indent_flags &amp; indent_indent) &amp;&amp; indent_length)</a>
<a name="ln4226">					text_output_indent(writer, indent, indent_length, depth);</a>
<a name="ln4227"> </a>
<a name="ln4228">				if (PUGI__NODETYPE(node) == node_element)</a>
<a name="ln4229">				{</a>
<a name="ln4230">					indent_flags = indent_newline | indent_indent;</a>
<a name="ln4231"> </a>
<a name="ln4232">					if (node_output_start(writer, node, indent, indent_length, flags, depth))</a>
<a name="ln4233">					{</a>
<a name="ln4234">						// element nodes can have value if parse_embed_pcdata was used</a>
<a name="ln4235">						if (node-&gt;value)</a>
<a name="ln4236">							indent_flags = 0;</a>
<a name="ln4237"> </a>
<a name="ln4238">						node = node-&gt;first_child;</a>
<a name="ln4239">						depth++;</a>
<a name="ln4240">						continue;</a>
<a name="ln4241">					}</a>
<a name="ln4242">				}</a>
<a name="ln4243">				else if (PUGI__NODETYPE(node) == node_document)</a>
<a name="ln4244">				{</a>
<a name="ln4245">					indent_flags = indent_indent;</a>
<a name="ln4246"> </a>
<a name="ln4247">					if (node-&gt;first_child)</a>
<a name="ln4248">					{</a>
<a name="ln4249">						node = node-&gt;first_child;</a>
<a name="ln4250">						continue;</a>
<a name="ln4251">					}</a>
<a name="ln4252">				}</a>
<a name="ln4253">				else</a>
<a name="ln4254">				{</a>
<a name="ln4255">					node_output_simple(writer, node, flags);</a>
<a name="ln4256"> </a>
<a name="ln4257">					indent_flags = indent_newline | indent_indent;</a>
<a name="ln4258">				}</a>
<a name="ln4259">			}</a>
<a name="ln4260"> </a>
<a name="ln4261">			// continue to the next node</a>
<a name="ln4262">			while (node != root)</a>
<a name="ln4263">			{</a>
<a name="ln4264">				if (node-&gt;next_sibling)</a>
<a name="ln4265">				{</a>
<a name="ln4266">					node = node-&gt;next_sibling;</a>
<a name="ln4267">					break;</a>
<a name="ln4268">				}</a>
<a name="ln4269"> </a>
<a name="ln4270">				node = node-&gt;parent;</a>
<a name="ln4271"> </a>
<a name="ln4272">				// write closing node</a>
<a name="ln4273">				if (PUGI__NODETYPE(node) == node_element)</a>
<a name="ln4274">				{</a>
<a name="ln4275">					depth--;</a>
<a name="ln4276"> </a>
<a name="ln4277">					if ((indent_flags &amp; indent_newline) &amp;&amp; (flags &amp; format_raw) == 0)</a>
<a name="ln4278">						writer.write('\n');</a>
<a name="ln4279"> </a>
<a name="ln4280">					if ((indent_flags &amp; indent_indent) &amp;&amp; indent_length)</a>
<a name="ln4281">						text_output_indent(writer, indent, indent_length, depth);</a>
<a name="ln4282"> </a>
<a name="ln4283">					node_output_end(writer, node);</a>
<a name="ln4284"> </a>
<a name="ln4285">					indent_flags = indent_newline | indent_indent;</a>
<a name="ln4286">				}</a>
<a name="ln4287">			}</a>
<a name="ln4288">		}</a>
<a name="ln4289">		while (node != root);</a>
<a name="ln4290"> </a>
<a name="ln4291">		if ((indent_flags &amp; indent_newline) &amp;&amp; (flags &amp; format_raw) == 0)</a>
<a name="ln4292">			writer.write('\n');</a>
<a name="ln4293">	}</a>
<a name="ln4294"> </a>
<a name="ln4295">	PUGI__FN bool has_declaration(xml_node_struct* node)</a>
<a name="ln4296">	{</a>
<a name="ln4297">		for (xml_node_struct* child = node-&gt;first_child; child; child = child-&gt;next_sibling)</a>
<a name="ln4298">		{</a>
<a name="ln4299">			xml_node_type type = PUGI__NODETYPE(child);</a>
<a name="ln4300"> </a>
<a name="ln4301">			if (type == node_declaration) return true;</a>
<a name="ln4302">			if (type == node_element) return false;</a>
<a name="ln4303">		}</a>
<a name="ln4304"> </a>
<a name="ln4305">		return false;</a>
<a name="ln4306">	}</a>
<a name="ln4307"> </a>
<a name="ln4308">	PUGI__FN bool is_attribute_of(xml_attribute_struct* attr, xml_node_struct* node)</a>
<a name="ln4309">	{</a>
<a name="ln4310">		for (xml_attribute_struct* a = node-&gt;first_attribute; a; a = a-&gt;next_attribute)</a>
<a name="ln4311">			if (a == attr)</a>
<a name="ln4312">				return true;</a>
<a name="ln4313"> </a>
<a name="ln4314">		return false;</a>
<a name="ln4315">	}</a>
<a name="ln4316"> </a>
<a name="ln4317">	PUGI__FN bool allow_insert_attribute(xml_node_type parent)</a>
<a name="ln4318">	{</a>
<a name="ln4319">		return parent == node_element || parent == node_declaration;</a>
<a name="ln4320">	}</a>
<a name="ln4321"> </a>
<a name="ln4322">	PUGI__FN bool allow_insert_child(xml_node_type parent, xml_node_type child)</a>
<a name="ln4323">	{</a>
<a name="ln4324">		if (parent != node_document &amp;&amp; parent != node_element) return false;</a>
<a name="ln4325">		if (child == node_document || child == node_null) return false;</a>
<a name="ln4326">		if (parent != node_document &amp;&amp; (child == node_declaration || child == node_doctype)) return false;</a>
<a name="ln4327"> </a>
<a name="ln4328">		return true;</a>
<a name="ln4329">	}</a>
<a name="ln4330"> </a>
<a name="ln4331">	PUGI__FN bool allow_move(xml_node parent, xml_node child)</a>
<a name="ln4332">	{</a>
<a name="ln4333">		// check that child can be a child of parent</a>
<a name="ln4334">		if (!allow_insert_child(parent.type(), child.type()))</a>
<a name="ln4335">			return false;</a>
<a name="ln4336"> </a>
<a name="ln4337">		// check that node is not moved between documents</a>
<a name="ln4338">		if (parent.root() != child.root())</a>
<a name="ln4339">			return false;</a>
<a name="ln4340"> </a>
<a name="ln4341">		// check that new parent is not in the child subtree</a>
<a name="ln4342">		xml_node cur = parent;</a>
<a name="ln4343"> </a>
<a name="ln4344">		while (cur)</a>
<a name="ln4345">		{</a>
<a name="ln4346">			if (cur == child)</a>
<a name="ln4347">				return false;</a>
<a name="ln4348"> </a>
<a name="ln4349">			cur = cur.parent();</a>
<a name="ln4350">		}</a>
<a name="ln4351"> </a>
<a name="ln4352">		return true;</a>
<a name="ln4353">	}</a>
<a name="ln4354"> </a>
<a name="ln4355">	template &lt;typename String, typename Header&gt;</a>
<a name="ln4356">	PUGI__FN void node_copy_string(String&amp; dest, Header&amp; header, uintptr_t header_mask, char_t* source, Header&amp; source_header, xml_allocator* alloc)</a>
<a name="ln4357">	{</a>
<a name="ln4358">		assert(!dest &amp;&amp; (header &amp; header_mask) == 0);</a>
<a name="ln4359"> </a>
<a name="ln4360">		if (source)</a>
<a name="ln4361">		{</a>
<a name="ln4362">			if (alloc &amp;&amp; (source_header &amp; header_mask) == 0)</a>
<a name="ln4363">			{</a>
<a name="ln4364">				dest = source;</a>
<a name="ln4365"> </a>
<a name="ln4366">				// since strcpy_insitu can reuse document buffer memory we need to mark both source and dest as shared</a>
<a name="ln4367">				header |= xml_memory_page_contents_shared_mask;</a>
<a name="ln4368">				source_header |= xml_memory_page_contents_shared_mask;</a>
<a name="ln4369">			}</a>
<a name="ln4370">			else</a>
<a name="ln4371">				strcpy_insitu(dest, header, header_mask, source, strlength(source));</a>
<a name="ln4372">		}</a>
<a name="ln4373">	}</a>
<a name="ln4374"> </a>
<a name="ln4375">	PUGI__FN void node_copy_contents(xml_node_struct* dn, xml_node_struct* sn, xml_allocator* shared_alloc)</a>
<a name="ln4376">	{</a>
<a name="ln4377">		node_copy_string(dn-&gt;name, dn-&gt;header, xml_memory_page_name_allocated_mask, sn-&gt;name, sn-&gt;header, shared_alloc);</a>
<a name="ln4378">		node_copy_string(dn-&gt;value, dn-&gt;header, xml_memory_page_value_allocated_mask, sn-&gt;value, sn-&gt;header, shared_alloc);</a>
<a name="ln4379"> </a>
<a name="ln4380">		for (xml_attribute_struct* sa = sn-&gt;first_attribute; sa; sa = sa-&gt;next_attribute)</a>
<a name="ln4381">		{</a>
<a name="ln4382">			xml_attribute_struct* da = append_new_attribute(dn, get_allocator(dn));</a>
<a name="ln4383"> </a>
<a name="ln4384">			if (da)</a>
<a name="ln4385">			{</a>
<a name="ln4386">				node_copy_string(da-&gt;name, da-&gt;header, xml_memory_page_name_allocated_mask, sa-&gt;name, sa-&gt;header, shared_alloc);</a>
<a name="ln4387">				node_copy_string(da-&gt;value, da-&gt;header, xml_memory_page_value_allocated_mask, sa-&gt;value, sa-&gt;header, shared_alloc);</a>
<a name="ln4388">			}</a>
<a name="ln4389">		}</a>
<a name="ln4390">	}</a>
<a name="ln4391"> </a>
<a name="ln4392">	PUGI__FN void node_copy_tree(xml_node_struct* dn, xml_node_struct* sn)</a>
<a name="ln4393">	{</a>
<a name="ln4394">		xml_allocator&amp; alloc = get_allocator(dn);</a>
<a name="ln4395">		xml_allocator* shared_alloc = (&amp;alloc == &amp;get_allocator(sn)) ? &amp;alloc : 0;</a>
<a name="ln4396"> </a>
<a name="ln4397">		node_copy_contents(dn, sn, shared_alloc);</a>
<a name="ln4398"> </a>
<a name="ln4399">		xml_node_struct* dit = dn;</a>
<a name="ln4400">		xml_node_struct* sit = sn-&gt;first_child;</a>
<a name="ln4401"> </a>
<a name="ln4402">		while (sit &amp;&amp; sit != sn)</a>
<a name="ln4403">		{</a>
<a name="ln4404">			if (sit != dn)</a>
<a name="ln4405">			{</a>
<a name="ln4406">				xml_node_struct* copy = append_new_node(dit, alloc, PUGI__NODETYPE(sit));</a>
<a name="ln4407"> </a>
<a name="ln4408">				if (copy)</a>
<a name="ln4409">				{</a>
<a name="ln4410">					node_copy_contents(copy, sit, shared_alloc);</a>
<a name="ln4411"> </a>
<a name="ln4412">					if (sit-&gt;first_child)</a>
<a name="ln4413">					{</a>
<a name="ln4414">						dit = copy;</a>
<a name="ln4415">						sit = sit-&gt;first_child;</a>
<a name="ln4416">						continue;</a>
<a name="ln4417">					}</a>
<a name="ln4418">				}</a>
<a name="ln4419">			}</a>
<a name="ln4420"> </a>
<a name="ln4421">			// continue to the next node</a>
<a name="ln4422">			do</a>
<a name="ln4423">			{</a>
<a name="ln4424">				if (sit-&gt;next_sibling)</a>
<a name="ln4425">				{</a>
<a name="ln4426">					sit = sit-&gt;next_sibling;</a>
<a name="ln4427">					break;</a>
<a name="ln4428">				}</a>
<a name="ln4429"> </a>
<a name="ln4430">				sit = sit-&gt;parent;</a>
<a name="ln4431">				dit = dit-&gt;parent;</a>
<a name="ln4432">			}</a>
<a name="ln4433">			while (sit != sn);</a>
<a name="ln4434">		}</a>
<a name="ln4435">	}</a>
<a name="ln4436"> </a>
<a name="ln4437">	PUGI__FN void node_copy_attribute(xml_attribute_struct* da, xml_attribute_struct* sa)</a>
<a name="ln4438">	{</a>
<a name="ln4439">		xml_allocator&amp; alloc = get_allocator(da);</a>
<a name="ln4440">		xml_allocator* shared_alloc = (&amp;alloc == &amp;get_allocator(sa)) ? &amp;alloc : 0;</a>
<a name="ln4441"> </a>
<a name="ln4442">		node_copy_string(da-&gt;name, da-&gt;header, xml_memory_page_name_allocated_mask, sa-&gt;name, sa-&gt;header, shared_alloc);</a>
<a name="ln4443">		node_copy_string(da-&gt;value, da-&gt;header, xml_memory_page_value_allocated_mask, sa-&gt;value, sa-&gt;header, shared_alloc);</a>
<a name="ln4444">	}</a>
<a name="ln4445"> </a>
<a name="ln4446">	inline bool is_text_node(xml_node_struct* node)</a>
<a name="ln4447">	{</a>
<a name="ln4448">		xml_node_type type = PUGI__NODETYPE(node);</a>
<a name="ln4449"> </a>
<a name="ln4450">		return type == node_pcdata || type == node_cdata;</a>
<a name="ln4451">	}</a>
<a name="ln4452"> </a>
<a name="ln4453">	// get value with conversion functions</a>
<a name="ln4454">	template &lt;typename U&gt; U string_to_integer(const char_t* value, U minneg, U maxpos)</a>
<a name="ln4455">	{</a>
<a name="ln4456">		U result = 0;</a>
<a name="ln4457">		const char_t* s = value;</a>
<a name="ln4458"> </a>
<a name="ln4459">		while (PUGI__IS_CHARTYPE(*s, ct_space))</a>
<a name="ln4460">			s++;</a>
<a name="ln4461"> </a>
<a name="ln4462">		bool negative = (*s == '-');</a>
<a name="ln4463"> </a>
<a name="ln4464">		s += (*s == '+' || *s == '-');</a>
<a name="ln4465"> </a>
<a name="ln4466">		bool overflow = false;</a>
<a name="ln4467"> </a>
<a name="ln4468">		if (s[0] == '0' &amp;&amp; (s[1] | ' ') == 'x')</a>
<a name="ln4469">		{</a>
<a name="ln4470">			s += 2;</a>
<a name="ln4471"> </a>
<a name="ln4472">			// since overflow detection relies on length of the sequence skip leading zeros</a>
<a name="ln4473">			while (*s == '0')</a>
<a name="ln4474">				s++;</a>
<a name="ln4475"> </a>
<a name="ln4476">			const char_t* start = s;</a>
<a name="ln4477"> </a>
<a name="ln4478">			for (;;)</a>
<a name="ln4479">			{</a>
<a name="ln4480">				if (static_cast&lt;unsigned&gt;(*s - '0') &lt; 10)</a>
<a name="ln4481">					result = result * 16 + (*s - '0');</a>
<a name="ln4482">				else if (static_cast&lt;unsigned&gt;((*s | ' ') - 'a') &lt; 6)</a>
<a name="ln4483">					result = result * 16 + ((*s | ' ') - 'a' + 10);</a>
<a name="ln4484">				else</a>
<a name="ln4485">					break;</a>
<a name="ln4486"> </a>
<a name="ln4487">				s++;</a>
<a name="ln4488">			}</a>
<a name="ln4489"> </a>
<a name="ln4490">			size_t digits = static_cast&lt;size_t&gt;(s - start);</a>
<a name="ln4491"> </a>
<a name="ln4492">			overflow = digits &gt; sizeof(U) * 2;</a>
<a name="ln4493">		}</a>
<a name="ln4494">		else</a>
<a name="ln4495">		{</a>
<a name="ln4496">			// since overflow detection relies on length of the sequence skip leading zeros</a>
<a name="ln4497">			while (*s == '0')</a>
<a name="ln4498">				s++;</a>
<a name="ln4499"> </a>
<a name="ln4500">			const char_t* start = s;</a>
<a name="ln4501"> </a>
<a name="ln4502">			for (;;)</a>
<a name="ln4503">			{</a>
<a name="ln4504">				if (static_cast&lt;unsigned&gt;(*s - '0') &lt; 10)</a>
<a name="ln4505">					result = result * 10 + (*s - '0');</a>
<a name="ln4506">				else</a>
<a name="ln4507">					break;</a>
<a name="ln4508"> </a>
<a name="ln4509">				s++;</a>
<a name="ln4510">			}</a>
<a name="ln4511"> </a>
<a name="ln4512">			size_t digits = static_cast&lt;size_t&gt;(s - start);</a>
<a name="ln4513"> </a>
<a name="ln4514">			PUGI__STATIC_ASSERT(sizeof(U) == 8 || sizeof(U) == 4 || sizeof(U) == 2);</a>
<a name="ln4515"> </a>
<a name="ln4516">			const size_t max_digits10 = sizeof(U) == 8 ? 20 : sizeof(U) == 4 ? 10 : 5;</a>
<a name="ln4517">			const char_t max_lead = sizeof(U) == 8 ? '1' : sizeof(U) == 4 ? '4' : '6';</a>
<a name="ln4518">			const size_t high_bit = sizeof(U) * 8 - 1;</a>
<a name="ln4519"> </a>
<a name="ln4520">			overflow = digits &gt;= max_digits10 &amp;&amp; !(digits == max_digits10 &amp;&amp; (*start &lt; max_lead || (*start == max_lead &amp;&amp; result &gt;&gt; high_bit)));</a>
<a name="ln4521">		}</a>
<a name="ln4522"> </a>
<a name="ln4523">		if (negative)</a>
<a name="ln4524">			return (overflow || result &gt; minneg) ? 0 - minneg : 0 - result;</a>
<a name="ln4525">		else</a>
<a name="ln4526">			return (overflow || result &gt; maxpos) ? maxpos : result;</a>
<a name="ln4527">	}</a>
<a name="ln4528"> </a>
<a name="ln4529">	PUGI__FN int get_value_int(const char_t* value)</a>
<a name="ln4530">	{</a>
<a name="ln4531">		return string_to_integer&lt;unsigned int&gt;(value, 0 - static_cast&lt;unsigned int&gt;(INT_MIN), INT_MAX);</a>
<a name="ln4532">	}</a>
<a name="ln4533"> </a>
<a name="ln4534">	PUGI__FN unsigned int get_value_uint(const char_t* value)</a>
<a name="ln4535">	{</a>
<a name="ln4536">		return string_to_integer&lt;unsigned int&gt;(value, 0, UINT_MAX);</a>
<a name="ln4537">	}</a>
<a name="ln4538"> </a>
<a name="ln4539">	PUGI__FN double get_value_double(const char_t* value)</a>
<a name="ln4540">	{</a>
<a name="ln4541">	#ifdef PUGIXML_WCHAR_MODE</a>
<a name="ln4542">		return wcstod(value, 0);</a>
<a name="ln4543">	#else</a>
<a name="ln4544">		return strtod(value, 0);</a>
<a name="ln4545">	#endif</a>
<a name="ln4546">	}</a>
<a name="ln4547"> </a>
<a name="ln4548">	PUGI__FN float get_value_float(const char_t* value)</a>
<a name="ln4549">	{</a>
<a name="ln4550">	#ifdef PUGIXML_WCHAR_MODE</a>
<a name="ln4551">		return static_cast&lt;float&gt;(wcstod(value, 0));</a>
<a name="ln4552">	#else</a>
<a name="ln4553">		return static_cast&lt;float&gt;(strtod(value, 0));</a>
<a name="ln4554">	#endif</a>
<a name="ln4555">	}</a>
<a name="ln4556"> </a>
<a name="ln4557">	PUGI__FN bool get_value_bool(const char_t* value)</a>
<a name="ln4558">	{</a>
<a name="ln4559">		// only look at first char</a>
<a name="ln4560">		char_t first = *value;</a>
<a name="ln4561"> </a>
<a name="ln4562">		// 1*, t* (true), T* (True), y* (yes), Y* (YES)</a>
<a name="ln4563">		return (first == '1' || first == 't' || first == 'T' || first == 'y' || first == 'Y');</a>
<a name="ln4564">	}</a>
<a name="ln4565"> </a>
<a name="ln4566">#ifdef PUGIXML_HAS_LONG_LONG</a>
<a name="ln4567">	PUGI__FN long long get_value_llong(const char_t* value)</a>
<a name="ln4568">	{</a>
<a name="ln4569">		return string_to_integer&lt;unsigned long long&gt;(value, 0 - static_cast&lt;unsigned long long&gt;(LLONG_MIN), LLONG_MAX);</a>
<a name="ln4570">	}</a>
<a name="ln4571"> </a>
<a name="ln4572">	PUGI__FN unsigned long long get_value_ullong(const char_t* value)</a>
<a name="ln4573">	{</a>
<a name="ln4574">		return string_to_integer&lt;unsigned long long&gt;(value, 0, ULLONG_MAX);</a>
<a name="ln4575">	}</a>
<a name="ln4576">#endif</a>
<a name="ln4577"> </a>
<a name="ln4578">	template &lt;typename U&gt; PUGI__FN char_t* integer_to_string(char_t* begin, char_t* end, U value, bool negative)</a>
<a name="ln4579">	{</a>
<a name="ln4580">		char_t* result = end - 1;</a>
<a name="ln4581">		U rest = negative ? 0 - value : value;</a>
<a name="ln4582"> </a>
<a name="ln4583">		do</a>
<a name="ln4584">		{</a>
<a name="ln4585">			*result-- = static_cast&lt;char_t&gt;('0' + (rest % 10));</a>
<a name="ln4586">			rest /= 10;</a>
<a name="ln4587">		}</a>
<a name="ln4588">		while (rest);</a>
<a name="ln4589"> </a>
<a name="ln4590">		assert(result &gt;= begin);</a>
<a name="ln4591">		(void)begin;</a>
<a name="ln4592"> </a>
<a name="ln4593">		*result = '-';</a>
<a name="ln4594"> </a>
<a name="ln4595">		return result + !negative;</a>
<a name="ln4596">	}</a>
<a name="ln4597"> </a>
<a name="ln4598">	// set value with conversion functions</a>
<a name="ln4599">	template &lt;typename String, typename Header&gt;</a>
<a name="ln4600">	PUGI__FN bool set_value_ascii(String&amp; dest, Header&amp; header, uintptr_t header_mask, char* buf)</a>
<a name="ln4601">	{</a>
<a name="ln4602">	#ifdef PUGIXML_WCHAR_MODE</a>
<a name="ln4603">		char_t wbuf[128];</a>
<a name="ln4604">		assert(strlen(buf) &lt; sizeof(wbuf) / sizeof(wbuf[0]));</a>
<a name="ln4605"> </a>
<a name="ln4606">		size_t offset = 0;</a>
<a name="ln4607">		for (; buf[offset]; ++offset) wbuf[offset] = buf[offset];</a>
<a name="ln4608"> </a>
<a name="ln4609">		return strcpy_insitu(dest, header, header_mask, wbuf, offset);</a>
<a name="ln4610">	#else</a>
<a name="ln4611">		return strcpy_insitu(dest, header, header_mask, buf, strlen(buf));</a>
<a name="ln4612">	#endif</a>
<a name="ln4613">	}</a>
<a name="ln4614"> </a>
<a name="ln4615">	template &lt;typename U, typename String, typename Header&gt;</a>
<a name="ln4616">	PUGI__FN bool set_value_integer(String&amp; dest, Header&amp; header, uintptr_t header_mask, U value, bool negative)</a>
<a name="ln4617">	{</a>
<a name="ln4618">		char_t buf[64];</a>
<a name="ln4619">		char_t* end = buf + sizeof(buf) / sizeof(buf[0]);</a>
<a name="ln4620">		char_t* begin = integer_to_string(buf, end, value, negative);</a>
<a name="ln4621"> </a>
<a name="ln4622">		return strcpy_insitu(dest, header, header_mask, begin, end - begin);</a>
<a name="ln4623">	}</a>
<a name="ln4624"> </a>
<a name="ln4625">	template &lt;typename String, typename Header&gt;</a>
<a name="ln4626">	PUGI__FN bool set_value_convert(String&amp; dest, Header&amp; header, uintptr_t header_mask, float value)</a>
<a name="ln4627">	{</a>
<a name="ln4628">		char buf[128];</a>
<a name="ln4629">		sprintf(buf, &quot;%.9g&quot;, value);</a>
<a name="ln4630"> </a>
<a name="ln4631">		return set_value_ascii(dest, header, header_mask, buf);</a>
<a name="ln4632">	}</a>
<a name="ln4633"> </a>
<a name="ln4634">	template &lt;typename String, typename Header&gt;</a>
<a name="ln4635">	PUGI__FN bool set_value_convert(String&amp; dest, Header&amp; header, uintptr_t header_mask, double value)</a>
<a name="ln4636">	{</a>
<a name="ln4637">		char buf[128];</a>
<a name="ln4638">		sprintf(buf, &quot;%.17g&quot;, value);</a>
<a name="ln4639"> </a>
<a name="ln4640">		return set_value_ascii(dest, header, header_mask, buf);</a>
<a name="ln4641">	}</a>
<a name="ln4642"> </a>
<a name="ln4643">	template &lt;typename String, typename Header&gt;</a>
<a name="ln4644">	PUGI__FN bool set_value_bool(String&amp; dest, Header&amp; header, uintptr_t header_mask, bool value)</a>
<a name="ln4645">	{</a>
<a name="ln4646">		return strcpy_insitu(dest, header, header_mask, value ? PUGIXML_TEXT(&quot;true&quot;) : PUGIXML_TEXT(&quot;false&quot;), value ? 4 : 5);</a>
<a name="ln4647">	}</a>
<a name="ln4648"> </a>
<a name="ln4649">	PUGI__FN xml_parse_result load_buffer_impl(xml_document_struct* doc, xml_node_struct* root, void* contents, size_t size, unsigned int options, xml_encoding encoding, bool is_mutable, bool own, char_t** out_buffer)</a>
<a name="ln4650">	{</a>
<a name="ln4651">		// check input buffer</a>
<a name="ln4652">		if (!contents &amp;&amp; size) return make_parse_result(status_io_error);</a>
<a name="ln4653"> </a>
<a name="ln4654">		// get actual encoding</a>
<a name="ln4655">		xml_encoding buffer_encoding = impl::get_buffer_encoding(encoding, contents, size);</a>
<a name="ln4656"> </a>
<a name="ln4657">		// get private buffer</a>
<a name="ln4658">		char_t* buffer = 0;</a>
<a name="ln4659">		size_t length = 0;</a>
<a name="ln4660"> </a>
<a name="ln4661">		if (!impl::convert_buffer(buffer, length, buffer_encoding, contents, size, is_mutable)) return impl::make_parse_result(status_out_of_memory);</a>
<a name="ln4662"> </a>
<a name="ln4663">		// delete original buffer if we performed a conversion</a>
<a name="ln4664">		if (own &amp;&amp; buffer != contents &amp;&amp; contents) impl::xml_memory::deallocate(contents);</a>
<a name="ln4665"> </a>
<a name="ln4666">		// grab onto buffer if it's our buffer, user is responsible for deallocating contents himself</a>
<a name="ln4667">		if (own || buffer != contents) *out_buffer = buffer;</a>
<a name="ln4668"> </a>
<a name="ln4669">		// store buffer for offset_debug</a>
<a name="ln4670">		doc-&gt;buffer = buffer;</a>
<a name="ln4671"> </a>
<a name="ln4672">		// parse</a>
<a name="ln4673">		xml_parse_result res = impl::xml_parser::parse(buffer, length, doc, root, options);</a>
<a name="ln4674"> </a>
<a name="ln4675">		// remember encoding</a>
<a name="ln4676">		res.encoding = buffer_encoding;</a>
<a name="ln4677"> </a>
<a name="ln4678">		return res;</a>
<a name="ln4679">	}</a>
<a name="ln4680"> </a>
<a name="ln4681">	// we need to get length of entire file to load it in memory; the only (relatively) sane way to do it is via seek/tell trick</a>
<a name="ln4682">	PUGI__FN xml_parse_status get_file_size(FILE* file, size_t&amp; out_result)</a>
<a name="ln4683">	{</a>
<a name="ln4684">	#if defined(PUGI__MSVC_CRT_VERSION) &amp;&amp; PUGI__MSVC_CRT_VERSION &gt;= 1400 &amp;&amp; !defined(_WIN32_WCE)</a>
<a name="ln4685">		// there are 64-bit versions of fseek/ftell, let's use them</a>
<a name="ln4686">		typedef __int64 length_type;</a>
<a name="ln4687"> </a>
<a name="ln4688">		_fseeki64(file, 0, SEEK_END);</a>
<a name="ln4689">		length_type length = _ftelli64(file);</a>
<a name="ln4690">		_fseeki64(file, 0, SEEK_SET);</a>
<a name="ln4691">	#elif defined(__MINGW32__) &amp;&amp; !defined(__NO_MINGW_LFS) &amp;&amp; (!defined(__STRICT_ANSI__) || defined(__MINGW64_VERSION_MAJOR))</a>
<a name="ln4692">		// there are 64-bit versions of fseek/ftell, let's use them</a>
<a name="ln4693">		typedef off64_t length_type;</a>
<a name="ln4694"> </a>
<a name="ln4695">		fseeko64(file, 0, SEEK_END);</a>
<a name="ln4696">		length_type length = ftello64(file);</a>
<a name="ln4697">		fseeko64(file, 0, SEEK_SET);</a>
<a name="ln4698">	#else</a>
<a name="ln4699">		// if this is a 32-bit OS, long is enough; if this is a unix system, long is 64-bit, which is enough; otherwise we can't do anything anyway.</a>
<a name="ln4700">		typedef long length_type;</a>
<a name="ln4701"> </a>
<a name="ln4702">		fseek(file, 0, SEEK_END);</a>
<a name="ln4703">		length_type length = ftell(file);</a>
<a name="ln4704">		fseek(file, 0, SEEK_SET);</a>
<a name="ln4705">	#endif</a>
<a name="ln4706"> </a>
<a name="ln4707">		// check for I/O errors</a>
<a name="ln4708">		if (length &lt; 0) return status_io_error;</a>
<a name="ln4709"> </a>
<a name="ln4710">		// check for overflow</a>
<a name="ln4711">		size_t result = static_cast&lt;size_t&gt;(length);</a>
<a name="ln4712"> </a>
<a name="ln4713">		if (static_cast&lt;length_type&gt;(result) != length) return status_out_of_memory;</a>
<a name="ln4714"> </a>
<a name="ln4715">		// finalize</a>
<a name="ln4716">		out_result = result;</a>
<a name="ln4717"> </a>
<a name="ln4718">		return status_ok;</a>
<a name="ln4719">	}</a>
<a name="ln4720"> </a>
<a name="ln4721">	// This function assumes that buffer has extra sizeof(char_t) writable bytes after size</a>
<a name="ln4722">	PUGI__FN size_t zero_terminate_buffer(void* buffer, size_t size, xml_encoding encoding)</a>
<a name="ln4723">	{</a>
<a name="ln4724">		// We only need to zero-terminate if encoding conversion does not do it for us</a>
<a name="ln4725">	#ifdef PUGIXML_WCHAR_MODE</a>
<a name="ln4726">		xml_encoding wchar_encoding = get_wchar_encoding();</a>
<a name="ln4727"> </a>
<a name="ln4728">		if (encoding == wchar_encoding || need_endian_swap_utf(encoding, wchar_encoding))</a>
<a name="ln4729">		{</a>
<a name="ln4730">			size_t length = size / sizeof(char_t);</a>
<a name="ln4731"> </a>
<a name="ln4732">			static_cast&lt;char_t*&gt;(buffer)[length] = 0;</a>
<a name="ln4733">			return (length + 1) * sizeof(char_t);</a>
<a name="ln4734">		}</a>
<a name="ln4735">	#else</a>
<a name="ln4736">		if (encoding == encoding_utf8)</a>
<a name="ln4737">		{</a>
<a name="ln4738">			static_cast&lt;char*&gt;(buffer)[size] = 0;</a>
<a name="ln4739">			return size + 1;</a>
<a name="ln4740">		}</a>
<a name="ln4741">	#endif</a>
<a name="ln4742"> </a>
<a name="ln4743">		return size;</a>
<a name="ln4744">	}</a>
<a name="ln4745"> </a>
<a name="ln4746">	PUGI__FN xml_parse_result load_file_impl(xml_document_struct* doc, FILE* file, unsigned int options, xml_encoding encoding, char_t** out_buffer)</a>
<a name="ln4747">	{</a>
<a name="ln4748">		if (!file) return make_parse_result(status_file_not_found);</a>
<a name="ln4749"> </a>
<a name="ln4750">		// get file size (can result in I/O errors)</a>
<a name="ln4751">		size_t size = 0;</a>
<a name="ln4752">		xml_parse_status size_status = get_file_size(file, size);</a>
<a name="ln4753">		if (size_status != status_ok) return make_parse_result(size_status);</a>
<a name="ln4754"> </a>
<a name="ln4755">		size_t max_suffix_size = sizeof(char_t);</a>
<a name="ln4756"> </a>
<a name="ln4757">		// allocate buffer for the whole file</a>
<a name="ln4758">		char* contents = static_cast&lt;char*&gt;(xml_memory::allocate(size + max_suffix_size));</a>
<a name="ln4759">		if (!contents) return make_parse_result(status_out_of_memory);</a>
<a name="ln4760"> </a>
<a name="ln4761">		// read file in memory</a>
<a name="ln4762">		size_t read_size = fread(contents, 1, size, file);</a>
<a name="ln4763"> </a>
<a name="ln4764">		if (read_size != size)</a>
<a name="ln4765">		{</a>
<a name="ln4766">			xml_memory::deallocate(contents);</a>
<a name="ln4767">			return make_parse_result(status_io_error);</a>
<a name="ln4768">		}</a>
<a name="ln4769"> </a>
<a name="ln4770">		xml_encoding real_encoding = get_buffer_encoding(encoding, contents, size);</a>
<a name="ln4771"> </a>
<a name="ln4772">		return load_buffer_impl(doc, doc, contents, zero_terminate_buffer(contents, size, real_encoding), options, real_encoding, true, true, out_buffer);</a>
<a name="ln4773">	}</a>
<a name="ln4774"> </a>
<a name="ln4775">	PUGI__FN void close_file(FILE* file)</a>
<a name="ln4776">	{</a>
<a name="ln4777">		fclose(file);</a>
<a name="ln4778">	}</a>
<a name="ln4779"> </a>
<a name="ln4780">#ifndef PUGIXML_NO_STL</a>
<a name="ln4781">	template &lt;typename T&gt; struct xml_stream_chunk</a>
<a name="ln4782">	{</a>
<a name="ln4783">		static xml_stream_chunk* create()</a>
<a name="ln4784">		{</a>
<a name="ln4785">			void* memory = xml_memory::allocate(sizeof(xml_stream_chunk));</a>
<a name="ln4786">			if (!memory) return 0;</a>
<a name="ln4787"> </a>
<a name="ln4788">			return new (memory) xml_stream_chunk();</a>
<a name="ln4789">		}</a>
<a name="ln4790"> </a>
<a name="ln4791">		static void destroy(xml_stream_chunk* chunk)</a>
<a name="ln4792">		{</a>
<a name="ln4793">			// free chunk chain</a>
<a name="ln4794">			while (chunk)</a>
<a name="ln4795">			{</a>
<a name="ln4796">				xml_stream_chunk* next_ = chunk-&gt;next;</a>
<a name="ln4797"> </a>
<a name="ln4798">				xml_memory::deallocate(chunk);</a>
<a name="ln4799"> </a>
<a name="ln4800">				chunk = next_;</a>
<a name="ln4801">			}</a>
<a name="ln4802">		}</a>
<a name="ln4803"> </a>
<a name="ln4804">		xml_stream_chunk(): next(0), size(0)</a>
<a name="ln4805">		{</a>
<a name="ln4806">		}</a>
<a name="ln4807"> </a>
<a name="ln4808">		xml_stream_chunk* next;</a>
<a name="ln4809">		size_t size;</a>
<a name="ln4810"> </a>
<a name="ln4811">		T data[xml_memory_page_size / sizeof(T)];</a>
<a name="ln4812">	};</a>
<a name="ln4813"> </a>
<a name="ln4814">	template &lt;typename T&gt; PUGI__FN xml_parse_status load_stream_data_noseek(std::basic_istream&lt;T&gt;&amp; stream, void** out_buffer, size_t* out_size)</a>
<a name="ln4815">	{</a>
<a name="ln4816">		auto_deleter&lt;xml_stream_chunk&lt;T&gt; &gt; chunks(0, xml_stream_chunk&lt;T&gt;::destroy);</a>
<a name="ln4817"> </a>
<a name="ln4818">		// read file to a chunk list</a>
<a name="ln4819">		size_t total = 0;</a>
<a name="ln4820">		xml_stream_chunk&lt;T&gt;* last = 0;</a>
<a name="ln4821"> </a>
<a name="ln4822">		while (!stream.eof())</a>
<a name="ln4823">		{</a>
<a name="ln4824">			// allocate new chunk</a>
<a name="ln4825">			xml_stream_chunk&lt;T&gt;* chunk = xml_stream_chunk&lt;T&gt;::create();</a>
<a name="ln4826">			if (!chunk) return status_out_of_memory;</a>
<a name="ln4827"> </a>
<a name="ln4828">			// append chunk to list</a>
<a name="ln4829">			if (last) last = last-&gt;next = chunk;</a>
<a name="ln4830">			else chunks.data = last = chunk;</a>
<a name="ln4831"> </a>
<a name="ln4832">			// read data to chunk</a>
<a name="ln4833">			stream.read(chunk-&gt;data, static_cast&lt;std::streamsize&gt;(sizeof(chunk-&gt;data) / sizeof(T)));</a>
<a name="ln4834">			chunk-&gt;size = static_cast&lt;size_t&gt;(stream.gcount()) * sizeof(T);</a>
<a name="ln4835"> </a>
<a name="ln4836">			// read may set failbit | eofbit in case gcount() is less than read length, so check for other I/O errors</a>
<a name="ln4837">			if (stream.bad() || (!stream.eof() &amp;&amp; stream.fail())) return status_io_error;</a>
<a name="ln4838"> </a>
<a name="ln4839">			// guard against huge files (chunk size is small enough to make this overflow check work)</a>
<a name="ln4840">			if (total + chunk-&gt;size &lt; total) return status_out_of_memory;</a>
<a name="ln4841">			total += chunk-&gt;size;</a>
<a name="ln4842">		}</a>
<a name="ln4843"> </a>
<a name="ln4844">		size_t max_suffix_size = sizeof(char_t);</a>
<a name="ln4845"> </a>
<a name="ln4846">		// copy chunk list to a contiguous buffer</a>
<a name="ln4847">		char* buffer = static_cast&lt;char*&gt;(xml_memory::allocate(total + max_suffix_size));</a>
<a name="ln4848">		if (!buffer) return status_out_of_memory;</a>
<a name="ln4849"> </a>
<a name="ln4850">		char* write = buffer;</a>
<a name="ln4851"> </a>
<a name="ln4852">		for (xml_stream_chunk&lt;T&gt;* chunk = chunks.data; chunk; chunk = chunk-&gt;next)</a>
<a name="ln4853">		{</a>
<a name="ln4854">			assert(write + chunk-&gt;size &lt;= buffer + total);</a>
<a name="ln4855">			memcpy(write, chunk-&gt;data, chunk-&gt;size);</a>
<a name="ln4856">			write += chunk-&gt;size;</a>
<a name="ln4857">		}</a>
<a name="ln4858"> </a>
<a name="ln4859">		assert(write == buffer + total);</a>
<a name="ln4860"> </a>
<a name="ln4861">		// return buffer</a>
<a name="ln4862">		*out_buffer = buffer;</a>
<a name="ln4863">		*out_size = total;</a>
<a name="ln4864"> </a>
<a name="ln4865">		return status_ok;</a>
<a name="ln4866">	}</a>
<a name="ln4867"> </a>
<a name="ln4868">	template &lt;typename T&gt; PUGI__FN xml_parse_status load_stream_data_seek(std::basic_istream&lt;T&gt;&amp; stream, void** out_buffer, size_t* out_size)</a>
<a name="ln4869">	{</a>
<a name="ln4870">		// get length of remaining data in stream</a>
<a name="ln4871">		typename std::basic_istream&lt;T&gt;::pos_type pos = stream.tellg();</a>
<a name="ln4872">		stream.seekg(0, std::ios::end);</a>
<a name="ln4873">		std::streamoff length = stream.tellg() - pos;</a>
<a name="ln4874">		stream.seekg(pos);</a>
<a name="ln4875"> </a>
<a name="ln4876">		if (stream.fail() || pos &lt; 0) return status_io_error;</a>
<a name="ln4877"> </a>
<a name="ln4878">		// guard against huge files</a>
<a name="ln4879">		size_t read_length = static_cast&lt;size_t&gt;(length);</a>
<a name="ln4880"> </a>
<a name="ln4881">		if (static_cast&lt;std::streamsize&gt;(read_length) != length || length &lt; 0) return status_out_of_memory;</a>
<a name="ln4882"> </a>
<a name="ln4883">		size_t max_suffix_size = sizeof(char_t);</a>
<a name="ln4884"> </a>
<a name="ln4885">		// read stream data into memory (guard against stream exceptions with buffer holder)</a>
<a name="ln4886">		auto_deleter&lt;void&gt; buffer(xml_memory::allocate(read_length * sizeof(T) + max_suffix_size), xml_memory::deallocate);</a>
<a name="ln4887">		if (!buffer.data) return status_out_of_memory;</a>
<a name="ln4888"> </a>
<a name="ln4889">		stream.read(static_cast&lt;T*&gt;(buffer.data), static_cast&lt;std::streamsize&gt;(read_length));</a>
<a name="ln4890"> </a>
<a name="ln4891">		// read may set failbit | eofbit in case gcount() is less than read_length (i.e. line ending conversion), so check for other I/O errors</a>
<a name="ln4892">		if (stream.bad() || (!stream.eof() &amp;&amp; stream.fail())) return status_io_error;</a>
<a name="ln4893"> </a>
<a name="ln4894">		// return buffer</a>
<a name="ln4895">		size_t actual_length = static_cast&lt;size_t&gt;(stream.gcount());</a>
<a name="ln4896">		assert(actual_length &lt;= read_length);</a>
<a name="ln4897"> </a>
<a name="ln4898">		*out_buffer = buffer.release();</a>
<a name="ln4899">		*out_size = actual_length * sizeof(T);</a>
<a name="ln4900"> </a>
<a name="ln4901">		return status_ok;</a>
<a name="ln4902">	}</a>
<a name="ln4903"> </a>
<a name="ln4904">	template &lt;typename T&gt; PUGI__FN xml_parse_result load_stream_impl(xml_document_struct* doc, std::basic_istream&lt;T&gt;&amp; stream, unsigned int options, xml_encoding encoding, char_t** out_buffer)</a>
<a name="ln4905">	{</a>
<a name="ln4906">		void* buffer = 0;</a>
<a name="ln4907">		size_t size = 0;</a>
<a name="ln4908">		xml_parse_status status = status_ok;</a>
<a name="ln4909"> </a>
<a name="ln4910">		// if stream has an error bit set, bail out (otherwise tellg() can fail and we'll clear error bits)</a>
<a name="ln4911">		if (stream.fail()) return make_parse_result(status_io_error);</a>
<a name="ln4912"> </a>
<a name="ln4913">		// load stream to memory (using seek-based implementation if possible, since it's faster and takes less memory)</a>
<a name="ln4914">		if (stream.tellg() &lt; 0)</a>
<a name="ln4915">		{</a>
<a name="ln4916">			stream.clear(); // clear error flags that could be set by a failing tellg</a>
<a name="ln4917">			status = load_stream_data_noseek(stream, &amp;buffer, &amp;size);</a>
<a name="ln4918">		}</a>
<a name="ln4919">		else</a>
<a name="ln4920">			status = load_stream_data_seek(stream, &amp;buffer, &amp;size);</a>
<a name="ln4921"> </a>
<a name="ln4922">		if (status != status_ok) return make_parse_result(status);</a>
<a name="ln4923"> </a>
<a name="ln4924">		xml_encoding real_encoding = get_buffer_encoding(encoding, buffer, size);</a>
<a name="ln4925"> </a>
<a name="ln4926">		return load_buffer_impl(doc, doc, buffer, zero_terminate_buffer(buffer, size, real_encoding), options, real_encoding, true, true, out_buffer);</a>
<a name="ln4927">	}</a>
<a name="ln4928">#endif</a>
<a name="ln4929"> </a>
<a name="ln4930">#if defined(PUGI__MSVC_CRT_VERSION) || defined(__BORLANDC__) || (defined(__MINGW32__) &amp;&amp; (!defined(__STRICT_ANSI__) || defined(__MINGW64_VERSION_MAJOR)))</a>
<a name="ln4931">	PUGI__FN FILE* open_file_wide(const wchar_t* path, const wchar_t* mode)</a>
<a name="ln4932">	{</a>
<a name="ln4933">		return _wfopen(path, mode);</a>
<a name="ln4934">	}</a>
<a name="ln4935">#else</a>
<a name="ln4936">	PUGI__FN char* convert_path_heap(const wchar_t* str)</a>
<a name="ln4937">	{</a>
<a name="ln4938">		assert(str);</a>
<a name="ln4939"> </a>
<a name="ln4940">		// first pass: get length in utf8 characters</a>
<a name="ln4941">		size_t length = strlength_wide(str);</a>
<a name="ln4942">		size_t size = as_utf8_begin(str, length);</a>
<a name="ln4943"> </a>
<a name="ln4944">		// allocate resulting string</a>
<a name="ln4945">		char* result = static_cast&lt;char*&gt;(xml_memory::allocate(size + 1));</a>
<a name="ln4946">		if (!result) return 0;</a>
<a name="ln4947"> </a>
<a name="ln4948">		// second pass: convert to utf8</a>
<a name="ln4949">		as_utf8_end(result, size, str, length);</a>
<a name="ln4950"> </a>
<a name="ln4951">		// zero-terminate</a>
<a name="ln4952">		result[size] = 0;</a>
<a name="ln4953"> </a>
<a name="ln4954">		return result;</a>
<a name="ln4955">	}</a>
<a name="ln4956"> </a>
<a name="ln4957">	PUGI__FN FILE* open_file_wide(const wchar_t* path, const wchar_t* mode)</a>
<a name="ln4958">	{</a>
<a name="ln4959">		// there is no standard function to open wide paths, so our best bet is to try utf8 path</a>
<a name="ln4960">		char* path_utf8 = convert_path_heap(path);</a>
<a name="ln4961">		if (!path_utf8) return 0;</a>
<a name="ln4962"> </a>
<a name="ln4963">		// convert mode to ASCII (we mirror _wfopen interface)</a>
<a name="ln4964">		char mode_ascii[4] = {0};</a>
<a name="ln4965">		for (size_t i = 0; mode[i]; ++i) mode_ascii[i] = static_cast&lt;char&gt;(mode[i]);</a>
<a name="ln4966"> </a>
<a name="ln4967">		// try to open the utf8 path</a>
<a name="ln4968">		FILE* result = fopen(path_utf8, mode_ascii);</a>
<a name="ln4969"> </a>
<a name="ln4970">		// free dummy buffer</a>
<a name="ln4971">		xml_memory::deallocate(path_utf8);</a>
<a name="ln4972"> </a>
<a name="ln4973">		return result;</a>
<a name="ln4974">	}</a>
<a name="ln4975">#endif</a>
<a name="ln4976"> </a>
<a name="ln4977">	PUGI__FN bool save_file_impl(const xml_document&amp; doc, FILE* file, const char_t* indent, unsigned int flags, xml_encoding encoding)</a>
<a name="ln4978">	{</a>
<a name="ln4979">		if (!file) return false;</a>
<a name="ln4980"> </a>
<a name="ln4981">		xml_writer_file writer(file);</a>
<a name="ln4982">		doc.save(writer, indent, flags, encoding);</a>
<a name="ln4983"> </a>
<a name="ln4984">		return ferror(file) == 0;</a>
<a name="ln4985">	}</a>
<a name="ln4986"> </a>
<a name="ln4987">	struct name_null_sentry</a>
<a name="ln4988">	{</a>
<a name="ln4989">		xml_node_struct* node;</a>
<a name="ln4990">		char_t* name;</a>
<a name="ln4991"> </a>
<a name="ln4992">		name_null_sentry(xml_node_struct* node_): node(node_), name(node_-&gt;name)</a>
<a name="ln4993">		{</a>
<a name="ln4994">			node-&gt;name = 0;</a>
<a name="ln4995">		}</a>
<a name="ln4996"> </a>
<a name="ln4997">		~name_null_sentry()</a>
<a name="ln4998">		{</a>
<a name="ln4999">			node-&gt;name = name;</a>
<a name="ln5000">		}</a>
<a name="ln5001">	};</a>
<a name="ln5002">PUGI__NS_END</a>
<a name="ln5003"> </a>
<a name="ln5004">namespace pugi</a>
<a name="ln5005">{</a>
<a name="ln5006">	PUGI__FN xml_writer_file::xml_writer_file(void* file_): file(file_)</a>
<a name="ln5007">	{</a>
<a name="ln5008">	}</a>
<a name="ln5009"> </a>
<a name="ln5010">	PUGI__FN void xml_writer_file::write(const void* data, size_t size)</a>
<a name="ln5011">	{</a>
<a name="ln5012">		size_t result = fwrite(data, 1, size, static_cast&lt;FILE*&gt;(file));</a>
<a name="ln5013">		(void)!result; // unfortunately we can't do proper error handling here</a>
<a name="ln5014">	}</a>
<a name="ln5015"> </a>
<a name="ln5016">#ifndef PUGIXML_NO_STL</a>
<a name="ln5017">	PUGI__FN xml_writer_stream::xml_writer_stream(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; stream): narrow_stream(&amp;stream), wide_stream(0)</a>
<a name="ln5018">	{</a>
<a name="ln5019">	}</a>
<a name="ln5020"> </a>
<a name="ln5021">	PUGI__FN xml_writer_stream::xml_writer_stream(std::basic_ostream&lt;wchar_t, std::char_traits&lt;wchar_t&gt; &gt;&amp; stream): narrow_stream(0), wide_stream(&amp;stream)</a>
<a name="ln5022">	{</a>
<a name="ln5023">	}</a>
<a name="ln5024"> </a>
<a name="ln5025">	PUGI__FN void xml_writer_stream::write(const void* data, size_t size)</a>
<a name="ln5026">	{</a>
<a name="ln5027">		if (narrow_stream)</a>
<a name="ln5028">		{</a>
<a name="ln5029">			assert(!wide_stream);</a>
<a name="ln5030">      narrow_stream-&gt;imbue(std::locale(narrow_stream-&gt;getloc(), new punct_facet&lt;char, '.'&gt;));</a>
<a name="ln5031">			narrow_stream-&gt;write(reinterpret_cast&lt;const char*&gt;(data), static_cast&lt;std::streamsize&gt;(size));</a>
<a name="ln5032">		}</a>
<a name="ln5033">		else</a>
<a name="ln5034">		{</a>
<a name="ln5035">			assert(wide_stream);</a>
<a name="ln5036">			assert(size % sizeof(wchar_t) == 0);</a>
<a name="ln5037">      wide_stream-&gt;imbue(std::locale(wide_stream-&gt;getloc(), new punct_facet&lt;char, '.'&gt;));</a>
<a name="ln5038">			wide_stream-&gt;write(reinterpret_cast&lt;const wchar_t*&gt;(data), static_cast&lt;std::streamsize&gt;(size / sizeof(wchar_t)));</a>
<a name="ln5039">		}</a>
<a name="ln5040">	}</a>
<a name="ln5041">#endif</a>
<a name="ln5042"> </a>
<a name="ln5043">	PUGI__FN xml_tree_walker::xml_tree_walker(): _depth(0)</a>
<a name="ln5044">	{</a>
<a name="ln5045">	}</a>
<a name="ln5046"> </a>
<a name="ln5047">	PUGI__FN xml_tree_walker::~xml_tree_walker()</a>
<a name="ln5048">	{</a>
<a name="ln5049">	}</a>
<a name="ln5050"> </a>
<a name="ln5051">	PUGI__FN int xml_tree_walker::depth() const</a>
<a name="ln5052">	{</a>
<a name="ln5053">		return _depth;</a>
<a name="ln5054">	}</a>
<a name="ln5055"> </a>
<a name="ln5056">	PUGI__FN bool xml_tree_walker::begin(xml_node&amp;)</a>
<a name="ln5057">	{</a>
<a name="ln5058">		return true;</a>
<a name="ln5059">	}</a>
<a name="ln5060"> </a>
<a name="ln5061">	PUGI__FN bool xml_tree_walker::end(xml_node&amp;)</a>
<a name="ln5062">	{</a>
<a name="ln5063">		return true;</a>
<a name="ln5064">	}</a>
<a name="ln5065"> </a>
<a name="ln5066">	PUGI__FN xml_attribute::xml_attribute(): _attr(0)</a>
<a name="ln5067">	{</a>
<a name="ln5068">	}</a>
<a name="ln5069"> </a>
<a name="ln5070">	PUGI__FN xml_attribute::xml_attribute(xml_attribute_struct* attr): _attr(attr)</a>
<a name="ln5071">	{</a>
<a name="ln5072">	}</a>
<a name="ln5073"> </a>
<a name="ln5074">	PUGI__FN static void unspecified_bool_xml_attribute(xml_attribute***)</a>
<a name="ln5075">	{</a>
<a name="ln5076">	}</a>
<a name="ln5077"> </a>
<a name="ln5078">	PUGI__FN xml_attribute::operator xml_attribute::unspecified_bool_type() const</a>
<a name="ln5079">	{</a>
<a name="ln5080">		return _attr ? unspecified_bool_xml_attribute : 0;</a>
<a name="ln5081">	}</a>
<a name="ln5082"> </a>
<a name="ln5083">	PUGI__FN bool xml_attribute::operator!() const</a>
<a name="ln5084">	{</a>
<a name="ln5085">		return !_attr;</a>
<a name="ln5086">	}</a>
<a name="ln5087"> </a>
<a name="ln5088">	PUGI__FN bool xml_attribute::operator==(const xml_attribute&amp; r) const</a>
<a name="ln5089">	{</a>
<a name="ln5090">		return (_attr == r._attr);</a>
<a name="ln5091">	}</a>
<a name="ln5092"> </a>
<a name="ln5093">	PUGI__FN bool xml_attribute::operator!=(const xml_attribute&amp; r) const</a>
<a name="ln5094">	{</a>
<a name="ln5095">		return (_attr != r._attr);</a>
<a name="ln5096">	}</a>
<a name="ln5097"> </a>
<a name="ln5098">	PUGI__FN bool xml_attribute::operator&lt;(const xml_attribute&amp; r) const</a>
<a name="ln5099">	{</a>
<a name="ln5100">		return (_attr &lt; r._attr);</a>
<a name="ln5101">	}</a>
<a name="ln5102"> </a>
<a name="ln5103">	PUGI__FN bool xml_attribute::operator&gt;(const xml_attribute&amp; r) const</a>
<a name="ln5104">	{</a>
<a name="ln5105">		return (_attr &gt; r._attr);</a>
<a name="ln5106">	}</a>
<a name="ln5107"> </a>
<a name="ln5108">	PUGI__FN bool xml_attribute::operator&lt;=(const xml_attribute&amp; r) const</a>
<a name="ln5109">	{</a>
<a name="ln5110">		return (_attr &lt;= r._attr);</a>
<a name="ln5111">	}</a>
<a name="ln5112"> </a>
<a name="ln5113">	PUGI__FN bool xml_attribute::operator&gt;=(const xml_attribute&amp; r) const</a>
<a name="ln5114">	{</a>
<a name="ln5115">		return (_attr &gt;= r._attr);</a>
<a name="ln5116">	}</a>
<a name="ln5117"> </a>
<a name="ln5118">	PUGI__FN xml_attribute xml_attribute::next_attribute() const</a>
<a name="ln5119">	{</a>
<a name="ln5120">		return _attr ? xml_attribute(_attr-&gt;next_attribute) : xml_attribute();</a>
<a name="ln5121">	}</a>
<a name="ln5122"> </a>
<a name="ln5123">	PUGI__FN xml_attribute xml_attribute::previous_attribute() const</a>
<a name="ln5124">	{</a>
<a name="ln5125">		return _attr &amp;&amp; _attr-&gt;prev_attribute_c-&gt;next_attribute ? xml_attribute(_attr-&gt;prev_attribute_c) : xml_attribute();</a>
<a name="ln5126">	}</a>
<a name="ln5127"> </a>
<a name="ln5128">	PUGI__FN const char_t* xml_attribute::as_string(const char_t* def) const</a>
<a name="ln5129">	{</a>
<a name="ln5130">		return (_attr &amp;&amp; _attr-&gt;value) ? _attr-&gt;value + 0 : def;</a>
<a name="ln5131">	}</a>
<a name="ln5132"> </a>
<a name="ln5133">	PUGI__FN int xml_attribute::as_int(int def) const</a>
<a name="ln5134">	{</a>
<a name="ln5135">		return (_attr &amp;&amp; _attr-&gt;value) ? impl::get_value_int(_attr-&gt;value) : def;</a>
<a name="ln5136">	}</a>
<a name="ln5137"> </a>
<a name="ln5138">	PUGI__FN unsigned int xml_attribute::as_uint(unsigned int def) const</a>
<a name="ln5139">	{</a>
<a name="ln5140">		return (_attr &amp;&amp; _attr-&gt;value) ? impl::get_value_uint(_attr-&gt;value) : def;</a>
<a name="ln5141">	}</a>
<a name="ln5142"> </a>
<a name="ln5143">	PUGI__FN double xml_attribute::as_double(double def) const</a>
<a name="ln5144">	{</a>
<a name="ln5145">		return (_attr &amp;&amp; _attr-&gt;value) ? impl::get_value_double(_attr-&gt;value) : def;</a>
<a name="ln5146">	}</a>
<a name="ln5147"> </a>
<a name="ln5148">	PUGI__FN float xml_attribute::as_float(float def) const</a>
<a name="ln5149">	{</a>
<a name="ln5150">		return (_attr &amp;&amp; _attr-&gt;value) ? impl::get_value_float(_attr-&gt;value) : def;</a>
<a name="ln5151">	}</a>
<a name="ln5152"> </a>
<a name="ln5153">	PUGI__FN bool xml_attribute::as_bool(bool def) const</a>
<a name="ln5154">	{</a>
<a name="ln5155">		return (_attr &amp;&amp; _attr-&gt;value) ? impl::get_value_bool(_attr-&gt;value) : def;</a>
<a name="ln5156">	}</a>
<a name="ln5157"> </a>
<a name="ln5158">#ifdef PUGIXML_HAS_LONG_LONG</a>
<a name="ln5159">	PUGI__FN long long xml_attribute::as_llong(long long def) const</a>
<a name="ln5160">	{</a>
<a name="ln5161">		return (_attr &amp;&amp; _attr-&gt;value) ? impl::get_value_llong(_attr-&gt;value) : def;</a>
<a name="ln5162">	}</a>
<a name="ln5163"> </a>
<a name="ln5164">	PUGI__FN unsigned long long xml_attribute::as_ullong(unsigned long long def) const</a>
<a name="ln5165">	{</a>
<a name="ln5166">		return (_attr &amp;&amp; _attr-&gt;value) ? impl::get_value_ullong(_attr-&gt;value) : def;</a>
<a name="ln5167">	}</a>
<a name="ln5168">#endif</a>
<a name="ln5169"> </a>
<a name="ln5170">	PUGI__FN bool xml_attribute::empty() const</a>
<a name="ln5171">	{</a>
<a name="ln5172">		return !_attr;</a>
<a name="ln5173">	}</a>
<a name="ln5174"> </a>
<a name="ln5175">	PUGI__FN const char_t* xml_attribute::name() const</a>
<a name="ln5176">	{</a>
<a name="ln5177">		return (_attr &amp;&amp; _attr-&gt;name) ? _attr-&gt;name + 0 : PUGIXML_TEXT(&quot;&quot;);</a>
<a name="ln5178">	}</a>
<a name="ln5179"> </a>
<a name="ln5180">	PUGI__FN const char_t* xml_attribute::value() const</a>
<a name="ln5181">	{</a>
<a name="ln5182">		return (_attr &amp;&amp; _attr-&gt;value) ? _attr-&gt;value + 0 : PUGIXML_TEXT(&quot;&quot;);</a>
<a name="ln5183">	}</a>
<a name="ln5184"> </a>
<a name="ln5185">	PUGI__FN size_t xml_attribute::hash_value() const</a>
<a name="ln5186">	{</a>
<a name="ln5187">		return static_cast&lt;size_t&gt;(reinterpret_cast&lt;uintptr_t&gt;(_attr) / sizeof(xml_attribute_struct));</a>
<a name="ln5188">	}</a>
<a name="ln5189"> </a>
<a name="ln5190">	PUGI__FN xml_attribute_struct* xml_attribute::internal_object() const</a>
<a name="ln5191">	{</a>
<a name="ln5192">		return _attr;</a>
<a name="ln5193">	}</a>
<a name="ln5194"> </a>
<a name="ln5195">	PUGI__FN xml_attribute&amp; xml_attribute::operator=(const char_t* rhs)</a>
<a name="ln5196">	{</a>
<a name="ln5197">		set_value(rhs);</a>
<a name="ln5198">		return *this;</a>
<a name="ln5199">	}</a>
<a name="ln5200"> </a>
<a name="ln5201">	PUGI__FN xml_attribute&amp; xml_attribute::operator=(int rhs)</a>
<a name="ln5202">	{</a>
<a name="ln5203">		set_value(rhs);</a>
<a name="ln5204">		return *this;</a>
<a name="ln5205">	}</a>
<a name="ln5206"> </a>
<a name="ln5207">	PUGI__FN xml_attribute&amp; xml_attribute::operator=(unsigned int rhs)</a>
<a name="ln5208">	{</a>
<a name="ln5209">		set_value(rhs);</a>
<a name="ln5210">		return *this;</a>
<a name="ln5211">	}</a>
<a name="ln5212"> </a>
<a name="ln5213">	PUGI__FN xml_attribute&amp; xml_attribute::operator=(long rhs)</a>
<a name="ln5214">	{</a>
<a name="ln5215">		set_value(rhs);</a>
<a name="ln5216">		return *this;</a>
<a name="ln5217">	}</a>
<a name="ln5218"> </a>
<a name="ln5219">	PUGI__FN xml_attribute&amp; xml_attribute::operator=(unsigned long rhs)</a>
<a name="ln5220">	{</a>
<a name="ln5221">		set_value(rhs);</a>
<a name="ln5222">		return *this;</a>
<a name="ln5223">	}</a>
<a name="ln5224"> </a>
<a name="ln5225">	PUGI__FN xml_attribute&amp; xml_attribute::operator=(double rhs)</a>
<a name="ln5226">	{</a>
<a name="ln5227">		set_value(rhs);</a>
<a name="ln5228">		return *this;</a>
<a name="ln5229">	}</a>
<a name="ln5230"> </a>
<a name="ln5231">	PUGI__FN xml_attribute&amp; xml_attribute::operator=(float rhs)</a>
<a name="ln5232">	{</a>
<a name="ln5233">		set_value(rhs);</a>
<a name="ln5234">		return *this;</a>
<a name="ln5235">	}</a>
<a name="ln5236"> </a>
<a name="ln5237">	PUGI__FN xml_attribute&amp; xml_attribute::operator=(bool rhs)</a>
<a name="ln5238">	{</a>
<a name="ln5239">		set_value(rhs);</a>
<a name="ln5240">		return *this;</a>
<a name="ln5241">	}</a>
<a name="ln5242"> </a>
<a name="ln5243">#ifdef PUGIXML_HAS_LONG_LONG</a>
<a name="ln5244">	PUGI__FN xml_attribute&amp; xml_attribute::operator=(long long rhs)</a>
<a name="ln5245">	{</a>
<a name="ln5246">		set_value(rhs);</a>
<a name="ln5247">		return *this;</a>
<a name="ln5248">	}</a>
<a name="ln5249"> </a>
<a name="ln5250">	PUGI__FN xml_attribute&amp; xml_attribute::operator=(unsigned long long rhs)</a>
<a name="ln5251">	{</a>
<a name="ln5252">		set_value(rhs);</a>
<a name="ln5253">		return *this;</a>
<a name="ln5254">	}</a>
<a name="ln5255">#endif</a>
<a name="ln5256"> </a>
<a name="ln5257">	PUGI__FN bool xml_attribute::set_name(const char_t* rhs)</a>
<a name="ln5258">	{</a>
<a name="ln5259">		if (!_attr) return false;</a>
<a name="ln5260"> </a>
<a name="ln5261">		return impl::strcpy_insitu(_attr-&gt;name, _attr-&gt;header, impl::xml_memory_page_name_allocated_mask, rhs, impl::strlength(rhs));</a>
<a name="ln5262">	}</a>
<a name="ln5263"> </a>
<a name="ln5264">	PUGI__FN bool xml_attribute::set_value(const char_t* rhs)</a>
<a name="ln5265">	{</a>
<a name="ln5266">		if (!_attr) return false;</a>
<a name="ln5267"> </a>
<a name="ln5268">		return impl::strcpy_insitu(_attr-&gt;value, _attr-&gt;header, impl::xml_memory_page_value_allocated_mask, rhs, impl::strlength(rhs));</a>
<a name="ln5269">	}</a>
<a name="ln5270"> </a>
<a name="ln5271">	PUGI__FN bool xml_attribute::set_value(int rhs)</a>
<a name="ln5272">	{</a>
<a name="ln5273">		if (!_attr) return false;</a>
<a name="ln5274"> </a>
<a name="ln5275">		return impl::set_value_integer&lt;unsigned int&gt;(_attr-&gt;value, _attr-&gt;header, impl::xml_memory_page_value_allocated_mask, rhs, rhs &lt; 0);</a>
<a name="ln5276">	}</a>
<a name="ln5277"> </a>
<a name="ln5278">	PUGI__FN bool xml_attribute::set_value(unsigned int rhs)</a>
<a name="ln5279">	{</a>
<a name="ln5280">		if (!_attr) return false;</a>
<a name="ln5281"> </a>
<a name="ln5282">		return impl::set_value_integer&lt;unsigned int&gt;(_attr-&gt;value, _attr-&gt;header, impl::xml_memory_page_value_allocated_mask, rhs, false);</a>
<a name="ln5283">	}</a>
<a name="ln5284"> </a>
<a name="ln5285">	PUGI__FN bool xml_attribute::set_value(long rhs)</a>
<a name="ln5286">	{</a>
<a name="ln5287">		if (!_attr) return false;</a>
<a name="ln5288"> </a>
<a name="ln5289">		return impl::set_value_integer&lt;unsigned long&gt;(_attr-&gt;value, _attr-&gt;header, impl::xml_memory_page_value_allocated_mask, rhs, rhs &lt; 0);</a>
<a name="ln5290">	}</a>
<a name="ln5291"> </a>
<a name="ln5292">	PUGI__FN bool xml_attribute::set_value(unsigned long rhs)</a>
<a name="ln5293">	{</a>
<a name="ln5294">		if (!_attr) return false;</a>
<a name="ln5295"> </a>
<a name="ln5296">		return impl::set_value_integer&lt;unsigned long&gt;(_attr-&gt;value, _attr-&gt;header, impl::xml_memory_page_value_allocated_mask, rhs, false);</a>
<a name="ln5297">	}</a>
<a name="ln5298"> </a>
<a name="ln5299">	PUGI__FN bool xml_attribute::set_value(double rhs)</a>
<a name="ln5300">	{</a>
<a name="ln5301">		if (!_attr) return false;</a>
<a name="ln5302"> </a>
<a name="ln5303">		return impl::set_value_convert(_attr-&gt;value, _attr-&gt;header, impl::xml_memory_page_value_allocated_mask, rhs);</a>
<a name="ln5304">	}</a>
<a name="ln5305"> </a>
<a name="ln5306">	PUGI__FN bool xml_attribute::set_value(float rhs)</a>
<a name="ln5307">	{</a>
<a name="ln5308">		if (!_attr) return false;</a>
<a name="ln5309"> </a>
<a name="ln5310">		return impl::set_value_convert(_attr-&gt;value, _attr-&gt;header, impl::xml_memory_page_value_allocated_mask, rhs);</a>
<a name="ln5311">	}</a>
<a name="ln5312"> </a>
<a name="ln5313">	PUGI__FN bool xml_attribute::set_value(bool rhs)</a>
<a name="ln5314">	{</a>
<a name="ln5315">		if (!_attr) return false;</a>
<a name="ln5316"> </a>
<a name="ln5317">		return impl::set_value_bool(_attr-&gt;value, _attr-&gt;header, impl::xml_memory_page_value_allocated_mask, rhs);</a>
<a name="ln5318">	}</a>
<a name="ln5319"> </a>
<a name="ln5320">#ifdef PUGIXML_HAS_LONG_LONG</a>
<a name="ln5321">	PUGI__FN bool xml_attribute::set_value(long long rhs)</a>
<a name="ln5322">	{</a>
<a name="ln5323">		if (!_attr) return false;</a>
<a name="ln5324"> </a>
<a name="ln5325">		return impl::set_value_integer&lt;unsigned long long&gt;(_attr-&gt;value, _attr-&gt;header, impl::xml_memory_page_value_allocated_mask, rhs, rhs &lt; 0);</a>
<a name="ln5326">	}</a>
<a name="ln5327"> </a>
<a name="ln5328">	PUGI__FN bool xml_attribute::set_value(unsigned long long rhs)</a>
<a name="ln5329">	{</a>
<a name="ln5330">		if (!_attr) return false;</a>
<a name="ln5331"> </a>
<a name="ln5332">		return impl::set_value_integer&lt;unsigned long long&gt;(_attr-&gt;value, _attr-&gt;header, impl::xml_memory_page_value_allocated_mask, rhs, false);</a>
<a name="ln5333">	}</a>
<a name="ln5334">#endif</a>
<a name="ln5335"> </a>
<a name="ln5336">#ifdef __BORLANDC__</a>
<a name="ln5337">	PUGI__FN bool operator&amp;&amp;(const xml_attribute&amp; lhs, bool rhs)</a>
<a name="ln5338">	{</a>
<a name="ln5339">		return (bool)lhs &amp;&amp; rhs;</a>
<a name="ln5340">	}</a>
<a name="ln5341"> </a>
<a name="ln5342">	PUGI__FN bool operator||(const xml_attribute&amp; lhs, bool rhs)</a>
<a name="ln5343">	{</a>
<a name="ln5344">		return (bool)lhs || rhs;</a>
<a name="ln5345">	}</a>
<a name="ln5346">#endif</a>
<a name="ln5347"> </a>
<a name="ln5348">	PUGI__FN xml_node::xml_node(): _root(0)</a>
<a name="ln5349">	{</a>
<a name="ln5350">	}</a>
<a name="ln5351"> </a>
<a name="ln5352">	PUGI__FN xml_node::xml_node(xml_node_struct* p): _root(p)</a>
<a name="ln5353">	{</a>
<a name="ln5354">	}</a>
<a name="ln5355"> </a>
<a name="ln5356">	PUGI__FN static void unspecified_bool_xml_node(xml_node***)</a>
<a name="ln5357">	{</a>
<a name="ln5358">	}</a>
<a name="ln5359"> </a>
<a name="ln5360">	PUGI__FN xml_node::operator xml_node::unspecified_bool_type() const</a>
<a name="ln5361">	{</a>
<a name="ln5362">		return _root ? unspecified_bool_xml_node : 0;</a>
<a name="ln5363">	}</a>
<a name="ln5364"> </a>
<a name="ln5365">	PUGI__FN bool xml_node::operator!() const</a>
<a name="ln5366">	{</a>
<a name="ln5367">		return !_root;</a>
<a name="ln5368">	}</a>
<a name="ln5369"> </a>
<a name="ln5370">	PUGI__FN xml_node::iterator xml_node::begin() const</a>
<a name="ln5371">	{</a>
<a name="ln5372">		return iterator(_root ? _root-&gt;first_child + 0 : 0, _root);</a>
<a name="ln5373">	}</a>
<a name="ln5374"> </a>
<a name="ln5375">	PUGI__FN xml_node::iterator xml_node::end() const</a>
<a name="ln5376">	{</a>
<a name="ln5377">		return iterator(0, _root);</a>
<a name="ln5378">	}</a>
<a name="ln5379"> </a>
<a name="ln5380">	PUGI__FN xml_node::attribute_iterator xml_node::attributes_begin() const</a>
<a name="ln5381">	{</a>
<a name="ln5382">		return attribute_iterator(_root ? _root-&gt;first_attribute + 0 : 0, _root);</a>
<a name="ln5383">	}</a>
<a name="ln5384"> </a>
<a name="ln5385">	PUGI__FN xml_node::attribute_iterator xml_node::attributes_end() const</a>
<a name="ln5386">	{</a>
<a name="ln5387">		return attribute_iterator(0, _root);</a>
<a name="ln5388">	}</a>
<a name="ln5389"> </a>
<a name="ln5390">	PUGI__FN xml_object_range&lt;xml_node_iterator&gt; xml_node::children() const</a>
<a name="ln5391">	{</a>
<a name="ln5392">		return xml_object_range&lt;xml_node_iterator&gt;(begin(), end());</a>
<a name="ln5393">	}</a>
<a name="ln5394"> </a>
<a name="ln5395">	PUGI__FN xml_object_range&lt;xml_named_node_iterator&gt; xml_node::children(const char_t* name_) const</a>
<a name="ln5396">	{</a>
<a name="ln5397">		return xml_object_range&lt;xml_named_node_iterator&gt;(xml_named_node_iterator(child(name_)._root, _root, name_), xml_named_node_iterator(0, _root, name_));</a>
<a name="ln5398">	}</a>
<a name="ln5399"> </a>
<a name="ln5400">	PUGI__FN xml_object_range&lt;xml_attribute_iterator&gt; xml_node::attributes() const</a>
<a name="ln5401">	{</a>
<a name="ln5402">		return xml_object_range&lt;xml_attribute_iterator&gt;(attributes_begin(), attributes_end());</a>
<a name="ln5403">	}</a>
<a name="ln5404"> </a>
<a name="ln5405">	PUGI__FN bool xml_node::operator==(const xml_node&amp; r) const</a>
<a name="ln5406">	{</a>
<a name="ln5407">		return (_root == r._root);</a>
<a name="ln5408">	}</a>
<a name="ln5409"> </a>
<a name="ln5410">	PUGI__FN bool xml_node::operator!=(const xml_node&amp; r) const</a>
<a name="ln5411">	{</a>
<a name="ln5412">		return (_root != r._root);</a>
<a name="ln5413">	}</a>
<a name="ln5414"> </a>
<a name="ln5415">	PUGI__FN bool xml_node::operator&lt;(const xml_node&amp; r) const</a>
<a name="ln5416">	{</a>
<a name="ln5417">		return (_root &lt; r._root);</a>
<a name="ln5418">	}</a>
<a name="ln5419"> </a>
<a name="ln5420">	PUGI__FN bool xml_node::operator&gt;(const xml_node&amp; r) const</a>
<a name="ln5421">	{</a>
<a name="ln5422">		return (_root &gt; r._root);</a>
<a name="ln5423">	}</a>
<a name="ln5424"> </a>
<a name="ln5425">	PUGI__FN bool xml_node::operator&lt;=(const xml_node&amp; r) const</a>
<a name="ln5426">	{</a>
<a name="ln5427">		return (_root &lt;= r._root);</a>
<a name="ln5428">	}</a>
<a name="ln5429"> </a>
<a name="ln5430">	PUGI__FN bool xml_node::operator&gt;=(const xml_node&amp; r) const</a>
<a name="ln5431">	{</a>
<a name="ln5432">		return (_root &gt;= r._root);</a>
<a name="ln5433">	}</a>
<a name="ln5434"> </a>
<a name="ln5435">	PUGI__FN bool xml_node::empty() const</a>
<a name="ln5436">	{</a>
<a name="ln5437">		return !_root;</a>
<a name="ln5438">	}</a>
<a name="ln5439"> </a>
<a name="ln5440">	PUGI__FN const char_t* xml_node::name() const</a>
<a name="ln5441">	{</a>
<a name="ln5442">		return (_root &amp;&amp; _root-&gt;name) ? _root-&gt;name + 0 : PUGIXML_TEXT(&quot;&quot;);</a>
<a name="ln5443">	}</a>
<a name="ln5444"> </a>
<a name="ln5445">	PUGI__FN xml_node_type xml_node::type() const</a>
<a name="ln5446">	{</a>
<a name="ln5447">		return _root ? PUGI__NODETYPE(_root) : node_null;</a>
<a name="ln5448">	}</a>
<a name="ln5449"> </a>
<a name="ln5450">	PUGI__FN const char_t* xml_node::value() const</a>
<a name="ln5451">	{</a>
<a name="ln5452">		return (_root &amp;&amp; _root-&gt;value) ? _root-&gt;value + 0 : PUGIXML_TEXT(&quot;&quot;);</a>
<a name="ln5453">	}</a>
<a name="ln5454"> </a>
<a name="ln5455">	PUGI__FN xml_node xml_node::child(const char_t* name_) const</a>
<a name="ln5456">	{</a>
<a name="ln5457">		if (!_root) return xml_node();</a>
<a name="ln5458"> </a>
<a name="ln5459">		for (xml_node_struct* i = _root-&gt;first_child; i; i = i-&gt;next_sibling)</a>
<a name="ln5460">			if (i-&gt;name &amp;&amp; impl::strequal(name_, i-&gt;name)) return xml_node(i);</a>
<a name="ln5461"> </a>
<a name="ln5462">		return xml_node();</a>
<a name="ln5463">	}</a>
<a name="ln5464"> </a>
<a name="ln5465">	PUGI__FN xml_attribute xml_node::attribute(const char_t* name_) const</a>
<a name="ln5466">	{</a>
<a name="ln5467">		if (!_root) return xml_attribute();</a>
<a name="ln5468"> </a>
<a name="ln5469">		for (xml_attribute_struct* i = _root-&gt;first_attribute; i; i = i-&gt;next_attribute)</a>
<a name="ln5470">			if (i-&gt;name &amp;&amp; impl::strequal(name_, i-&gt;name))</a>
<a name="ln5471">				return xml_attribute(i);</a>
<a name="ln5472"> </a>
<a name="ln5473">		return xml_attribute();</a>
<a name="ln5474">	}</a>
<a name="ln5475"> </a>
<a name="ln5476">	PUGI__FN xml_node xml_node::next_sibling(const char_t* name_) const</a>
<a name="ln5477">	{</a>
<a name="ln5478">		if (!_root) return xml_node();</a>
<a name="ln5479"> </a>
<a name="ln5480">		for (xml_node_struct* i = _root-&gt;next_sibling; i; i = i-&gt;next_sibling)</a>
<a name="ln5481">			if (i-&gt;name &amp;&amp; impl::strequal(name_, i-&gt;name)) return xml_node(i);</a>
<a name="ln5482"> </a>
<a name="ln5483">		return xml_node();</a>
<a name="ln5484">	}</a>
<a name="ln5485"> </a>
<a name="ln5486">	PUGI__FN xml_node xml_node::next_sibling() const</a>
<a name="ln5487">	{</a>
<a name="ln5488">		return _root ? xml_node(_root-&gt;next_sibling) : xml_node();</a>
<a name="ln5489">	}</a>
<a name="ln5490"> </a>
<a name="ln5491">	PUGI__FN xml_node xml_node::previous_sibling(const char_t* name_) const</a>
<a name="ln5492">	{</a>
<a name="ln5493">		if (!_root) return xml_node();</a>
<a name="ln5494"> </a>
<a name="ln5495">		for (xml_node_struct* i = _root-&gt;prev_sibling_c; i-&gt;next_sibling; i = i-&gt;prev_sibling_c)</a>
<a name="ln5496">			if (i-&gt;name &amp;&amp; impl::strequal(name_, i-&gt;name)) return xml_node(i);</a>
<a name="ln5497"> </a>
<a name="ln5498">		return xml_node();</a>
<a name="ln5499">	}</a>
<a name="ln5500"> </a>
<a name="ln5501">	PUGI__FN xml_attribute xml_node::attribute(const char_t* name_, xml_attribute&amp; hint_) const</a>
<a name="ln5502">	{</a>
<a name="ln5503">		xml_attribute_struct* hint = hint_._attr;</a>
<a name="ln5504"> </a>
<a name="ln5505">		// if hint is not an attribute of node, behavior is not defined</a>
<a name="ln5506">		assert(!hint || (_root &amp;&amp; impl::is_attribute_of(hint, _root)));</a>
<a name="ln5507"> </a>
<a name="ln5508">		if (!_root) return xml_attribute();</a>
<a name="ln5509"> </a>
<a name="ln5510">		// optimistically search from hint up until the end</a>
<a name="ln5511">		for (xml_attribute_struct* i = hint; i; i = i-&gt;next_attribute)</a>
<a name="ln5512">			if (i-&gt;name &amp;&amp; impl::strequal(name_, i-&gt;name))</a>
<a name="ln5513">			{</a>
<a name="ln5514">				// Update hint to maximize efficiency of searching for consecutive attributes</a>
<a name="ln5515">				hint_._attr = i-&gt;next_attribute;</a>
<a name="ln5516"> </a>
<a name="ln5517">				return xml_attribute(i);</a>
<a name="ln5518">			}</a>
<a name="ln5519"> </a>
<a name="ln5520">		// wrap around and search from the first attribute until the hint</a>
<a name="ln5521">		// 'j' null pointer check is technically redundant, but it prevents a crash in case the assertion above fails</a>
<a name="ln5522">		for (xml_attribute_struct* j = _root-&gt;first_attribute; j &amp;&amp; j != hint; j = j-&gt;next_attribute)</a>
<a name="ln5523">			if (j-&gt;name &amp;&amp; impl::strequal(name_, j-&gt;name))</a>
<a name="ln5524">			{</a>
<a name="ln5525">				// Update hint to maximize efficiency of searching for consecutive attributes</a>
<a name="ln5526">				hint_._attr = j-&gt;next_attribute;</a>
<a name="ln5527"> </a>
<a name="ln5528">				return xml_attribute(j);</a>
<a name="ln5529">			}</a>
<a name="ln5530"> </a>
<a name="ln5531">		return xml_attribute();</a>
<a name="ln5532">	}</a>
<a name="ln5533"> </a>
<a name="ln5534">	PUGI__FN xml_node xml_node::previous_sibling() const</a>
<a name="ln5535">	{</a>
<a name="ln5536">		if (!_root) return xml_node();</a>
<a name="ln5537"> </a>
<a name="ln5538">		if (_root-&gt;prev_sibling_c-&gt;next_sibling) return xml_node(_root-&gt;prev_sibling_c);</a>
<a name="ln5539">		else return xml_node();</a>
<a name="ln5540">	}</a>
<a name="ln5541"> </a>
<a name="ln5542">	PUGI__FN xml_node xml_node::parent() const</a>
<a name="ln5543">	{</a>
<a name="ln5544">		return _root ? xml_node(_root-&gt;parent) : xml_node();</a>
<a name="ln5545">	}</a>
<a name="ln5546"> </a>
<a name="ln5547">	PUGI__FN xml_node xml_node::root() const</a>
<a name="ln5548">	{</a>
<a name="ln5549">		return _root ? xml_node(&amp;impl::get_document(_root)) : xml_node();</a>
<a name="ln5550">	}</a>
<a name="ln5551"> </a>
<a name="ln5552">	PUGI__FN xml_text xml_node::text() const</a>
<a name="ln5553">	{</a>
<a name="ln5554">		return xml_text(_root);</a>
<a name="ln5555">	}</a>
<a name="ln5556"> </a>
<a name="ln5557">	PUGI__FN const char_t* xml_node::child_value() const</a>
<a name="ln5558">	{</a>
<a name="ln5559">		if (!_root) return PUGIXML_TEXT(&quot;&quot;);</a>
<a name="ln5560"> </a>
<a name="ln5561">		// element nodes can have value if parse_embed_pcdata was used</a>
<a name="ln5562">		if (PUGI__NODETYPE(_root) == node_element &amp;&amp; _root-&gt;value)</a>
<a name="ln5563">			return _root-&gt;value;</a>
<a name="ln5564"> </a>
<a name="ln5565">		for (xml_node_struct* i = _root-&gt;first_child; i; i = i-&gt;next_sibling)</a>
<a name="ln5566">			if (impl::is_text_node(i) &amp;&amp; i-&gt;value)</a>
<a name="ln5567">				return i-&gt;value;</a>
<a name="ln5568"> </a>
<a name="ln5569">		return PUGIXML_TEXT(&quot;&quot;);</a>
<a name="ln5570">	}</a>
<a name="ln5571"> </a>
<a name="ln5572">	PUGI__FN const char_t* xml_node::child_value(const char_t* name_) const</a>
<a name="ln5573">	{</a>
<a name="ln5574">		return child(name_).child_value();</a>
<a name="ln5575">	}</a>
<a name="ln5576"> </a>
<a name="ln5577">	PUGI__FN xml_attribute xml_node::first_attribute() const</a>
<a name="ln5578">	{</a>
<a name="ln5579">		return _root ? xml_attribute(_root-&gt;first_attribute) : xml_attribute();</a>
<a name="ln5580">	}</a>
<a name="ln5581"> </a>
<a name="ln5582">	PUGI__FN xml_attribute xml_node::last_attribute() const</a>
<a name="ln5583">	{</a>
<a name="ln5584">		return _root &amp;&amp; _root-&gt;first_attribute ? xml_attribute(_root-&gt;first_attribute-&gt;prev_attribute_c) : xml_attribute();</a>
<a name="ln5585">	}</a>
<a name="ln5586"> </a>
<a name="ln5587">	PUGI__FN xml_node xml_node::first_child() const</a>
<a name="ln5588">	{</a>
<a name="ln5589">		return _root ? xml_node(_root-&gt;first_child) : xml_node();</a>
<a name="ln5590">	}</a>
<a name="ln5591"> </a>
<a name="ln5592">	PUGI__FN xml_node xml_node::last_child() const</a>
<a name="ln5593">	{</a>
<a name="ln5594">		return _root &amp;&amp; _root-&gt;first_child ? xml_node(_root-&gt;first_child-&gt;prev_sibling_c) : xml_node();</a>
<a name="ln5595">	}</a>
<a name="ln5596"> </a>
<a name="ln5597">	PUGI__FN bool xml_node::set_name(const char_t* rhs)</a>
<a name="ln5598">	{</a>
<a name="ln5599">		xml_node_type type_ = _root ? PUGI__NODETYPE(_root) : node_null;</a>
<a name="ln5600"> </a>
<a name="ln5601">		if (type_ != node_element &amp;&amp; type_ != node_pi &amp;&amp; type_ != node_declaration)</a>
<a name="ln5602">			return false;</a>
<a name="ln5603"> </a>
<a name="ln5604">		return impl::strcpy_insitu(_root-&gt;name, _root-&gt;header, impl::xml_memory_page_name_allocated_mask, rhs, impl::strlength(rhs));</a>
<a name="ln5605">	}</a>
<a name="ln5606"> </a>
<a name="ln5607">	PUGI__FN bool xml_node::set_value(const char_t* rhs)</a>
<a name="ln5608">	{</a>
<a name="ln5609">		xml_node_type type_ = _root ? PUGI__NODETYPE(_root) : node_null;</a>
<a name="ln5610"> </a>
<a name="ln5611">		if (type_ != node_pcdata &amp;&amp; type_ != node_cdata &amp;&amp; type_ != node_comment &amp;&amp; type_ != node_pi &amp;&amp; type_ != node_doctype)</a>
<a name="ln5612">			return false;</a>
<a name="ln5613"> </a>
<a name="ln5614">		return impl::strcpy_insitu(_root-&gt;value, _root-&gt;header, impl::xml_memory_page_value_allocated_mask, rhs, impl::strlength(rhs));</a>
<a name="ln5615">	}</a>
<a name="ln5616"> </a>
<a name="ln5617">	PUGI__FN xml_attribute xml_node::append_attribute(const char_t* name_)</a>
<a name="ln5618">	{</a>
<a name="ln5619">		if (!impl::allow_insert_attribute(type())) return xml_attribute();</a>
<a name="ln5620"> </a>
<a name="ln5621">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln5622">		if (!alloc.reserve()) return xml_attribute();</a>
<a name="ln5623"> </a>
<a name="ln5624">		xml_attribute a(impl::allocate_attribute(alloc));</a>
<a name="ln5625">		if (!a) return xml_attribute();</a>
<a name="ln5626"> </a>
<a name="ln5627">		impl::append_attribute(a._attr, _root);</a>
<a name="ln5628"> </a>
<a name="ln5629">		a.set_name(name_);</a>
<a name="ln5630"> </a>
<a name="ln5631">		return a;</a>
<a name="ln5632">	}</a>
<a name="ln5633"> </a>
<a name="ln5634">	PUGI__FN xml_attribute xml_node::prepend_attribute(const char_t* name_)</a>
<a name="ln5635">	{</a>
<a name="ln5636">		if (!impl::allow_insert_attribute(type())) return xml_attribute();</a>
<a name="ln5637"> </a>
<a name="ln5638">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln5639">		if (!alloc.reserve()) return xml_attribute();</a>
<a name="ln5640"> </a>
<a name="ln5641">		xml_attribute a(impl::allocate_attribute(alloc));</a>
<a name="ln5642">		if (!a) return xml_attribute();</a>
<a name="ln5643"> </a>
<a name="ln5644">		impl::prepend_attribute(a._attr, _root);</a>
<a name="ln5645"> </a>
<a name="ln5646">		a.set_name(name_);</a>
<a name="ln5647"> </a>
<a name="ln5648">		return a;</a>
<a name="ln5649">	}</a>
<a name="ln5650"> </a>
<a name="ln5651">	PUGI__FN xml_attribute xml_node::insert_attribute_after(const char_t* name_, const xml_attribute&amp; attr)</a>
<a name="ln5652">	{</a>
<a name="ln5653">		if (!impl::allow_insert_attribute(type())) return xml_attribute();</a>
<a name="ln5654">		if (!attr || !impl::is_attribute_of(attr._attr, _root)) return xml_attribute();</a>
<a name="ln5655"> </a>
<a name="ln5656">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln5657">		if (!alloc.reserve()) return xml_attribute();</a>
<a name="ln5658"> </a>
<a name="ln5659">		xml_attribute a(impl::allocate_attribute(alloc));</a>
<a name="ln5660">		if (!a) return xml_attribute();</a>
<a name="ln5661"> </a>
<a name="ln5662">		impl::insert_attribute_after(a._attr, attr._attr, _root);</a>
<a name="ln5663"> </a>
<a name="ln5664">		a.set_name(name_);</a>
<a name="ln5665"> </a>
<a name="ln5666">		return a;</a>
<a name="ln5667">	}</a>
<a name="ln5668"> </a>
<a name="ln5669">	PUGI__FN xml_attribute xml_node::insert_attribute_before(const char_t* name_, const xml_attribute&amp; attr)</a>
<a name="ln5670">	{</a>
<a name="ln5671">		if (!impl::allow_insert_attribute(type())) return xml_attribute();</a>
<a name="ln5672">		if (!attr || !impl::is_attribute_of(attr._attr, _root)) return xml_attribute();</a>
<a name="ln5673"> </a>
<a name="ln5674">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln5675">		if (!alloc.reserve()) return xml_attribute();</a>
<a name="ln5676"> </a>
<a name="ln5677">		xml_attribute a(impl::allocate_attribute(alloc));</a>
<a name="ln5678">		if (!a) return xml_attribute();</a>
<a name="ln5679"> </a>
<a name="ln5680">		impl::insert_attribute_before(a._attr, attr._attr, _root);</a>
<a name="ln5681"> </a>
<a name="ln5682">		a.set_name(name_);</a>
<a name="ln5683"> </a>
<a name="ln5684">		return a;</a>
<a name="ln5685">	}</a>
<a name="ln5686"> </a>
<a name="ln5687">	PUGI__FN xml_attribute xml_node::append_copy(const xml_attribute&amp; proto)</a>
<a name="ln5688">	{</a>
<a name="ln5689">		if (!proto) return xml_attribute();</a>
<a name="ln5690">		if (!impl::allow_insert_attribute(type())) return xml_attribute();</a>
<a name="ln5691"> </a>
<a name="ln5692">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln5693">		if (!alloc.reserve()) return xml_attribute();</a>
<a name="ln5694"> </a>
<a name="ln5695">		xml_attribute a(impl::allocate_attribute(alloc));</a>
<a name="ln5696">		if (!a) return xml_attribute();</a>
<a name="ln5697"> </a>
<a name="ln5698">		impl::append_attribute(a._attr, _root);</a>
<a name="ln5699">		impl::node_copy_attribute(a._attr, proto._attr);</a>
<a name="ln5700"> </a>
<a name="ln5701">		return a;</a>
<a name="ln5702">	}</a>
<a name="ln5703"> </a>
<a name="ln5704">	PUGI__FN xml_attribute xml_node::prepend_copy(const xml_attribute&amp; proto)</a>
<a name="ln5705">	{</a>
<a name="ln5706">		if (!proto) return xml_attribute();</a>
<a name="ln5707">		if (!impl::allow_insert_attribute(type())) return xml_attribute();</a>
<a name="ln5708"> </a>
<a name="ln5709">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln5710">		if (!alloc.reserve()) return xml_attribute();</a>
<a name="ln5711"> </a>
<a name="ln5712">		xml_attribute a(impl::allocate_attribute(alloc));</a>
<a name="ln5713">		if (!a) return xml_attribute();</a>
<a name="ln5714"> </a>
<a name="ln5715">		impl::prepend_attribute(a._attr, _root);</a>
<a name="ln5716">		impl::node_copy_attribute(a._attr, proto._attr);</a>
<a name="ln5717"> </a>
<a name="ln5718">		return a;</a>
<a name="ln5719">	}</a>
<a name="ln5720"> </a>
<a name="ln5721">	PUGI__FN xml_attribute xml_node::insert_copy_after(const xml_attribute&amp; proto, const xml_attribute&amp; attr)</a>
<a name="ln5722">	{</a>
<a name="ln5723">		if (!proto) return xml_attribute();</a>
<a name="ln5724">		if (!impl::allow_insert_attribute(type())) return xml_attribute();</a>
<a name="ln5725">		if (!attr || !impl::is_attribute_of(attr._attr, _root)) return xml_attribute();</a>
<a name="ln5726"> </a>
<a name="ln5727">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln5728">		if (!alloc.reserve()) return xml_attribute();</a>
<a name="ln5729"> </a>
<a name="ln5730">		xml_attribute a(impl::allocate_attribute(alloc));</a>
<a name="ln5731">		if (!a) return xml_attribute();</a>
<a name="ln5732"> </a>
<a name="ln5733">		impl::insert_attribute_after(a._attr, attr._attr, _root);</a>
<a name="ln5734">		impl::node_copy_attribute(a._attr, proto._attr);</a>
<a name="ln5735"> </a>
<a name="ln5736">		return a;</a>
<a name="ln5737">	}</a>
<a name="ln5738"> </a>
<a name="ln5739">	PUGI__FN xml_attribute xml_node::insert_copy_before(const xml_attribute&amp; proto, const xml_attribute&amp; attr)</a>
<a name="ln5740">	{</a>
<a name="ln5741">		if (!proto) return xml_attribute();</a>
<a name="ln5742">		if (!impl::allow_insert_attribute(type())) return xml_attribute();</a>
<a name="ln5743">		if (!attr || !impl::is_attribute_of(attr._attr, _root)) return xml_attribute();</a>
<a name="ln5744"> </a>
<a name="ln5745">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln5746">		if (!alloc.reserve()) return xml_attribute();</a>
<a name="ln5747"> </a>
<a name="ln5748">		xml_attribute a(impl::allocate_attribute(alloc));</a>
<a name="ln5749">		if (!a) return xml_attribute();</a>
<a name="ln5750"> </a>
<a name="ln5751">		impl::insert_attribute_before(a._attr, attr._attr, _root);</a>
<a name="ln5752">		impl::node_copy_attribute(a._attr, proto._attr);</a>
<a name="ln5753"> </a>
<a name="ln5754">		return a;</a>
<a name="ln5755">	}</a>
<a name="ln5756"> </a>
<a name="ln5757">	PUGI__FN xml_node xml_node::append_child(xml_node_type type_)</a>
<a name="ln5758">	{</a>
<a name="ln5759">		if (!impl::allow_insert_child(type(), type_)) return xml_node();</a>
<a name="ln5760"> </a>
<a name="ln5761">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln5762">		if (!alloc.reserve()) return xml_node();</a>
<a name="ln5763"> </a>
<a name="ln5764">		xml_node n(impl::allocate_node(alloc, type_));</a>
<a name="ln5765">		if (!n) return xml_node();</a>
<a name="ln5766"> </a>
<a name="ln5767">		impl::append_node(n._root, _root);</a>
<a name="ln5768"> </a>
<a name="ln5769">		if (type_ == node_declaration) n.set_name(PUGIXML_TEXT(&quot;xml&quot;));</a>
<a name="ln5770"> </a>
<a name="ln5771">		return n;</a>
<a name="ln5772">	}</a>
<a name="ln5773"> </a>
<a name="ln5774">	PUGI__FN xml_node xml_node::prepend_child(xml_node_type type_)</a>
<a name="ln5775">	{</a>
<a name="ln5776">		if (!impl::allow_insert_child(type(), type_)) return xml_node();</a>
<a name="ln5777"> </a>
<a name="ln5778">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln5779">		if (!alloc.reserve()) return xml_node();</a>
<a name="ln5780"> </a>
<a name="ln5781">		xml_node n(impl::allocate_node(alloc, type_));</a>
<a name="ln5782">		if (!n) return xml_node();</a>
<a name="ln5783"> </a>
<a name="ln5784">		impl::prepend_node(n._root, _root);</a>
<a name="ln5785"> </a>
<a name="ln5786">		if (type_ == node_declaration) n.set_name(PUGIXML_TEXT(&quot;xml&quot;));</a>
<a name="ln5787"> </a>
<a name="ln5788">		return n;</a>
<a name="ln5789">	}</a>
<a name="ln5790"> </a>
<a name="ln5791">	PUGI__FN xml_node xml_node::insert_child_before(xml_node_type type_, const xml_node&amp; node)</a>
<a name="ln5792">	{</a>
<a name="ln5793">		if (!impl::allow_insert_child(type(), type_)) return xml_node();</a>
<a name="ln5794">		if (!node._root || node._root-&gt;parent != _root) return xml_node();</a>
<a name="ln5795"> </a>
<a name="ln5796">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln5797">		if (!alloc.reserve()) return xml_node();</a>
<a name="ln5798"> </a>
<a name="ln5799">		xml_node n(impl::allocate_node(alloc, type_));</a>
<a name="ln5800">		if (!n) return xml_node();</a>
<a name="ln5801"> </a>
<a name="ln5802">		impl::insert_node_before(n._root, node._root);</a>
<a name="ln5803"> </a>
<a name="ln5804">		if (type_ == node_declaration) n.set_name(PUGIXML_TEXT(&quot;xml&quot;));</a>
<a name="ln5805"> </a>
<a name="ln5806">		return n;</a>
<a name="ln5807">	}</a>
<a name="ln5808"> </a>
<a name="ln5809">	PUGI__FN xml_node xml_node::insert_child_after(xml_node_type type_, const xml_node&amp; node)</a>
<a name="ln5810">	{</a>
<a name="ln5811">		if (!impl::allow_insert_child(type(), type_)) return xml_node();</a>
<a name="ln5812">		if (!node._root || node._root-&gt;parent != _root) return xml_node();</a>
<a name="ln5813"> </a>
<a name="ln5814">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln5815">		if (!alloc.reserve()) return xml_node();</a>
<a name="ln5816"> </a>
<a name="ln5817">		xml_node n(impl::allocate_node(alloc, type_));</a>
<a name="ln5818">		if (!n) return xml_node();</a>
<a name="ln5819"> </a>
<a name="ln5820">		impl::insert_node_after(n._root, node._root);</a>
<a name="ln5821"> </a>
<a name="ln5822">		if (type_ == node_declaration) n.set_name(PUGIXML_TEXT(&quot;xml&quot;));</a>
<a name="ln5823"> </a>
<a name="ln5824">		return n;</a>
<a name="ln5825">	}</a>
<a name="ln5826"> </a>
<a name="ln5827">	PUGI__FN xml_node xml_node::append_child(const char_t* name_)</a>
<a name="ln5828">	{</a>
<a name="ln5829">		xml_node result = append_child(node_element);</a>
<a name="ln5830"> </a>
<a name="ln5831">		result.set_name(name_);</a>
<a name="ln5832"> </a>
<a name="ln5833">		return result;</a>
<a name="ln5834">	}</a>
<a name="ln5835"> </a>
<a name="ln5836">	PUGI__FN xml_node xml_node::prepend_child(const char_t* name_)</a>
<a name="ln5837">	{</a>
<a name="ln5838">		xml_node result = prepend_child(node_element);</a>
<a name="ln5839"> </a>
<a name="ln5840">		result.set_name(name_);</a>
<a name="ln5841"> </a>
<a name="ln5842">		return result;</a>
<a name="ln5843">	}</a>
<a name="ln5844"> </a>
<a name="ln5845">	PUGI__FN xml_node xml_node::insert_child_after(const char_t* name_, const xml_node&amp; node)</a>
<a name="ln5846">	{</a>
<a name="ln5847">		xml_node result = insert_child_after(node_element, node);</a>
<a name="ln5848"> </a>
<a name="ln5849">		result.set_name(name_);</a>
<a name="ln5850"> </a>
<a name="ln5851">		return result;</a>
<a name="ln5852">	}</a>
<a name="ln5853"> </a>
<a name="ln5854">	PUGI__FN xml_node xml_node::insert_child_before(const char_t* name_, const xml_node&amp; node)</a>
<a name="ln5855">	{</a>
<a name="ln5856">		xml_node result = insert_child_before(node_element, node);</a>
<a name="ln5857"> </a>
<a name="ln5858">		result.set_name(name_);</a>
<a name="ln5859"> </a>
<a name="ln5860">		return result;</a>
<a name="ln5861">	}</a>
<a name="ln5862"> </a>
<a name="ln5863">	PUGI__FN xml_node xml_node::append_copy(const xml_node&amp; proto)</a>
<a name="ln5864">	{</a>
<a name="ln5865">		xml_node_type type_ = proto.type();</a>
<a name="ln5866">		if (!impl::allow_insert_child(type(), type_)) return xml_node();</a>
<a name="ln5867"> </a>
<a name="ln5868">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln5869">		if (!alloc.reserve()) return xml_node();</a>
<a name="ln5870"> </a>
<a name="ln5871">		xml_node n(impl::allocate_node(alloc, type_));</a>
<a name="ln5872">		if (!n) return xml_node();</a>
<a name="ln5873"> </a>
<a name="ln5874">		impl::append_node(n._root, _root);</a>
<a name="ln5875">		impl::node_copy_tree(n._root, proto._root);</a>
<a name="ln5876"> </a>
<a name="ln5877">		return n;</a>
<a name="ln5878">	}</a>
<a name="ln5879"> </a>
<a name="ln5880">	PUGI__FN xml_node xml_node::prepend_copy(const xml_node&amp; proto)</a>
<a name="ln5881">	{</a>
<a name="ln5882">		xml_node_type type_ = proto.type();</a>
<a name="ln5883">		if (!impl::allow_insert_child(type(), type_)) return xml_node();</a>
<a name="ln5884"> </a>
<a name="ln5885">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln5886">		if (!alloc.reserve()) return xml_node();</a>
<a name="ln5887"> </a>
<a name="ln5888">		xml_node n(impl::allocate_node(alloc, type_));</a>
<a name="ln5889">		if (!n) return xml_node();</a>
<a name="ln5890"> </a>
<a name="ln5891">		impl::prepend_node(n._root, _root);</a>
<a name="ln5892">		impl::node_copy_tree(n._root, proto._root);</a>
<a name="ln5893"> </a>
<a name="ln5894">		return n;</a>
<a name="ln5895">	}</a>
<a name="ln5896"> </a>
<a name="ln5897">	PUGI__FN xml_node xml_node::insert_copy_after(const xml_node&amp; proto, const xml_node&amp; node)</a>
<a name="ln5898">	{</a>
<a name="ln5899">		xml_node_type type_ = proto.type();</a>
<a name="ln5900">		if (!impl::allow_insert_child(type(), type_)) return xml_node();</a>
<a name="ln5901">		if (!node._root || node._root-&gt;parent != _root) return xml_node();</a>
<a name="ln5902"> </a>
<a name="ln5903">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln5904">		if (!alloc.reserve()) return xml_node();</a>
<a name="ln5905"> </a>
<a name="ln5906">		xml_node n(impl::allocate_node(alloc, type_));</a>
<a name="ln5907">		if (!n) return xml_node();</a>
<a name="ln5908"> </a>
<a name="ln5909">		impl::insert_node_after(n._root, node._root);</a>
<a name="ln5910">		impl::node_copy_tree(n._root, proto._root);</a>
<a name="ln5911"> </a>
<a name="ln5912">		return n;</a>
<a name="ln5913">	}</a>
<a name="ln5914"> </a>
<a name="ln5915">	PUGI__FN xml_node xml_node::insert_copy_before(const xml_node&amp; proto, const xml_node&amp; node)</a>
<a name="ln5916">	{</a>
<a name="ln5917">		xml_node_type type_ = proto.type();</a>
<a name="ln5918">		if (!impl::allow_insert_child(type(), type_)) return xml_node();</a>
<a name="ln5919">		if (!node._root || node._root-&gt;parent != _root) return xml_node();</a>
<a name="ln5920"> </a>
<a name="ln5921">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln5922">		if (!alloc.reserve()) return xml_node();</a>
<a name="ln5923"> </a>
<a name="ln5924">		xml_node n(impl::allocate_node(alloc, type_));</a>
<a name="ln5925">		if (!n) return xml_node();</a>
<a name="ln5926"> </a>
<a name="ln5927">		impl::insert_node_before(n._root, node._root);</a>
<a name="ln5928">		impl::node_copy_tree(n._root, proto._root);</a>
<a name="ln5929"> </a>
<a name="ln5930">		return n;</a>
<a name="ln5931">	}</a>
<a name="ln5932"> </a>
<a name="ln5933">	PUGI__FN xml_node xml_node::append_move(const xml_node&amp; moved)</a>
<a name="ln5934">	{</a>
<a name="ln5935">		if (!impl::allow_move(*this, moved)) return xml_node();</a>
<a name="ln5936"> </a>
<a name="ln5937">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln5938">		if (!alloc.reserve()) return xml_node();</a>
<a name="ln5939"> </a>
<a name="ln5940">		// disable document_buffer_order optimization since moving nodes around changes document order without changing buffer pointers</a>
<a name="ln5941">		impl::get_document(_root).header |= impl::xml_memory_page_contents_shared_mask;</a>
<a name="ln5942"> </a>
<a name="ln5943">		impl::remove_node(moved._root);</a>
<a name="ln5944">		impl::append_node(moved._root, _root);</a>
<a name="ln5945"> </a>
<a name="ln5946">		return moved;</a>
<a name="ln5947">	}</a>
<a name="ln5948"> </a>
<a name="ln5949">	PUGI__FN xml_node xml_node::prepend_move(const xml_node&amp; moved)</a>
<a name="ln5950">	{</a>
<a name="ln5951">		if (!impl::allow_move(*this, moved)) return xml_node();</a>
<a name="ln5952"> </a>
<a name="ln5953">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln5954">		if (!alloc.reserve()) return xml_node();</a>
<a name="ln5955"> </a>
<a name="ln5956">		// disable document_buffer_order optimization since moving nodes around changes document order without changing buffer pointers</a>
<a name="ln5957">		impl::get_document(_root).header |= impl::xml_memory_page_contents_shared_mask;</a>
<a name="ln5958"> </a>
<a name="ln5959">		impl::remove_node(moved._root);</a>
<a name="ln5960">		impl::prepend_node(moved._root, _root);</a>
<a name="ln5961"> </a>
<a name="ln5962">		return moved;</a>
<a name="ln5963">	}</a>
<a name="ln5964"> </a>
<a name="ln5965">	PUGI__FN xml_node xml_node::insert_move_after(const xml_node&amp; moved, const xml_node&amp; node)</a>
<a name="ln5966">	{</a>
<a name="ln5967">		if (!impl::allow_move(*this, moved)) return xml_node();</a>
<a name="ln5968">		if (!node._root || node._root-&gt;parent != _root) return xml_node();</a>
<a name="ln5969">		if (moved._root == node._root) return xml_node();</a>
<a name="ln5970"> </a>
<a name="ln5971">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln5972">		if (!alloc.reserve()) return xml_node();</a>
<a name="ln5973"> </a>
<a name="ln5974">		// disable document_buffer_order optimization since moving nodes around changes document order without changing buffer pointers</a>
<a name="ln5975">		impl::get_document(_root).header |= impl::xml_memory_page_contents_shared_mask;</a>
<a name="ln5976"> </a>
<a name="ln5977">		impl::remove_node(moved._root);</a>
<a name="ln5978">		impl::insert_node_after(moved._root, node._root);</a>
<a name="ln5979"> </a>
<a name="ln5980">		return moved;</a>
<a name="ln5981">	}</a>
<a name="ln5982"> </a>
<a name="ln5983">	PUGI__FN xml_node xml_node::insert_move_before(const xml_node&amp; moved, const xml_node&amp; node)</a>
<a name="ln5984">	{</a>
<a name="ln5985">		if (!impl::allow_move(*this, moved)) return xml_node();</a>
<a name="ln5986">		if (!node._root || node._root-&gt;parent != _root) return xml_node();</a>
<a name="ln5987">		if (moved._root == node._root) return xml_node();</a>
<a name="ln5988"> </a>
<a name="ln5989">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln5990">		if (!alloc.reserve()) return xml_node();</a>
<a name="ln5991"> </a>
<a name="ln5992">		// disable document_buffer_order optimization since moving nodes around changes document order without changing buffer pointers</a>
<a name="ln5993">		impl::get_document(_root).header |= impl::xml_memory_page_contents_shared_mask;</a>
<a name="ln5994"> </a>
<a name="ln5995">		impl::remove_node(moved._root);</a>
<a name="ln5996">		impl::insert_node_before(moved._root, node._root);</a>
<a name="ln5997"> </a>
<a name="ln5998">		return moved;</a>
<a name="ln5999">	}</a>
<a name="ln6000"> </a>
<a name="ln6001">	PUGI__FN bool xml_node::remove_attribute(const char_t* name_)</a>
<a name="ln6002">	{</a>
<a name="ln6003">		return remove_attribute(attribute(name_));</a>
<a name="ln6004">	}</a>
<a name="ln6005"> </a>
<a name="ln6006">	PUGI__FN bool xml_node::remove_attribute(const xml_attribute&amp; a)</a>
<a name="ln6007">	{</a>
<a name="ln6008">		if (!_root || !a._attr) return false;</a>
<a name="ln6009">		if (!impl::is_attribute_of(a._attr, _root)) return false;</a>
<a name="ln6010"> </a>
<a name="ln6011">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln6012">		if (!alloc.reserve()) return false;</a>
<a name="ln6013"> </a>
<a name="ln6014">		impl::remove_attribute(a._attr, _root);</a>
<a name="ln6015">		impl::destroy_attribute(a._attr, alloc);</a>
<a name="ln6016"> </a>
<a name="ln6017">		return true;</a>
<a name="ln6018">	}</a>
<a name="ln6019"> </a>
<a name="ln6020">	PUGI__FN bool xml_node::remove_child(const char_t* name_)</a>
<a name="ln6021">	{</a>
<a name="ln6022">		return remove_child(child(name_));</a>
<a name="ln6023">	}</a>
<a name="ln6024"> </a>
<a name="ln6025">	PUGI__FN bool xml_node::remove_child(const xml_node&amp; n)</a>
<a name="ln6026">	{</a>
<a name="ln6027">		if (!_root || !n._root || n._root-&gt;parent != _root) return false;</a>
<a name="ln6028"> </a>
<a name="ln6029">		impl::xml_allocator&amp; alloc = impl::get_allocator(_root);</a>
<a name="ln6030">		if (!alloc.reserve()) return false;</a>
<a name="ln6031"> </a>
<a name="ln6032">		impl::remove_node(n._root);</a>
<a name="ln6033">		impl::destroy_node(n._root, alloc);</a>
<a name="ln6034"> </a>
<a name="ln6035">		return true;</a>
<a name="ln6036">	}</a>
<a name="ln6037"> </a>
<a name="ln6038">	PUGI__FN xml_parse_result xml_node::append_buffer(const void* contents, size_t size, unsigned int options, xml_encoding encoding)</a>
<a name="ln6039">	{</a>
<a name="ln6040">		// append_buffer is only valid for elements/documents</a>
<a name="ln6041">		if (!impl::allow_insert_child(type(), node_element)) return impl::make_parse_result(status_append_invalid_root);</a>
<a name="ln6042"> </a>
<a name="ln6043">		// get document node</a>
<a name="ln6044">		impl::xml_document_struct* doc = &amp;impl::get_document(_root);</a>
<a name="ln6045"> </a>
<a name="ln6046">		// disable document_buffer_order optimization since in a document with multiple buffers comparing buffer pointers does not make sense</a>
<a name="ln6047">		doc-&gt;header |= impl::xml_memory_page_contents_shared_mask;</a>
<a name="ln6048"> </a>
<a name="ln6049">		// get extra buffer element (we'll store the document fragment buffer there so that we can deallocate it later)</a>
<a name="ln6050">		impl::xml_memory_page* page = 0;</a>
<a name="ln6051">		impl::xml_extra_buffer* extra = static_cast&lt;impl::xml_extra_buffer*&gt;(doc-&gt;allocate_memory(sizeof(impl::xml_extra_buffer), page));</a>
<a name="ln6052">		(void)page;</a>
<a name="ln6053"> </a>
<a name="ln6054">		if (!extra) return impl::make_parse_result(status_out_of_memory);</a>
<a name="ln6055"> </a>
<a name="ln6056">		// add extra buffer to the list</a>
<a name="ln6057">		extra-&gt;buffer = 0;</a>
<a name="ln6058">		extra-&gt;next = doc-&gt;extra_buffers;</a>
<a name="ln6059">		doc-&gt;extra_buffers = extra;</a>
<a name="ln6060"> </a>
<a name="ln6061">		// name of the root has to be NULL before parsing - otherwise closing node mismatches will not be detected at the top level</a>
<a name="ln6062">		impl::name_null_sentry sentry(_root);</a>
<a name="ln6063"> </a>
<a name="ln6064">		return impl::load_buffer_impl(doc, _root, const_cast&lt;void*&gt;(contents), size, options, encoding, false, false, &amp;extra-&gt;buffer);</a>
<a name="ln6065">	}</a>
<a name="ln6066"> </a>
<a name="ln6067">	PUGI__FN xml_node xml_node::find_child_by_attribute(const char_t* name_, const char_t* attr_name, const char_t* attr_value) const</a>
<a name="ln6068">	{</a>
<a name="ln6069">		if (!_root) return xml_node();</a>
<a name="ln6070"> </a>
<a name="ln6071">		for (xml_node_struct* i = _root-&gt;first_child; i; i = i-&gt;next_sibling)</a>
<a name="ln6072">			if (i-&gt;name &amp;&amp; impl::strequal(name_, i-&gt;name))</a>
<a name="ln6073">			{</a>
<a name="ln6074">				for (xml_attribute_struct* a = i-&gt;first_attribute; a; a = a-&gt;next_attribute)</a>
<a name="ln6075">					if (a-&gt;name &amp;&amp; impl::strequal(attr_name, a-&gt;name) &amp;&amp; impl::strequal(attr_value, a-&gt;value ? a-&gt;value + 0 : PUGIXML_TEXT(&quot;&quot;)))</a>
<a name="ln6076">						return xml_node(i);</a>
<a name="ln6077">			}</a>
<a name="ln6078"> </a>
<a name="ln6079">		return xml_node();</a>
<a name="ln6080">	}</a>
<a name="ln6081"> </a>
<a name="ln6082">	PUGI__FN xml_node xml_node::find_child_by_attribute(const char_t* attr_name, const char_t* attr_value) const</a>
<a name="ln6083">	{</a>
<a name="ln6084">		if (!_root) return xml_node();</a>
<a name="ln6085"> </a>
<a name="ln6086">		for (xml_node_struct* i = _root-&gt;first_child; i; i = i-&gt;next_sibling)</a>
<a name="ln6087">			for (xml_attribute_struct* a = i-&gt;first_attribute; a; a = a-&gt;next_attribute)</a>
<a name="ln6088">				if (a-&gt;name &amp;&amp; impl::strequal(attr_name, a-&gt;name) &amp;&amp; impl::strequal(attr_value, a-&gt;value ? a-&gt;value + 0 : PUGIXML_TEXT(&quot;&quot;)))</a>
<a name="ln6089">					return xml_node(i);</a>
<a name="ln6090"> </a>
<a name="ln6091">		return xml_node();</a>
<a name="ln6092">	}</a>
<a name="ln6093"> </a>
<a name="ln6094">#ifndef PUGIXML_NO_STL</a>
<a name="ln6095">	PUGI__FN string_t xml_node::path(char_t delimiter) const</a>
<a name="ln6096">	{</a>
<a name="ln6097">		if (!_root) return string_t();</a>
<a name="ln6098"> </a>
<a name="ln6099">		size_t offset = 0;</a>
<a name="ln6100"> </a>
<a name="ln6101">		for (xml_node_struct* i = _root; i; i = i-&gt;parent)</a>
<a name="ln6102">		{</a>
<a name="ln6103">			offset += (i != _root);</a>
<a name="ln6104">			offset += i-&gt;name ? impl::strlength(i-&gt;name) : 0;</a>
<a name="ln6105">		}</a>
<a name="ln6106"> </a>
<a name="ln6107">		string_t result;</a>
<a name="ln6108">		result.resize(offset);</a>
<a name="ln6109"> </a>
<a name="ln6110">		for (xml_node_struct* j = _root; j; j = j-&gt;parent)</a>
<a name="ln6111">		{</a>
<a name="ln6112">			if (j != _root)</a>
<a name="ln6113">				result[--offset] = delimiter;</a>
<a name="ln6114"> </a>
<a name="ln6115">			if (j-&gt;name &amp;&amp; *j-&gt;name)</a>
<a name="ln6116">			{</a>
<a name="ln6117">				size_t length = impl::strlength(j-&gt;name);</a>
<a name="ln6118"> </a>
<a name="ln6119">				offset -= length;</a>
<a name="ln6120">				memcpy(&amp;result[offset], j-&gt;name, length * sizeof(char_t));</a>
<a name="ln6121">			}</a>
<a name="ln6122">		}</a>
<a name="ln6123"> </a>
<a name="ln6124">		assert(offset == 0);</a>
<a name="ln6125"> </a>
<a name="ln6126">		return result;</a>
<a name="ln6127">	}</a>
<a name="ln6128">#endif</a>
<a name="ln6129"> </a>
<a name="ln6130">	PUGI__FN xml_node xml_node::first_element_by_path(const char_t* path_, char_t delimiter) const</a>
<a name="ln6131">	{</a>
<a name="ln6132">		xml_node found = *this; // Current search context.</a>
<a name="ln6133"> </a>
<a name="ln6134">		if (!_root || !path_ || !path_[0]) return found;</a>
<a name="ln6135"> </a>
<a name="ln6136">		if (path_[0] == delimiter)</a>
<a name="ln6137">		{</a>
<a name="ln6138">			// Absolute path; e.g. '/foo/bar'</a>
<a name="ln6139">			found = found.root();</a>
<a name="ln6140">			++path_;</a>
<a name="ln6141">		}</a>
<a name="ln6142"> </a>
<a name="ln6143">		const char_t* path_segment = path_;</a>
<a name="ln6144"> </a>
<a name="ln6145">		while (*path_segment == delimiter) ++path_segment;</a>
<a name="ln6146"> </a>
<a name="ln6147">		const char_t* path_segment_end = path_segment;</a>
<a name="ln6148"> </a>
<a name="ln6149">		while (*path_segment_end &amp;&amp; *path_segment_end != delimiter) ++path_segment_end;</a>
<a name="ln6150"> </a>
<a name="ln6151">		if (path_segment == path_segment_end) return found;</a>
<a name="ln6152"> </a>
<a name="ln6153">		const char_t* next_segment = path_segment_end;</a>
<a name="ln6154"> </a>
<a name="ln6155">		while (*next_segment == delimiter) ++next_segment;</a>
<a name="ln6156"> </a>
<a name="ln6157">		if (*path_segment == '.' &amp;&amp; path_segment + 1 == path_segment_end)</a>
<a name="ln6158">			return found.first_element_by_path(next_segment, delimiter);</a>
<a name="ln6159">		else if (*path_segment == '.' &amp;&amp; *(path_segment+1) == '.' &amp;&amp; path_segment + 2 == path_segment_end)</a>
<a name="ln6160">			return found.parent().first_element_by_path(next_segment, delimiter);</a>
<a name="ln6161">		else</a>
<a name="ln6162">		{</a>
<a name="ln6163">			for (xml_node_struct* j = found._root-&gt;first_child; j; j = j-&gt;next_sibling)</a>
<a name="ln6164">			{</a>
<a name="ln6165">				if (j-&gt;name &amp;&amp; impl::strequalrange(j-&gt;name, path_segment, static_cast&lt;size_t&gt;(path_segment_end - path_segment)))</a>
<a name="ln6166">				{</a>
<a name="ln6167">					xml_node subsearch = xml_node(j).first_element_by_path(next_segment, delimiter);</a>
<a name="ln6168"> </a>
<a name="ln6169">					if (subsearch) return subsearch;</a>
<a name="ln6170">				}</a>
<a name="ln6171">			}</a>
<a name="ln6172"> </a>
<a name="ln6173">			return xml_node();</a>
<a name="ln6174">		}</a>
<a name="ln6175">	}</a>
<a name="ln6176"> </a>
<a name="ln6177">	PUGI__FN bool xml_node::traverse(xml_tree_walker&amp; walker)</a>
<a name="ln6178">	{</a>
<a name="ln6179">		walker._depth = -1;</a>
<a name="ln6180"> </a>
<a name="ln6181">		xml_node arg_begin = *this;</a>
<a name="ln6182">		if (!walker.begin(arg_begin)) return false;</a>
<a name="ln6183"> </a>
<a name="ln6184">		xml_node cur = first_child();</a>
<a name="ln6185"> </a>
<a name="ln6186">		if (cur)</a>
<a name="ln6187">		{</a>
<a name="ln6188">			++walker._depth;</a>
<a name="ln6189"> </a>
<a name="ln6190">			do</a>
<a name="ln6191">			{</a>
<a name="ln6192">				xml_node arg_for_each = cur;</a>
<a name="ln6193">				if (!walker.for_each(arg_for_each))</a>
<a name="ln6194">					return false;</a>
<a name="ln6195"> </a>
<a name="ln6196">				if (cur.first_child())</a>
<a name="ln6197">				{</a>
<a name="ln6198">					++walker._depth;</a>
<a name="ln6199">					cur = cur.first_child();</a>
<a name="ln6200">				}</a>
<a name="ln6201">				else if (cur.next_sibling())</a>
<a name="ln6202">					cur = cur.next_sibling();</a>
<a name="ln6203">				else</a>
<a name="ln6204">				{</a>
<a name="ln6205">					// Borland C++ workaround</a>
<a name="ln6206">					while (!cur.next_sibling() &amp;&amp; cur != *this &amp;&amp; !cur.parent().empty())</a>
<a name="ln6207">					{</a>
<a name="ln6208">						--walker._depth;</a>
<a name="ln6209">						cur = cur.parent();</a>
<a name="ln6210">					}</a>
<a name="ln6211"> </a>
<a name="ln6212">					if (cur != *this)</a>
<a name="ln6213">						cur = cur.next_sibling();</a>
<a name="ln6214">				}</a>
<a name="ln6215">			}</a>
<a name="ln6216">			while (cur &amp;&amp; cur != *this);</a>
<a name="ln6217">		}</a>
<a name="ln6218"> </a>
<a name="ln6219">		assert(walker._depth == -1);</a>
<a name="ln6220"> </a>
<a name="ln6221">		xml_node arg_end = *this;</a>
<a name="ln6222">		return walker.end(arg_end);</a>
<a name="ln6223">	}</a>
<a name="ln6224"> </a>
<a name="ln6225">	PUGI__FN size_t xml_node::hash_value() const</a>
<a name="ln6226">	{</a>
<a name="ln6227">		return static_cast&lt;size_t&gt;(reinterpret_cast&lt;uintptr_t&gt;(_root) / sizeof(xml_node_struct));</a>
<a name="ln6228">	}</a>
<a name="ln6229"> </a>
<a name="ln6230">	PUGI__FN xml_node_struct* xml_node::internal_object() const</a>
<a name="ln6231">	{</a>
<a name="ln6232">		return _root;</a>
<a name="ln6233">	}</a>
<a name="ln6234"> </a>
<a name="ln6235">	PUGI__FN void xml_node::print(xml_writer&amp; writer, const char_t* indent, unsigned int flags, xml_encoding encoding, unsigned int depth) const</a>
<a name="ln6236">	{</a>
<a name="ln6237">		if (!_root) return;</a>
<a name="ln6238"> </a>
<a name="ln6239">		impl::xml_buffered_writer buffered_writer(writer, encoding);</a>
<a name="ln6240"> </a>
<a name="ln6241">		impl::node_output(buffered_writer, _root, indent, flags, depth);</a>
<a name="ln6242"> </a>
<a name="ln6243">		buffered_writer.flush();</a>
<a name="ln6244">	}</a>
<a name="ln6245"> </a>
<a name="ln6246">#ifndef PUGIXML_NO_STL</a>
<a name="ln6247">	PUGI__FN void xml_node::print(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; stream, const char_t* indent, unsigned int flags, xml_encoding encoding, unsigned int depth) const</a>
<a name="ln6248">	{</a>
<a name="ln6249">		xml_writer_stream writer(stream);</a>
<a name="ln6250"> </a>
<a name="ln6251">		print(writer, indent, flags, encoding, depth);</a>
<a name="ln6252">	}</a>
<a name="ln6253"> </a>
<a name="ln6254">	PUGI__FN void xml_node::print(std::basic_ostream&lt;wchar_t, std::char_traits&lt;wchar_t&gt; &gt;&amp; stream, const char_t* indent, unsigned int flags, unsigned int depth) const</a>
<a name="ln6255">	{</a>
<a name="ln6256">		xml_writer_stream writer(stream);</a>
<a name="ln6257"> </a>
<a name="ln6258">		print(writer, indent, flags, encoding_wchar, depth);</a>
<a name="ln6259">	}</a>
<a name="ln6260">#endif</a>
<a name="ln6261"> </a>
<a name="ln6262">	PUGI__FN ptrdiff_t xml_node::offset_debug() const</a>
<a name="ln6263">	{</a>
<a name="ln6264">		if (!_root) return -1;</a>
<a name="ln6265"> </a>
<a name="ln6266">		impl::xml_document_struct&amp; doc = impl::get_document(_root);</a>
<a name="ln6267"> </a>
<a name="ln6268">		// we can determine the offset reliably only if there is exactly once parse buffer</a>
<a name="ln6269">		if (!doc.buffer || doc.extra_buffers) return -1;</a>
<a name="ln6270"> </a>
<a name="ln6271">		switch (type())</a>
<a name="ln6272">		{</a>
<a name="ln6273">		case node_document:</a>
<a name="ln6274">			return 0;</a>
<a name="ln6275"> </a>
<a name="ln6276">		case node_element:</a>
<a name="ln6277">		case node_declaration:</a>
<a name="ln6278">		case node_pi:</a>
<a name="ln6279">			return _root-&gt;name &amp;&amp; (_root-&gt;header &amp; impl::xml_memory_page_name_allocated_or_shared_mask) == 0 ? _root-&gt;name - doc.buffer : -1;</a>
<a name="ln6280"> </a>
<a name="ln6281">		case node_pcdata:</a>
<a name="ln6282">		case node_cdata:</a>
<a name="ln6283">		case node_comment:</a>
<a name="ln6284">		case node_doctype:</a>
<a name="ln6285">			return _root-&gt;value &amp;&amp; (_root-&gt;header &amp; impl::xml_memory_page_value_allocated_or_shared_mask) == 0 ? _root-&gt;value - doc.buffer : -1;</a>
<a name="ln6286"> </a>
<a name="ln6287">		default:</a>
<a name="ln6288">			return -1;</a>
<a name="ln6289">		}</a>
<a name="ln6290">	}</a>
<a name="ln6291"> </a>
<a name="ln6292">#ifdef __BORLANDC__</a>
<a name="ln6293">	PUGI__FN bool operator&amp;&amp;(const xml_node&amp; lhs, bool rhs)</a>
<a name="ln6294">	{</a>
<a name="ln6295">		return (bool)lhs &amp;&amp; rhs;</a>
<a name="ln6296">	}</a>
<a name="ln6297"> </a>
<a name="ln6298">	PUGI__FN bool operator||(const xml_node&amp; lhs, bool rhs)</a>
<a name="ln6299">	{</a>
<a name="ln6300">		return (bool)lhs || rhs;</a>
<a name="ln6301">	}</a>
<a name="ln6302">#endif</a>
<a name="ln6303"> </a>
<a name="ln6304">	PUGI__FN xml_text::xml_text(xml_node_struct* root): _root(root)</a>
<a name="ln6305">	{</a>
<a name="ln6306">	}</a>
<a name="ln6307"> </a>
<a name="ln6308">	PUGI__FN xml_node_struct* xml_text::_data() const</a>
<a name="ln6309">	{</a>
<a name="ln6310">		if (!_root || impl::is_text_node(_root)) return _root;</a>
<a name="ln6311"> </a>
<a name="ln6312">		// element nodes can have value if parse_embed_pcdata was used</a>
<a name="ln6313">		if (PUGI__NODETYPE(_root) == node_element &amp;&amp; _root-&gt;value)</a>
<a name="ln6314">			return _root;</a>
<a name="ln6315"> </a>
<a name="ln6316">		for (xml_node_struct* node = _root-&gt;first_child; node; node = node-&gt;next_sibling)</a>
<a name="ln6317">			if (impl::is_text_node(node))</a>
<a name="ln6318">				return node;</a>
<a name="ln6319"> </a>
<a name="ln6320">		return 0;</a>
<a name="ln6321">	}</a>
<a name="ln6322"> </a>
<a name="ln6323">	PUGI__FN xml_node_struct* xml_text::_data_new()</a>
<a name="ln6324">	{</a>
<a name="ln6325">		xml_node_struct* d = _data();</a>
<a name="ln6326">		if (d) return d;</a>
<a name="ln6327"> </a>
<a name="ln6328">		return xml_node(_root).append_child(node_pcdata).internal_object();</a>
<a name="ln6329">	}</a>
<a name="ln6330"> </a>
<a name="ln6331">	PUGI__FN xml_text::xml_text(): _root(0)</a>
<a name="ln6332">	{</a>
<a name="ln6333">	}</a>
<a name="ln6334"> </a>
<a name="ln6335">	PUGI__FN static void unspecified_bool_xml_text(xml_text***)</a>
<a name="ln6336">	{</a>
<a name="ln6337">	}</a>
<a name="ln6338"> </a>
<a name="ln6339">	PUGI__FN xml_text::operator xml_text::unspecified_bool_type() const</a>
<a name="ln6340">	{</a>
<a name="ln6341">		return _data() ? unspecified_bool_xml_text : 0;</a>
<a name="ln6342">	}</a>
<a name="ln6343"> </a>
<a name="ln6344">	PUGI__FN bool xml_text::operator!() const</a>
<a name="ln6345">	{</a>
<a name="ln6346">		return !_data();</a>
<a name="ln6347">	}</a>
<a name="ln6348"> </a>
<a name="ln6349">	PUGI__FN bool xml_text::empty() const</a>
<a name="ln6350">	{</a>
<a name="ln6351">		return _data() == 0;</a>
<a name="ln6352">	}</a>
<a name="ln6353"> </a>
<a name="ln6354">	PUGI__FN const char_t* xml_text::get() const</a>
<a name="ln6355">	{</a>
<a name="ln6356">		xml_node_struct* d = _data();</a>
<a name="ln6357"> </a>
<a name="ln6358">		return (d &amp;&amp; d-&gt;value) ? d-&gt;value + 0 : PUGIXML_TEXT(&quot;&quot;);</a>
<a name="ln6359">	}</a>
<a name="ln6360"> </a>
<a name="ln6361">	PUGI__FN const char_t* xml_text::as_string(const char_t* def) const</a>
<a name="ln6362">	{</a>
<a name="ln6363">		xml_node_struct* d = _data();</a>
<a name="ln6364"> </a>
<a name="ln6365">		return (d &amp;&amp; d-&gt;value) ? d-&gt;value + 0 : def;</a>
<a name="ln6366">	}</a>
<a name="ln6367"> </a>
<a name="ln6368">	PUGI__FN int xml_text::as_int(int def) const</a>
<a name="ln6369">	{</a>
<a name="ln6370">		xml_node_struct* d = _data();</a>
<a name="ln6371"> </a>
<a name="ln6372">		return (d &amp;&amp; d-&gt;value) ? impl::get_value_int(d-&gt;value) : def;</a>
<a name="ln6373">	}</a>
<a name="ln6374"> </a>
<a name="ln6375">	PUGI__FN unsigned int xml_text::as_uint(unsigned int def) const</a>
<a name="ln6376">	{</a>
<a name="ln6377">		xml_node_struct* d = _data();</a>
<a name="ln6378"> </a>
<a name="ln6379">		return (d &amp;&amp; d-&gt;value) ? impl::get_value_uint(d-&gt;value) : def;</a>
<a name="ln6380">	}</a>
<a name="ln6381"> </a>
<a name="ln6382">	PUGI__FN double xml_text::as_double(double def) const</a>
<a name="ln6383">	{</a>
<a name="ln6384">		xml_node_struct* d = _data();</a>
<a name="ln6385"> </a>
<a name="ln6386">		return (d &amp;&amp; d-&gt;value) ? impl::get_value_double(d-&gt;value) : def;</a>
<a name="ln6387">	}</a>
<a name="ln6388"> </a>
<a name="ln6389">	PUGI__FN float xml_text::as_float(float def) const</a>
<a name="ln6390">	{</a>
<a name="ln6391">		xml_node_struct* d = _data();</a>
<a name="ln6392"> </a>
<a name="ln6393">		return (d &amp;&amp; d-&gt;value) ? impl::get_value_float(d-&gt;value) : def;</a>
<a name="ln6394">	}</a>
<a name="ln6395"> </a>
<a name="ln6396">	PUGI__FN bool xml_text::as_bool(bool def) const</a>
<a name="ln6397">	{</a>
<a name="ln6398">		xml_node_struct* d = _data();</a>
<a name="ln6399"> </a>
<a name="ln6400">		return (d &amp;&amp; d-&gt;value) ? impl::get_value_bool(d-&gt;value) : def;</a>
<a name="ln6401">	}</a>
<a name="ln6402"> </a>
<a name="ln6403">#ifdef PUGIXML_HAS_LONG_LONG</a>
<a name="ln6404">	PUGI__FN long long xml_text::as_llong(long long def) const</a>
<a name="ln6405">	{</a>
<a name="ln6406">		xml_node_struct* d = _data();</a>
<a name="ln6407"> </a>
<a name="ln6408">		return (d &amp;&amp; d-&gt;value) ? impl::get_value_llong(d-&gt;value) : def;</a>
<a name="ln6409">	}</a>
<a name="ln6410"> </a>
<a name="ln6411">	PUGI__FN unsigned long long xml_text::as_ullong(unsigned long long def) const</a>
<a name="ln6412">	{</a>
<a name="ln6413">		xml_node_struct* d = _data();</a>
<a name="ln6414"> </a>
<a name="ln6415">		return (d &amp;&amp; d-&gt;value) ? impl::get_value_ullong(d-&gt;value) : def;</a>
<a name="ln6416">	}</a>
<a name="ln6417">#endif</a>
<a name="ln6418"> </a>
<a name="ln6419">	PUGI__FN bool xml_text::set(const char_t* rhs)</a>
<a name="ln6420">	{</a>
<a name="ln6421">		xml_node_struct* dn = _data_new();</a>
<a name="ln6422"> </a>
<a name="ln6423">		return dn ? impl::strcpy_insitu(dn-&gt;value, dn-&gt;header, impl::xml_memory_page_value_allocated_mask, rhs, impl::strlength(rhs)) : false;</a>
<a name="ln6424">	}</a>
<a name="ln6425"> </a>
<a name="ln6426">	PUGI__FN bool xml_text::set(int rhs)</a>
<a name="ln6427">	{</a>
<a name="ln6428">		xml_node_struct* dn = _data_new();</a>
<a name="ln6429"> </a>
<a name="ln6430">		return dn ? impl::set_value_integer&lt;unsigned int&gt;(dn-&gt;value, dn-&gt;header, impl::xml_memory_page_value_allocated_mask, rhs, rhs &lt; 0) : false;</a>
<a name="ln6431">	}</a>
<a name="ln6432"> </a>
<a name="ln6433">	PUGI__FN bool xml_text::set(unsigned int rhs)</a>
<a name="ln6434">	{</a>
<a name="ln6435">		xml_node_struct* dn = _data_new();</a>
<a name="ln6436"> </a>
<a name="ln6437">		return dn ? impl::set_value_integer&lt;unsigned int&gt;(dn-&gt;value, dn-&gt;header, impl::xml_memory_page_value_allocated_mask, rhs, false) : false;</a>
<a name="ln6438">	}</a>
<a name="ln6439"> </a>
<a name="ln6440">	PUGI__FN bool xml_text::set(long rhs)</a>
<a name="ln6441">	{</a>
<a name="ln6442">		xml_node_struct* dn = _data_new();</a>
<a name="ln6443"> </a>
<a name="ln6444">		return dn ? impl::set_value_integer&lt;unsigned long&gt;(dn-&gt;value, dn-&gt;header, impl::xml_memory_page_value_allocated_mask, rhs, rhs &lt; 0) : false;</a>
<a name="ln6445">	}</a>
<a name="ln6446"> </a>
<a name="ln6447">	PUGI__FN bool xml_text::set(unsigned long rhs)</a>
<a name="ln6448">	{</a>
<a name="ln6449">		xml_node_struct* dn = _data_new();</a>
<a name="ln6450"> </a>
<a name="ln6451">		return dn ? impl::set_value_integer&lt;unsigned long&gt;(dn-&gt;value, dn-&gt;header, impl::xml_memory_page_value_allocated_mask, rhs, false) : false;</a>
<a name="ln6452">	}</a>
<a name="ln6453"> </a>
<a name="ln6454">	PUGI__FN bool xml_text::set(float rhs)</a>
<a name="ln6455">	{</a>
<a name="ln6456">		xml_node_struct* dn = _data_new();</a>
<a name="ln6457"> </a>
<a name="ln6458">		return dn ? impl::set_value_convert(dn-&gt;value, dn-&gt;header, impl::xml_memory_page_value_allocated_mask, rhs) : false;</a>
<a name="ln6459">	}</a>
<a name="ln6460"> </a>
<a name="ln6461">	PUGI__FN bool xml_text::set(double rhs)</a>
<a name="ln6462">	{</a>
<a name="ln6463">		xml_node_struct* dn = _data_new();</a>
<a name="ln6464"> </a>
<a name="ln6465">		return dn ? impl::set_value_convert(dn-&gt;value, dn-&gt;header, impl::xml_memory_page_value_allocated_mask, rhs) : false;</a>
<a name="ln6466">	}</a>
<a name="ln6467"> </a>
<a name="ln6468">	PUGI__FN bool xml_text::set(bool rhs)</a>
<a name="ln6469">	{</a>
<a name="ln6470">		xml_node_struct* dn = _data_new();</a>
<a name="ln6471"> </a>
<a name="ln6472">		return dn ? impl::set_value_bool(dn-&gt;value, dn-&gt;header, impl::xml_memory_page_value_allocated_mask, rhs) : false;</a>
<a name="ln6473">	}</a>
<a name="ln6474"> </a>
<a name="ln6475">#ifdef PUGIXML_HAS_LONG_LONG</a>
<a name="ln6476">	PUGI__FN bool xml_text::set(long long rhs)</a>
<a name="ln6477">	{</a>
<a name="ln6478">		xml_node_struct* dn = _data_new();</a>
<a name="ln6479"> </a>
<a name="ln6480">		return dn ? impl::set_value_integer&lt;unsigned long long&gt;(dn-&gt;value, dn-&gt;header, impl::xml_memory_page_value_allocated_mask, rhs, rhs &lt; 0) : false;</a>
<a name="ln6481">	}</a>
<a name="ln6482"> </a>
<a name="ln6483">	PUGI__FN bool xml_text::set(unsigned long long rhs)</a>
<a name="ln6484">	{</a>
<a name="ln6485">		xml_node_struct* dn = _data_new();</a>
<a name="ln6486"> </a>
<a name="ln6487">		return dn ? impl::set_value_integer&lt;unsigned long long&gt;(dn-&gt;value, dn-&gt;header, impl::xml_memory_page_value_allocated_mask, rhs, false) : false;</a>
<a name="ln6488">	}</a>
<a name="ln6489">#endif</a>
<a name="ln6490"> </a>
<a name="ln6491">	PUGI__FN xml_text&amp; xml_text::operator=(const char_t* rhs)</a>
<a name="ln6492">	{</a>
<a name="ln6493">		set(rhs);</a>
<a name="ln6494">		return *this;</a>
<a name="ln6495">	}</a>
<a name="ln6496"> </a>
<a name="ln6497">	PUGI__FN xml_text&amp; xml_text::operator=(int rhs)</a>
<a name="ln6498">	{</a>
<a name="ln6499">		set(rhs);</a>
<a name="ln6500">		return *this;</a>
<a name="ln6501">	}</a>
<a name="ln6502"> </a>
<a name="ln6503">	PUGI__FN xml_text&amp; xml_text::operator=(unsigned int rhs)</a>
<a name="ln6504">	{</a>
<a name="ln6505">		set(rhs);</a>
<a name="ln6506">		return *this;</a>
<a name="ln6507">	}</a>
<a name="ln6508"> </a>
<a name="ln6509">	PUGI__FN xml_text&amp; xml_text::operator=(long rhs)</a>
<a name="ln6510">	{</a>
<a name="ln6511">		set(rhs);</a>
<a name="ln6512">		return *this;</a>
<a name="ln6513">	}</a>
<a name="ln6514"> </a>
<a name="ln6515">	PUGI__FN xml_text&amp; xml_text::operator=(unsigned long rhs)</a>
<a name="ln6516">	{</a>
<a name="ln6517">		set(rhs);</a>
<a name="ln6518">		return *this;</a>
<a name="ln6519">	}</a>
<a name="ln6520"> </a>
<a name="ln6521">	PUGI__FN xml_text&amp; xml_text::operator=(double rhs)</a>
<a name="ln6522">	{</a>
<a name="ln6523">		set(rhs);</a>
<a name="ln6524">		return *this;</a>
<a name="ln6525">	}</a>
<a name="ln6526"> </a>
<a name="ln6527">	PUGI__FN xml_text&amp; xml_text::operator=(float rhs)</a>
<a name="ln6528">	{</a>
<a name="ln6529">		set(rhs);</a>
<a name="ln6530">		return *this;</a>
<a name="ln6531">	}</a>
<a name="ln6532"> </a>
<a name="ln6533">	PUGI__FN xml_text&amp; xml_text::operator=(bool rhs)</a>
<a name="ln6534">	{</a>
<a name="ln6535">		set(rhs);</a>
<a name="ln6536">		return *this;</a>
<a name="ln6537">	}</a>
<a name="ln6538"> </a>
<a name="ln6539">#ifdef PUGIXML_HAS_LONG_LONG</a>
<a name="ln6540">	PUGI__FN xml_text&amp; xml_text::operator=(long long rhs)</a>
<a name="ln6541">	{</a>
<a name="ln6542">		set(rhs);</a>
<a name="ln6543">		return *this;</a>
<a name="ln6544">	}</a>
<a name="ln6545"> </a>
<a name="ln6546">	PUGI__FN xml_text&amp; xml_text::operator=(unsigned long long rhs)</a>
<a name="ln6547">	{</a>
<a name="ln6548">		set(rhs);</a>
<a name="ln6549">		return *this;</a>
<a name="ln6550">	}</a>
<a name="ln6551">#endif</a>
<a name="ln6552"> </a>
<a name="ln6553">	PUGI__FN xml_node xml_text::data() const</a>
<a name="ln6554">	{</a>
<a name="ln6555">		return xml_node(_data());</a>
<a name="ln6556">	}</a>
<a name="ln6557"> </a>
<a name="ln6558">#ifdef __BORLANDC__</a>
<a name="ln6559">	PUGI__FN bool operator&amp;&amp;(const xml_text&amp; lhs, bool rhs)</a>
<a name="ln6560">	{</a>
<a name="ln6561">		return (bool)lhs &amp;&amp; rhs;</a>
<a name="ln6562">	}</a>
<a name="ln6563"> </a>
<a name="ln6564">	PUGI__FN bool operator||(const xml_text&amp; lhs, bool rhs)</a>
<a name="ln6565">	{</a>
<a name="ln6566">		return (bool)lhs || rhs;</a>
<a name="ln6567">	}</a>
<a name="ln6568">#endif</a>
<a name="ln6569"> </a>
<a name="ln6570">	PUGI__FN xml_node_iterator::xml_node_iterator()</a>
<a name="ln6571">	{</a>
<a name="ln6572">	}</a>
<a name="ln6573"> </a>
<a name="ln6574">	PUGI__FN xml_node_iterator::xml_node_iterator(const xml_node&amp; node): _wrap(node), _parent(node.parent())</a>
<a name="ln6575">	{</a>
<a name="ln6576">	}</a>
<a name="ln6577"> </a>
<a name="ln6578">	PUGI__FN xml_node_iterator::xml_node_iterator(xml_node_struct* ref, xml_node_struct* parent): _wrap(ref), _parent(parent)</a>
<a name="ln6579">	{</a>
<a name="ln6580">	}</a>
<a name="ln6581"> </a>
<a name="ln6582">	PUGI__FN bool xml_node_iterator::operator==(const xml_node_iterator&amp; rhs) const</a>
<a name="ln6583">	{</a>
<a name="ln6584">		return _wrap._root == rhs._wrap._root &amp;&amp; _parent._root == rhs._parent._root;</a>
<a name="ln6585">	}</a>
<a name="ln6586"> </a>
<a name="ln6587">	PUGI__FN bool xml_node_iterator::operator!=(const xml_node_iterator&amp; rhs) const</a>
<a name="ln6588">	{</a>
<a name="ln6589">		return _wrap._root != rhs._wrap._root || _parent._root != rhs._parent._root;</a>
<a name="ln6590">	}</a>
<a name="ln6591"> </a>
<a name="ln6592">	PUGI__FN xml_node&amp; xml_node_iterator::operator*() const</a>
<a name="ln6593">	{</a>
<a name="ln6594">		assert(_wrap._root);</a>
<a name="ln6595">		return _wrap;</a>
<a name="ln6596">	}</a>
<a name="ln6597"> </a>
<a name="ln6598">	PUGI__FN xml_node* xml_node_iterator::operator-&gt;() const</a>
<a name="ln6599">	{</a>
<a name="ln6600">		assert(_wrap._root);</a>
<a name="ln6601">		return const_cast&lt;xml_node*&gt;(&amp;_wrap); // BCC5 workaround</a>
<a name="ln6602">	}</a>
<a name="ln6603"> </a>
<a name="ln6604">	PUGI__FN const xml_node_iterator&amp; xml_node_iterator::operator++()</a>
<a name="ln6605">	{</a>
<a name="ln6606">		assert(_wrap._root);</a>
<a name="ln6607">		_wrap._root = _wrap._root-&gt;next_sibling;</a>
<a name="ln6608">		return *this;</a>
<a name="ln6609">	}</a>
<a name="ln6610"> </a>
<a name="ln6611">	PUGI__FN xml_node_iterator xml_node_iterator::operator++(int)</a>
<a name="ln6612">	{</a>
<a name="ln6613">		xml_node_iterator temp = *this;</a>
<a name="ln6614">		++*this;</a>
<a name="ln6615">		return temp;</a>
<a name="ln6616">	}</a>
<a name="ln6617"> </a>
<a name="ln6618">	PUGI__FN const xml_node_iterator&amp; xml_node_iterator::operator--()</a>
<a name="ln6619">	{</a>
<a name="ln6620">		_wrap = _wrap._root ? _wrap.previous_sibling() : _parent.last_child();</a>
<a name="ln6621">		return *this;</a>
<a name="ln6622">	}</a>
<a name="ln6623"> </a>
<a name="ln6624">	PUGI__FN xml_node_iterator xml_node_iterator::operator--(int)</a>
<a name="ln6625">	{</a>
<a name="ln6626">		xml_node_iterator temp = *this;</a>
<a name="ln6627">		--*this;</a>
<a name="ln6628">		return temp;</a>
<a name="ln6629">	}</a>
<a name="ln6630"> </a>
<a name="ln6631">	PUGI__FN xml_attribute_iterator::xml_attribute_iterator()</a>
<a name="ln6632">	{</a>
<a name="ln6633">	}</a>
<a name="ln6634"> </a>
<a name="ln6635">	PUGI__FN xml_attribute_iterator::xml_attribute_iterator(const xml_attribute&amp; attr, const xml_node&amp; parent): _wrap(attr), _parent(parent)</a>
<a name="ln6636">	{</a>
<a name="ln6637">	}</a>
<a name="ln6638"> </a>
<a name="ln6639">	PUGI__FN xml_attribute_iterator::xml_attribute_iterator(xml_attribute_struct* ref, xml_node_struct* parent): _wrap(ref), _parent(parent)</a>
<a name="ln6640">	{</a>
<a name="ln6641">	}</a>
<a name="ln6642"> </a>
<a name="ln6643">	PUGI__FN bool xml_attribute_iterator::operator==(const xml_attribute_iterator&amp; rhs) const</a>
<a name="ln6644">	{</a>
<a name="ln6645">		return _wrap._attr == rhs._wrap._attr &amp;&amp; _parent._root == rhs._parent._root;</a>
<a name="ln6646">	}</a>
<a name="ln6647"> </a>
<a name="ln6648">	PUGI__FN bool xml_attribute_iterator::operator!=(const xml_attribute_iterator&amp; rhs) const</a>
<a name="ln6649">	{</a>
<a name="ln6650">		return _wrap._attr != rhs._wrap._attr || _parent._root != rhs._parent._root;</a>
<a name="ln6651">	}</a>
<a name="ln6652"> </a>
<a name="ln6653">	PUGI__FN xml_attribute&amp; xml_attribute_iterator::operator*() const</a>
<a name="ln6654">	{</a>
<a name="ln6655">		assert(_wrap._attr);</a>
<a name="ln6656">		return _wrap;</a>
<a name="ln6657">	}</a>
<a name="ln6658"> </a>
<a name="ln6659">	PUGI__FN xml_attribute* xml_attribute_iterator::operator-&gt;() const</a>
<a name="ln6660">	{</a>
<a name="ln6661">		assert(_wrap._attr);</a>
<a name="ln6662">		return const_cast&lt;xml_attribute*&gt;(&amp;_wrap); // BCC5 workaround</a>
<a name="ln6663">	}</a>
<a name="ln6664"> </a>
<a name="ln6665">	PUGI__FN const xml_attribute_iterator&amp; xml_attribute_iterator::operator++()</a>
<a name="ln6666">	{</a>
<a name="ln6667">		assert(_wrap._attr);</a>
<a name="ln6668">		_wrap._attr = _wrap._attr-&gt;next_attribute;</a>
<a name="ln6669">		return *this;</a>
<a name="ln6670">	}</a>
<a name="ln6671"> </a>
<a name="ln6672">	PUGI__FN xml_attribute_iterator xml_attribute_iterator::operator++(int)</a>
<a name="ln6673">	{</a>
<a name="ln6674">		xml_attribute_iterator temp = *this;</a>
<a name="ln6675">		++*this;</a>
<a name="ln6676">		return temp;</a>
<a name="ln6677">	}</a>
<a name="ln6678"> </a>
<a name="ln6679">	PUGI__FN const xml_attribute_iterator&amp; xml_attribute_iterator::operator--()</a>
<a name="ln6680">	{</a>
<a name="ln6681">		_wrap = _wrap._attr ? _wrap.previous_attribute() : _parent.last_attribute();</a>
<a name="ln6682">		return *this;</a>
<a name="ln6683">	}</a>
<a name="ln6684"> </a>
<a name="ln6685">	PUGI__FN xml_attribute_iterator xml_attribute_iterator::operator--(int)</a>
<a name="ln6686">	{</a>
<a name="ln6687">		xml_attribute_iterator temp = *this;</a>
<a name="ln6688">		--*this;</a>
<a name="ln6689">		return temp;</a>
<a name="ln6690">	}</a>
<a name="ln6691"> </a>
<a name="ln6692">	PUGI__FN xml_named_node_iterator::xml_named_node_iterator(): _name(0)</a>
<a name="ln6693">	{</a>
<a name="ln6694">	}</a>
<a name="ln6695"> </a>
<a name="ln6696">	PUGI__FN xml_named_node_iterator::xml_named_node_iterator(const xml_node&amp; node, const char_t* name): _wrap(node), _parent(node.parent()), _name(name)</a>
<a name="ln6697">	{</a>
<a name="ln6698">	}</a>
<a name="ln6699"> </a>
<a name="ln6700">	PUGI__FN xml_named_node_iterator::xml_named_node_iterator(xml_node_struct* ref, xml_node_struct* parent, const char_t* name): _wrap(ref), _parent(parent), _name(name)</a>
<a name="ln6701">	{</a>
<a name="ln6702">	}</a>
<a name="ln6703"> </a>
<a name="ln6704">	PUGI__FN bool xml_named_node_iterator::operator==(const xml_named_node_iterator&amp; rhs) const</a>
<a name="ln6705">	{</a>
<a name="ln6706">		return _wrap._root == rhs._wrap._root &amp;&amp; _parent._root == rhs._parent._root;</a>
<a name="ln6707">	}</a>
<a name="ln6708"> </a>
<a name="ln6709">	PUGI__FN bool xml_named_node_iterator::operator!=(const xml_named_node_iterator&amp; rhs) const</a>
<a name="ln6710">	{</a>
<a name="ln6711">		return _wrap._root != rhs._wrap._root || _parent._root != rhs._parent._root;</a>
<a name="ln6712">	}</a>
<a name="ln6713"> </a>
<a name="ln6714">	PUGI__FN xml_node&amp; xml_named_node_iterator::operator*() const</a>
<a name="ln6715">	{</a>
<a name="ln6716">		assert(_wrap._root);</a>
<a name="ln6717">		return _wrap;</a>
<a name="ln6718">	}</a>
<a name="ln6719"> </a>
<a name="ln6720">	PUGI__FN xml_node* xml_named_node_iterator::operator-&gt;() const</a>
<a name="ln6721">	{</a>
<a name="ln6722">		assert(_wrap._root);</a>
<a name="ln6723">		return const_cast&lt;xml_node*&gt;(&amp;_wrap); // BCC5 workaround</a>
<a name="ln6724">	}</a>
<a name="ln6725"> </a>
<a name="ln6726">	PUGI__FN const xml_named_node_iterator&amp; xml_named_node_iterator::operator++()</a>
<a name="ln6727">	{</a>
<a name="ln6728">		assert(_wrap._root);</a>
<a name="ln6729">		_wrap = _wrap.next_sibling(_name);</a>
<a name="ln6730">		return *this;</a>
<a name="ln6731">	}</a>
<a name="ln6732"> </a>
<a name="ln6733">	PUGI__FN xml_named_node_iterator xml_named_node_iterator::operator++(int)</a>
<a name="ln6734">	{</a>
<a name="ln6735">		xml_named_node_iterator temp = *this;</a>
<a name="ln6736">		++*this;</a>
<a name="ln6737">		return temp;</a>
<a name="ln6738">	}</a>
<a name="ln6739"> </a>
<a name="ln6740">	PUGI__FN const xml_named_node_iterator&amp; xml_named_node_iterator::operator--()</a>
<a name="ln6741">	{</a>
<a name="ln6742">		if (_wrap._root)</a>
<a name="ln6743">			_wrap = _wrap.previous_sibling(_name);</a>
<a name="ln6744">		else</a>
<a name="ln6745">		{</a>
<a name="ln6746">			_wrap = _parent.last_child();</a>
<a name="ln6747"> </a>
<a name="ln6748">			if (!impl::strequal(_wrap.name(), _name))</a>
<a name="ln6749">				_wrap = _wrap.previous_sibling(_name);</a>
<a name="ln6750">		}</a>
<a name="ln6751"> </a>
<a name="ln6752">		return *this;</a>
<a name="ln6753">	}</a>
<a name="ln6754"> </a>
<a name="ln6755">	PUGI__FN xml_named_node_iterator xml_named_node_iterator::operator--(int)</a>
<a name="ln6756">	{</a>
<a name="ln6757">		xml_named_node_iterator temp = *this;</a>
<a name="ln6758">		--*this;</a>
<a name="ln6759">		return temp;</a>
<a name="ln6760">	}</a>
<a name="ln6761"> </a>
<a name="ln6762">	PUGI__FN xml_parse_result::xml_parse_result(): status(status_internal_error), offset(0), encoding(encoding_auto)</a>
<a name="ln6763">	{</a>
<a name="ln6764">	}</a>
<a name="ln6765"> </a>
<a name="ln6766">	PUGI__FN xml_parse_result::operator bool() const</a>
<a name="ln6767">	{</a>
<a name="ln6768">		return status == status_ok;</a>
<a name="ln6769">	}</a>
<a name="ln6770"> </a>
<a name="ln6771">	PUGI__FN const char* xml_parse_result::description() const</a>
<a name="ln6772">	{</a>
<a name="ln6773">		switch (status)</a>
<a name="ln6774">		{</a>
<a name="ln6775">		case status_ok: return &quot;No error&quot;;</a>
<a name="ln6776"> </a>
<a name="ln6777">		case status_file_not_found: return &quot;File was not found&quot;;</a>
<a name="ln6778">		case status_io_error: return &quot;Error reading from file/stream&quot;;</a>
<a name="ln6779">		case status_out_of_memory: return &quot;Could not allocate memory&quot;;</a>
<a name="ln6780">		case status_internal_error: return &quot;Internal error occurred&quot;;</a>
<a name="ln6781"> </a>
<a name="ln6782">		case status_unrecognized_tag: return &quot;Could not determine tag type&quot;;</a>
<a name="ln6783"> </a>
<a name="ln6784">		case status_bad_pi: return &quot;Error parsing document declaration/processing instruction&quot;;</a>
<a name="ln6785">		case status_bad_comment: return &quot;Error parsing comment&quot;;</a>
<a name="ln6786">		case status_bad_cdata: return &quot;Error parsing CDATA section&quot;;</a>
<a name="ln6787">		case status_bad_doctype: return &quot;Error parsing document type declaration&quot;;</a>
<a name="ln6788">		case status_bad_pcdata: return &quot;Error parsing PCDATA section&quot;;</a>
<a name="ln6789">		case status_bad_start_element: return &quot;Error parsing start element tag&quot;;</a>
<a name="ln6790">		case status_bad_attribute: return &quot;Error parsing element attribute&quot;;</a>
<a name="ln6791">		case status_bad_end_element: return &quot;Error parsing end element tag&quot;;</a>
<a name="ln6792">		case status_end_element_mismatch: return &quot;Start-end tags mismatch&quot;;</a>
<a name="ln6793"> </a>
<a name="ln6794">		case status_append_invalid_root: return &quot;Unable to append nodes: root is not an element or document&quot;;</a>
<a name="ln6795"> </a>
<a name="ln6796">		case status_no_document_element: return &quot;No document element found&quot;;</a>
<a name="ln6797"> </a>
<a name="ln6798">		default: return &quot;Unknown error&quot;;</a>
<a name="ln6799">		}</a>
<a name="ln6800">	}</a>
<a name="ln6801"> </a>
<a name="ln6802">	PUGI__FN xml_document::xml_document(): _buffer(0)</a>
<a name="ln6803">	{</a>
<a name="ln6804">		_create();</a>
<a name="ln6805">	}</a>
<a name="ln6806"> </a>
<a name="ln6807">	PUGI__FN xml_document::~xml_document()</a>
<a name="ln6808">	{</a>
<a name="ln6809">		_destroy();</a>
<a name="ln6810">	}</a>
<a name="ln6811"> </a>
<a name="ln6812">	PUGI__FN void xml_document::reset()</a>
<a name="ln6813">	{</a>
<a name="ln6814">		_destroy();</a>
<a name="ln6815">		_create();</a>
<a name="ln6816">	}</a>
<a name="ln6817"> </a>
<a name="ln6818">	PUGI__FN void xml_document::reset(const xml_document&amp; proto)</a>
<a name="ln6819">	{</a>
<a name="ln6820">		reset();</a>
<a name="ln6821"> </a>
<a name="ln6822">		for (xml_node cur = proto.first_child(); cur; cur = cur.next_sibling())</a>
<a name="ln6823">			append_copy(cur);</a>
<a name="ln6824">	}</a>
<a name="ln6825"> </a>
<a name="ln6826">	PUGI__FN void xml_document::_create()</a>
<a name="ln6827">	{</a>
<a name="ln6828">		assert(!_root);</a>
<a name="ln6829"> </a>
<a name="ln6830">	#ifdef PUGIXML_COMPACT</a>
<a name="ln6831">		const size_t page_offset = sizeof(uint32_t);</a>
<a name="ln6832">	#else</a>
<a name="ln6833">		const size_t page_offset = 0;</a>
<a name="ln6834">	#endif</a>
<a name="ln6835"> </a>
<a name="ln6836">		// initialize sentinel page</a>
<a name="ln6837">		PUGI__STATIC_ASSERT(sizeof(impl::xml_memory_page) + sizeof(impl::xml_document_struct) + page_offset &lt;= sizeof(_memory));</a>
<a name="ln6838"> </a>
<a name="ln6839">		// prepare page structure</a>
<a name="ln6840">		impl::xml_memory_page* page = impl::xml_memory_page::construct(_memory);</a>
<a name="ln6841">		assert(page);</a>
<a name="ln6842"> </a>
<a name="ln6843">		page-&gt;busy_size = impl::xml_memory_page_size;</a>
<a name="ln6844"> </a>
<a name="ln6845">		// setup first page marker</a>
<a name="ln6846">	#ifdef PUGIXML_COMPACT</a>
<a name="ln6847">		// round-trip through void* to avoid 'cast increases required alignment of target type' warning</a>
<a name="ln6848">		page-&gt;compact_page_marker = reinterpret_cast&lt;uint32_t*&gt;(static_cast&lt;void*&gt;(reinterpret_cast&lt;char*&gt;(page) + sizeof(impl::xml_memory_page)));</a>
<a name="ln6849">		*page-&gt;compact_page_marker = sizeof(impl::xml_memory_page);</a>
<a name="ln6850">	#endif</a>
<a name="ln6851"> </a>
<a name="ln6852">		// allocate new root</a>
<a name="ln6853">		_root = new (reinterpret_cast&lt;char*&gt;(page) + sizeof(impl::xml_memory_page) + page_offset) impl::xml_document_struct(page);</a>
<a name="ln6854">		_root-&gt;prev_sibling_c = _root;</a>
<a name="ln6855"> </a>
<a name="ln6856">		// setup sentinel page</a>
<a name="ln6857">		page-&gt;allocator = static_cast&lt;impl::xml_document_struct*&gt;(_root);</a>
<a name="ln6858"> </a>
<a name="ln6859">		// setup hash table pointer in allocator</a>
<a name="ln6860">	#ifdef PUGIXML_COMPACT</a>
<a name="ln6861">		page-&gt;allocator-&gt;_hash = &amp;static_cast&lt;impl::xml_document_struct*&gt;(_root)-&gt;hash;</a>
<a name="ln6862">	#endif</a>
<a name="ln6863"> </a>
<a name="ln6864">		// verify the document allocation</a>
<a name="ln6865">		assert(reinterpret_cast&lt;char*&gt;(_root) + sizeof(impl::xml_document_struct) &lt;= _memory + sizeof(_memory));</a>
<a name="ln6866">	}</a>
<a name="ln6867"> </a>
<a name="ln6868">	PUGI__FN void xml_document::_destroy()</a>
<a name="ln6869">	{</a>
<a name="ln6870">		assert(_root);</a>
<a name="ln6871"> </a>
<a name="ln6872">		// destroy static storage</a>
<a name="ln6873">		if (_buffer)</a>
<a name="ln6874">		{</a>
<a name="ln6875">			impl::xml_memory::deallocate(_buffer);</a>
<a name="ln6876">			_buffer = 0;</a>
<a name="ln6877">		}</a>
<a name="ln6878"> </a>
<a name="ln6879">		// destroy extra buffers (note: no need to destroy linked list nodes, they're allocated using document allocator)</a>
<a name="ln6880">		for (impl::xml_extra_buffer* extra = static_cast&lt;impl::xml_document_struct*&gt;(_root)-&gt;extra_buffers; extra; extra = extra-&gt;next)</a>
<a name="ln6881">		{</a>
<a name="ln6882">			if (extra-&gt;buffer) impl::xml_memory::deallocate(extra-&gt;buffer);</a>
<a name="ln6883">		}</a>
<a name="ln6884"> </a>
<a name="ln6885">		// destroy dynamic storage, leave sentinel page (it's in static memory)</a>
<a name="ln6886">		impl::xml_memory_page* root_page = PUGI__GETPAGE(_root);</a>
<a name="ln6887">		assert(root_page &amp;&amp; !root_page-&gt;prev);</a>
<a name="ln6888">		assert(reinterpret_cast&lt;char*&gt;(root_page) &gt;= _memory &amp;&amp; reinterpret_cast&lt;char*&gt;(root_page) &lt; _memory + sizeof(_memory));</a>
<a name="ln6889"> </a>
<a name="ln6890">		for (impl::xml_memory_page* page = root_page-&gt;next; page; )</a>
<a name="ln6891">		{</a>
<a name="ln6892">			impl::xml_memory_page* next = page-&gt;next;</a>
<a name="ln6893"> </a>
<a name="ln6894">			impl::xml_allocator::deallocate_page(page);</a>
<a name="ln6895"> </a>
<a name="ln6896">			page = next;</a>
<a name="ln6897">		}</a>
<a name="ln6898"> </a>
<a name="ln6899">	#ifdef PUGIXML_COMPACT</a>
<a name="ln6900">		// destroy hash table</a>
<a name="ln6901">		static_cast&lt;impl::xml_document_struct*&gt;(_root)-&gt;hash.clear();</a>
<a name="ln6902">	#endif</a>
<a name="ln6903"> </a>
<a name="ln6904">		_root = 0;</a>
<a name="ln6905">	}</a>
<a name="ln6906"> </a>
<a name="ln6907">#ifndef PUGIXML_NO_STL</a>
<a name="ln6908">	PUGI__FN xml_parse_result xml_document::load(std::basic_istream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; stream, unsigned int options, xml_encoding encoding)</a>
<a name="ln6909">	{</a>
<a name="ln6910">		reset();</a>
<a name="ln6911"> </a>
<a name="ln6912">		return impl::load_stream_impl(static_cast&lt;impl::xml_document_struct*&gt;(_root), stream, options, encoding, &amp;_buffer);</a>
<a name="ln6913">	}</a>
<a name="ln6914"> </a>
<a name="ln6915">	PUGI__FN xml_parse_result xml_document::load(std::basic_istream&lt;wchar_t, std::char_traits&lt;wchar_t&gt; &gt;&amp; stream, unsigned int options)</a>
<a name="ln6916">	{</a>
<a name="ln6917">		reset();</a>
<a name="ln6918"> </a>
<a name="ln6919">		return impl::load_stream_impl(static_cast&lt;impl::xml_document_struct*&gt;(_root), stream, options, encoding_wchar, &amp;_buffer);</a>
<a name="ln6920">	}</a>
<a name="ln6921">#endif</a>
<a name="ln6922"> </a>
<a name="ln6923">	PUGI__FN xml_parse_result xml_document::load_string(const char_t* contents, unsigned int options)</a>
<a name="ln6924">	{</a>
<a name="ln6925">		// Force native encoding (skip autodetection)</a>
<a name="ln6926">	#ifdef PUGIXML_WCHAR_MODE</a>
<a name="ln6927">		xml_encoding encoding = encoding_wchar;</a>
<a name="ln6928">	#else</a>
<a name="ln6929">		xml_encoding encoding = encoding_utf8;</a>
<a name="ln6930">	#endif</a>
<a name="ln6931"> </a>
<a name="ln6932">		return load_buffer(contents, impl::strlength(contents) * sizeof(char_t), options, encoding);</a>
<a name="ln6933">	}</a>
<a name="ln6934"> </a>
<a name="ln6935">	PUGI__FN xml_parse_result xml_document::load(const char_t* contents, unsigned int options)</a>
<a name="ln6936">	{</a>
<a name="ln6937">		return load_string(contents, options);</a>
<a name="ln6938">	}</a>
<a name="ln6939"> </a>
<a name="ln6940">	PUGI__FN xml_parse_result xml_document::load_file(const char* path_, unsigned int options, xml_encoding encoding)</a>
<a name="ln6941">	{</a>
<a name="ln6942">		reset();</a>
<a name="ln6943"> </a>
<a name="ln6944">		using impl::auto_deleter; // MSVC7 workaround</a>
<a name="ln6945">		auto_deleter&lt;FILE&gt; file(fopen(path_, &quot;rb&quot;), impl::close_file);</a>
<a name="ln6946"> </a>
<a name="ln6947">		return impl::load_file_impl(static_cast&lt;impl::xml_document_struct*&gt;(_root), file.data, options, encoding, &amp;_buffer);</a>
<a name="ln6948">	}</a>
<a name="ln6949"> </a>
<a name="ln6950">	PUGI__FN xml_parse_result xml_document::load_file(const wchar_t* path_, unsigned int options, xml_encoding encoding)</a>
<a name="ln6951">	{</a>
<a name="ln6952">		reset();</a>
<a name="ln6953"> </a>
<a name="ln6954">		using impl::auto_deleter; // MSVC7 workaround</a>
<a name="ln6955">		auto_deleter&lt;FILE&gt; file(impl::open_file_wide(path_, L&quot;rb&quot;), impl::close_file);</a>
<a name="ln6956"> </a>
<a name="ln6957">		return impl::load_file_impl(static_cast&lt;impl::xml_document_struct*&gt;(_root), file.data, options, encoding, &amp;_buffer);</a>
<a name="ln6958">	}</a>
<a name="ln6959"> </a>
<a name="ln6960">	PUGI__FN xml_parse_result xml_document::load_buffer(const void* contents, size_t size, unsigned int options, xml_encoding encoding)</a>
<a name="ln6961">	{</a>
<a name="ln6962">		reset();</a>
<a name="ln6963"> </a>
<a name="ln6964">		return impl::load_buffer_impl(static_cast&lt;impl::xml_document_struct*&gt;(_root), _root, const_cast&lt;void*&gt;(contents), size, options, encoding, false, false, &amp;_buffer);</a>
<a name="ln6965">	}</a>
<a name="ln6966"> </a>
<a name="ln6967">	PUGI__FN xml_parse_result xml_document::load_buffer_inplace(void* contents, size_t size, unsigned int options, xml_encoding encoding)</a>
<a name="ln6968">	{</a>
<a name="ln6969">		reset();</a>
<a name="ln6970"> </a>
<a name="ln6971">		return impl::load_buffer_impl(static_cast&lt;impl::xml_document_struct*&gt;(_root), _root, contents, size, options, encoding, true, false, &amp;_buffer);</a>
<a name="ln6972">	}</a>
<a name="ln6973"> </a>
<a name="ln6974">	PUGI__FN xml_parse_result xml_document::load_buffer_inplace_own(void* contents, size_t size, unsigned int options, xml_encoding encoding)</a>
<a name="ln6975">	{</a>
<a name="ln6976">		reset();</a>
<a name="ln6977"> </a>
<a name="ln6978">		return impl::load_buffer_impl(static_cast&lt;impl::xml_document_struct*&gt;(_root), _root, contents, size, options, encoding, true, true, &amp;_buffer);</a>
<a name="ln6979">	}</a>
<a name="ln6980"> </a>
<a name="ln6981">	PUGI__FN void xml_document::save(xml_writer&amp; writer, const char_t* indent, unsigned int flags, xml_encoding encoding) const</a>
<a name="ln6982">	{</a>
<a name="ln6983">		impl::xml_buffered_writer buffered_writer(writer, encoding);</a>
<a name="ln6984"> </a>
<a name="ln6985">		if ((flags &amp; format_write_bom) &amp;&amp; encoding != encoding_latin1)</a>
<a name="ln6986">		{</a>
<a name="ln6987">			// BOM always represents the codepoint U+FEFF, so just write it in native encoding</a>
<a name="ln6988">		#ifdef PUGIXML_WCHAR_MODE</a>
<a name="ln6989">			unsigned int bom = 0xfeff;</a>
<a name="ln6990">			buffered_writer.write(static_cast&lt;wchar_t&gt;(bom));</a>
<a name="ln6991">		#else</a>
<a name="ln6992">			buffered_writer.write('\xef', '\xbb', '\xbf');</a>
<a name="ln6993">		#endif</a>
<a name="ln6994">		}</a>
<a name="ln6995"> </a>
<a name="ln6996">		if (!(flags &amp; format_no_declaration) &amp;&amp; !impl::has_declaration(_root))</a>
<a name="ln6997">		{</a>
<a name="ln6998">			buffered_writer.write_string(PUGIXML_TEXT(&quot;&lt;?xml version=\&quot;1.0\&quot;&quot;));</a>
<a name="ln6999">			if (encoding == encoding_latin1) buffered_writer.write_string(PUGIXML_TEXT(&quot; encoding=\&quot;ISO-8859-1\&quot;&quot;));</a>
<a name="ln7000">			buffered_writer.write('?', '&gt;');</a>
<a name="ln7001">			if (!(flags &amp; format_raw)) buffered_writer.write('\n');</a>
<a name="ln7002">		}</a>
<a name="ln7003"> </a>
<a name="ln7004">		impl::node_output(buffered_writer, _root, indent, flags, 0);</a>
<a name="ln7005"> </a>
<a name="ln7006">		buffered_writer.flush();</a>
<a name="ln7007">	}</a>
<a name="ln7008"> </a>
<a name="ln7009">#ifndef PUGIXML_NO_STL</a>
<a name="ln7010">	PUGI__FN void xml_document::save(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; stream, const char_t* indent, unsigned int flags, xml_encoding encoding) const</a>
<a name="ln7011">	{</a>
<a name="ln7012">		xml_writer_stream writer(stream);</a>
<a name="ln7013"> </a>
<a name="ln7014">		save(writer, indent, flags, encoding);</a>
<a name="ln7015">	}</a>
<a name="ln7016"> </a>
<a name="ln7017">	PUGI__FN void xml_document::save(std::basic_ostream&lt;wchar_t, std::char_traits&lt;wchar_t&gt; &gt;&amp; stream, const char_t* indent, unsigned int flags) const</a>
<a name="ln7018">	{</a>
<a name="ln7019">		xml_writer_stream writer(stream);</a>
<a name="ln7020"> </a>
<a name="ln7021">		save(writer, indent, flags, encoding_wchar);</a>
<a name="ln7022">	}</a>
<a name="ln7023">#endif</a>
<a name="ln7024"> </a>
<a name="ln7025">	PUGI__FN bool xml_document::save_file(const char* path_, const char_t* indent, unsigned int flags, xml_encoding encoding) const</a>
<a name="ln7026">	{</a>
<a name="ln7027">		using impl::auto_deleter; // MSVC7 workaround</a>
<a name="ln7028">		auto_deleter&lt;FILE&gt; file(fopen(path_, (flags &amp; format_save_file_text) ? &quot;w&quot; : &quot;wb&quot;), impl::close_file);</a>
<a name="ln7029"> </a>
<a name="ln7030">		return impl::save_file_impl(*this, file.data, indent, flags, encoding);</a>
<a name="ln7031">	}</a>
<a name="ln7032"> </a>
<a name="ln7033">	PUGI__FN bool xml_document::save_file(const wchar_t* path_, const char_t* indent, unsigned int flags, xml_encoding encoding) const</a>
<a name="ln7034">	{</a>
<a name="ln7035">		using impl::auto_deleter; // MSVC7 workaround</a>
<a name="ln7036">		auto_deleter&lt;FILE&gt; file(impl::open_file_wide(path_, (flags &amp; format_save_file_text) ? L&quot;w&quot; : L&quot;wb&quot;), impl::close_file);</a>
<a name="ln7037"> </a>
<a name="ln7038">		return impl::save_file_impl(*this, file.data, indent, flags, encoding);</a>
<a name="ln7039">	}</a>
<a name="ln7040"> </a>
<a name="ln7041">	PUGI__FN xml_node xml_document::document_element() const</a>
<a name="ln7042">	{</a>
<a name="ln7043">		assert(_root);</a>
<a name="ln7044"> </a>
<a name="ln7045">		for (xml_node_struct* i = _root-&gt;first_child; i; i = i-&gt;next_sibling)</a>
<a name="ln7046">			if (PUGI__NODETYPE(i) == node_element)</a>
<a name="ln7047">				return xml_node(i);</a>
<a name="ln7048"> </a>
<a name="ln7049">		return xml_node();</a>
<a name="ln7050">	}</a>
<a name="ln7051"> </a>
<a name="ln7052">#ifndef PUGIXML_NO_STL</a>
<a name="ln7053">	PUGI__FN std::string PUGIXML_FUNCTION as_utf8(const wchar_t* str)</a>
<a name="ln7054">	{</a>
<a name="ln7055">		assert(str);</a>
<a name="ln7056"> </a>
<a name="ln7057">		return impl::as_utf8_impl(str, impl::strlength_wide(str));</a>
<a name="ln7058">	}</a>
<a name="ln7059"> </a>
<a name="ln7060">	PUGI__FN std::string PUGIXML_FUNCTION as_utf8(const std::basic_string&lt;wchar_t&gt;&amp; str)</a>
<a name="ln7061">	{</a>
<a name="ln7062">		return impl::as_utf8_impl(str.c_str(), str.size());</a>
<a name="ln7063">	}</a>
<a name="ln7064"> </a>
<a name="ln7065">	PUGI__FN std::basic_string&lt;wchar_t&gt; PUGIXML_FUNCTION as_wide(const char* str)</a>
<a name="ln7066">	{</a>
<a name="ln7067">		assert(str);</a>
<a name="ln7068"> </a>
<a name="ln7069">		return impl::as_wide_impl(str, strlen(str));</a>
<a name="ln7070">	}</a>
<a name="ln7071"> </a>
<a name="ln7072">	PUGI__FN std::basic_string&lt;wchar_t&gt; PUGIXML_FUNCTION as_wide(const std::string&amp; str)</a>
<a name="ln7073">	{</a>
<a name="ln7074">		return impl::as_wide_impl(str.c_str(), str.size());</a>
<a name="ln7075">	}</a>
<a name="ln7076">#endif</a>
<a name="ln7077"> </a>
<a name="ln7078">	PUGI__FN void PUGIXML_FUNCTION set_memory_management_functions(allocation_function allocate, deallocation_function deallocate)</a>
<a name="ln7079">	{</a>
<a name="ln7080">		impl::xml_memory::allocate = allocate;</a>
<a name="ln7081">		impl::xml_memory::deallocate = deallocate;</a>
<a name="ln7082">	}</a>
<a name="ln7083"> </a>
<a name="ln7084">	PUGI__FN allocation_function PUGIXML_FUNCTION get_memory_allocation_function()</a>
<a name="ln7085">	{</a>
<a name="ln7086">		return impl::xml_memory::allocate;</a>
<a name="ln7087">	}</a>
<a name="ln7088"> </a>
<a name="ln7089">	PUGI__FN deallocation_function PUGIXML_FUNCTION get_memory_deallocation_function()</a>
<a name="ln7090">	{</a>
<a name="ln7091">		return impl::xml_memory::deallocate;</a>
<a name="ln7092">	}</a>
<a name="ln7093">}</a>
<a name="ln7094"> </a>
<a name="ln7095">#if !defined(PUGIXML_NO_STL) &amp;&amp; (defined(_MSC_VER) || defined(__ICC))</a>
<a name="ln7096">namespace std</a>
<a name="ln7097">{</a>
<a name="ln7098">	// Workarounds for (non-standard) iterator category detection for older versions (MSVC7/IC8 and earlier)</a>
<a name="ln7099">	PUGI__FN std::bidirectional_iterator_tag _Iter_cat(const pugi::xml_node_iterator&amp;)</a>
<a name="ln7100">	{</a>
<a name="ln7101">		return std::bidirectional_iterator_tag();</a>
<a name="ln7102">	}</a>
<a name="ln7103"> </a>
<a name="ln7104">	PUGI__FN std::bidirectional_iterator_tag _Iter_cat(const pugi::xml_attribute_iterator&amp;)</a>
<a name="ln7105">	{</a>
<a name="ln7106">		return std::bidirectional_iterator_tag();</a>
<a name="ln7107">	}</a>
<a name="ln7108"> </a>
<a name="ln7109">	PUGI__FN std::bidirectional_iterator_tag _Iter_cat(const pugi::xml_named_node_iterator&amp;)</a>
<a name="ln7110">	{</a>
<a name="ln7111">		return std::bidirectional_iterator_tag();</a>
<a name="ln7112">	}</a>
<a name="ln7113">}</a>
<a name="ln7114">#endif</a>
<a name="ln7115"> </a>
<a name="ln7116">#if !defined(PUGIXML_NO_STL) &amp;&amp; defined(__SUNPRO_CC)</a>
<a name="ln7117">namespace std</a>
<a name="ln7118">{</a>
<a name="ln7119">	// Workarounds for (non-standard) iterator category detection</a>
<a name="ln7120">	PUGI__FN std::bidirectional_iterator_tag __iterator_category(const pugi::xml_node_iterator&amp;)</a>
<a name="ln7121">	{</a>
<a name="ln7122">		return std::bidirectional_iterator_tag();</a>
<a name="ln7123">	}</a>
<a name="ln7124"> </a>
<a name="ln7125">	PUGI__FN std::bidirectional_iterator_tag __iterator_category(const pugi::xml_attribute_iterator&amp;)</a>
<a name="ln7126">	{</a>
<a name="ln7127">		return std::bidirectional_iterator_tag();</a>
<a name="ln7128">	}</a>
<a name="ln7129"> </a>
<a name="ln7130">	PUGI__FN std::bidirectional_iterator_tag __iterator_category(const pugi::xml_named_node_iterator&amp;)</a>
<a name="ln7131">	{</a>
<a name="ln7132">		return std::bidirectional_iterator_tag();</a>
<a name="ln7133">	}</a>
<a name="ln7134">}</a>
<a name="ln7135">#endif</a>
<a name="ln7136"> </a>
<a name="ln7137">#ifndef PUGIXML_NO_XPATH</a>
<a name="ln7138">// STL replacements</a>
<a name="ln7139">PUGI__NS_BEGIN</a>
<a name="ln7140">	struct equal_to</a>
<a name="ln7141">	{</a>
<a name="ln7142">		template &lt;typename T&gt; bool operator()(const T&amp; lhs, const T&amp; rhs) const</a>
<a name="ln7143">		{</a>
<a name="ln7144">			return lhs == rhs;</a>
<a name="ln7145">		}</a>
<a name="ln7146">	};</a>
<a name="ln7147"> </a>
<a name="ln7148">	struct not_equal_to</a>
<a name="ln7149">	{</a>
<a name="ln7150">		template &lt;typename T&gt; bool operator()(const T&amp; lhs, const T&amp; rhs) const</a>
<a name="ln7151">		{</a>
<a name="ln7152">			return lhs != rhs;</a>
<a name="ln7153">		}</a>
<a name="ln7154">	};</a>
<a name="ln7155"> </a>
<a name="ln7156">	struct less</a>
<a name="ln7157">	{</a>
<a name="ln7158">		template &lt;typename T&gt; bool operator()(const T&amp; lhs, const T&amp; rhs) const</a>
<a name="ln7159">		{</a>
<a name="ln7160">			return lhs &lt; rhs;</a>
<a name="ln7161">		}</a>
<a name="ln7162">	};</a>
<a name="ln7163"> </a>
<a name="ln7164">	struct less_equal</a>
<a name="ln7165">	{</a>
<a name="ln7166">		template &lt;typename T&gt; bool operator()(const T&amp; lhs, const T&amp; rhs) const</a>
<a name="ln7167">		{</a>
<a name="ln7168">			return lhs &lt;= rhs;</a>
<a name="ln7169">		}</a>
<a name="ln7170">	};</a>
<a name="ln7171"> </a>
<a name="ln7172">	template &lt;typename T&gt; void swap(T&amp; lhs, T&amp; rhs)</a>
<a name="ln7173">	{</a>
<a name="ln7174">		T temp = lhs;</a>
<a name="ln7175">		lhs = rhs;</a>
<a name="ln7176">		rhs = temp;</a>
<a name="ln7177">	}</a>
<a name="ln7178"> </a>
<a name="ln7179">	template &lt;typename I, typename Pred&gt; I min_element(I begin, I end, const Pred&amp; pred)</a>
<a name="ln7180">	{</a>
<a name="ln7181">		I result = begin;</a>
<a name="ln7182"> </a>
<a name="ln7183">		for (I it = begin + 1; it != end; ++it)</a>
<a name="ln7184">			if (pred(*it, *result))</a>
<a name="ln7185">				result = it;</a>
<a name="ln7186"> </a>
<a name="ln7187">		return result;</a>
<a name="ln7188">	}</a>
<a name="ln7189"> </a>
<a name="ln7190">	template &lt;typename I&gt; void reverse(I begin, I end)</a>
<a name="ln7191">	{</a>
<a name="ln7192">		while (end - begin &gt; 1) swap(*begin++, *--end);</a>
<a name="ln7193">	}</a>
<a name="ln7194"> </a>
<a name="ln7195">	template &lt;typename I&gt; I unique(I begin, I end)</a>
<a name="ln7196">	{</a>
<a name="ln7197">		// fast skip head</a>
<a name="ln7198">		while (end - begin &gt; 1 &amp;&amp; *begin != *(begin + 1)) begin++;</a>
<a name="ln7199"> </a>
<a name="ln7200">		if (begin == end) return begin;</a>
<a name="ln7201"> </a>
<a name="ln7202">		// last written element</a>
<a name="ln7203">		I write = begin++;</a>
<a name="ln7204"> </a>
<a name="ln7205">		// merge unique elements</a>
<a name="ln7206">		while (begin != end)</a>
<a name="ln7207">		{</a>
<a name="ln7208">			if (*begin != *write)</a>
<a name="ln7209">				*++write = *begin++;</a>
<a name="ln7210">			else</a>
<a name="ln7211">				begin++;</a>
<a name="ln7212">		}</a>
<a name="ln7213"> </a>
<a name="ln7214">		// past-the-end (write points to live element)</a>
<a name="ln7215">		return write + 1;</a>
<a name="ln7216">	}</a>
<a name="ln7217"> </a>
<a name="ln7218">	template &lt;typename I&gt; void copy_backwards(I begin, I end, I target)</a>
<a name="ln7219">	{</a>
<a name="ln7220">		while (begin != end) *--target = *--end;</a>
<a name="ln7221">	}</a>
<a name="ln7222"> </a>
<a name="ln7223">	template &lt;typename I, typename Pred, typename T&gt; void insertion_sort(I begin, I end, const Pred&amp; pred, T*)</a>
<a name="ln7224">	{</a>
<a name="ln7225">		assert(begin != end);</a>
<a name="ln7226"> </a>
<a name="ln7227">		for (I it = begin + 1; it != end; ++it)</a>
<a name="ln7228">		{</a>
<a name="ln7229">			T val = *it;</a>
<a name="ln7230"> </a>
<a name="ln7231">			if (pred(val, *begin))</a>
<a name="ln7232">			{</a>
<a name="ln7233">				// move to front</a>
<a name="ln7234">				copy_backwards(begin, it, it + 1);</a>
<a name="ln7235">				*begin = val;</a>
<a name="ln7236">			}</a>
<a name="ln7237">			else</a>
<a name="ln7238">			{</a>
<a name="ln7239">				I hole = it;</a>
<a name="ln7240"> </a>
<a name="ln7241">				// move hole backwards</a>
<a name="ln7242">				while (pred(val, *(hole - 1)))</a>
<a name="ln7243">				{</a>
<a name="ln7244">					*hole = *(hole - 1);</a>
<a name="ln7245">					hole--;</a>
<a name="ln7246">				}</a>
<a name="ln7247"> </a>
<a name="ln7248">				// fill hole with element</a>
<a name="ln7249">				*hole = val;</a>
<a name="ln7250">			}</a>
<a name="ln7251">		}</a>
<a name="ln7252">	}</a>
<a name="ln7253"> </a>
<a name="ln7254">	// std variant for elements with ==</a>
<a name="ln7255">	template &lt;typename I, typename Pred&gt; void partition(I begin, I middle, I end, const Pred&amp; pred, I* out_eqbeg, I* out_eqend)</a>
<a name="ln7256">	{</a>
<a name="ln7257">		I eqbeg = middle, eqend = middle + 1;</a>
<a name="ln7258"> </a>
<a name="ln7259">		// expand equal range</a>
<a name="ln7260">		while (eqbeg != begin &amp;&amp; *(eqbeg - 1) == *eqbeg) --eqbeg;</a>
<a name="ln7261">		while (eqend != end &amp;&amp; *eqend == *eqbeg) ++eqend;</a>
<a name="ln7262"> </a>
<a name="ln7263">		// process outer elements</a>
<a name="ln7264">		I ltend = eqbeg, gtbeg = eqend;</a>
<a name="ln7265"> </a>
<a name="ln7266">		for (;;)</a>
<a name="ln7267">		{</a>
<a name="ln7268">			// find the element from the right side that belongs to the left one</a>
<a name="ln7269">			for (; gtbeg != end; ++gtbeg)</a>
<a name="ln7270">				if (!pred(*eqbeg, *gtbeg))</a>
<a name="ln7271">				{</a>
<a name="ln7272">					if (*gtbeg == *eqbeg) swap(*gtbeg, *eqend++);</a>
<a name="ln7273">					else break;</a>
<a name="ln7274">				}</a>
<a name="ln7275"> </a>
<a name="ln7276">			// find the element from the left side that belongs to the right one</a>
<a name="ln7277">			for (; ltend != begin; --ltend)</a>
<a name="ln7278">				if (!pred(*(ltend - 1), *eqbeg))</a>
<a name="ln7279">				{</a>
<a name="ln7280">					if (*eqbeg == *(ltend - 1)) swap(*(ltend - 1), *--eqbeg);</a>
<a name="ln7281">					else break;</a>
<a name="ln7282">				}</a>
<a name="ln7283"> </a>
<a name="ln7284">			// scanned all elements</a>
<a name="ln7285">			if (gtbeg == end &amp;&amp; ltend == begin)</a>
<a name="ln7286">			{</a>
<a name="ln7287">				*out_eqbeg = eqbeg;</a>
<a name="ln7288">				*out_eqend = eqend;</a>
<a name="ln7289">				return;</a>
<a name="ln7290">			}</a>
<a name="ln7291"> </a>
<a name="ln7292">			// make room for elements by moving equal area</a>
<a name="ln7293">			if (gtbeg == end)</a>
<a name="ln7294">			{</a>
<a name="ln7295">				if (--ltend != --eqbeg) swap(*ltend, *eqbeg);</a>
<a name="ln7296">				swap(*eqbeg, *--eqend);</a>
<a name="ln7297">			}</a>
<a name="ln7298">			else if (ltend == begin)</a>
<a name="ln7299">			{</a>
<a name="ln7300">				if (eqend != gtbeg) swap(*eqbeg, *eqend);</a>
<a name="ln7301">				++eqend;</a>
<a name="ln7302">				swap(*gtbeg++, *eqbeg++);</a>
<a name="ln7303">			}</a>
<a name="ln7304">			else swap(*gtbeg++, *--ltend);</a>
<a name="ln7305">		}</a>
<a name="ln7306">	}</a>
<a name="ln7307"> </a>
<a name="ln7308">	template &lt;typename I, typename Pred&gt; void median3(I first, I middle, I last, const Pred&amp; pred)</a>
<a name="ln7309">	{</a>
<a name="ln7310">		if (pred(*middle, *first)) swap(*middle, *first);</a>
<a name="ln7311">		if (pred(*last, *middle)) swap(*last, *middle);</a>
<a name="ln7312">		if (pred(*middle, *first)) swap(*middle, *first);</a>
<a name="ln7313">	}</a>
<a name="ln7314"> </a>
<a name="ln7315">	template &lt;typename I, typename Pred&gt; void median(I first, I middle, I last, const Pred&amp; pred)</a>
<a name="ln7316">	{</a>
<a name="ln7317">		if (last - first &lt;= 40)</a>
<a name="ln7318">		{</a>
<a name="ln7319">			// median of three for small chunks</a>
<a name="ln7320">			median3(first, middle, last, pred);</a>
<a name="ln7321">		}</a>
<a name="ln7322">		else</a>
<a name="ln7323">		{</a>
<a name="ln7324">			// median of nine</a>
<a name="ln7325">			size_t step = (last - first + 1) / 8;</a>
<a name="ln7326"> </a>
<a name="ln7327">			median3(first, first + step, first + 2 * step, pred);</a>
<a name="ln7328">			median3(middle - step, middle, middle + step, pred);</a>
<a name="ln7329">			median3(last - 2 * step, last - step, last, pred);</a>
<a name="ln7330">			median3(first + step, middle, last - step, pred);</a>
<a name="ln7331">		}</a>
<a name="ln7332">	}</a>
<a name="ln7333"> </a>
<a name="ln7334">	template &lt;typename I, typename Pred&gt; void sort(I begin, I end, const Pred&amp; pred)</a>
<a name="ln7335">	{</a>
<a name="ln7336">		// sort large chunks</a>
<a name="ln7337">		while (end - begin &gt; 32)</a>
<a name="ln7338">		{</a>
<a name="ln7339">			// find median element</a>
<a name="ln7340">			I middle = begin + (end - begin) / 2;</a>
<a name="ln7341">			median(begin, middle, end - 1, pred);</a>
<a name="ln7342"> </a>
<a name="ln7343">			// partition in three chunks (&lt; = &gt;)</a>
<a name="ln7344">			I eqbeg, eqend;</a>
<a name="ln7345">			partition(begin, middle, end, pred, &amp;eqbeg, &amp;eqend);</a>
<a name="ln7346"> </a>
<a name="ln7347">			// loop on larger half</a>
<a name="ln7348">			if (eqbeg - begin &gt; end - eqend)</a>
<a name="ln7349">			{</a>
<a name="ln7350">				sort(eqend, end, pred);</a>
<a name="ln7351">				end = eqbeg;</a>
<a name="ln7352">			}</a>
<a name="ln7353">			else</a>
<a name="ln7354">			{</a>
<a name="ln7355">				sort(begin, eqbeg, pred);</a>
<a name="ln7356">				begin = eqend;</a>
<a name="ln7357">			}</a>
<a name="ln7358">		}</a>
<a name="ln7359"> </a>
<a name="ln7360">		// insertion sort small chunk</a>
<a name="ln7361">		if (begin != end) insertion_sort(begin, end, pred, &amp;*begin);</a>
<a name="ln7362">	}</a>
<a name="ln7363">PUGI__NS_END</a>
<a name="ln7364"> </a>
<a name="ln7365">// Allocator used for AST and evaluation stacks</a>
<a name="ln7366">PUGI__NS_BEGIN</a>
<a name="ln7367">	static const size_t xpath_memory_page_size =</a>
<a name="ln7368">	#ifdef PUGIXML_MEMORY_XPATH_PAGE_SIZE</a>
<a name="ln7369">		PUGIXML_MEMORY_XPATH_PAGE_SIZE</a>
<a name="ln7370">	#else</a>
<a name="ln7371">		4096</a>
<a name="ln7372">	#endif</a>
<a name="ln7373">		;</a>
<a name="ln7374"> </a>
<a name="ln7375">	static const uintptr_t xpath_memory_block_alignment = sizeof(double) &gt; sizeof(void*) ? sizeof(double) : sizeof(void*);</a>
<a name="ln7376"> </a>
<a name="ln7377">	struct xpath_memory_block</a>
<a name="ln7378">	{</a>
<a name="ln7379">		xpath_memory_block* next;</a>
<a name="ln7380">		size_t capacity;</a>
<a name="ln7381"> </a>
<a name="ln7382">		union</a>
<a name="ln7383">		{</a>
<a name="ln7384">			char data[xpath_memory_page_size];</a>
<a name="ln7385">			double alignment;</a>
<a name="ln7386">		};</a>
<a name="ln7387">	};</a>
<a name="ln7388"> </a>
<a name="ln7389">	class xpath_allocator</a>
<a name="ln7390">	{</a>
<a name="ln7391">		xpath_memory_block* _root;</a>
<a name="ln7392">		size_t _root_size;</a>
<a name="ln7393"> </a>
<a name="ln7394">	public:</a>
<a name="ln7395">	#ifdef PUGIXML_NO_EXCEPTIONS</a>
<a name="ln7396">		jmp_buf* error_handler;</a>
<a name="ln7397">	#endif</a>
<a name="ln7398"> </a>
<a name="ln7399">		xpath_allocator(xpath_memory_block* root, size_t root_size = 0): _root(root), _root_size(root_size)</a>
<a name="ln7400">		{</a>
<a name="ln7401">		#ifdef PUGIXML_NO_EXCEPTIONS</a>
<a name="ln7402">			error_handler = 0;</a>
<a name="ln7403">		#endif</a>
<a name="ln7404">		}</a>
<a name="ln7405"> </a>
<a name="ln7406">		void* allocate_nothrow(size_t size)</a>
<a name="ln7407">		{</a>
<a name="ln7408">			// round size up to block alignment boundary</a>
<a name="ln7409">			size = (size + xpath_memory_block_alignment - 1) &amp; ~(xpath_memory_block_alignment - 1);</a>
<a name="ln7410"> </a>
<a name="ln7411">			if (_root_size + size &lt;= _root-&gt;capacity)</a>
<a name="ln7412">			{</a>
<a name="ln7413">				void* buf = &amp;_root-&gt;data[0] + _root_size;</a>
<a name="ln7414">				_root_size += size;</a>
<a name="ln7415">				return buf;</a>
<a name="ln7416">			}</a>
<a name="ln7417">			else</a>
<a name="ln7418">			{</a>
<a name="ln7419">				// make sure we have at least 1/4th of the page free after allocation to satisfy subsequent allocation requests</a>
<a name="ln7420">				size_t block_capacity_base = sizeof(_root-&gt;data);</a>
<a name="ln7421">				size_t block_capacity_req = size + block_capacity_base / 4;</a>
<a name="ln7422">				size_t block_capacity = (block_capacity_base &gt; block_capacity_req) ? block_capacity_base : block_capacity_req;</a>
<a name="ln7423"> </a>
<a name="ln7424">				size_t block_size = block_capacity + offsetof(xpath_memory_block, data);</a>
<a name="ln7425"> </a>
<a name="ln7426">				xpath_memory_block* block = static_cast&lt;xpath_memory_block*&gt;(xml_memory::allocate(block_size));</a>
<a name="ln7427">				if (!block) return 0;</a>
<a name="ln7428"> </a>
<a name="ln7429">				block-&gt;next = _root;</a>
<a name="ln7430">				block-&gt;capacity = block_capacity;</a>
<a name="ln7431"> </a>
<a name="ln7432">				_root = block;</a>
<a name="ln7433">				_root_size = size;</a>
<a name="ln7434"> </a>
<a name="ln7435">				return block-&gt;data;</a>
<a name="ln7436">			}</a>
<a name="ln7437">		}</a>
<a name="ln7438"> </a>
<a name="ln7439">		void* allocate(size_t size)</a>
<a name="ln7440">		{</a>
<a name="ln7441">			void* result = allocate_nothrow(size);</a>
<a name="ln7442"> </a>
<a name="ln7443">			if (!result)</a>
<a name="ln7444">			{</a>
<a name="ln7445">			#ifdef PUGIXML_NO_EXCEPTIONS</a>
<a name="ln7446">				assert(error_handler);</a>
<a name="ln7447">				longjmp(*error_handler, 1);</a>
<a name="ln7448">			#else</a>
<a name="ln7449">				throw std::bad_alloc();</a>
<a name="ln7450">			#endif</a>
<a name="ln7451">			}</a>
<a name="ln7452"> </a>
<a name="ln7453">			return result;</a>
<a name="ln7454">		}</a>
<a name="ln7455"> </a>
<a name="ln7456">		void* reallocate(void* ptr, size_t old_size, size_t new_size)</a>
<a name="ln7457">		{</a>
<a name="ln7458">			// round size up to block alignment boundary</a>
<a name="ln7459">			old_size = (old_size + xpath_memory_block_alignment - 1) &amp; ~(xpath_memory_block_alignment - 1);</a>
<a name="ln7460">			new_size = (new_size + xpath_memory_block_alignment - 1) &amp; ~(xpath_memory_block_alignment - 1);</a>
<a name="ln7461"> </a>
<a name="ln7462">			// we can only reallocate the last object</a>
<a name="ln7463">			assert(ptr == 0 || static_cast&lt;char*&gt;(ptr) + old_size == &amp;_root-&gt;data[0] + _root_size);</a>
<a name="ln7464"> </a>
<a name="ln7465">			// adjust root size so that we have not allocated the object at all</a>
<a name="ln7466">			bool only_object = (_root_size == old_size);</a>
<a name="ln7467"> </a>
<a name="ln7468">			if (ptr) _root_size -= old_size;</a>
<a name="ln7469"> </a>
<a name="ln7470">			// allocate a new version (this will obviously reuse the memory if possible)</a>
<a name="ln7471">			void* result = allocate(new_size);</a>
<a name="ln7472">			assert(result);</a>
<a name="ln7473"> </a>
<a name="ln7474">			// we have a new block</a>
<a name="ln7475">			if (result != ptr &amp;&amp; ptr)</a>
<a name="ln7476">			{</a>
<a name="ln7477">				// copy old data</a>
<a name="ln7478">				assert(new_size &gt;= old_size);</a>
<a name="ln7479">				memcpy(result, ptr, old_size);</a>
<a name="ln7480"> </a>
<a name="ln7481">				// free the previous page if it had no other objects</a>
<a name="ln7482">				if (only_object)</a>
<a name="ln7483">				{</a>
<a name="ln7484">					assert(_root-&gt;data == result);</a>
<a name="ln7485">					assert(_root-&gt;next);</a>
<a name="ln7486"> </a>
<a name="ln7487">					xpath_memory_block* next = _root-&gt;next-&gt;next;</a>
<a name="ln7488"> </a>
<a name="ln7489">					if (next)</a>
<a name="ln7490">					{</a>
<a name="ln7491">						// deallocate the whole page, unless it was the first one</a>
<a name="ln7492">						xml_memory::deallocate(_root-&gt;next);</a>
<a name="ln7493">						_root-&gt;next = next;</a>
<a name="ln7494">					}</a>
<a name="ln7495">				}</a>
<a name="ln7496">			}</a>
<a name="ln7497"> </a>
<a name="ln7498">			return result;</a>
<a name="ln7499">		}</a>
<a name="ln7500"> </a>
<a name="ln7501">		void revert(const xpath_allocator&amp; state)</a>
<a name="ln7502">		{</a>
<a name="ln7503">			// free all new pages</a>
<a name="ln7504">			xpath_memory_block* cur = _root;</a>
<a name="ln7505"> </a>
<a name="ln7506">			while (cur != state._root)</a>
<a name="ln7507">			{</a>
<a name="ln7508">				xpath_memory_block* next = cur-&gt;next;</a>
<a name="ln7509"> </a>
<a name="ln7510">				xml_memory::deallocate(cur);</a>
<a name="ln7511"> </a>
<a name="ln7512">				cur = next;</a>
<a name="ln7513">			}</a>
<a name="ln7514"> </a>
<a name="ln7515">			// restore state</a>
<a name="ln7516">			_root = state._root;</a>
<a name="ln7517">			_root_size = state._root_size;</a>
<a name="ln7518">		}</a>
<a name="ln7519"> </a>
<a name="ln7520">		void release()</a>
<a name="ln7521">		{</a>
<a name="ln7522">			xpath_memory_block* cur = _root;</a>
<a name="ln7523">			assert(cur);</a>
<a name="ln7524"> </a>
<a name="ln7525">			while (cur-&gt;next)</a>
<a name="ln7526">			{</a>
<a name="ln7527">				xpath_memory_block* next = cur-&gt;next;</a>
<a name="ln7528"> </a>
<a name="ln7529">				xml_memory::deallocate(cur);</a>
<a name="ln7530"> </a>
<a name="ln7531">				cur = next;</a>
<a name="ln7532">			}</a>
<a name="ln7533">		}</a>
<a name="ln7534">	};</a>
<a name="ln7535"> </a>
<a name="ln7536">	struct xpath_allocator_capture</a>
<a name="ln7537">	{</a>
<a name="ln7538">		xpath_allocator_capture(xpath_allocator* alloc): _target(alloc), _state(*alloc)</a>
<a name="ln7539">		{</a>
<a name="ln7540">		}</a>
<a name="ln7541"> </a>
<a name="ln7542">		~xpath_allocator_capture()</a>
<a name="ln7543">		{</a>
<a name="ln7544">			_target-&gt;revert(_state);</a>
<a name="ln7545">		}</a>
<a name="ln7546"> </a>
<a name="ln7547">		xpath_allocator* _target;</a>
<a name="ln7548">		xpath_allocator _state;</a>
<a name="ln7549">	};</a>
<a name="ln7550"> </a>
<a name="ln7551">	struct xpath_stack</a>
<a name="ln7552">	{</a>
<a name="ln7553">		xpath_allocator* result;</a>
<a name="ln7554">		xpath_allocator* temp;</a>
<a name="ln7555">	};</a>
<a name="ln7556"> </a>
<a name="ln7557">	struct xpath_stack_data</a>
<a name="ln7558">	{</a>
<a name="ln7559">		xpath_memory_block blocks[2];</a>
<a name="ln7560">		xpath_allocator result;</a>
<a name="ln7561">		xpath_allocator temp;</a>
<a name="ln7562">		xpath_stack stack;</a>
<a name="ln7563"> </a>
<a name="ln7564">	#ifdef PUGIXML_NO_EXCEPTIONS</a>
<a name="ln7565">		jmp_buf error_handler;</a>
<a name="ln7566">	#endif</a>
<a name="ln7567"> </a>
<a name="ln7568">		xpath_stack_data(): result(blocks + 0), temp(blocks + 1)</a>
<a name="ln7569">		{</a>
<a name="ln7570">			blocks[0].next = blocks[1].next = 0;</a>
<a name="ln7571">			blocks[0].capacity = blocks[1].capacity = sizeof(blocks[0].data);</a>
<a name="ln7572"> </a>
<a name="ln7573">			stack.result = &amp;result;</a>
<a name="ln7574">			stack.temp = &amp;temp;</a>
<a name="ln7575"> </a>
<a name="ln7576">		#ifdef PUGIXML_NO_EXCEPTIONS</a>
<a name="ln7577">			result.error_handler = temp.error_handler = &amp;error_handler;</a>
<a name="ln7578">		#endif</a>
<a name="ln7579">		}</a>
<a name="ln7580"> </a>
<a name="ln7581">		~xpath_stack_data()</a>
<a name="ln7582">		{</a>
<a name="ln7583">			result.release();</a>
<a name="ln7584">			temp.release();</a>
<a name="ln7585">		}</a>
<a name="ln7586">	};</a>
<a name="ln7587">PUGI__NS_END</a>
<a name="ln7588"> </a>
<a name="ln7589">// String class</a>
<a name="ln7590">PUGI__NS_BEGIN</a>
<a name="ln7591">	class xpath_string</a>
<a name="ln7592">	{</a>
<a name="ln7593">		const char_t* _buffer;</a>
<a name="ln7594">		bool _uses_heap;</a>
<a name="ln7595">		size_t _length_heap;</a>
<a name="ln7596"> </a>
<a name="ln7597">		static char_t* duplicate_string(const char_t* string, size_t length, xpath_allocator* alloc)</a>
<a name="ln7598">		{</a>
<a name="ln7599">			char_t* result = static_cast&lt;char_t*&gt;(alloc-&gt;allocate((length + 1) * sizeof(char_t)));</a>
<a name="ln7600">			assert(result);</a>
<a name="ln7601"> </a>
<a name="ln7602">			memcpy(result, string, length * sizeof(char_t));</a>
<a name="ln7603">			result[length] = 0;</a>
<a name="ln7604"> </a>
<a name="ln7605">			return result;</a>
<a name="ln7606">		}</a>
<a name="ln7607"> </a>
<a name="ln7608">		xpath_string(const char_t* buffer, bool uses_heap_, size_t length_heap): _buffer(buffer), _uses_heap(uses_heap_), _length_heap(length_heap)</a>
<a name="ln7609">		{</a>
<a name="ln7610">		}</a>
<a name="ln7611"> </a>
<a name="ln7612">	public:</a>
<a name="ln7613">		static xpath_string from_const(const char_t* str)</a>
<a name="ln7614">		{</a>
<a name="ln7615">			return xpath_string(str, false, 0);</a>
<a name="ln7616">		}</a>
<a name="ln7617"> </a>
<a name="ln7618">		static xpath_string from_heap_preallocated(const char_t* begin, const char_t* end)</a>
<a name="ln7619">		{</a>
<a name="ln7620">			assert(begin &lt;= end &amp;&amp; *end == 0);</a>
<a name="ln7621"> </a>
<a name="ln7622">			return xpath_string(begin, true, static_cast&lt;size_t&gt;(end - begin));</a>
<a name="ln7623">		}</a>
<a name="ln7624"> </a>
<a name="ln7625">		static xpath_string from_heap(const char_t* begin, const char_t* end, xpath_allocator* alloc)</a>
<a name="ln7626">		{</a>
<a name="ln7627">			assert(begin &lt;= end);</a>
<a name="ln7628"> </a>
<a name="ln7629">			size_t length = static_cast&lt;size_t&gt;(end - begin);</a>
<a name="ln7630"> </a>
<a name="ln7631">			return length == 0 ? xpath_string() : xpath_string(duplicate_string(begin, length, alloc), true, length);</a>
<a name="ln7632">		}</a>
<a name="ln7633"> </a>
<a name="ln7634">		xpath_string(): _buffer(PUGIXML_TEXT(&quot;&quot;)), _uses_heap(false), _length_heap(0)</a>
<a name="ln7635">		{</a>
<a name="ln7636">		}</a>
<a name="ln7637"> </a>
<a name="ln7638">		void append(const xpath_string&amp; o, xpath_allocator* alloc)</a>
<a name="ln7639">		{</a>
<a name="ln7640">			// skip empty sources</a>
<a name="ln7641">			if (!*o._buffer) return;</a>
<a name="ln7642"> </a>
<a name="ln7643">			// fast append for constant empty target and constant source</a>
<a name="ln7644">			if (!*_buffer &amp;&amp; !_uses_heap &amp;&amp; !o._uses_heap)</a>
<a name="ln7645">			{</a>
<a name="ln7646">				_buffer = o._buffer;</a>
<a name="ln7647">			}</a>
<a name="ln7648">			else</a>
<a name="ln7649">			{</a>
<a name="ln7650">				// need to make heap copy</a>
<a name="ln7651">				size_t target_length = length();</a>
<a name="ln7652">				size_t source_length = o.length();</a>
<a name="ln7653">				size_t result_length = target_length + source_length;</a>
<a name="ln7654"> </a>
<a name="ln7655">				// allocate new buffer</a>
<a name="ln7656">				char_t* result = static_cast&lt;char_t*&gt;(alloc-&gt;reallocate(_uses_heap ? const_cast&lt;char_t*&gt;(_buffer) : 0, (target_length + 1) * sizeof(char_t), (result_length + 1) * sizeof(char_t)));</a>
<a name="ln7657">				assert(result);</a>
<a name="ln7658"> </a>
<a name="ln7659">				// append first string to the new buffer in case there was no reallocation</a>
<a name="ln7660">				if (!_uses_heap) memcpy(result, _buffer, target_length * sizeof(char_t));</a>
<a name="ln7661"> </a>
<a name="ln7662">				// append second string to the new buffer</a>
<a name="ln7663">				memcpy(result + target_length, o._buffer, source_length * sizeof(char_t));</a>
<a name="ln7664">				result[result_length] = 0;</a>
<a name="ln7665"> </a>
<a name="ln7666">				// finalize</a>
<a name="ln7667">				_buffer = result;</a>
<a name="ln7668">				_uses_heap = true;</a>
<a name="ln7669">				_length_heap = result_length;</a>
<a name="ln7670">			}</a>
<a name="ln7671">		}</a>
<a name="ln7672"> </a>
<a name="ln7673">		const char_t* c_str() const</a>
<a name="ln7674">		{</a>
<a name="ln7675">			return _buffer;</a>
<a name="ln7676">		}</a>
<a name="ln7677"> </a>
<a name="ln7678">		size_t length() const</a>
<a name="ln7679">		{</a>
<a name="ln7680">			return _uses_heap ? _length_heap : strlength(_buffer);</a>
<a name="ln7681">		}</a>
<a name="ln7682"> </a>
<a name="ln7683">		char_t* data(xpath_allocator* alloc)</a>
<a name="ln7684">		{</a>
<a name="ln7685">			// make private heap copy</a>
<a name="ln7686">			if (!_uses_heap)</a>
<a name="ln7687">			{</a>
<a name="ln7688">				size_t length_ = strlength(_buffer);</a>
<a name="ln7689"> </a>
<a name="ln7690">				_buffer = duplicate_string(_buffer, length_, alloc);</a>
<a name="ln7691">				_uses_heap = true;</a>
<a name="ln7692">				_length_heap = length_;</a>
<a name="ln7693">			}</a>
<a name="ln7694"> </a>
<a name="ln7695">			return const_cast&lt;char_t*&gt;(_buffer);</a>
<a name="ln7696">		}</a>
<a name="ln7697"> </a>
<a name="ln7698">		bool empty() const</a>
<a name="ln7699">		{</a>
<a name="ln7700">			return *_buffer == 0;</a>
<a name="ln7701">		}</a>
<a name="ln7702"> </a>
<a name="ln7703">		bool operator==(const xpath_string&amp; o) const</a>
<a name="ln7704">		{</a>
<a name="ln7705">			return strequal(_buffer, o._buffer);</a>
<a name="ln7706">		}</a>
<a name="ln7707"> </a>
<a name="ln7708">		bool operator!=(const xpath_string&amp; o) const</a>
<a name="ln7709">		{</a>
<a name="ln7710">			return !strequal(_buffer, o._buffer);</a>
<a name="ln7711">		}</a>
<a name="ln7712"> </a>
<a name="ln7713">		bool uses_heap() const</a>
<a name="ln7714">		{</a>
<a name="ln7715">			return _uses_heap;</a>
<a name="ln7716">		}</a>
<a name="ln7717">	};</a>
<a name="ln7718">PUGI__NS_END</a>
<a name="ln7719"> </a>
<a name="ln7720">PUGI__NS_BEGIN</a>
<a name="ln7721">	PUGI__FN bool starts_with(const char_t* string, const char_t* pattern)</a>
<a name="ln7722">	{</a>
<a name="ln7723">		while (*pattern &amp;&amp; *string == *pattern)</a>
<a name="ln7724">		{</a>
<a name="ln7725">			string++;</a>
<a name="ln7726">			pattern++;</a>
<a name="ln7727">		}</a>
<a name="ln7728"> </a>
<a name="ln7729">		return *pattern == 0;</a>
<a name="ln7730">	}</a>
<a name="ln7731"> </a>
<a name="ln7732">	PUGI__FN const char_t* find_char(const char_t* s, char_t c)</a>
<a name="ln7733">	{</a>
<a name="ln7734">	#ifdef PUGIXML_WCHAR_MODE</a>
<a name="ln7735">		return wcschr(s, c);</a>
<a name="ln7736">	#else</a>
<a name="ln7737">		return strchr(s, c);</a>
<a name="ln7738">	#endif</a>
<a name="ln7739">	}</a>
<a name="ln7740"> </a>
<a name="ln7741">	PUGI__FN const char_t* find_substring(const char_t* s, const char_t* p)</a>
<a name="ln7742">	{</a>
<a name="ln7743">	#ifdef PUGIXML_WCHAR_MODE</a>
<a name="ln7744">		// MSVC6 wcsstr bug workaround (if s is empty it always returns 0)</a>
<a name="ln7745">		return (*p == 0) ? s : wcsstr(s, p);</a>
<a name="ln7746">	#else</a>
<a name="ln7747">		return strstr(s, p);</a>
<a name="ln7748">	#endif</a>
<a name="ln7749">	}</a>
<a name="ln7750"> </a>
<a name="ln7751">	// Converts symbol to lower case, if it is an ASCII one</a>
<a name="ln7752">	PUGI__FN char_t tolower_ascii(char_t ch)</a>
<a name="ln7753">	{</a>
<a name="ln7754">		return static_cast&lt;unsigned int&gt;(ch - 'A') &lt; 26 ? static_cast&lt;char_t&gt;(ch | ' ') : ch;</a>
<a name="ln7755">	}</a>
<a name="ln7756"> </a>
<a name="ln7757">	PUGI__FN xpath_string string_value(const xpath_node&amp; na, xpath_allocator* alloc)</a>
<a name="ln7758">	{</a>
<a name="ln7759">		if (na.attribute())</a>
<a name="ln7760">			return xpath_string::from_const(na.attribute().value());</a>
<a name="ln7761">		else</a>
<a name="ln7762">		{</a>
<a name="ln7763">			xml_node n = na.node();</a>
<a name="ln7764"> </a>
<a name="ln7765">			switch (n.type())</a>
<a name="ln7766">			{</a>
<a name="ln7767">			case node_pcdata:</a>
<a name="ln7768">			case node_cdata:</a>
<a name="ln7769">			case node_comment:</a>
<a name="ln7770">			case node_pi:</a>
<a name="ln7771">				return xpath_string::from_const(n.value());</a>
<a name="ln7772"> </a>
<a name="ln7773">			case node_document:</a>
<a name="ln7774">			case node_element:</a>
<a name="ln7775">			{</a>
<a name="ln7776">				xpath_string result;</a>
<a name="ln7777"> </a>
<a name="ln7778">				// element nodes can have value if parse_embed_pcdata was used</a>
<a name="ln7779">				if (n.value()[0])</a>
<a name="ln7780">					result.append(xpath_string::from_const(n.value()), alloc);</a>
<a name="ln7781"> </a>
<a name="ln7782">				xml_node cur = n.first_child();</a>
<a name="ln7783"> </a>
<a name="ln7784">				while (cur &amp;&amp; cur != n)</a>
<a name="ln7785">				{</a>
<a name="ln7786">					if (cur.type() == node_pcdata || cur.type() == node_cdata)</a>
<a name="ln7787">						result.append(xpath_string::from_const(cur.value()), alloc);</a>
<a name="ln7788"> </a>
<a name="ln7789">					if (cur.first_child())</a>
<a name="ln7790">						cur = cur.first_child();</a>
<a name="ln7791">					else if (cur.next_sibling())</a>
<a name="ln7792">						cur = cur.next_sibling();</a>
<a name="ln7793">					else</a>
<a name="ln7794">					{</a>
<a name="ln7795">						while (!cur.next_sibling() &amp;&amp; cur != n)</a>
<a name="ln7796">							cur = cur.parent();</a>
<a name="ln7797"> </a>
<a name="ln7798">						if (cur != n) cur = cur.next_sibling();</a>
<a name="ln7799">					}</a>
<a name="ln7800">				}</a>
<a name="ln7801"> </a>
<a name="ln7802">				return result;</a>
<a name="ln7803">			}</a>
<a name="ln7804"> </a>
<a name="ln7805">			default:</a>
<a name="ln7806">				return xpath_string();</a>
<a name="ln7807">			}</a>
<a name="ln7808">		}</a>
<a name="ln7809">	}</a>
<a name="ln7810"> </a>
<a name="ln7811">	PUGI__FN bool node_is_before_sibling(xml_node_struct* ln, xml_node_struct* rn)</a>
<a name="ln7812">	{</a>
<a name="ln7813">		assert(ln-&gt;parent == rn-&gt;parent);</a>
<a name="ln7814"> </a>
<a name="ln7815">		// there is no common ancestor (the shared parent is null), nodes are from different documents</a>
<a name="ln7816">		if (!ln-&gt;parent) return ln &lt; rn;</a>
<a name="ln7817"> </a>
<a name="ln7818">		// determine sibling order</a>
<a name="ln7819">		xml_node_struct* ls = ln;</a>
<a name="ln7820">		xml_node_struct* rs = rn;</a>
<a name="ln7821"> </a>
<a name="ln7822">		while (ls &amp;&amp; rs)</a>
<a name="ln7823">		{</a>
<a name="ln7824">			if (ls == rn) return true;</a>
<a name="ln7825">			if (rs == ln) return false;</a>
<a name="ln7826"> </a>
<a name="ln7827">			ls = ls-&gt;next_sibling;</a>
<a name="ln7828">			rs = rs-&gt;next_sibling;</a>
<a name="ln7829">		}</a>
<a name="ln7830"> </a>
<a name="ln7831">		// if rn sibling chain ended ln must be before rn</a>
<a name="ln7832">		return !rs;</a>
<a name="ln7833">	}</a>
<a name="ln7834"> </a>
<a name="ln7835">	PUGI__FN bool node_is_before(xml_node_struct* ln, xml_node_struct* rn)</a>
<a name="ln7836">	{</a>
<a name="ln7837">		// find common ancestor at the same depth, if any</a>
<a name="ln7838">		xml_node_struct* lp = ln;</a>
<a name="ln7839">		xml_node_struct* rp = rn;</a>
<a name="ln7840"> </a>
<a name="ln7841">		while (lp &amp;&amp; rp &amp;&amp; lp-&gt;parent != rp-&gt;parent)</a>
<a name="ln7842">		{</a>
<a name="ln7843">			lp = lp-&gt;parent;</a>
<a name="ln7844">			rp = rp-&gt;parent;</a>
<a name="ln7845">		}</a>
<a name="ln7846"> </a>
<a name="ln7847">		// parents are the same!</a>
<a name="ln7848">		if (lp &amp;&amp; rp) return node_is_before_sibling(lp, rp);</a>
<a name="ln7849"> </a>
<a name="ln7850">		// nodes are at different depths, need to normalize heights</a>
<a name="ln7851">		bool left_higher = !lp;</a>
<a name="ln7852"> </a>
<a name="ln7853">		while (lp)</a>
<a name="ln7854">		{</a>
<a name="ln7855">			lp = lp-&gt;parent;</a>
<a name="ln7856">			ln = ln-&gt;parent;</a>
<a name="ln7857">		}</a>
<a name="ln7858"> </a>
<a name="ln7859">		while (rp)</a>
<a name="ln7860">		{</a>
<a name="ln7861">			rp = rp-&gt;parent;</a>
<a name="ln7862">			rn = rn-&gt;parent;</a>
<a name="ln7863">		}</a>
<a name="ln7864"> </a>
<a name="ln7865">		// one node is the ancestor of the other</a>
<a name="ln7866">		if (ln == rn) return left_higher;</a>
<a name="ln7867"> </a>
<a name="ln7868">		// find common ancestor... again</a>
<a name="ln7869">		while (ln-&gt;parent != rn-&gt;parent)</a>
<a name="ln7870">		{</a>
<a name="ln7871">			ln = ln-&gt;parent;</a>
<a name="ln7872">			rn = rn-&gt;parent;</a>
<a name="ln7873">		}</a>
<a name="ln7874"> </a>
<a name="ln7875">		return node_is_before_sibling(ln, rn);</a>
<a name="ln7876">	}</a>
<a name="ln7877"> </a>
<a name="ln7878">	PUGI__FN bool node_is_ancestor(xml_node_struct* parent, xml_node_struct* node)</a>
<a name="ln7879">	{</a>
<a name="ln7880">		while (node &amp;&amp; node != parent) node = node-&gt;parent;</a>
<a name="ln7881"> </a>
<a name="ln7882">		return parent &amp;&amp; node == parent;</a>
<a name="ln7883">	}</a>
<a name="ln7884"> </a>
<a name="ln7885">	PUGI__FN const void* document_buffer_order(const xpath_node&amp; xnode)</a>
<a name="ln7886">	{</a>
<a name="ln7887">		xml_node_struct* node = xnode.node().internal_object();</a>
<a name="ln7888"> </a>
<a name="ln7889">		if (node)</a>
<a name="ln7890">		{</a>
<a name="ln7891">			if ((get_document(node).header &amp; xml_memory_page_contents_shared_mask) == 0)</a>
<a name="ln7892">			{</a>
<a name="ln7893">				if (node-&gt;name &amp;&amp; (node-&gt;header &amp; impl::xml_memory_page_name_allocated_or_shared_mask) == 0) return node-&gt;name;</a>
<a name="ln7894">				if (node-&gt;value &amp;&amp; (node-&gt;header &amp; impl::xml_memory_page_value_allocated_or_shared_mask) == 0) return node-&gt;value;</a>
<a name="ln7895">			}</a>
<a name="ln7896"> </a>
<a name="ln7897">			return 0;</a>
<a name="ln7898">		}</a>
<a name="ln7899"> </a>
<a name="ln7900">		xml_attribute_struct* attr = xnode.attribute().internal_object();</a>
<a name="ln7901"> </a>
<a name="ln7902">		if (attr)</a>
<a name="ln7903">		{</a>
<a name="ln7904">			if ((get_document(attr).header &amp; xml_memory_page_contents_shared_mask) == 0)</a>
<a name="ln7905">			{</a>
<a name="ln7906">				if ((attr-&gt;header &amp; impl::xml_memory_page_name_allocated_or_shared_mask) == 0) return attr-&gt;name;</a>
<a name="ln7907">				if ((attr-&gt;header &amp; impl::xml_memory_page_value_allocated_or_shared_mask) == 0) return attr-&gt;value;</a>
<a name="ln7908">			}</a>
<a name="ln7909"> </a>
<a name="ln7910">			return 0;</a>
<a name="ln7911">		}</a>
<a name="ln7912"> </a>
<a name="ln7913">		return 0;</a>
<a name="ln7914">	}</a>
<a name="ln7915"> </a>
<a name="ln7916">	struct document_order_comparator</a>
<a name="ln7917">	{</a>
<a name="ln7918">		bool operator()(const xpath_node&amp; lhs, const xpath_node&amp; rhs) const</a>
<a name="ln7919">		{</a>
<a name="ln7920">			// optimized document order based check</a>
<a name="ln7921">			const void* lo = document_buffer_order(lhs);</a>
<a name="ln7922">			const void* ro = document_buffer_order(rhs);</a>
<a name="ln7923"> </a>
<a name="ln7924">			if (lo &amp;&amp; ro) return lo &lt; ro;</a>
<a name="ln7925"> </a>
<a name="ln7926">			// slow comparison</a>
<a name="ln7927">			xml_node ln = lhs.node(), rn = rhs.node();</a>
<a name="ln7928"> </a>
<a name="ln7929">			// compare attributes</a>
<a name="ln7930">			if (lhs.attribute() &amp;&amp; rhs.attribute())</a>
<a name="ln7931">			{</a>
<a name="ln7932">				// shared parent</a>
<a name="ln7933">				if (lhs.parent() == rhs.parent())</a>
<a name="ln7934">				{</a>
<a name="ln7935">					// determine sibling order</a>
<a name="ln7936">					for (xml_attribute a = lhs.attribute(); a; a = a.next_attribute())</a>
<a name="ln7937">						if (a == rhs.attribute())</a>
<a name="ln7938">							return true;</a>
<a name="ln7939"> </a>
<a name="ln7940">					return false;</a>
<a name="ln7941">				}</a>
<a name="ln7942"> </a>
<a name="ln7943">				// compare attribute parents</a>
<a name="ln7944">				ln = lhs.parent();</a>
<a name="ln7945">				rn = rhs.parent();</a>
<a name="ln7946">			}</a>
<a name="ln7947">			else if (lhs.attribute())</a>
<a name="ln7948">			{</a>
<a name="ln7949">				// attributes go after the parent element</a>
<a name="ln7950">				if (lhs.parent() == rhs.node()) return false;</a>
<a name="ln7951"> </a>
<a name="ln7952">				ln = lhs.parent();</a>
<a name="ln7953">			}</a>
<a name="ln7954">			else if (rhs.attribute())</a>
<a name="ln7955">			{</a>
<a name="ln7956">				// attributes go after the parent element</a>
<a name="ln7957">				if (rhs.parent() == lhs.node()) return true;</a>
<a name="ln7958"> </a>
<a name="ln7959">				rn = rhs.parent();</a>
<a name="ln7960">			}</a>
<a name="ln7961"> </a>
<a name="ln7962">			if (ln == rn) return false;</a>
<a name="ln7963"> </a>
<a name="ln7964">			if (!ln || !rn) return ln &lt; rn;</a>
<a name="ln7965"> </a>
<a name="ln7966">			return node_is_before(ln.internal_object(), rn.internal_object());</a>
<a name="ln7967">		}</a>
<a name="ln7968">	};</a>
<a name="ln7969"> </a>
<a name="ln7970">	struct duplicate_comparator</a>
<a name="ln7971">	{</a>
<a name="ln7972">		bool operator()(const xpath_node&amp; lhs, const xpath_node&amp; rhs) const</a>
<a name="ln7973">		{</a>
<a name="ln7974">			if (lhs.attribute()) return rhs.attribute() ? lhs.attribute() &lt; rhs.attribute() : true;</a>
<a name="ln7975">			else return rhs.attribute() ? false : lhs.node() &lt; rhs.node();</a>
<a name="ln7976">		}</a>
<a name="ln7977">	};</a>
<a name="ln7978"> </a>
<a name="ln7979">	PUGI__FN double gen_nan()</a>
<a name="ln7980">	{</a>
<a name="ln7981">	#if defined(__STDC_IEC_559__) || ((FLT_RADIX - 0 == 2) &amp;&amp; (FLT_MAX_EXP - 0 == 128) &amp;&amp; (FLT_MANT_DIG - 0 == 24))</a>
<a name="ln7982">		PUGI__STATIC_ASSERT(sizeof(float) == sizeof(uint32_t));</a>
<a name="ln7983">		typedef uint32_t UI; // BCC5 workaround</a>
<a name="ln7984">		union { float f; UI i; } u;</a>
<a name="ln7985">		u.i = 0x7fc00000;</a>
<a name="ln7986">		return u.f;</a>
<a name="ln7987">	#else</a>
<a name="ln7988">		// fallback</a>
<a name="ln7989">		const volatile double zero = 0.0;</a>
<a name="ln7990">		return zero / zero;</a>
<a name="ln7991">	#endif</a>
<a name="ln7992">	}</a>
<a name="ln7993"> </a>
<a name="ln7994">	PUGI__FN bool is_nan(double value)</a>
<a name="ln7995">	{</a>
<a name="ln7996">	#if defined(PUGI__MSVC_CRT_VERSION) || defined(__BORLANDC__)</a>
<a name="ln7997">		return !!_isnan(value);</a>
<a name="ln7998">	#elif defined(fpclassify) &amp;&amp; defined(FP_NAN)</a>
<a name="ln7999">		return fpclassify(value) == FP_NAN;</a>
<a name="ln8000">	#else</a>
<a name="ln8001">		// fallback</a>
<a name="ln8002">		const volatile double v = value;</a>
<a name="ln8003">		return v != v;</a>
<a name="ln8004">	#endif</a>
<a name="ln8005">	}</a>
<a name="ln8006"> </a>
<a name="ln8007">	PUGI__FN const char_t* convert_number_to_string_special(double value)</a>
<a name="ln8008">	{</a>
<a name="ln8009">	#if defined(PUGI__MSVC_CRT_VERSION) || defined(__BORLANDC__)</a>
<a name="ln8010">		if (_finite(value)) return (value == 0) ? PUGIXML_TEXT(&quot;0&quot;) : 0;</a>
<a name="ln8011">		if (_isnan(value)) return PUGIXML_TEXT(&quot;NaN&quot;);</a>
<a name="ln8012">		return value &gt; 0 ? PUGIXML_TEXT(&quot;Infinity&quot;) : PUGIXML_TEXT(&quot;-Infinity&quot;);</a>
<a name="ln8013">	#elif defined(fpclassify) &amp;&amp; defined(FP_NAN) &amp;&amp; defined(FP_INFINITE) &amp;&amp; defined(FP_ZERO)</a>
<a name="ln8014">		switch (fpclassify(value))</a>
<a name="ln8015">		{</a>
<a name="ln8016">		case FP_NAN:</a>
<a name="ln8017">			return PUGIXML_TEXT(&quot;NaN&quot;);</a>
<a name="ln8018"> </a>
<a name="ln8019">		case FP_INFINITE:</a>
<a name="ln8020">			return value &gt; 0 ? PUGIXML_TEXT(&quot;Infinity&quot;) : PUGIXML_TEXT(&quot;-Infinity&quot;);</a>
<a name="ln8021"> </a>
<a name="ln8022">		case FP_ZERO:</a>
<a name="ln8023">			return PUGIXML_TEXT(&quot;0&quot;);</a>
<a name="ln8024"> </a>
<a name="ln8025">		default:</a>
<a name="ln8026">			return 0;</a>
<a name="ln8027">		}</a>
<a name="ln8028">	#else</a>
<a name="ln8029">		// fallback</a>
<a name="ln8030">		const volatile double v = value;</a>
<a name="ln8031"> </a>
<a name="ln8032">		if (v == 0) return PUGIXML_TEXT(&quot;0&quot;);</a>
<a name="ln8033">		if (v != v) return PUGIXML_TEXT(&quot;NaN&quot;);</a>
<a name="ln8034">		if (v * 2 == v) return value &gt; 0 ? PUGIXML_TEXT(&quot;Infinity&quot;) : PUGIXML_TEXT(&quot;-Infinity&quot;);</a>
<a name="ln8035">		return 0;</a>
<a name="ln8036">	#endif</a>
<a name="ln8037">	}</a>
<a name="ln8038"> </a>
<a name="ln8039">	PUGI__FN bool convert_number_to_boolean(double value)</a>
<a name="ln8040">	{</a>
<a name="ln8041">		return (value != 0 &amp;&amp; !is_nan(value));</a>
<a name="ln8042">	}</a>
<a name="ln8043"> </a>
<a name="ln8044">	PUGI__FN void truncate_zeros(char* begin, char* end)</a>
<a name="ln8045">	{</a>
<a name="ln8046">		while (begin != end &amp;&amp; end[-1] == '0') end--;</a>
<a name="ln8047"> </a>
<a name="ln8048">		*end = 0;</a>
<a name="ln8049">	}</a>
<a name="ln8050"> </a>
<a name="ln8051">	// gets mantissa digits in the form of 0.xxxxx with 0. implied and the exponent</a>
<a name="ln8052">#if defined(PUGI__MSVC_CRT_VERSION) &amp;&amp; PUGI__MSVC_CRT_VERSION &gt;= 1400 &amp;&amp; !defined(_WIN32_WCE)</a>
<a name="ln8053">	PUGI__FN void convert_number_to_mantissa_exponent(double value, char* buffer, size_t buffer_size, char** out_mantissa, int* out_exponent)</a>
<a name="ln8054">	{</a>
<a name="ln8055">		// get base values</a>
<a name="ln8056">		int sign, exponent;</a>
<a name="ln8057">		_ecvt_s(buffer, buffer_size, value, DBL_DIG + 1, &amp;exponent, &amp;sign);</a>
<a name="ln8058"> </a>
<a name="ln8059">		// truncate redundant zeros</a>
<a name="ln8060">		truncate_zeros(buffer, buffer + strlen(buffer));</a>
<a name="ln8061"> </a>
<a name="ln8062">		// fill results</a>
<a name="ln8063">		*out_mantissa = buffer;</a>
<a name="ln8064">		*out_exponent = exponent;</a>
<a name="ln8065">	}</a>
<a name="ln8066">#else</a>
<a name="ln8067">	PUGI__FN void convert_number_to_mantissa_exponent(double value, char* buffer, size_t buffer_size, char** out_mantissa, int* out_exponent)</a>
<a name="ln8068">	{</a>
<a name="ln8069">		// get a scientific notation value with IEEE DBL_DIG decimals</a>
<a name="ln8070">		sprintf(buffer, &quot;%.*e&quot;, DBL_DIG, value);</a>
<a name="ln8071">		assert(strlen(buffer) &lt; buffer_size);</a>
<a name="ln8072">		(void)!buffer_size;</a>
<a name="ln8073"> </a>
<a name="ln8074">		// get the exponent (possibly negative)</a>
<a name="ln8075">		char* exponent_string = strchr(buffer, 'e');</a>
<a name="ln8076">		assert(exponent_string);</a>
<a name="ln8077"> </a>
<a name="ln8078">		int exponent = atoi(exponent_string + 1);</a>
<a name="ln8079"> </a>
<a name="ln8080">		// extract mantissa string: skip sign</a>
<a name="ln8081">		char* mantissa = buffer[0] == '-' ? buffer + 1 : buffer;</a>
<a name="ln8082">		assert(mantissa[0] != '0' &amp;&amp; mantissa[1] == '.');</a>
<a name="ln8083"> </a>
<a name="ln8084">		// divide mantissa by 10 to eliminate integer part</a>
<a name="ln8085">		mantissa[1] = mantissa[0];</a>
<a name="ln8086">		mantissa++;</a>
<a name="ln8087">		exponent++;</a>
<a name="ln8088"> </a>
<a name="ln8089">		// remove extra mantissa digits and zero-terminate mantissa</a>
<a name="ln8090">		truncate_zeros(mantissa, exponent_string);</a>
<a name="ln8091"> </a>
<a name="ln8092">		// fill results</a>
<a name="ln8093">		*out_mantissa = mantissa;</a>
<a name="ln8094">		*out_exponent = exponent;</a>
<a name="ln8095">	}</a>
<a name="ln8096">#endif</a>
<a name="ln8097"> </a>
<a name="ln8098">	PUGI__FN xpath_string convert_number_to_string(double value, xpath_allocator* alloc)</a>
<a name="ln8099">	{</a>
<a name="ln8100">		// try special number conversion</a>
<a name="ln8101">		const char_t* special = convert_number_to_string_special(value);</a>
<a name="ln8102">		if (special) return xpath_string::from_const(special);</a>
<a name="ln8103"> </a>
<a name="ln8104">		// get mantissa + exponent form</a>
<a name="ln8105">		char mantissa_buffer[32];</a>
<a name="ln8106"> </a>
<a name="ln8107">		char* mantissa;</a>
<a name="ln8108">		int exponent;</a>
<a name="ln8109">		convert_number_to_mantissa_exponent(value, mantissa_buffer, sizeof(mantissa_buffer), &amp;mantissa, &amp;exponent);</a>
<a name="ln8110"> </a>
<a name="ln8111">		// allocate a buffer of suitable length for the number</a>
<a name="ln8112">		size_t result_size = strlen(mantissa_buffer) + (exponent &gt; 0 ? exponent : -exponent) + 4;</a>
<a name="ln8113">		char_t* result = static_cast&lt;char_t*&gt;(alloc-&gt;allocate(sizeof(char_t) * result_size));</a>
<a name="ln8114">		assert(result);</a>
<a name="ln8115"> </a>
<a name="ln8116">		// make the number!</a>
<a name="ln8117">		char_t* s = result;</a>
<a name="ln8118"> </a>
<a name="ln8119">		// sign</a>
<a name="ln8120">		if (value &lt; 0) *s++ = '-';</a>
<a name="ln8121"> </a>
<a name="ln8122">		// integer part</a>
<a name="ln8123">		if (exponent &lt;= 0)</a>
<a name="ln8124">		{</a>
<a name="ln8125">			*s++ = '0';</a>
<a name="ln8126">		}</a>
<a name="ln8127">		else</a>
<a name="ln8128">		{</a>
<a name="ln8129">			while (exponent &gt; 0)</a>
<a name="ln8130">			{</a>
<a name="ln8131">				assert(*mantissa == 0 || static_cast&lt;unsigned int&gt;(static_cast&lt;unsigned int&gt;(*mantissa) - '0') &lt;= 9);</a>
<a name="ln8132">				*s++ = *mantissa ? *mantissa++ : '0';</a>
<a name="ln8133">				exponent--;</a>
<a name="ln8134">			}</a>
<a name="ln8135">		}</a>
<a name="ln8136"> </a>
<a name="ln8137">		// fractional part</a>
<a name="ln8138">		if (*mantissa)</a>
<a name="ln8139">		{</a>
<a name="ln8140">			// decimal point</a>
<a name="ln8141">			*s++ = '.';</a>
<a name="ln8142"> </a>
<a name="ln8143">			// extra zeroes from negative exponent</a>
<a name="ln8144">			while (exponent &lt; 0)</a>
<a name="ln8145">			{</a>
<a name="ln8146">				*s++ = '0';</a>
<a name="ln8147">				exponent++;</a>
<a name="ln8148">			}</a>
<a name="ln8149"> </a>
<a name="ln8150">			// extra mantissa digits</a>
<a name="ln8151">			while (*mantissa)</a>
<a name="ln8152">			{</a>
<a name="ln8153">				assert(static_cast&lt;unsigned int&gt;(*mantissa - '0') &lt;= 9);</a>
<a name="ln8154">				*s++ = *mantissa++;</a>
<a name="ln8155">			}</a>
<a name="ln8156">		}</a>
<a name="ln8157"> </a>
<a name="ln8158">		// zero-terminate</a>
<a name="ln8159">		assert(s &lt; result + result_size);</a>
<a name="ln8160">		*s = 0;</a>
<a name="ln8161"> </a>
<a name="ln8162">		return xpath_string::from_heap_preallocated(result, s);</a>
<a name="ln8163">	}</a>
<a name="ln8164"> </a>
<a name="ln8165">	PUGI__FN bool check_string_to_number_format(const char_t* string)</a>
<a name="ln8166">	{</a>
<a name="ln8167">		// parse leading whitespace</a>
<a name="ln8168">		while (PUGI__IS_CHARTYPE(*string, ct_space)) ++string;</a>
<a name="ln8169"> </a>
<a name="ln8170">		// parse sign</a>
<a name="ln8171">		if (*string == '-') ++string;</a>
<a name="ln8172"> </a>
<a name="ln8173">		if (!*string) return false;</a>
<a name="ln8174"> </a>
<a name="ln8175">		// if there is no integer part, there should be a decimal part with at least one digit</a>
<a name="ln8176">		if (!PUGI__IS_CHARTYPEX(string[0], ctx_digit) &amp;&amp; (string[0] != '.' || !PUGI__IS_CHARTYPEX(string[1], ctx_digit))) return false;</a>
<a name="ln8177"> </a>
<a name="ln8178">		// parse integer part</a>
<a name="ln8179">		while (PUGI__IS_CHARTYPEX(*string, ctx_digit)) ++string;</a>
<a name="ln8180"> </a>
<a name="ln8181">		// parse decimal part</a>
<a name="ln8182">		if (*string == '.')</a>
<a name="ln8183">		{</a>
<a name="ln8184">			++string;</a>
<a name="ln8185"> </a>
<a name="ln8186">			while (PUGI__IS_CHARTYPEX(*string, ctx_digit)) ++string;</a>
<a name="ln8187">		}</a>
<a name="ln8188"> </a>
<a name="ln8189">		// parse trailing whitespace</a>
<a name="ln8190">		while (PUGI__IS_CHARTYPE(*string, ct_space)) ++string;</a>
<a name="ln8191"> </a>
<a name="ln8192">		return *string == 0;</a>
<a name="ln8193">	}</a>
<a name="ln8194"> </a>
<a name="ln8195">	PUGI__FN double convert_string_to_number(const char_t* string)</a>
<a name="ln8196">	{</a>
<a name="ln8197">		// check string format</a>
<a name="ln8198">		if (!check_string_to_number_format(string)) return gen_nan();</a>
<a name="ln8199"> </a>
<a name="ln8200">		// parse string</a>
<a name="ln8201">	#ifdef PUGIXML_WCHAR_MODE</a>
<a name="ln8202">		return wcstod(string, 0);</a>
<a name="ln8203">	#else</a>
<a name="ln8204">		return strtod(string, 0);</a>
<a name="ln8205">	#endif</a>
<a name="ln8206">	}</a>
<a name="ln8207"> </a>
<a name="ln8208">	PUGI__FN bool convert_string_to_number_scratch(char_t (&amp;buffer)[32], const char_t* begin, const char_t* end, double* out_result)</a>
<a name="ln8209">	{</a>
<a name="ln8210">		size_t length = static_cast&lt;size_t&gt;(end - begin);</a>
<a name="ln8211">		char_t* scratch = buffer;</a>
<a name="ln8212"> </a>
<a name="ln8213">		if (length &gt;= sizeof(buffer) / sizeof(buffer[0]))</a>
<a name="ln8214">		{</a>
<a name="ln8215">			// need to make dummy on-heap copy</a>
<a name="ln8216">			scratch = static_cast&lt;char_t*&gt;(xml_memory::allocate((length + 1) * sizeof(char_t)));</a>
<a name="ln8217">			if (!scratch) return false;</a>
<a name="ln8218">		}</a>
<a name="ln8219"> </a>
<a name="ln8220">		// copy string to zero-terminated buffer and perform conversion</a>
<a name="ln8221">		memcpy(scratch, begin, length * sizeof(char_t));</a>
<a name="ln8222">		scratch[length] = 0;</a>
<a name="ln8223"> </a>
<a name="ln8224">		*out_result = convert_string_to_number(scratch);</a>
<a name="ln8225"> </a>
<a name="ln8226">		// free dummy buffer</a>
<a name="ln8227">		if (scratch != buffer) xml_memory::deallocate(scratch);</a>
<a name="ln8228"> </a>
<a name="ln8229">		return true;</a>
<a name="ln8230">	}</a>
<a name="ln8231"> </a>
<a name="ln8232">	PUGI__FN double round_nearest(double value)</a>
<a name="ln8233">	{</a>
<a name="ln8234">		return floor(value + 0.5);</a>
<a name="ln8235">	}</a>
<a name="ln8236"> </a>
<a name="ln8237">	PUGI__FN double round_nearest_nzero(double value)</a>
<a name="ln8238">	{</a>
<a name="ln8239">		// same as round_nearest, but returns -0 for [-0.5, -0]</a>
<a name="ln8240">		// ceil is used to differentiate between +0 and -0 (we return -0 for [-0.5, -0] and +0 for +0)</a>
<a name="ln8241">		return (value &gt;= -0.5 &amp;&amp; value &lt;= 0) ? ceil(value) : floor(value + 0.5);</a>
<a name="ln8242">	}</a>
<a name="ln8243"> </a>
<a name="ln8244">	PUGI__FN const char_t* qualified_name(const xpath_node&amp; node)</a>
<a name="ln8245">	{</a>
<a name="ln8246">		return node.attribute() ? node.attribute().name() : node.node().name();</a>
<a name="ln8247">	}</a>
<a name="ln8248"> </a>
<a name="ln8249">	PUGI__FN const char_t* local_name(const xpath_node&amp; node)</a>
<a name="ln8250">	{</a>
<a name="ln8251">		const char_t* name = qualified_name(node);</a>
<a name="ln8252">		const char_t* p = find_char(name, ':');</a>
<a name="ln8253"> </a>
<a name="ln8254">		return p ? p + 1 : name;</a>
<a name="ln8255">	}</a>
<a name="ln8256"> </a>
<a name="ln8257">	struct namespace_uri_predicate</a>
<a name="ln8258">	{</a>
<a name="ln8259">		const char_t* prefix;</a>
<a name="ln8260">		size_t prefix_length;</a>
<a name="ln8261"> </a>
<a name="ln8262">		namespace_uri_predicate(const char_t* name)</a>
<a name="ln8263">		{</a>
<a name="ln8264">			const char_t* pos = find_char(name, ':');</a>
<a name="ln8265"> </a>
<a name="ln8266">			prefix = pos ? name : 0;</a>
<a name="ln8267">			prefix_length = pos ? static_cast&lt;size_t&gt;(pos - name) : 0;</a>
<a name="ln8268">		}</a>
<a name="ln8269"> </a>
<a name="ln8270">		bool operator()(xml_attribute a) const</a>
<a name="ln8271">		{</a>
<a name="ln8272">			const char_t* name = a.name();</a>
<a name="ln8273"> </a>
<a name="ln8274">			if (!starts_with(name, PUGIXML_TEXT(&quot;xmlns&quot;))) return false;</a>
<a name="ln8275"> </a>
<a name="ln8276">			return prefix ? name[5] == ':' &amp;&amp; strequalrange(name + 6, prefix, prefix_length) : name[5] == 0;</a>
<a name="ln8277">		}</a>
<a name="ln8278">	};</a>
<a name="ln8279"> </a>
<a name="ln8280">	PUGI__FN const char_t* namespace_uri(xml_node node)</a>
<a name="ln8281">	{</a>
<a name="ln8282">		namespace_uri_predicate pred = node.name();</a>
<a name="ln8283"> </a>
<a name="ln8284">		xml_node p = node;</a>
<a name="ln8285"> </a>
<a name="ln8286">		while (p)</a>
<a name="ln8287">		{</a>
<a name="ln8288">			xml_attribute a = p.find_attribute(pred);</a>
<a name="ln8289"> </a>
<a name="ln8290">			if (a) return a.value();</a>
<a name="ln8291"> </a>
<a name="ln8292">			p = p.parent();</a>
<a name="ln8293">		}</a>
<a name="ln8294"> </a>
<a name="ln8295">		return PUGIXML_TEXT(&quot;&quot;);</a>
<a name="ln8296">	}</a>
<a name="ln8297"> </a>
<a name="ln8298">	PUGI__FN const char_t* namespace_uri(xml_attribute attr, xml_node parent)</a>
<a name="ln8299">	{</a>
<a name="ln8300">		namespace_uri_predicate pred = attr.name();</a>
<a name="ln8301"> </a>
<a name="ln8302">		// Default namespace does not apply to attributes</a>
<a name="ln8303">		if (!pred.prefix) return PUGIXML_TEXT(&quot;&quot;);</a>
<a name="ln8304"> </a>
<a name="ln8305">		xml_node p = parent;</a>
<a name="ln8306"> </a>
<a name="ln8307">		while (p)</a>
<a name="ln8308">		{</a>
<a name="ln8309">			xml_attribute a = p.find_attribute(pred);</a>
<a name="ln8310"> </a>
<a name="ln8311">			if (a) return a.value();</a>
<a name="ln8312"> </a>
<a name="ln8313">			p = p.parent();</a>
<a name="ln8314">		}</a>
<a name="ln8315"> </a>
<a name="ln8316">		return PUGIXML_TEXT(&quot;&quot;);</a>
<a name="ln8317">	}</a>
<a name="ln8318"> </a>
<a name="ln8319">	PUGI__FN const char_t* namespace_uri(const xpath_node&amp; node)</a>
<a name="ln8320">	{</a>
<a name="ln8321">		return node.attribute() ? namespace_uri(node.attribute(), node.parent()) : namespace_uri(node.node());</a>
<a name="ln8322">	}</a>
<a name="ln8323"> </a>
<a name="ln8324">	PUGI__FN char_t* normalize_space(char_t* buffer)</a>
<a name="ln8325">	{</a>
<a name="ln8326">		char_t* write = buffer;</a>
<a name="ln8327"> </a>
<a name="ln8328">		for (char_t* it = buffer; *it; )</a>
<a name="ln8329">		{</a>
<a name="ln8330">			char_t ch = *it++;</a>
<a name="ln8331"> </a>
<a name="ln8332">			if (PUGI__IS_CHARTYPE(ch, ct_space))</a>
<a name="ln8333">			{</a>
<a name="ln8334">				// replace whitespace sequence with single space</a>
<a name="ln8335">				while (PUGI__IS_CHARTYPE(*it, ct_space)) it++;</a>
<a name="ln8336"> </a>
<a name="ln8337">				// avoid leading spaces</a>
<a name="ln8338">				if (write != buffer) *write++ = ' ';</a>
<a name="ln8339">			}</a>
<a name="ln8340">			else *write++ = ch;</a>
<a name="ln8341">		}</a>
<a name="ln8342"> </a>
<a name="ln8343">		// remove trailing space</a>
<a name="ln8344">		if (write != buffer &amp;&amp; PUGI__IS_CHARTYPE(write[-1], ct_space)) write--;</a>
<a name="ln8345"> </a>
<a name="ln8346">		// zero-terminate</a>
<a name="ln8347">		*write = 0;</a>
<a name="ln8348"> </a>
<a name="ln8349">		return write;</a>
<a name="ln8350">	}</a>
<a name="ln8351"> </a>
<a name="ln8352">	PUGI__FN char_t* translate(char_t* buffer, const char_t* from, const char_t* to, size_t to_length)</a>
<a name="ln8353">	{</a>
<a name="ln8354">		char_t* write = buffer;</a>
<a name="ln8355"> </a>
<a name="ln8356">		while (*buffer)</a>
<a name="ln8357">		{</a>
<a name="ln8358">			PUGI__DMC_VOLATILE char_t ch = *buffer++;</a>
<a name="ln8359"> </a>
<a name="ln8360">			const char_t* pos = find_char(from, ch);</a>
<a name="ln8361"> </a>
<a name="ln8362">			if (!pos)</a>
<a name="ln8363">				*write++ = ch; // do not process</a>
<a name="ln8364">			else if (static_cast&lt;size_t&gt;(pos - from) &lt; to_length)</a>
<a name="ln8365">				*write++ = to[pos - from]; // replace</a>
<a name="ln8366">		}</a>
<a name="ln8367"> </a>
<a name="ln8368">		// zero-terminate</a>
<a name="ln8369">		*write = 0;</a>
<a name="ln8370"> </a>
<a name="ln8371">		return write;</a>
<a name="ln8372">	}</a>
<a name="ln8373"> </a>
<a name="ln8374">	PUGI__FN unsigned char* translate_table_generate(xpath_allocator* alloc, const char_t* from, const char_t* to)</a>
<a name="ln8375">	{</a>
<a name="ln8376">		unsigned char table[128] = {0};</a>
<a name="ln8377"> </a>
<a name="ln8378">		while (*from)</a>
<a name="ln8379">		{</a>
<a name="ln8380">			unsigned int fc = static_cast&lt;unsigned int&gt;(*from);</a>
<a name="ln8381">			unsigned int tc = static_cast&lt;unsigned int&gt;(*to);</a>
<a name="ln8382"> </a>
<a name="ln8383">			if (fc &gt;= 128 || tc &gt;= 128)</a>
<a name="ln8384">				return 0;</a>
<a name="ln8385"> </a>
<a name="ln8386">			// code=128 means &quot;skip character&quot;</a>
<a name="ln8387">			if (!table[fc])</a>
<a name="ln8388">				table[fc] = static_cast&lt;unsigned char&gt;(tc ? tc : 128);</a>
<a name="ln8389"> </a>
<a name="ln8390">			from++;</a>
<a name="ln8391">			if (tc) to++;</a>
<a name="ln8392">		}</a>
<a name="ln8393"> </a>
<a name="ln8394">		for (int i = 0; i &lt; 128; ++i)</a>
<a name="ln8395">			if (!table[i])</a>
<a name="ln8396">				table[i] = static_cast&lt;unsigned char&gt;(i);</a>
<a name="ln8397"> </a>
<a name="ln8398">		void* result = alloc-&gt;allocate_nothrow(sizeof(table));</a>
<a name="ln8399"> </a>
<a name="ln8400">		if (result)</a>
<a name="ln8401">		{</a>
<a name="ln8402">			memcpy(result, table, sizeof(table));</a>
<a name="ln8403">		}</a>
<a name="ln8404"> </a>
<a name="ln8405">		return static_cast&lt;unsigned char*&gt;(result);</a>
<a name="ln8406">	}</a>
<a name="ln8407"> </a>
<a name="ln8408">	PUGI__FN char_t* translate_table(char_t* buffer, const unsigned char* table)</a>
<a name="ln8409">	{</a>
<a name="ln8410">		char_t* write = buffer;</a>
<a name="ln8411"> </a>
<a name="ln8412">		while (*buffer)</a>
<a name="ln8413">		{</a>
<a name="ln8414">			char_t ch = *buffer++;</a>
<a name="ln8415">			unsigned int index = static_cast&lt;unsigned int&gt;(ch);</a>
<a name="ln8416"> </a>
<a name="ln8417">			if (index &lt; 128)</a>
<a name="ln8418">			{</a>
<a name="ln8419">				unsigned char code = table[index];</a>
<a name="ln8420"> </a>
<a name="ln8421">				// code=128 means &quot;skip character&quot; (table size is 128 so 128 can be a special value)</a>
<a name="ln8422">				// this code skips these characters without extra branches</a>
<a name="ln8423">				*write = static_cast&lt;char_t&gt;(code);</a>
<a name="ln8424">				write += 1 - (code &gt;&gt; 7);</a>
<a name="ln8425">			}</a>
<a name="ln8426">			else</a>
<a name="ln8427">			{</a>
<a name="ln8428">				*write++ = ch;</a>
<a name="ln8429">			}</a>
<a name="ln8430">		}</a>
<a name="ln8431"> </a>
<a name="ln8432">		// zero-terminate</a>
<a name="ln8433">		*write = 0;</a>
<a name="ln8434"> </a>
<a name="ln8435">		return write;</a>
<a name="ln8436">	}</a>
<a name="ln8437"> </a>
<a name="ln8438">	inline bool is_xpath_attribute(const char_t* name)</a>
<a name="ln8439">	{</a>
<a name="ln8440">		return !(starts_with(name, PUGIXML_TEXT(&quot;xmlns&quot;)) &amp;&amp; (name[5] == 0 || name[5] == ':'));</a>
<a name="ln8441">	}</a>
<a name="ln8442"> </a>
<a name="ln8443">	struct xpath_variable_boolean: xpath_variable</a>
<a name="ln8444">	{</a>
<a name="ln8445">		xpath_variable_boolean(): xpath_variable(xpath_type_boolean), value(false)</a>
<a name="ln8446">		{</a>
<a name="ln8447">		}</a>
<a name="ln8448"> </a>
<a name="ln8449">		bool value;</a>
<a name="ln8450">		char_t name[1];</a>
<a name="ln8451">	};</a>
<a name="ln8452"> </a>
<a name="ln8453">	struct xpath_variable_number: xpath_variable</a>
<a name="ln8454">	{</a>
<a name="ln8455">		xpath_variable_number(): xpath_variable(xpath_type_number), value(0)</a>
<a name="ln8456">		{</a>
<a name="ln8457">		}</a>
<a name="ln8458"> </a>
<a name="ln8459">		double value;</a>
<a name="ln8460">		char_t name[1];</a>
<a name="ln8461">	};</a>
<a name="ln8462"> </a>
<a name="ln8463">	struct xpath_variable_string: xpath_variable</a>
<a name="ln8464">	{</a>
<a name="ln8465">		xpath_variable_string(): xpath_variable(xpath_type_string), value(0)</a>
<a name="ln8466">		{</a>
<a name="ln8467">		}</a>
<a name="ln8468"> </a>
<a name="ln8469">		~xpath_variable_string()</a>
<a name="ln8470">		{</a>
<a name="ln8471">			if (value) xml_memory::deallocate(value);</a>
<a name="ln8472">		}</a>
<a name="ln8473"> </a>
<a name="ln8474">		char_t* value;</a>
<a name="ln8475">		char_t name[1];</a>
<a name="ln8476">	};</a>
<a name="ln8477"> </a>
<a name="ln8478">	struct xpath_variable_node_set: xpath_variable</a>
<a name="ln8479">	{</a>
<a name="ln8480">		xpath_variable_node_set(): xpath_variable(xpath_type_node_set)</a>
<a name="ln8481">		{</a>
<a name="ln8482">		}</a>
<a name="ln8483"> </a>
<a name="ln8484">		xpath_node_set value;</a>
<a name="ln8485">		char_t name[1];</a>
<a name="ln8486">	};</a>
<a name="ln8487"> </a>
<a name="ln8488">	static const xpath_node_set dummy_node_set;</a>
<a name="ln8489"> </a>
<a name="ln8490">	PUGI__FN unsigned int hash_string(const char_t* str)</a>
<a name="ln8491">	{</a>
<a name="ln8492">		// Jenkins one-at-a-time hash (http://en.wikipedia.org/wiki/Jenkins_hash_function#one-at-a-time)</a>
<a name="ln8493">		unsigned int result = 0;</a>
<a name="ln8494"> </a>
<a name="ln8495">		while (*str)</a>
<a name="ln8496">		{</a>
<a name="ln8497">			result += static_cast&lt;unsigned int&gt;(*str++);</a>
<a name="ln8498">			result += result &lt;&lt; 10;</a>
<a name="ln8499">			result ^= result &gt;&gt; 6;</a>
<a name="ln8500">		}</a>
<a name="ln8501"> </a>
<a name="ln8502">		result += result &lt;&lt; 3;</a>
<a name="ln8503">		result ^= result &gt;&gt; 11;</a>
<a name="ln8504">		result += result &lt;&lt; 15;</a>
<a name="ln8505"> </a>
<a name="ln8506">		return result;</a>
<a name="ln8507">	}</a>
<a name="ln8508"> </a>
<a name="ln8509">	template &lt;typename T&gt; PUGI__FN T* new_xpath_variable(const char_t* name)</a>
<a name="ln8510">	{</a>
<a name="ln8511">		size_t length = strlength(name);</a>
<a name="ln8512">		if (length == 0) return 0; // empty variable names are invalid</a>
<a name="ln8513"> </a>
<a name="ln8514">		// $$ we can't use offsetof(T, name) because T is non-POD, so we just allocate additional length characters</a>
<a name="ln8515">		void* memory = xml_memory::allocate(sizeof(T) + length * sizeof(char_t));</a>
<a name="ln8516">		if (!memory) return 0;</a>
<a name="ln8517"> </a>
<a name="ln8518">		T* result = new (memory) T();</a>
<a name="ln8519"> </a>
<a name="ln8520">		memcpy(result-&gt;name, name, (length + 1) * sizeof(char_t));</a>
<a name="ln8521"> </a>
<a name="ln8522">		return result;</a>
<a name="ln8523">	}</a>
<a name="ln8524"> </a>
<a name="ln8525">	PUGI__FN xpath_variable* new_xpath_variable(xpath_value_type type, const char_t* name)</a>
<a name="ln8526">	{</a>
<a name="ln8527">		switch (type)</a>
<a name="ln8528">		{</a>
<a name="ln8529">		case xpath_type_node_set:</a>
<a name="ln8530">			return new_xpath_variable&lt;xpath_variable_node_set&gt;(name);</a>
<a name="ln8531"> </a>
<a name="ln8532">		case xpath_type_number:</a>
<a name="ln8533">			return new_xpath_variable&lt;xpath_variable_number&gt;(name);</a>
<a name="ln8534"> </a>
<a name="ln8535">		case xpath_type_string:</a>
<a name="ln8536">			return new_xpath_variable&lt;xpath_variable_string&gt;(name);</a>
<a name="ln8537"> </a>
<a name="ln8538">		case xpath_type_boolean:</a>
<a name="ln8539">			return new_xpath_variable&lt;xpath_variable_boolean&gt;(name);</a>
<a name="ln8540"> </a>
<a name="ln8541">		default:</a>
<a name="ln8542">			return 0;</a>
<a name="ln8543">		}</a>
<a name="ln8544">	}</a>
<a name="ln8545"> </a>
<a name="ln8546">	template &lt;typename T&gt; PUGI__FN void delete_xpath_variable(T* var)</a>
<a name="ln8547">	{</a>
<a name="ln8548">		var-&gt;~T();</a>
<a name="ln8549">		xml_memory::deallocate(var);</a>
<a name="ln8550">	}</a>
<a name="ln8551"> </a>
<a name="ln8552">	PUGI__FN void delete_xpath_variable(xpath_value_type type, xpath_variable* var)</a>
<a name="ln8553">	{</a>
<a name="ln8554">		switch (type)</a>
<a name="ln8555">		{</a>
<a name="ln8556">		case xpath_type_node_set:</a>
<a name="ln8557">			delete_xpath_variable(static_cast&lt;xpath_variable_node_set*&gt;(var));</a>
<a name="ln8558">			break;</a>
<a name="ln8559"> </a>
<a name="ln8560">		case xpath_type_number:</a>
<a name="ln8561">			delete_xpath_variable(static_cast&lt;xpath_variable_number*&gt;(var));</a>
<a name="ln8562">			break;</a>
<a name="ln8563"> </a>
<a name="ln8564">		case xpath_type_string:</a>
<a name="ln8565">			delete_xpath_variable(static_cast&lt;xpath_variable_string*&gt;(var));</a>
<a name="ln8566">			break;</a>
<a name="ln8567"> </a>
<a name="ln8568">		case xpath_type_boolean:</a>
<a name="ln8569">			delete_xpath_variable(static_cast&lt;xpath_variable_boolean*&gt;(var));</a>
<a name="ln8570">			break;</a>
<a name="ln8571"> </a>
<a name="ln8572">		default:</a>
<a name="ln8573">			assert(false &amp;&amp; &quot;Invalid variable type&quot;);</a>
<a name="ln8574">		}</a>
<a name="ln8575">	}</a>
<a name="ln8576"> </a>
<a name="ln8577">	PUGI__FN bool copy_xpath_variable(xpath_variable* lhs, const xpath_variable* rhs)</a>
<a name="ln8578">	{</a>
<a name="ln8579">		switch (rhs-&gt;type())</a>
<a name="ln8580">		{</a>
<a name="ln8581">		case xpath_type_node_set:</a>
<a name="ln8582">			return lhs-&gt;set(static_cast&lt;const xpath_variable_node_set*&gt;(rhs)-&gt;value);</a>
<a name="ln8583"> </a>
<a name="ln8584">		case xpath_type_number:</a>
<a name="ln8585">			return lhs-&gt;set(static_cast&lt;const xpath_variable_number*&gt;(rhs)-&gt;value);</a>
<a name="ln8586"> </a>
<a name="ln8587">		case xpath_type_string:</a>
<a name="ln8588">			return lhs-&gt;set(static_cast&lt;const xpath_variable_string*&gt;(rhs)-&gt;value);</a>
<a name="ln8589"> </a>
<a name="ln8590">		case xpath_type_boolean:</a>
<a name="ln8591">			return lhs-&gt;set(static_cast&lt;const xpath_variable_boolean*&gt;(rhs)-&gt;value);</a>
<a name="ln8592"> </a>
<a name="ln8593">		default:</a>
<a name="ln8594">			assert(false &amp;&amp; &quot;Invalid variable type&quot;);</a>
<a name="ln8595">			return false;</a>
<a name="ln8596">		}</a>
<a name="ln8597">	}</a>
<a name="ln8598"> </a>
<a name="ln8599">	PUGI__FN bool get_variable_scratch(char_t (&amp;buffer)[32], xpath_variable_set* set, const char_t* begin, const char_t* end, xpath_variable** out_result)</a>
<a name="ln8600">	{</a>
<a name="ln8601">		size_t length = static_cast&lt;size_t&gt;(end - begin);</a>
<a name="ln8602">		char_t* scratch = buffer;</a>
<a name="ln8603"> </a>
<a name="ln8604">		if (length &gt;= sizeof(buffer) / sizeof(buffer[0]))</a>
<a name="ln8605">		{</a>
<a name="ln8606">			// need to make dummy on-heap copy</a>
<a name="ln8607">			scratch = static_cast&lt;char_t*&gt;(xml_memory::allocate((length + 1) * sizeof(char_t)));</a>
<a name="ln8608">			if (!scratch) return false;</a>
<a name="ln8609">		}</a>
<a name="ln8610"> </a>
<a name="ln8611">		// copy string to zero-terminated buffer and perform lookup</a>
<a name="ln8612">		memcpy(scratch, begin, length * sizeof(char_t));</a>
<a name="ln8613">		scratch[length] = 0;</a>
<a name="ln8614"> </a>
<a name="ln8615">		*out_result = set-&gt;get(scratch);</a>
<a name="ln8616"> </a>
<a name="ln8617">		// free dummy buffer</a>
<a name="ln8618">		if (scratch != buffer) xml_memory::deallocate(scratch);</a>
<a name="ln8619"> </a>
<a name="ln8620">		return true;</a>
<a name="ln8621">	}</a>
<a name="ln8622">PUGI__NS_END</a>
<a name="ln8623"> </a>
<a name="ln8624">// Internal node set class</a>
<a name="ln8625">PUGI__NS_BEGIN</a>
<a name="ln8626">	PUGI__FN xpath_node_set::type_t xpath_get_order(const xpath_node* begin, const xpath_node* end)</a>
<a name="ln8627">	{</a>
<a name="ln8628">		if (end - begin &lt; 2)</a>
<a name="ln8629">			return xpath_node_set::type_sorted;</a>
<a name="ln8630"> </a>
<a name="ln8631">		document_order_comparator cmp;</a>
<a name="ln8632"> </a>
<a name="ln8633">		bool first = cmp(begin[0], begin[1]);</a>
<a name="ln8634"> </a>
<a name="ln8635">		for (const xpath_node* it = begin + 1; it + 1 &lt; end; ++it)</a>
<a name="ln8636">			if (cmp(it[0], it[1]) != first)</a>
<a name="ln8637">				return xpath_node_set::type_unsorted;</a>
<a name="ln8638"> </a>
<a name="ln8639">		return first ? xpath_node_set::type_sorted : xpath_node_set::type_sorted_reverse;</a>
<a name="ln8640">	}</a>
<a name="ln8641"> </a>
<a name="ln8642">	PUGI__FN xpath_node_set::type_t xpath_sort(xpath_node* begin, xpath_node* end, xpath_node_set::type_t type, bool rev)</a>
<a name="ln8643">	{</a>
<a name="ln8644">		xpath_node_set::type_t order = rev ? xpath_node_set::type_sorted_reverse : xpath_node_set::type_sorted;</a>
<a name="ln8645"> </a>
<a name="ln8646">		if (type == xpath_node_set::type_unsorted)</a>
<a name="ln8647">		{</a>
<a name="ln8648">			xpath_node_set::type_t sorted = xpath_get_order(begin, end);</a>
<a name="ln8649"> </a>
<a name="ln8650">			if (sorted == xpath_node_set::type_unsorted)</a>
<a name="ln8651">			{</a>
<a name="ln8652">				sort(begin, end, document_order_comparator());</a>
<a name="ln8653"> </a>
<a name="ln8654">				type = xpath_node_set::type_sorted;</a>
<a name="ln8655">			}</a>
<a name="ln8656">			else</a>
<a name="ln8657">				type = sorted;</a>
<a name="ln8658">		}</a>
<a name="ln8659"> </a>
<a name="ln8660">		if (type != order) reverse(begin, end);</a>
<a name="ln8661"> </a>
<a name="ln8662">		return order;</a>
<a name="ln8663">	}</a>
<a name="ln8664"> </a>
<a name="ln8665">	PUGI__FN xpath_node xpath_first(const xpath_node* begin, const xpath_node* end, xpath_node_set::type_t type)</a>
<a name="ln8666">	{</a>
<a name="ln8667">		if (begin == end) return xpath_node();</a>
<a name="ln8668"> </a>
<a name="ln8669">		switch (type)</a>
<a name="ln8670">		{</a>
<a name="ln8671">		case xpath_node_set::type_sorted:</a>
<a name="ln8672">			return *begin;</a>
<a name="ln8673"> </a>
<a name="ln8674">		case xpath_node_set::type_sorted_reverse:</a>
<a name="ln8675">			return *(end - 1);</a>
<a name="ln8676"> </a>
<a name="ln8677">		case xpath_node_set::type_unsorted:</a>
<a name="ln8678">			return *min_element(begin, end, document_order_comparator());</a>
<a name="ln8679"> </a>
<a name="ln8680">		default:</a>
<a name="ln8681">			assert(false &amp;&amp; &quot;Invalid node set type&quot;);</a>
<a name="ln8682">			return xpath_node();</a>
<a name="ln8683">		}</a>
<a name="ln8684">	}</a>
<a name="ln8685"> </a>
<a name="ln8686">	class xpath_node_set_raw</a>
<a name="ln8687">	{</a>
<a name="ln8688">		xpath_node_set::type_t _type;</a>
<a name="ln8689"> </a>
<a name="ln8690">		xpath_node* _begin;</a>
<a name="ln8691">		xpath_node* _end;</a>
<a name="ln8692">		xpath_node* _eos;</a>
<a name="ln8693"> </a>
<a name="ln8694">	public:</a>
<a name="ln8695">		xpath_node_set_raw(): _type(xpath_node_set::type_unsorted), _begin(0), _end(0), _eos(0)</a>
<a name="ln8696">		{</a>
<a name="ln8697">		}</a>
<a name="ln8698"> </a>
<a name="ln8699">		xpath_node* begin() const</a>
<a name="ln8700">		{</a>
<a name="ln8701">			return _begin;</a>
<a name="ln8702">		}</a>
<a name="ln8703"> </a>
<a name="ln8704">		xpath_node* end() const</a>
<a name="ln8705">		{</a>
<a name="ln8706">			return _end;</a>
<a name="ln8707">		}</a>
<a name="ln8708"> </a>
<a name="ln8709">		bool empty() const</a>
<a name="ln8710">		{</a>
<a name="ln8711">			return _begin == _end;</a>
<a name="ln8712">		}</a>
<a name="ln8713"> </a>
<a name="ln8714">		size_t size() const</a>
<a name="ln8715">		{</a>
<a name="ln8716">			return static_cast&lt;size_t&gt;(_end - _begin);</a>
<a name="ln8717">		}</a>
<a name="ln8718"> </a>
<a name="ln8719">		xpath_node first() const</a>
<a name="ln8720">		{</a>
<a name="ln8721">			return xpath_first(_begin, _end, _type);</a>
<a name="ln8722">		}</a>
<a name="ln8723"> </a>
<a name="ln8724">		void push_back_grow(const xpath_node&amp; node, xpath_allocator* alloc);</a>
<a name="ln8725"> </a>
<a name="ln8726">		void push_back(const xpath_node&amp; node, xpath_allocator* alloc)</a>
<a name="ln8727">		{</a>
<a name="ln8728">			if (_end != _eos)</a>
<a name="ln8729">				*_end++ = node;</a>
<a name="ln8730">			else</a>
<a name="ln8731">				push_back_grow(node, alloc);</a>
<a name="ln8732">		}</a>
<a name="ln8733"> </a>
<a name="ln8734">		void append(const xpath_node* begin_, const xpath_node* end_, xpath_allocator* alloc)</a>
<a name="ln8735">		{</a>
<a name="ln8736">			if (begin_ == end_) return;</a>
<a name="ln8737"> </a>
<a name="ln8738">			size_t size_ = static_cast&lt;size_t&gt;(_end - _begin);</a>
<a name="ln8739">			size_t capacity = static_cast&lt;size_t&gt;(_eos - _begin);</a>
<a name="ln8740">			size_t count = static_cast&lt;size_t&gt;(end_ - begin_);</a>
<a name="ln8741"> </a>
<a name="ln8742">			if (size_ + count &gt; capacity)</a>
<a name="ln8743">			{</a>
<a name="ln8744">				// reallocate the old array or allocate a new one</a>
<a name="ln8745">				xpath_node* data = static_cast&lt;xpath_node*&gt;(alloc-&gt;reallocate(_begin, capacity * sizeof(xpath_node), (size_ + count) * sizeof(xpath_node)));</a>
<a name="ln8746">				assert(data);</a>
<a name="ln8747"> </a>
<a name="ln8748">				// finalize</a>
<a name="ln8749">				_begin = data;</a>
<a name="ln8750">				_end = data + size_;</a>
<a name="ln8751">				_eos = data + size_ + count;</a>
<a name="ln8752">			}</a>
<a name="ln8753"> </a>
<a name="ln8754">			memcpy(_end, begin_, count * sizeof(xpath_node));</a>
<a name="ln8755">			_end += count;</a>
<a name="ln8756">		}</a>
<a name="ln8757"> </a>
<a name="ln8758">		void sort_do()</a>
<a name="ln8759">		{</a>
<a name="ln8760">			_type = xpath_sort(_begin, _end, _type, false);</a>
<a name="ln8761">		}</a>
<a name="ln8762"> </a>
<a name="ln8763">		void truncate(xpath_node* pos)</a>
<a name="ln8764">		{</a>
<a name="ln8765">			assert(_begin &lt;= pos &amp;&amp; pos &lt;= _end);</a>
<a name="ln8766"> </a>
<a name="ln8767">			_end = pos;</a>
<a name="ln8768">		}</a>
<a name="ln8769"> </a>
<a name="ln8770">		void remove_duplicates()</a>
<a name="ln8771">		{</a>
<a name="ln8772">			if (_type == xpath_node_set::type_unsorted)</a>
<a name="ln8773">				sort(_begin, _end, duplicate_comparator());</a>
<a name="ln8774"> </a>
<a name="ln8775">			_end = unique(_begin, _end);</a>
<a name="ln8776">		}</a>
<a name="ln8777"> </a>
<a name="ln8778">		xpath_node_set::type_t type() const</a>
<a name="ln8779">		{</a>
<a name="ln8780">			return _type;</a>
<a name="ln8781">		}</a>
<a name="ln8782"> </a>
<a name="ln8783">		void set_type(xpath_node_set::type_t value)</a>
<a name="ln8784">		{</a>
<a name="ln8785">			_type = value;</a>
<a name="ln8786">		}</a>
<a name="ln8787">	};</a>
<a name="ln8788"> </a>
<a name="ln8789">	PUGI__FN_NO_INLINE void xpath_node_set_raw::push_back_grow(const xpath_node&amp; node, xpath_allocator* alloc)</a>
<a name="ln8790">	{</a>
<a name="ln8791">		size_t capacity = static_cast&lt;size_t&gt;(_eos - _begin);</a>
<a name="ln8792"> </a>
<a name="ln8793">		// get new capacity (1.5x rule)</a>
<a name="ln8794">		size_t new_capacity = capacity + capacity / 2 + 1;</a>
<a name="ln8795"> </a>
<a name="ln8796">		// reallocate the old array or allocate a new one</a>
<a name="ln8797">		xpath_node* data = static_cast&lt;xpath_node*&gt;(alloc-&gt;reallocate(_begin, capacity * sizeof(xpath_node), new_capacity * sizeof(xpath_node)));</a>
<a name="ln8798">		assert(data);</a>
<a name="ln8799"> </a>
<a name="ln8800">		// finalize</a>
<a name="ln8801">		_begin = data;</a>
<a name="ln8802">		_end = data + capacity;</a>
<a name="ln8803">		_eos = data + new_capacity;</a>
<a name="ln8804"> </a>
<a name="ln8805">		// push</a>
<a name="ln8806">		*_end++ = node;</a>
<a name="ln8807">	}</a>
<a name="ln8808">PUGI__NS_END</a>
<a name="ln8809"> </a>
<a name="ln8810">PUGI__NS_BEGIN</a>
<a name="ln8811">	struct xpath_context</a>
<a name="ln8812">	{</a>
<a name="ln8813">		xpath_node n;</a>
<a name="ln8814">		size_t position, size;</a>
<a name="ln8815"> </a>
<a name="ln8816">		xpath_context(const xpath_node&amp; n_, size_t position_, size_t size_): n(n_), position(position_), size(size_)</a>
<a name="ln8817">		{</a>
<a name="ln8818">		}</a>
<a name="ln8819">	};</a>
<a name="ln8820"> </a>
<a name="ln8821">	enum lexeme_t</a>
<a name="ln8822">	{</a>
<a name="ln8823">		lex_none = 0,</a>
<a name="ln8824">		lex_equal,</a>
<a name="ln8825">		lex_not_equal,</a>
<a name="ln8826">		lex_less,</a>
<a name="ln8827">		lex_greater,</a>
<a name="ln8828">		lex_less_or_equal,</a>
<a name="ln8829">		lex_greater_or_equal,</a>
<a name="ln8830">		lex_plus,</a>
<a name="ln8831">		lex_minus,</a>
<a name="ln8832">		lex_multiply,</a>
<a name="ln8833">		lex_union,</a>
<a name="ln8834">		lex_var_ref,</a>
<a name="ln8835">		lex_open_brace,</a>
<a name="ln8836">		lex_close_brace,</a>
<a name="ln8837">		lex_quoted_string,</a>
<a name="ln8838">		lex_number,</a>
<a name="ln8839">		lex_slash,</a>
<a name="ln8840">		lex_double_slash,</a>
<a name="ln8841">		lex_open_square_brace,</a>
<a name="ln8842">		lex_close_square_brace,</a>
<a name="ln8843">		lex_string,</a>
<a name="ln8844">		lex_comma,</a>
<a name="ln8845">		lex_axis_attribute,</a>
<a name="ln8846">		lex_dot,</a>
<a name="ln8847">		lex_double_dot,</a>
<a name="ln8848">		lex_double_colon,</a>
<a name="ln8849">		lex_eof</a>
<a name="ln8850">	};</a>
<a name="ln8851"> </a>
<a name="ln8852">	struct xpath_lexer_string</a>
<a name="ln8853">	{</a>
<a name="ln8854">		const char_t* begin;</a>
<a name="ln8855">		const char_t* end;</a>
<a name="ln8856"> </a>
<a name="ln8857">		xpath_lexer_string(): begin(0), end(0)</a>
<a name="ln8858">		{</a>
<a name="ln8859">		}</a>
<a name="ln8860"> </a>
<a name="ln8861">		bool operator==(const char_t* other) const</a>
<a name="ln8862">		{</a>
<a name="ln8863">			size_t length = static_cast&lt;size_t&gt;(end - begin);</a>
<a name="ln8864"> </a>
<a name="ln8865">			return strequalrange(other, begin, length);</a>
<a name="ln8866">		}</a>
<a name="ln8867">	};</a>
<a name="ln8868"> </a>
<a name="ln8869">	class xpath_lexer</a>
<a name="ln8870">	{</a>
<a name="ln8871">		const char_t* _cur;</a>
<a name="ln8872">		const char_t* _cur_lexeme_pos;</a>
<a name="ln8873">		xpath_lexer_string _cur_lexeme_contents;</a>
<a name="ln8874"> </a>
<a name="ln8875">		lexeme_t _cur_lexeme;</a>
<a name="ln8876"> </a>
<a name="ln8877">	public:</a>
<a name="ln8878">		explicit xpath_lexer(const char_t* query): _cur(query)</a>
<a name="ln8879">		{</a>
<a name="ln8880">			next();</a>
<a name="ln8881">		}</a>
<a name="ln8882"> </a>
<a name="ln8883">		const char_t* state() const</a>
<a name="ln8884">		{</a>
<a name="ln8885">			return _cur;</a>
<a name="ln8886">		}</a>
<a name="ln8887"> </a>
<a name="ln8888">		void next()</a>
<a name="ln8889">		{</a>
<a name="ln8890">			const char_t* cur = _cur;</a>
<a name="ln8891"> </a>
<a name="ln8892">			while (PUGI__IS_CHARTYPE(*cur, ct_space)) ++cur;</a>
<a name="ln8893"> </a>
<a name="ln8894">			// save lexeme position for error reporting</a>
<a name="ln8895">			_cur_lexeme_pos = cur;</a>
<a name="ln8896"> </a>
<a name="ln8897">			switch (*cur)</a>
<a name="ln8898">			{</a>
<a name="ln8899">			case 0:</a>
<a name="ln8900">				_cur_lexeme = lex_eof;</a>
<a name="ln8901">				break;</a>
<a name="ln8902"> </a>
<a name="ln8903">			case '&gt;':</a>
<a name="ln8904">				if (*(cur+1) == '=')</a>
<a name="ln8905">				{</a>
<a name="ln8906">					cur += 2;</a>
<a name="ln8907">					_cur_lexeme = lex_greater_or_equal;</a>
<a name="ln8908">				}</a>
<a name="ln8909">				else</a>
<a name="ln8910">				{</a>
<a name="ln8911">					cur += 1;</a>
<a name="ln8912">					_cur_lexeme = lex_greater;</a>
<a name="ln8913">				}</a>
<a name="ln8914">				break;</a>
<a name="ln8915"> </a>
<a name="ln8916">			case '&lt;':</a>
<a name="ln8917">				if (*(cur+1) == '=')</a>
<a name="ln8918">				{</a>
<a name="ln8919">					cur += 2;</a>
<a name="ln8920">					_cur_lexeme = lex_less_or_equal;</a>
<a name="ln8921">				}</a>
<a name="ln8922">				else</a>
<a name="ln8923">				{</a>
<a name="ln8924">					cur += 1;</a>
<a name="ln8925">					_cur_lexeme = lex_less;</a>
<a name="ln8926">				}</a>
<a name="ln8927">				break;</a>
<a name="ln8928"> </a>
<a name="ln8929">			case '!':</a>
<a name="ln8930">				if (*(cur+1) == '=')</a>
<a name="ln8931">				{</a>
<a name="ln8932">					cur += 2;</a>
<a name="ln8933">					_cur_lexeme = lex_not_equal;</a>
<a name="ln8934">				}</a>
<a name="ln8935">				else</a>
<a name="ln8936">				{</a>
<a name="ln8937">					_cur_lexeme = lex_none;</a>
<a name="ln8938">				}</a>
<a name="ln8939">				break;</a>
<a name="ln8940"> </a>
<a name="ln8941">			case '=':</a>
<a name="ln8942">				cur += 1;</a>
<a name="ln8943">				_cur_lexeme = lex_equal;</a>
<a name="ln8944"> </a>
<a name="ln8945">				break;</a>
<a name="ln8946"> </a>
<a name="ln8947">			case '+':</a>
<a name="ln8948">				cur += 1;</a>
<a name="ln8949">				_cur_lexeme = lex_plus;</a>
<a name="ln8950"> </a>
<a name="ln8951">				break;</a>
<a name="ln8952"> </a>
<a name="ln8953">			case '-':</a>
<a name="ln8954">				cur += 1;</a>
<a name="ln8955">				_cur_lexeme = lex_minus;</a>
<a name="ln8956"> </a>
<a name="ln8957">				break;</a>
<a name="ln8958"> </a>
<a name="ln8959">			case '*':</a>
<a name="ln8960">				cur += 1;</a>
<a name="ln8961">				_cur_lexeme = lex_multiply;</a>
<a name="ln8962"> </a>
<a name="ln8963">				break;</a>
<a name="ln8964"> </a>
<a name="ln8965">			case '|':</a>
<a name="ln8966">				cur += 1;</a>
<a name="ln8967">				_cur_lexeme = lex_union;</a>
<a name="ln8968"> </a>
<a name="ln8969">				break;</a>
<a name="ln8970"> </a>
<a name="ln8971">			case '$':</a>
<a name="ln8972">				cur += 1;</a>
<a name="ln8973"> </a>
<a name="ln8974">				if (PUGI__IS_CHARTYPEX(*cur, ctx_start_symbol))</a>
<a name="ln8975">				{</a>
<a name="ln8976">					_cur_lexeme_contents.begin = cur;</a>
<a name="ln8977"> </a>
<a name="ln8978">					while (PUGI__IS_CHARTYPEX(*cur, ctx_symbol)) cur++;</a>
<a name="ln8979"> </a>
<a name="ln8980">					if (cur[0] == ':' &amp;&amp; PUGI__IS_CHARTYPEX(cur[1], ctx_symbol)) // qname</a>
<a name="ln8981">					{</a>
<a name="ln8982">						cur++; // :</a>
<a name="ln8983"> </a>
<a name="ln8984">						while (PUGI__IS_CHARTYPEX(*cur, ctx_symbol)) cur++;</a>
<a name="ln8985">					}</a>
<a name="ln8986"> </a>
<a name="ln8987">					_cur_lexeme_contents.end = cur;</a>
<a name="ln8988"> </a>
<a name="ln8989">					_cur_lexeme = lex_var_ref;</a>
<a name="ln8990">				}</a>
<a name="ln8991">				else</a>
<a name="ln8992">				{</a>
<a name="ln8993">					_cur_lexeme = lex_none;</a>
<a name="ln8994">				}</a>
<a name="ln8995"> </a>
<a name="ln8996">				break;</a>
<a name="ln8997"> </a>
<a name="ln8998">			case '(':</a>
<a name="ln8999">				cur += 1;</a>
<a name="ln9000">				_cur_lexeme = lex_open_brace;</a>
<a name="ln9001"> </a>
<a name="ln9002">				break;</a>
<a name="ln9003"> </a>
<a name="ln9004">			case ')':</a>
<a name="ln9005">				cur += 1;</a>
<a name="ln9006">				_cur_lexeme = lex_close_brace;</a>
<a name="ln9007"> </a>
<a name="ln9008">				break;</a>
<a name="ln9009"> </a>
<a name="ln9010">			case '[':</a>
<a name="ln9011">				cur += 1;</a>
<a name="ln9012">				_cur_lexeme = lex_open_square_brace;</a>
<a name="ln9013"> </a>
<a name="ln9014">				break;</a>
<a name="ln9015"> </a>
<a name="ln9016">			case ']':</a>
<a name="ln9017">				cur += 1;</a>
<a name="ln9018">				_cur_lexeme = lex_close_square_brace;</a>
<a name="ln9019"> </a>
<a name="ln9020">				break;</a>
<a name="ln9021"> </a>
<a name="ln9022">			case ',':</a>
<a name="ln9023">				cur += 1;</a>
<a name="ln9024">				_cur_lexeme = lex_comma;</a>
<a name="ln9025"> </a>
<a name="ln9026">				break;</a>
<a name="ln9027"> </a>
<a name="ln9028">			case '/':</a>
<a name="ln9029">				if (*(cur+1) == '/')</a>
<a name="ln9030">				{</a>
<a name="ln9031">					cur += 2;</a>
<a name="ln9032">					_cur_lexeme = lex_double_slash;</a>
<a name="ln9033">				}</a>
<a name="ln9034">				else</a>
<a name="ln9035">				{</a>
<a name="ln9036">					cur += 1;</a>
<a name="ln9037">					_cur_lexeme = lex_slash;</a>
<a name="ln9038">				}</a>
<a name="ln9039">				break;</a>
<a name="ln9040"> </a>
<a name="ln9041">			case '.':</a>
<a name="ln9042">				if (*(cur+1) == '.')</a>
<a name="ln9043">				{</a>
<a name="ln9044">					cur += 2;</a>
<a name="ln9045">					_cur_lexeme = lex_double_dot;</a>
<a name="ln9046">				}</a>
<a name="ln9047">				else if (PUGI__IS_CHARTYPEX(*(cur+1), ctx_digit))</a>
<a name="ln9048">				{</a>
<a name="ln9049">					_cur_lexeme_contents.begin = cur; // .</a>
<a name="ln9050"> </a>
<a name="ln9051">					++cur;</a>
<a name="ln9052"> </a>
<a name="ln9053">					while (PUGI__IS_CHARTYPEX(*cur, ctx_digit)) cur++;</a>
<a name="ln9054"> </a>
<a name="ln9055">					_cur_lexeme_contents.end = cur;</a>
<a name="ln9056"> </a>
<a name="ln9057">					_cur_lexeme = lex_number;</a>
<a name="ln9058">				}</a>
<a name="ln9059">				else</a>
<a name="ln9060">				{</a>
<a name="ln9061">					cur += 1;</a>
<a name="ln9062">					_cur_lexeme = lex_dot;</a>
<a name="ln9063">				}</a>
<a name="ln9064">				break;</a>
<a name="ln9065"> </a>
<a name="ln9066">			case '@':</a>
<a name="ln9067">				cur += 1;</a>
<a name="ln9068">				_cur_lexeme = lex_axis_attribute;</a>
<a name="ln9069"> </a>
<a name="ln9070">				break;</a>
<a name="ln9071"> </a>
<a name="ln9072">			case '&quot;':</a>
<a name="ln9073">			case '\'':</a>
<a name="ln9074">			{</a>
<a name="ln9075">				char_t terminator = *cur;</a>
<a name="ln9076"> </a>
<a name="ln9077">				++cur;</a>
<a name="ln9078"> </a>
<a name="ln9079">				_cur_lexeme_contents.begin = cur;</a>
<a name="ln9080">				while (*cur &amp;&amp; *cur != terminator) cur++;</a>
<a name="ln9081">				_cur_lexeme_contents.end = cur;</a>
<a name="ln9082"> </a>
<a name="ln9083">				if (!*cur)</a>
<a name="ln9084">					_cur_lexeme = lex_none;</a>
<a name="ln9085">				else</a>
<a name="ln9086">				{</a>
<a name="ln9087">					cur += 1;</a>
<a name="ln9088">					_cur_lexeme = lex_quoted_string;</a>
<a name="ln9089">				}</a>
<a name="ln9090"> </a>
<a name="ln9091">				break;</a>
<a name="ln9092">			}</a>
<a name="ln9093"> </a>
<a name="ln9094">			case ':':</a>
<a name="ln9095">				if (*(cur+1) == ':')</a>
<a name="ln9096">				{</a>
<a name="ln9097">					cur += 2;</a>
<a name="ln9098">					_cur_lexeme = lex_double_colon;</a>
<a name="ln9099">				}</a>
<a name="ln9100">				else</a>
<a name="ln9101">				{</a>
<a name="ln9102">					_cur_lexeme = lex_none;</a>
<a name="ln9103">				}</a>
<a name="ln9104">				break;</a>
<a name="ln9105"> </a>
<a name="ln9106">			default:</a>
<a name="ln9107">				if (PUGI__IS_CHARTYPEX(*cur, ctx_digit))</a>
<a name="ln9108">				{</a>
<a name="ln9109">					_cur_lexeme_contents.begin = cur;</a>
<a name="ln9110"> </a>
<a name="ln9111">					while (PUGI__IS_CHARTYPEX(*cur, ctx_digit)) cur++;</a>
<a name="ln9112"> </a>
<a name="ln9113">					if (*cur == '.')</a>
<a name="ln9114">					{</a>
<a name="ln9115">						cur++;</a>
<a name="ln9116"> </a>
<a name="ln9117">						while (PUGI__IS_CHARTYPEX(*cur, ctx_digit)) cur++;</a>
<a name="ln9118">					}</a>
<a name="ln9119"> </a>
<a name="ln9120">					_cur_lexeme_contents.end = cur;</a>
<a name="ln9121"> </a>
<a name="ln9122">					_cur_lexeme = lex_number;</a>
<a name="ln9123">				}</a>
<a name="ln9124">				else if (PUGI__IS_CHARTYPEX(*cur, ctx_start_symbol))</a>
<a name="ln9125">				{</a>
<a name="ln9126">					_cur_lexeme_contents.begin = cur;</a>
<a name="ln9127"> </a>
<a name="ln9128">					while (PUGI__IS_CHARTYPEX(*cur, ctx_symbol)) cur++;</a>
<a name="ln9129"> </a>
<a name="ln9130">					if (cur[0] == ':')</a>
<a name="ln9131">					{</a>
<a name="ln9132">						if (cur[1] == '*') // namespace test ncname:*</a>
<a name="ln9133">						{</a>
<a name="ln9134">							cur += 2; // :*</a>
<a name="ln9135">						}</a>
<a name="ln9136">						else if (PUGI__IS_CHARTYPEX(cur[1], ctx_symbol)) // namespace test qname</a>
<a name="ln9137">						{</a>
<a name="ln9138">							cur++; // :</a>
<a name="ln9139"> </a>
<a name="ln9140">							while (PUGI__IS_CHARTYPEX(*cur, ctx_symbol)) cur++;</a>
<a name="ln9141">						}</a>
<a name="ln9142">					}</a>
<a name="ln9143"> </a>
<a name="ln9144">					_cur_lexeme_contents.end = cur;</a>
<a name="ln9145"> </a>
<a name="ln9146">					_cur_lexeme = lex_string;</a>
<a name="ln9147">				}</a>
<a name="ln9148">				else</a>
<a name="ln9149">				{</a>
<a name="ln9150">					_cur_lexeme = lex_none;</a>
<a name="ln9151">				}</a>
<a name="ln9152">			}</a>
<a name="ln9153"> </a>
<a name="ln9154">			_cur = cur;</a>
<a name="ln9155">		}</a>
<a name="ln9156"> </a>
<a name="ln9157">		lexeme_t current() const</a>
<a name="ln9158">		{</a>
<a name="ln9159">			return _cur_lexeme;</a>
<a name="ln9160">		}</a>
<a name="ln9161"> </a>
<a name="ln9162">		const char_t* current_pos() const</a>
<a name="ln9163">		{</a>
<a name="ln9164">			return _cur_lexeme_pos;</a>
<a name="ln9165">		}</a>
<a name="ln9166"> </a>
<a name="ln9167">		const xpath_lexer_string&amp; contents() const</a>
<a name="ln9168">		{</a>
<a name="ln9169">			assert(_cur_lexeme == lex_var_ref || _cur_lexeme == lex_number || _cur_lexeme == lex_string || _cur_lexeme == lex_quoted_string);</a>
<a name="ln9170"> </a>
<a name="ln9171">			return _cur_lexeme_contents;</a>
<a name="ln9172">		}</a>
<a name="ln9173">	};</a>
<a name="ln9174"> </a>
<a name="ln9175">	enum ast_type_t</a>
<a name="ln9176">	{</a>
<a name="ln9177">		ast_unknown,</a>
<a name="ln9178">		ast_op_or,						// left or right</a>
<a name="ln9179">		ast_op_and,						// left and right</a>
<a name="ln9180">		ast_op_equal,					// left = right</a>
<a name="ln9181">		ast_op_not_equal,				// left != right</a>
<a name="ln9182">		ast_op_less,					// left &lt; right</a>
<a name="ln9183">		ast_op_greater,					// left &gt; right</a>
<a name="ln9184">		ast_op_less_or_equal,			// left &lt;= right</a>
<a name="ln9185">		ast_op_greater_or_equal,		// left &gt;= right</a>
<a name="ln9186">		ast_op_add,						// left + right</a>
<a name="ln9187">		ast_op_subtract,				// left - right</a>
<a name="ln9188">		ast_op_multiply,				// left * right</a>
<a name="ln9189">		ast_op_divide,					// left / right</a>
<a name="ln9190">		ast_op_mod,						// left % right</a>
<a name="ln9191">		ast_op_negate,					// left - right</a>
<a name="ln9192">		ast_op_union,					// left | right</a>
<a name="ln9193">		ast_predicate,					// apply predicate to set; next points to next predicate</a>
<a name="ln9194">		ast_filter,						// select * from left where right</a>
<a name="ln9195">		ast_string_constant,			// string constant</a>
<a name="ln9196">		ast_number_constant,			// number constant</a>
<a name="ln9197">		ast_variable,					// variable</a>
<a name="ln9198">		ast_func_last,					// last()</a>
<a name="ln9199">		ast_func_position,				// position()</a>
<a name="ln9200">		ast_func_count,					// count(left)</a>
<a name="ln9201">		ast_func_id,					// id(left)</a>
<a name="ln9202">		ast_func_local_name_0,			// local-name()</a>
<a name="ln9203">		ast_func_local_name_1,			// local-name(left)</a>
<a name="ln9204">		ast_func_namespace_uri_0,		// namespace-uri()</a>
<a name="ln9205">		ast_func_namespace_uri_1,		// namespace-uri(left)</a>
<a name="ln9206">		ast_func_name_0,				// name()</a>
<a name="ln9207">		ast_func_name_1,				// name(left)</a>
<a name="ln9208">		ast_func_string_0,				// string()</a>
<a name="ln9209">		ast_func_string_1,				// string(left)</a>
<a name="ln9210">		ast_func_concat,				// concat(left, right, siblings)</a>
<a name="ln9211">		ast_func_starts_with,			// starts_with(left, right)</a>
<a name="ln9212">		ast_func_contains,				// contains(left, right)</a>
<a name="ln9213">		ast_func_substring_before,		// substring-before(left, right)</a>
<a name="ln9214">		ast_func_substring_after,		// substring-after(left, right)</a>
<a name="ln9215">		ast_func_substring_2,			// substring(left, right)</a>
<a name="ln9216">		ast_func_substring_3,			// substring(left, right, third)</a>
<a name="ln9217">		ast_func_string_length_0,		// string-length()</a>
<a name="ln9218">		ast_func_string_length_1,		// string-length(left)</a>
<a name="ln9219">		ast_func_normalize_space_0,		// normalize-space()</a>
<a name="ln9220">		ast_func_normalize_space_1,		// normalize-space(left)</a>
<a name="ln9221">		ast_func_translate,				// translate(left, right, third)</a>
<a name="ln9222">		ast_func_boolean,				// boolean(left)</a>
<a name="ln9223">		ast_func_not,					// not(left)</a>
<a name="ln9224">		ast_func_true,					// true()</a>
<a name="ln9225">		ast_func_false,					// false()</a>
<a name="ln9226">		ast_func_lang,					// lang(left)</a>
<a name="ln9227">		ast_func_number_0,				// number()</a>
<a name="ln9228">		ast_func_number_1,				// number(left)</a>
<a name="ln9229">		ast_func_sum,					// sum(left)</a>
<a name="ln9230">		ast_func_floor,					// floor(left)</a>
<a name="ln9231">		ast_func_ceiling,				// ceiling(left)</a>
<a name="ln9232">		ast_func_round,					// round(left)</a>
<a name="ln9233">		ast_step,						// process set left with step</a>
<a name="ln9234">		ast_step_root,					// select root node</a>
<a name="ln9235"> </a>
<a name="ln9236">		ast_opt_translate_table,		// translate(left, right, third) where right/third are constants</a>
<a name="ln9237">		ast_opt_compare_attribute		// @name = 'string'</a>
<a name="ln9238">	};</a>
<a name="ln9239"> </a>
<a name="ln9240">	enum axis_t</a>
<a name="ln9241">	{</a>
<a name="ln9242">		axis_ancestor,</a>
<a name="ln9243">		axis_ancestor_or_self,</a>
<a name="ln9244">		axis_attribute,</a>
<a name="ln9245">		axis_child,</a>
<a name="ln9246">		axis_descendant,</a>
<a name="ln9247">		axis_descendant_or_self,</a>
<a name="ln9248">		axis_following,</a>
<a name="ln9249">		axis_following_sibling,</a>
<a name="ln9250">		axis_namespace,</a>
<a name="ln9251">		axis_parent,</a>
<a name="ln9252">		axis_preceding,</a>
<a name="ln9253">		axis_preceding_sibling,</a>
<a name="ln9254">		axis_self</a>
<a name="ln9255">	};</a>
<a name="ln9256"> </a>
<a name="ln9257">	enum nodetest_t</a>
<a name="ln9258">	{</a>
<a name="ln9259">		nodetest_none,</a>
<a name="ln9260">		nodetest_name,</a>
<a name="ln9261">		nodetest_type_node,</a>
<a name="ln9262">		nodetest_type_comment,</a>
<a name="ln9263">		nodetest_type_pi,</a>
<a name="ln9264">		nodetest_type_text,</a>
<a name="ln9265">		nodetest_pi,</a>
<a name="ln9266">		nodetest_all,</a>
<a name="ln9267">		nodetest_all_in_namespace</a>
<a name="ln9268">	};</a>
<a name="ln9269"> </a>
<a name="ln9270">	enum predicate_t</a>
<a name="ln9271">	{</a>
<a name="ln9272">		predicate_default,</a>
<a name="ln9273">		predicate_posinv,</a>
<a name="ln9274">		predicate_constant,</a>
<a name="ln9275">		predicate_constant_one</a>
<a name="ln9276">	};</a>
<a name="ln9277"> </a>
<a name="ln9278">	enum nodeset_eval_t</a>
<a name="ln9279">	{</a>
<a name="ln9280">		nodeset_eval_all,</a>
<a name="ln9281">		nodeset_eval_any,</a>
<a name="ln9282">		nodeset_eval_first</a>
<a name="ln9283">	};</a>
<a name="ln9284"> </a>
<a name="ln9285">	template &lt;axis_t N&gt; struct axis_to_type</a>
<a name="ln9286">	{</a>
<a name="ln9287">		static const axis_t axis;</a>
<a name="ln9288">	};</a>
<a name="ln9289"> </a>
<a name="ln9290">	template &lt;axis_t N&gt; const axis_t axis_to_type&lt;N&gt;::axis = N;</a>
<a name="ln9291"> </a>
<a name="ln9292">	class xpath_ast_node</a>
<a name="ln9293">	{</a>
<a name="ln9294">	private:</a>
<a name="ln9295">		// node type</a>
<a name="ln9296">		char _type;</a>
<a name="ln9297">		char _rettype;</a>
<a name="ln9298"> </a>
<a name="ln9299">		// for ast_step</a>
<a name="ln9300">		char _axis;</a>
<a name="ln9301"> </a>
<a name="ln9302">		// for ast_step/ast_predicate/ast_filter</a>
<a name="ln9303">		char _test;</a>
<a name="ln9304"> </a>
<a name="ln9305">		// tree node structure</a>
<a name="ln9306">		xpath_ast_node* _left;</a>
<a name="ln9307">		xpath_ast_node* _right;</a>
<a name="ln9308">		xpath_ast_node* _next;</a>
<a name="ln9309"> </a>
<a name="ln9310">		union</a>
<a name="ln9311">		{</a>
<a name="ln9312">			// value for ast_string_constant</a>
<a name="ln9313">			const char_t* string;</a>
<a name="ln9314">			// value for ast_number_constant</a>
<a name="ln9315">			double number;</a>
<a name="ln9316">			// variable for ast_variable</a>
<a name="ln9317">			xpath_variable* variable;</a>
<a name="ln9318">			// node test for ast_step (node name/namespace/node type/pi target)</a>
<a name="ln9319">			const char_t* nodetest;</a>
<a name="ln9320">			// table for ast_opt_translate_table</a>
<a name="ln9321">			const unsigned char* table;</a>
<a name="ln9322">		} _data;</a>
<a name="ln9323"> </a>
<a name="ln9324">		xpath_ast_node(const xpath_ast_node&amp;);</a>
<a name="ln9325">		xpath_ast_node&amp; operator=(const xpath_ast_node&amp;);</a>
<a name="ln9326"> </a>
<a name="ln9327">		template &lt;class Comp&gt; static bool compare_eq(xpath_ast_node* lhs, xpath_ast_node* rhs, const xpath_context&amp; c, const xpath_stack&amp; stack, const Comp&amp; comp)</a>
<a name="ln9328">		{</a>
<a name="ln9329">			xpath_value_type lt = lhs-&gt;rettype(), rt = rhs-&gt;rettype();</a>
<a name="ln9330"> </a>
<a name="ln9331">			if (lt != xpath_type_node_set &amp;&amp; rt != xpath_type_node_set)</a>
<a name="ln9332">			{</a>
<a name="ln9333">				if (lt == xpath_type_boolean || rt == xpath_type_boolean)</a>
<a name="ln9334">					return comp(lhs-&gt;eval_boolean(c, stack), rhs-&gt;eval_boolean(c, stack));</a>
<a name="ln9335">				else if (lt == xpath_type_number || rt == xpath_type_number)</a>
<a name="ln9336">					return comp(lhs-&gt;eval_number(c, stack), rhs-&gt;eval_number(c, stack));</a>
<a name="ln9337">				else if (lt == xpath_type_string || rt == xpath_type_string)</a>
<a name="ln9338">				{</a>
<a name="ln9339">					xpath_allocator_capture cr(stack.result);</a>
<a name="ln9340"> </a>
<a name="ln9341">					xpath_string ls = lhs-&gt;eval_string(c, stack);</a>
<a name="ln9342">					xpath_string rs = rhs-&gt;eval_string(c, stack);</a>
<a name="ln9343"> </a>
<a name="ln9344">					return comp(ls, rs);</a>
<a name="ln9345">				}</a>
<a name="ln9346">			}</a>
<a name="ln9347">			else if (lt == xpath_type_node_set &amp;&amp; rt == xpath_type_node_set)</a>
<a name="ln9348">			{</a>
<a name="ln9349">				xpath_allocator_capture cr(stack.result);</a>
<a name="ln9350"> </a>
<a name="ln9351">				xpath_node_set_raw ls = lhs-&gt;eval_node_set(c, stack, nodeset_eval_all);</a>
<a name="ln9352">				xpath_node_set_raw rs = rhs-&gt;eval_node_set(c, stack, nodeset_eval_all);</a>
<a name="ln9353"> </a>
<a name="ln9354">				for (const xpath_node* li = ls.begin(); li != ls.end(); ++li)</a>
<a name="ln9355">					for (const xpath_node* ri = rs.begin(); ri != rs.end(); ++ri)</a>
<a name="ln9356">					{</a>
<a name="ln9357">						xpath_allocator_capture cri(stack.result);</a>
<a name="ln9358"> </a>
<a name="ln9359">						if (comp(string_value(*li, stack.result), string_value(*ri, stack.result)))</a>
<a name="ln9360">							return true;</a>
<a name="ln9361">					}</a>
<a name="ln9362"> </a>
<a name="ln9363">				return false;</a>
<a name="ln9364">			}</a>
<a name="ln9365">			else</a>
<a name="ln9366">			{</a>
<a name="ln9367">				if (lt == xpath_type_node_set)</a>
<a name="ln9368">				{</a>
<a name="ln9369">					swap(lhs, rhs);</a>
<a name="ln9370">					swap(lt, rt);</a>
<a name="ln9371">				}</a>
<a name="ln9372"> </a>
<a name="ln9373">				if (lt == xpath_type_boolean)</a>
<a name="ln9374">					return comp(lhs-&gt;eval_boolean(c, stack), rhs-&gt;eval_boolean(c, stack));</a>
<a name="ln9375">				else if (lt == xpath_type_number)</a>
<a name="ln9376">				{</a>
<a name="ln9377">					xpath_allocator_capture cr(stack.result);</a>
<a name="ln9378"> </a>
<a name="ln9379">					double l = lhs-&gt;eval_number(c, stack);</a>
<a name="ln9380">					xpath_node_set_raw rs = rhs-&gt;eval_node_set(c, stack, nodeset_eval_all);</a>
<a name="ln9381"> </a>
<a name="ln9382">					for (const xpath_node* ri = rs.begin(); ri != rs.end(); ++ri)</a>
<a name="ln9383">					{</a>
<a name="ln9384">						xpath_allocator_capture cri(stack.result);</a>
<a name="ln9385"> </a>
<a name="ln9386">						if (comp(l, convert_string_to_number(string_value(*ri, stack.result).c_str())))</a>
<a name="ln9387">							return true;</a>
<a name="ln9388">					}</a>
<a name="ln9389"> </a>
<a name="ln9390">					return false;</a>
<a name="ln9391">				}</a>
<a name="ln9392">				else if (lt == xpath_type_string)</a>
<a name="ln9393">				{</a>
<a name="ln9394">					xpath_allocator_capture cr(stack.result);</a>
<a name="ln9395"> </a>
<a name="ln9396">					xpath_string l = lhs-&gt;eval_string(c, stack);</a>
<a name="ln9397">					xpath_node_set_raw rs = rhs-&gt;eval_node_set(c, stack, nodeset_eval_all);</a>
<a name="ln9398"> </a>
<a name="ln9399">					for (const xpath_node* ri = rs.begin(); ri != rs.end(); ++ri)</a>
<a name="ln9400">					{</a>
<a name="ln9401">						xpath_allocator_capture cri(stack.result);</a>
<a name="ln9402"> </a>
<a name="ln9403">						if (comp(l, string_value(*ri, stack.result)))</a>
<a name="ln9404">							return true;</a>
<a name="ln9405">					}</a>
<a name="ln9406"> </a>
<a name="ln9407">					return false;</a>
<a name="ln9408">				}</a>
<a name="ln9409">			}</a>
<a name="ln9410"> </a>
<a name="ln9411">			assert(false &amp;&amp; &quot;Wrong types&quot;);</a>
<a name="ln9412">			return false;</a>
<a name="ln9413">		}</a>
<a name="ln9414"> </a>
<a name="ln9415">		static bool eval_once(xpath_node_set::type_t type, nodeset_eval_t eval)</a>
<a name="ln9416">		{</a>
<a name="ln9417">			return type == xpath_node_set::type_sorted ? eval != nodeset_eval_all : eval == nodeset_eval_any;</a>
<a name="ln9418">		}</a>
<a name="ln9419"> </a>
<a name="ln9420">		template &lt;class Comp&gt; static bool compare_rel(xpath_ast_node* lhs, xpath_ast_node* rhs, const xpath_context&amp; c, const xpath_stack&amp; stack, const Comp&amp; comp)</a>
<a name="ln9421">		{</a>
<a name="ln9422">			xpath_value_type lt = lhs-&gt;rettype(), rt = rhs-&gt;rettype();</a>
<a name="ln9423"> </a>
<a name="ln9424">			if (lt != xpath_type_node_set &amp;&amp; rt != xpath_type_node_set)</a>
<a name="ln9425">				return comp(lhs-&gt;eval_number(c, stack), rhs-&gt;eval_number(c, stack));</a>
<a name="ln9426">			else if (lt == xpath_type_node_set &amp;&amp; rt == xpath_type_node_set)</a>
<a name="ln9427">			{</a>
<a name="ln9428">				xpath_allocator_capture cr(stack.result);</a>
<a name="ln9429"> </a>
<a name="ln9430">				xpath_node_set_raw ls = lhs-&gt;eval_node_set(c, stack, nodeset_eval_all);</a>
<a name="ln9431">				xpath_node_set_raw rs = rhs-&gt;eval_node_set(c, stack, nodeset_eval_all);</a>
<a name="ln9432"> </a>
<a name="ln9433">				for (const xpath_node* li = ls.begin(); li != ls.end(); ++li)</a>
<a name="ln9434">				{</a>
<a name="ln9435">					xpath_allocator_capture cri(stack.result);</a>
<a name="ln9436"> </a>
<a name="ln9437">					double l = convert_string_to_number(string_value(*li, stack.result).c_str());</a>
<a name="ln9438"> </a>
<a name="ln9439">					for (const xpath_node* ri = rs.begin(); ri != rs.end(); ++ri)</a>
<a name="ln9440">					{</a>
<a name="ln9441">						xpath_allocator_capture crii(stack.result);</a>
<a name="ln9442"> </a>
<a name="ln9443">						if (comp(l, convert_string_to_number(string_value(*ri, stack.result).c_str())))</a>
<a name="ln9444">							return true;</a>
<a name="ln9445">					}</a>
<a name="ln9446">				}</a>
<a name="ln9447"> </a>
<a name="ln9448">				return false;</a>
<a name="ln9449">			}</a>
<a name="ln9450">			else if (lt != xpath_type_node_set &amp;&amp; rt == xpath_type_node_set)</a>
<a name="ln9451">			{</a>
<a name="ln9452">				xpath_allocator_capture cr(stack.result);</a>
<a name="ln9453"> </a>
<a name="ln9454">				double l = lhs-&gt;eval_number(c, stack);</a>
<a name="ln9455">				xpath_node_set_raw rs = rhs-&gt;eval_node_set(c, stack, nodeset_eval_all);</a>
<a name="ln9456"> </a>
<a name="ln9457">				for (const xpath_node* ri = rs.begin(); ri != rs.end(); ++ri)</a>
<a name="ln9458">				{</a>
<a name="ln9459">					xpath_allocator_capture cri(stack.result);</a>
<a name="ln9460"> </a>
<a name="ln9461">					if (comp(l, convert_string_to_number(string_value(*ri, stack.result).c_str())))</a>
<a name="ln9462">						return true;</a>
<a name="ln9463">				}</a>
<a name="ln9464"> </a>
<a name="ln9465">				return false;</a>
<a name="ln9466">			}</a>
<a name="ln9467">			else if (lt == xpath_type_node_set &amp;&amp; rt != xpath_type_node_set)</a>
<a name="ln9468">			{</a>
<a name="ln9469">				xpath_allocator_capture cr(stack.result);</a>
<a name="ln9470"> </a>
<a name="ln9471">				xpath_node_set_raw ls = lhs-&gt;eval_node_set(c, stack, nodeset_eval_all);</a>
<a name="ln9472">				double r = rhs-&gt;eval_number(c, stack);</a>
<a name="ln9473"> </a>
<a name="ln9474">				for (const xpath_node* li = ls.begin(); li != ls.end(); ++li)</a>
<a name="ln9475">				{</a>
<a name="ln9476">					xpath_allocator_capture cri(stack.result);</a>
<a name="ln9477"> </a>
<a name="ln9478">					if (comp(convert_string_to_number(string_value(*li, stack.result).c_str()), r))</a>
<a name="ln9479">						return true;</a>
<a name="ln9480">				}</a>
<a name="ln9481"> </a>
<a name="ln9482">				return false;</a>
<a name="ln9483">			}</a>
<a name="ln9484">			else</a>
<a name="ln9485">			{</a>
<a name="ln9486">				assert(false &amp;&amp; &quot;Wrong types&quot;);</a>
<a name="ln9487">				return false;</a>
<a name="ln9488">			}</a>
<a name="ln9489">		}</a>
<a name="ln9490"> </a>
<a name="ln9491">		static void apply_predicate_boolean(xpath_node_set_raw&amp; ns, size_t first, xpath_ast_node* expr, const xpath_stack&amp; stack, bool once)</a>
<a name="ln9492">		{</a>
<a name="ln9493">			assert(ns.size() &gt;= first);</a>
<a name="ln9494">			assert(expr-&gt;rettype() != xpath_type_number);</a>
<a name="ln9495"> </a>
<a name="ln9496">			size_t i = 1;</a>
<a name="ln9497">			size_t size = ns.size() - first;</a>
<a name="ln9498"> </a>
<a name="ln9499">			xpath_node* last = ns.begin() + first;</a>
<a name="ln9500"> </a>
<a name="ln9501">			// remove_if... or well, sort of</a>
<a name="ln9502">			for (xpath_node* it = last; it != ns.end(); ++it, ++i)</a>
<a name="ln9503">			{</a>
<a name="ln9504">				xpath_context c(*it, i, size);</a>
<a name="ln9505"> </a>
<a name="ln9506">				if (expr-&gt;eval_boolean(c, stack))</a>
<a name="ln9507">				{</a>
<a name="ln9508">					*last++ = *it;</a>
<a name="ln9509"> </a>
<a name="ln9510">					if (once) break;</a>
<a name="ln9511">				}</a>
<a name="ln9512">			}</a>
<a name="ln9513"> </a>
<a name="ln9514">			ns.truncate(last);</a>
<a name="ln9515">		}</a>
<a name="ln9516"> </a>
<a name="ln9517">		static void apply_predicate_number(xpath_node_set_raw&amp; ns, size_t first, xpath_ast_node* expr, const xpath_stack&amp; stack, bool once)</a>
<a name="ln9518">		{</a>
<a name="ln9519">			assert(ns.size() &gt;= first);</a>
<a name="ln9520">			assert(expr-&gt;rettype() == xpath_type_number);</a>
<a name="ln9521"> </a>
<a name="ln9522">			size_t i = 1;</a>
<a name="ln9523">			size_t size = ns.size() - first;</a>
<a name="ln9524"> </a>
<a name="ln9525">			xpath_node* last = ns.begin() + first;</a>
<a name="ln9526"> </a>
<a name="ln9527">			// remove_if... or well, sort of</a>
<a name="ln9528">			for (xpath_node* it = last; it != ns.end(); ++it, ++i)</a>
<a name="ln9529">			{</a>
<a name="ln9530">				xpath_context c(*it, i, size);</a>
<a name="ln9531"> </a>
<a name="ln9532">				if (expr-&gt;eval_number(c, stack) == i)</a>
<a name="ln9533">				{</a>
<a name="ln9534">					*last++ = *it;</a>
<a name="ln9535"> </a>
<a name="ln9536">					if (once) break;</a>
<a name="ln9537">				}</a>
<a name="ln9538">			}</a>
<a name="ln9539"> </a>
<a name="ln9540">			ns.truncate(last);</a>
<a name="ln9541">		}</a>
<a name="ln9542"> </a>
<a name="ln9543">		static void apply_predicate_number_const(xpath_node_set_raw&amp; ns, size_t first, xpath_ast_node* expr, const xpath_stack&amp; stack)</a>
<a name="ln9544">		{</a>
<a name="ln9545">			assert(ns.size() &gt;= first);</a>
<a name="ln9546">			assert(expr-&gt;rettype() == xpath_type_number);</a>
<a name="ln9547"> </a>
<a name="ln9548">			size_t size = ns.size() - first;</a>
<a name="ln9549"> </a>
<a name="ln9550">			xpath_node* last = ns.begin() + first;</a>
<a name="ln9551"> </a>
<a name="ln9552">			xpath_context c(xpath_node(), 1, size);</a>
<a name="ln9553"> </a>
<a name="ln9554">			double er = expr-&gt;eval_number(c, stack);</a>
<a name="ln9555"> </a>
<a name="ln9556">			if (er &gt;= 1.0 &amp;&amp; er &lt;= size)</a>
<a name="ln9557">			{</a>
<a name="ln9558">				size_t eri = static_cast&lt;size_t&gt;(er);</a>
<a name="ln9559"> </a>
<a name="ln9560">				if (er == eri)</a>
<a name="ln9561">				{</a>
<a name="ln9562">					xpath_node r = last[eri - 1];</a>
<a name="ln9563"> </a>
<a name="ln9564">					*last++ = r;</a>
<a name="ln9565">				}</a>
<a name="ln9566">			}</a>
<a name="ln9567"> </a>
<a name="ln9568">			ns.truncate(last);</a>
<a name="ln9569">		}</a>
<a name="ln9570"> </a>
<a name="ln9571">		void apply_predicate(xpath_node_set_raw&amp; ns, size_t first, const xpath_stack&amp; stack, bool once)</a>
<a name="ln9572">		{</a>
<a name="ln9573">			if (ns.size() == first) return;</a>
<a name="ln9574"> </a>
<a name="ln9575">			assert(_type == ast_filter || _type == ast_predicate);</a>
<a name="ln9576"> </a>
<a name="ln9577">			if (_test == predicate_constant || _test == predicate_constant_one)</a>
<a name="ln9578">				apply_predicate_number_const(ns, first, _right, stack);</a>
<a name="ln9579">			else if (_right-&gt;rettype() == xpath_type_number)</a>
<a name="ln9580">				apply_predicate_number(ns, first, _right, stack, once);</a>
<a name="ln9581">			else</a>
<a name="ln9582">				apply_predicate_boolean(ns, first, _right, stack, once);</a>
<a name="ln9583">		}</a>
<a name="ln9584"> </a>
<a name="ln9585">		void apply_predicates(xpath_node_set_raw&amp; ns, size_t first, const xpath_stack&amp; stack, nodeset_eval_t eval)</a>
<a name="ln9586">		{</a>
<a name="ln9587">			if (ns.size() == first) return;</a>
<a name="ln9588"> </a>
<a name="ln9589">			bool last_once = eval_once(ns.type(), eval);</a>
<a name="ln9590"> </a>
<a name="ln9591">			for (xpath_ast_node* pred = _right; pred; pred = pred-&gt;_next)</a>
<a name="ln9592">				pred-&gt;apply_predicate(ns, first, stack, !pred-&gt;_next &amp;&amp; last_once);</a>
<a name="ln9593">		}</a>
<a name="ln9594"> </a>
<a name="ln9595">		bool step_push(xpath_node_set_raw&amp; ns, xml_attribute_struct* a, xml_node_struct* parent, xpath_allocator* alloc)</a>
<a name="ln9596">		{</a>
<a name="ln9597">			assert(a);</a>
<a name="ln9598"> </a>
<a name="ln9599">			const char_t* name = a-&gt;name ? a-&gt;name + 0 : PUGIXML_TEXT(&quot;&quot;);</a>
<a name="ln9600"> </a>
<a name="ln9601">			switch (_test)</a>
<a name="ln9602">			{</a>
<a name="ln9603">			case nodetest_name:</a>
<a name="ln9604">				if (strequal(name, _data.nodetest) &amp;&amp; is_xpath_attribute(name))</a>
<a name="ln9605">				{</a>
<a name="ln9606">					ns.push_back(xpath_node(xml_attribute(a), xml_node(parent)), alloc);</a>
<a name="ln9607">					return true;</a>
<a name="ln9608">				}</a>
<a name="ln9609">				break;</a>
<a name="ln9610"> </a>
<a name="ln9611">			case nodetest_type_node:</a>
<a name="ln9612">			case nodetest_all:</a>
<a name="ln9613">				if (is_xpath_attribute(name))</a>
<a name="ln9614">				{</a>
<a name="ln9615">					ns.push_back(xpath_node(xml_attribute(a), xml_node(parent)), alloc);</a>
<a name="ln9616">					return true;</a>
<a name="ln9617">				}</a>
<a name="ln9618">				break;</a>
<a name="ln9619"> </a>
<a name="ln9620">			case nodetest_all_in_namespace:</a>
<a name="ln9621">				if (starts_with(name, _data.nodetest) &amp;&amp; is_xpath_attribute(name))</a>
<a name="ln9622">				{</a>
<a name="ln9623">					ns.push_back(xpath_node(xml_attribute(a), xml_node(parent)), alloc);</a>
<a name="ln9624">					return true;</a>
<a name="ln9625">				}</a>
<a name="ln9626">				break;</a>
<a name="ln9627"> </a>
<a name="ln9628">			default:</a>
<a name="ln9629">				;</a>
<a name="ln9630">			}</a>
<a name="ln9631"> </a>
<a name="ln9632">			return false;</a>
<a name="ln9633">		}</a>
<a name="ln9634"> </a>
<a name="ln9635">		bool step_push(xpath_node_set_raw&amp; ns, xml_node_struct* n, xpath_allocator* alloc)</a>
<a name="ln9636">		{</a>
<a name="ln9637">			assert(n);</a>
<a name="ln9638"> </a>
<a name="ln9639">			xml_node_type type = PUGI__NODETYPE(n);</a>
<a name="ln9640"> </a>
<a name="ln9641">			switch (_test)</a>
<a name="ln9642">			{</a>
<a name="ln9643">			case nodetest_name:</a>
<a name="ln9644">				if (type == node_element &amp;&amp; n-&gt;name &amp;&amp; strequal(n-&gt;name, _data.nodetest))</a>
<a name="ln9645">				{</a>
<a name="ln9646">					ns.push_back(xml_node(n), alloc);</a>
<a name="ln9647">					return true;</a>
<a name="ln9648">				}</a>
<a name="ln9649">				break;</a>
<a name="ln9650"> </a>
<a name="ln9651">			case nodetest_type_node:</a>
<a name="ln9652">				ns.push_back(xml_node(n), alloc);</a>
<a name="ln9653">				return true;</a>
<a name="ln9654"> </a>
<a name="ln9655">			case nodetest_type_comment:</a>
<a name="ln9656">				if (type == node_comment)</a>
<a name="ln9657">				{</a>
<a name="ln9658">					ns.push_back(xml_node(n), alloc);</a>
<a name="ln9659">					return true;</a>
<a name="ln9660">				}</a>
<a name="ln9661">				break;</a>
<a name="ln9662"> </a>
<a name="ln9663">			case nodetest_type_text:</a>
<a name="ln9664">				if (type == node_pcdata || type == node_cdata)</a>
<a name="ln9665">				{</a>
<a name="ln9666">					ns.push_back(xml_node(n), alloc);</a>
<a name="ln9667">					return true;</a>
<a name="ln9668">				}</a>
<a name="ln9669">				break;</a>
<a name="ln9670"> </a>
<a name="ln9671">			case nodetest_type_pi:</a>
<a name="ln9672">				if (type == node_pi)</a>
<a name="ln9673">				{</a>
<a name="ln9674">					ns.push_back(xml_node(n), alloc);</a>
<a name="ln9675">					return true;</a>
<a name="ln9676">				}</a>
<a name="ln9677">				break;</a>
<a name="ln9678"> </a>
<a name="ln9679">			case nodetest_pi:</a>
<a name="ln9680">				if (type == node_pi &amp;&amp; n-&gt;name &amp;&amp; strequal(n-&gt;name, _data.nodetest))</a>
<a name="ln9681">				{</a>
<a name="ln9682">					ns.push_back(xml_node(n), alloc);</a>
<a name="ln9683">					return true;</a>
<a name="ln9684">				}</a>
<a name="ln9685">				break;</a>
<a name="ln9686"> </a>
<a name="ln9687">			case nodetest_all:</a>
<a name="ln9688">				if (type == node_element)</a>
<a name="ln9689">				{</a>
<a name="ln9690">					ns.push_back(xml_node(n), alloc);</a>
<a name="ln9691">					return true;</a>
<a name="ln9692">				}</a>
<a name="ln9693">				break;</a>
<a name="ln9694"> </a>
<a name="ln9695">			case nodetest_all_in_namespace:</a>
<a name="ln9696">				if (type == node_element &amp;&amp; n-&gt;name &amp;&amp; starts_with(n-&gt;name, _data.nodetest))</a>
<a name="ln9697">				{</a>
<a name="ln9698">					ns.push_back(xml_node(n), alloc);</a>
<a name="ln9699">					return true;</a>
<a name="ln9700">				}</a>
<a name="ln9701">				break;</a>
<a name="ln9702"> </a>
<a name="ln9703">			default:</a>
<a name="ln9704">				assert(false &amp;&amp; &quot;Unknown axis&quot;);</a>
<a name="ln9705">			}</a>
<a name="ln9706"> </a>
<a name="ln9707">			return false;</a>
<a name="ln9708">		}</a>
<a name="ln9709"> </a>
<a name="ln9710">		template &lt;class T&gt; void step_fill(xpath_node_set_raw&amp; ns, xml_node_struct* n, xpath_allocator* alloc, bool once, T)</a>
<a name="ln9711">		{</a>
<a name="ln9712">			const axis_t axis = T::axis;</a>
<a name="ln9713"> </a>
<a name="ln9714">			switch (axis)</a>
<a name="ln9715">			{</a>
<a name="ln9716">			case axis_attribute:</a>
<a name="ln9717">			{</a>
<a name="ln9718">				for (xml_attribute_struct* a = n-&gt;first_attribute; a; a = a-&gt;next_attribute)</a>
<a name="ln9719">					if (step_push(ns, a, n, alloc) &amp; once)</a>
<a name="ln9720">						return;</a>
<a name="ln9721"> </a>
<a name="ln9722">				break;</a>
<a name="ln9723">			}</a>
<a name="ln9724"> </a>
<a name="ln9725">			case axis_child:</a>
<a name="ln9726">			{</a>
<a name="ln9727">				for (xml_node_struct* c = n-&gt;first_child; c; c = c-&gt;next_sibling)</a>
<a name="ln9728">					if (step_push(ns, c, alloc) &amp; once)</a>
<a name="ln9729">						return;</a>
<a name="ln9730"> </a>
<a name="ln9731">				break;</a>
<a name="ln9732">			}</a>
<a name="ln9733"> </a>
<a name="ln9734">			case axis_descendant:</a>
<a name="ln9735">			case axis_descendant_or_self:</a>
<a name="ln9736">			{</a>
<a name="ln9737">				if (axis == axis_descendant_or_self)</a>
<a name="ln9738">					if (step_push(ns, n, alloc) &amp; once)</a>
<a name="ln9739">						return;</a>
<a name="ln9740"> </a>
<a name="ln9741">				xml_node_struct* cur = n-&gt;first_child;</a>
<a name="ln9742"> </a>
<a name="ln9743">				while (cur)</a>
<a name="ln9744">				{</a>
<a name="ln9745">					if (step_push(ns, cur, alloc) &amp; once)</a>
<a name="ln9746">						return;</a>
<a name="ln9747"> </a>
<a name="ln9748">					if (cur-&gt;first_child)</a>
<a name="ln9749">						cur = cur-&gt;first_child;</a>
<a name="ln9750">					else</a>
<a name="ln9751">					{</a>
<a name="ln9752">						while (!cur-&gt;next_sibling)</a>
<a name="ln9753">						{</a>
<a name="ln9754">							cur = cur-&gt;parent;</a>
<a name="ln9755"> </a>
<a name="ln9756">							if (cur == n) return;</a>
<a name="ln9757">						}</a>
<a name="ln9758"> </a>
<a name="ln9759">						cur = cur-&gt;next_sibling;</a>
<a name="ln9760">					}</a>
<a name="ln9761">				}</a>
<a name="ln9762"> </a>
<a name="ln9763">				break;</a>
<a name="ln9764">			}</a>
<a name="ln9765"> </a>
<a name="ln9766">			case axis_following_sibling:</a>
<a name="ln9767">			{</a>
<a name="ln9768">				for (xml_node_struct* c = n-&gt;next_sibling; c; c = c-&gt;next_sibling)</a>
<a name="ln9769">					if (step_push(ns, c, alloc) &amp; once)</a>
<a name="ln9770">						return;</a>
<a name="ln9771"> </a>
<a name="ln9772">				break;</a>
<a name="ln9773">			}</a>
<a name="ln9774"> </a>
<a name="ln9775">			case axis_preceding_sibling:</a>
<a name="ln9776">			{</a>
<a name="ln9777">				for (xml_node_struct* c = n-&gt;prev_sibling_c; c-&gt;next_sibling; c = c-&gt;prev_sibling_c)</a>
<a name="ln9778">					if (step_push(ns, c, alloc) &amp; once)</a>
<a name="ln9779">						return;</a>
<a name="ln9780"> </a>
<a name="ln9781">				break;</a>
<a name="ln9782">			}</a>
<a name="ln9783"> </a>
<a name="ln9784">			case axis_following:</a>
<a name="ln9785">			{</a>
<a name="ln9786">				xml_node_struct* cur = n;</a>
<a name="ln9787"> </a>
<a name="ln9788">				// exit from this node so that we don't include descendants</a>
<a name="ln9789">				while (!cur-&gt;next_sibling)</a>
<a name="ln9790">				{</a>
<a name="ln9791">					cur = cur-&gt;parent;</a>
<a name="ln9792"> </a>
<a name="ln9793">					if (!cur) return;</a>
<a name="ln9794">				}</a>
<a name="ln9795"> </a>
<a name="ln9796">				cur = cur-&gt;next_sibling;</a>
<a name="ln9797"> </a>
<a name="ln9798">				while (cur)</a>
<a name="ln9799">				{</a>
<a name="ln9800">					if (step_push(ns, cur, alloc) &amp; once)</a>
<a name="ln9801">						return;</a>
<a name="ln9802"> </a>
<a name="ln9803">					if (cur-&gt;first_child)</a>
<a name="ln9804">						cur = cur-&gt;first_child;</a>
<a name="ln9805">					else</a>
<a name="ln9806">					{</a>
<a name="ln9807">						while (!cur-&gt;next_sibling)</a>
<a name="ln9808">						{</a>
<a name="ln9809">							cur = cur-&gt;parent;</a>
<a name="ln9810"> </a>
<a name="ln9811">							if (!cur) return;</a>
<a name="ln9812">						}</a>
<a name="ln9813"> </a>
<a name="ln9814">						cur = cur-&gt;next_sibling;</a>
<a name="ln9815">					}</a>
<a name="ln9816">				}</a>
<a name="ln9817"> </a>
<a name="ln9818">				break;</a>
<a name="ln9819">			}</a>
<a name="ln9820"> </a>
<a name="ln9821">			case axis_preceding:</a>
<a name="ln9822">			{</a>
<a name="ln9823">				xml_node_struct* cur = n;</a>
<a name="ln9824"> </a>
<a name="ln9825">				// exit from this node so that we don't include descendants</a>
<a name="ln9826">				while (!cur-&gt;prev_sibling_c-&gt;next_sibling)</a>
<a name="ln9827">				{</a>
<a name="ln9828">					cur = cur-&gt;parent;</a>
<a name="ln9829"> </a>
<a name="ln9830">					if (!cur) return;</a>
<a name="ln9831">				}</a>
<a name="ln9832"> </a>
<a name="ln9833">				cur = cur-&gt;prev_sibling_c;</a>
<a name="ln9834"> </a>
<a name="ln9835">				while (cur)</a>
<a name="ln9836">				{</a>
<a name="ln9837">					if (cur-&gt;first_child)</a>
<a name="ln9838">						cur = cur-&gt;first_child-&gt;prev_sibling_c;</a>
<a name="ln9839">					else</a>
<a name="ln9840">					{</a>
<a name="ln9841">						// leaf node, can't be ancestor</a>
<a name="ln9842">						if (step_push(ns, cur, alloc) &amp; once)</a>
<a name="ln9843">							return;</a>
<a name="ln9844"> </a>
<a name="ln9845">						while (!cur-&gt;prev_sibling_c-&gt;next_sibling)</a>
<a name="ln9846">						{</a>
<a name="ln9847">							cur = cur-&gt;parent;</a>
<a name="ln9848"> </a>
<a name="ln9849">							if (!cur) return;</a>
<a name="ln9850"> </a>
<a name="ln9851">							if (!node_is_ancestor(cur, n))</a>
<a name="ln9852">								if (step_push(ns, cur, alloc) &amp; once)</a>
<a name="ln9853">									return;</a>
<a name="ln9854">						}</a>
<a name="ln9855"> </a>
<a name="ln9856">						cur = cur-&gt;prev_sibling_c;</a>
<a name="ln9857">					}</a>
<a name="ln9858">				}</a>
<a name="ln9859"> </a>
<a name="ln9860">				break;</a>
<a name="ln9861">			}</a>
<a name="ln9862"> </a>
<a name="ln9863">			case axis_ancestor:</a>
<a name="ln9864">			case axis_ancestor_or_self:</a>
<a name="ln9865">			{</a>
<a name="ln9866">				if (axis == axis_ancestor_or_self)</a>
<a name="ln9867">					if (step_push(ns, n, alloc) &amp; once)</a>
<a name="ln9868">						return;</a>
<a name="ln9869"> </a>
<a name="ln9870">				xml_node_struct* cur = n-&gt;parent;</a>
<a name="ln9871"> </a>
<a name="ln9872">				while (cur)</a>
<a name="ln9873">				{</a>
<a name="ln9874">					if (step_push(ns, cur, alloc) &amp; once)</a>
<a name="ln9875">						return;</a>
<a name="ln9876"> </a>
<a name="ln9877">					cur = cur-&gt;parent;</a>
<a name="ln9878">				}</a>
<a name="ln9879"> </a>
<a name="ln9880">				break;</a>
<a name="ln9881">			}</a>
<a name="ln9882"> </a>
<a name="ln9883">			case axis_self:</a>
<a name="ln9884">			{</a>
<a name="ln9885">				step_push(ns, n, alloc);</a>
<a name="ln9886"> </a>
<a name="ln9887">				break;</a>
<a name="ln9888">			}</a>
<a name="ln9889"> </a>
<a name="ln9890">			case axis_parent:</a>
<a name="ln9891">			{</a>
<a name="ln9892">				if (n-&gt;parent)</a>
<a name="ln9893">					step_push(ns, n-&gt;parent, alloc);</a>
<a name="ln9894"> </a>
<a name="ln9895">				break;</a>
<a name="ln9896">			}</a>
<a name="ln9897"> </a>
<a name="ln9898">			default:</a>
<a name="ln9899">				assert(false &amp;&amp; &quot;Unimplemented axis&quot;);</a>
<a name="ln9900">			}</a>
<a name="ln9901">		}</a>
<a name="ln9902"> </a>
<a name="ln9903">		template &lt;class T&gt; void step_fill(xpath_node_set_raw&amp; ns, xml_attribute_struct* a, xml_node_struct* p, xpath_allocator* alloc, bool once, T v)</a>
<a name="ln9904">		{</a>
<a name="ln9905">			const axis_t axis = T::axis;</a>
<a name="ln9906"> </a>
<a name="ln9907">			switch (axis)</a>
<a name="ln9908">			{</a>
<a name="ln9909">			case axis_ancestor:</a>
<a name="ln9910">			case axis_ancestor_or_self:</a>
<a name="ln9911">			{</a>
<a name="ln9912">				if (axis == axis_ancestor_or_self &amp;&amp; _test == nodetest_type_node) // reject attributes based on principal node type test</a>
<a name="ln9913">					if (step_push(ns, a, p, alloc) &amp; once)</a>
<a name="ln9914">						return;</a>
<a name="ln9915"> </a>
<a name="ln9916">				xml_node_struct* cur = p;</a>
<a name="ln9917"> </a>
<a name="ln9918">				while (cur)</a>
<a name="ln9919">				{</a>
<a name="ln9920">					if (step_push(ns, cur, alloc) &amp; once)</a>
<a name="ln9921">						return;</a>
<a name="ln9922"> </a>
<a name="ln9923">					cur = cur-&gt;parent;</a>
<a name="ln9924">				}</a>
<a name="ln9925"> </a>
<a name="ln9926">				break;</a>
<a name="ln9927">			}</a>
<a name="ln9928"> </a>
<a name="ln9929">			case axis_descendant_or_self:</a>
<a name="ln9930">			case axis_self:</a>
<a name="ln9931">			{</a>
<a name="ln9932">				if (_test == nodetest_type_node) // reject attributes based on principal node type test</a>
<a name="ln9933">					step_push(ns, a, p, alloc);</a>
<a name="ln9934"> </a>
<a name="ln9935">				break;</a>
<a name="ln9936">			}</a>
<a name="ln9937"> </a>
<a name="ln9938">			case axis_following:</a>
<a name="ln9939">			{</a>
<a name="ln9940">				xml_node_struct* cur = p;</a>
<a name="ln9941"> </a>
<a name="ln9942">				while (cur)</a>
<a name="ln9943">				{</a>
<a name="ln9944">					if (cur-&gt;first_child)</a>
<a name="ln9945">						cur = cur-&gt;first_child;</a>
<a name="ln9946">					else</a>
<a name="ln9947">					{</a>
<a name="ln9948">						while (!cur-&gt;next_sibling)</a>
<a name="ln9949">						{</a>
<a name="ln9950">							cur = cur-&gt;parent;</a>
<a name="ln9951"> </a>
<a name="ln9952">							if (!cur) return;</a>
<a name="ln9953">						}</a>
<a name="ln9954"> </a>
<a name="ln9955">						cur = cur-&gt;next_sibling;</a>
<a name="ln9956">					}</a>
<a name="ln9957"> </a>
<a name="ln9958">					if (step_push(ns, cur, alloc) &amp; once)</a>
<a name="ln9959">						return;</a>
<a name="ln9960">				}</a>
<a name="ln9961"> </a>
<a name="ln9962">				break;</a>
<a name="ln9963">			}</a>
<a name="ln9964"> </a>
<a name="ln9965">			case axis_parent:</a>
<a name="ln9966">			{</a>
<a name="ln9967">				step_push(ns, p, alloc);</a>
<a name="ln9968"> </a>
<a name="ln9969">				break;</a>
<a name="ln9970">			}</a>
<a name="ln9971"> </a>
<a name="ln9972">			case axis_preceding:</a>
<a name="ln9973">			{</a>
<a name="ln9974">				// preceding:: axis does not include attribute nodes and attribute ancestors (they are the same as parent's ancestors), so we can reuse node preceding</a>
<a name="ln9975">				step_fill(ns, p, alloc, once, v);</a>
<a name="ln9976">				break;</a>
<a name="ln9977">			}</a>
<a name="ln9978"> </a>
<a name="ln9979">			default:</a>
<a name="ln9980">				assert(false &amp;&amp; &quot;Unimplemented axis&quot;);</a>
<a name="ln9981">			}</a>
<a name="ln9982">		}</a>
<a name="ln9983"> </a>
<a name="ln9984">		template &lt;class T&gt; void step_fill(xpath_node_set_raw&amp; ns, const xpath_node&amp; xn, xpath_allocator* alloc, bool once, T v)</a>
<a name="ln9985">		{</a>
<a name="ln9986">			const axis_t axis = T::axis;</a>
<a name="ln9987">			const bool axis_has_attributes = (axis == axis_ancestor || axis == axis_ancestor_or_self || axis == axis_descendant_or_self || axis == axis_following || axis == axis_parent || axis == axis_preceding || axis == axis_self);</a>
<a name="ln9988"> </a>
<a name="ln9989">			if (xn.node())</a>
<a name="ln9990">				step_fill(ns, xn.node().internal_object(), alloc, once, v);</a>
<a name="ln9991">			else if (axis_has_attributes &amp;&amp; xn.attribute() &amp;&amp; xn.parent())</a>
<a name="ln9992">				step_fill(ns, xn.attribute().internal_object(), xn.parent().internal_object(), alloc, once, v);</a>
<a name="ln9993">		}</a>
<a name="ln9994"> </a>
<a name="ln9995">		template &lt;class T&gt; xpath_node_set_raw step_do(const xpath_context&amp; c, const xpath_stack&amp; stack, nodeset_eval_t eval, T v)</a>
<a name="ln9996">		{</a>
<a name="ln9997">			const axis_t axis = T::axis;</a>
<a name="ln9998">			const bool axis_reverse = (axis == axis_ancestor || axis == axis_ancestor_or_self || axis == axis_preceding || axis == axis_preceding_sibling);</a>
<a name="ln9999">			const xpath_node_set::type_t axis_type = axis_reverse ? xpath_node_set::type_sorted_reverse : xpath_node_set::type_sorted;</a>
<a name="ln10000"> </a>
<a name="ln10001">			bool once =</a>
<a name="ln10002">				(axis == axis_attribute &amp;&amp; _test == nodetest_name) ||</a>
<a name="ln10003">				(!_right &amp;&amp; eval_once(axis_type, eval)) ||</a>
<a name="ln10004">				(_right &amp;&amp; !_right-&gt;_next &amp;&amp; _right-&gt;_test == predicate_constant_one);</a>
<a name="ln10005"> </a>
<a name="ln10006">			xpath_node_set_raw ns;</a>
<a name="ln10007">			ns.set_type(axis_type);</a>
<a name="ln10008"> </a>
<a name="ln10009">			if (_left)</a>
<a name="ln10010">			{</a>
<a name="ln10011">				xpath_node_set_raw s = _left-&gt;eval_node_set(c, stack, nodeset_eval_all);</a>
<a name="ln10012"> </a>
<a name="ln10013">				// self axis preserves the original order</a>
<a name="ln10014">				if (axis == axis_self) ns.set_type(s.type());</a>
<a name="ln10015"> </a>
<a name="ln10016">				for (const xpath_node* it = s.begin(); it != s.end(); ++it)</a>
<a name="ln10017">				{</a>
<a name="ln10018">					size_t size = ns.size();</a>
<a name="ln10019"> </a>
<a name="ln10020">					// in general, all axes generate elements in a particular order, but there is no order guarantee if axis is applied to two nodes</a>
<a name="ln10021">					if (axis != axis_self &amp;&amp; size != 0) ns.set_type(xpath_node_set::type_unsorted);</a>
<a name="ln10022"> </a>
<a name="ln10023">					step_fill(ns, *it, stack.result, once, v);</a>
<a name="ln10024">					if (_right) apply_predicates(ns, size, stack, eval);</a>
<a name="ln10025">				}</a>
<a name="ln10026">			}</a>
<a name="ln10027">			else</a>
<a name="ln10028">			{</a>
<a name="ln10029">				step_fill(ns, c.n, stack.result, once, v);</a>
<a name="ln10030">				if (_right) apply_predicates(ns, 0, stack, eval);</a>
<a name="ln10031">			}</a>
<a name="ln10032"> </a>
<a name="ln10033">			// child, attribute and self axes always generate unique set of nodes</a>
<a name="ln10034">			// for other axis, if the set stayed sorted, it stayed unique because the traversal algorithms do not visit the same node twice</a>
<a name="ln10035">			if (axis != axis_child &amp;&amp; axis != axis_attribute &amp;&amp; axis != axis_self &amp;&amp; ns.type() == xpath_node_set::type_unsorted)</a>
<a name="ln10036">				ns.remove_duplicates();</a>
<a name="ln10037"> </a>
<a name="ln10038">			return ns;</a>
<a name="ln10039">		}</a>
<a name="ln10040"> </a>
<a name="ln10041">	public:</a>
<a name="ln10042">		xpath_ast_node(ast_type_t type, xpath_value_type rettype_, const char_t* value):</a>
<a name="ln10043">			_type(static_cast&lt;char&gt;(type)), _rettype(static_cast&lt;char&gt;(rettype_)), _axis(0), _test(0), _left(0), _right(0), _next(0)</a>
<a name="ln10044">		{</a>
<a name="ln10045">			assert(type == ast_string_constant);</a>
<a name="ln10046">			_data.string = value;</a>
<a name="ln10047">		}</a>
<a name="ln10048"> </a>
<a name="ln10049">		xpath_ast_node(ast_type_t type, xpath_value_type rettype_, double value):</a>
<a name="ln10050">			_type(static_cast&lt;char&gt;(type)), _rettype(static_cast&lt;char&gt;(rettype_)), _axis(0), _test(0), _left(0), _right(0), _next(0)</a>
<a name="ln10051">		{</a>
<a name="ln10052">			assert(type == ast_number_constant);</a>
<a name="ln10053">			_data.number = value;</a>
<a name="ln10054">		}</a>
<a name="ln10055"> </a>
<a name="ln10056">		xpath_ast_node(ast_type_t type, xpath_value_type rettype_, xpath_variable* value):</a>
<a name="ln10057">			_type(static_cast&lt;char&gt;(type)), _rettype(static_cast&lt;char&gt;(rettype_)), _axis(0), _test(0), _left(0), _right(0), _next(0)</a>
<a name="ln10058">		{</a>
<a name="ln10059">			assert(type == ast_variable);</a>
<a name="ln10060">			_data.variable = value;</a>
<a name="ln10061">		}</a>
<a name="ln10062"> </a>
<a name="ln10063">		xpath_ast_node(ast_type_t type, xpath_value_type rettype_, xpath_ast_node* left = 0, xpath_ast_node* right = 0):</a>
<a name="ln10064">			_type(static_cast&lt;char&gt;(type)), _rettype(static_cast&lt;char&gt;(rettype_)), _axis(0), _test(0), _left(left), _right(right), _next(0)</a>
<a name="ln10065">		{</a>
<a name="ln10066">		}</a>
<a name="ln10067"> </a>
<a name="ln10068">		xpath_ast_node(ast_type_t type, xpath_ast_node* left, axis_t axis, nodetest_t test, const char_t* contents):</a>
<a name="ln10069">			_type(static_cast&lt;char&gt;(type)), _rettype(xpath_type_node_set), _axis(static_cast&lt;char&gt;(axis)), _test(static_cast&lt;char&gt;(test)), _left(left), _right(0), _next(0)</a>
<a name="ln10070">		{</a>
<a name="ln10071">			assert(type == ast_step);</a>
<a name="ln10072">			_data.nodetest = contents;</a>
<a name="ln10073">		}</a>
<a name="ln10074"> </a>
<a name="ln10075">		xpath_ast_node(ast_type_t type, xpath_ast_node* left, xpath_ast_node* right, predicate_t test):</a>
<a name="ln10076">			_type(static_cast&lt;char&gt;(type)), _rettype(xpath_type_node_set), _axis(0), _test(static_cast&lt;char&gt;(test)), _left(left), _right(right), _next(0)</a>
<a name="ln10077">		{</a>
<a name="ln10078">			assert(type == ast_filter || type == ast_predicate);</a>
<a name="ln10079">		}</a>
<a name="ln10080"> </a>
<a name="ln10081">		void set_next(xpath_ast_node* value)</a>
<a name="ln10082">		{</a>
<a name="ln10083">			_next = value;</a>
<a name="ln10084">		}</a>
<a name="ln10085"> </a>
<a name="ln10086">		void set_right(xpath_ast_node* value)</a>
<a name="ln10087">		{</a>
<a name="ln10088">			_right = value;</a>
<a name="ln10089">		}</a>
<a name="ln10090"> </a>
<a name="ln10091">		bool eval_boolean(const xpath_context&amp; c, const xpath_stack&amp; stack)</a>
<a name="ln10092">		{</a>
<a name="ln10093">			switch (_type)</a>
<a name="ln10094">			{</a>
<a name="ln10095">			case ast_op_or:</a>
<a name="ln10096">				return _left-&gt;eval_boolean(c, stack) || _right-&gt;eval_boolean(c, stack);</a>
<a name="ln10097"> </a>
<a name="ln10098">			case ast_op_and:</a>
<a name="ln10099">				return _left-&gt;eval_boolean(c, stack) &amp;&amp; _right-&gt;eval_boolean(c, stack);</a>
<a name="ln10100"> </a>
<a name="ln10101">			case ast_op_equal:</a>
<a name="ln10102">				return compare_eq(_left, _right, c, stack, equal_to());</a>
<a name="ln10103"> </a>
<a name="ln10104">			case ast_op_not_equal:</a>
<a name="ln10105">				return compare_eq(_left, _right, c, stack, not_equal_to());</a>
<a name="ln10106"> </a>
<a name="ln10107">			case ast_op_less:</a>
<a name="ln10108">				return compare_rel(_left, _right, c, stack, less());</a>
<a name="ln10109"> </a>
<a name="ln10110">			case ast_op_greater:</a>
<a name="ln10111">				return compare_rel(_right, _left, c, stack, less());</a>
<a name="ln10112"> </a>
<a name="ln10113">			case ast_op_less_or_equal:</a>
<a name="ln10114">				return compare_rel(_left, _right, c, stack, less_equal());</a>
<a name="ln10115"> </a>
<a name="ln10116">			case ast_op_greater_or_equal:</a>
<a name="ln10117">				return compare_rel(_right, _left, c, stack, less_equal());</a>
<a name="ln10118"> </a>
<a name="ln10119">			case ast_func_starts_with:</a>
<a name="ln10120">			{</a>
<a name="ln10121">				xpath_allocator_capture cr(stack.result);</a>
<a name="ln10122"> </a>
<a name="ln10123">				xpath_string lr = _left-&gt;eval_string(c, stack);</a>
<a name="ln10124">				xpath_string rr = _right-&gt;eval_string(c, stack);</a>
<a name="ln10125"> </a>
<a name="ln10126">				return starts_with(lr.c_str(), rr.c_str());</a>
<a name="ln10127">			}</a>
<a name="ln10128"> </a>
<a name="ln10129">			case ast_func_contains:</a>
<a name="ln10130">			{</a>
<a name="ln10131">				xpath_allocator_capture cr(stack.result);</a>
<a name="ln10132"> </a>
<a name="ln10133">				xpath_string lr = _left-&gt;eval_string(c, stack);</a>
<a name="ln10134">				xpath_string rr = _right-&gt;eval_string(c, stack);</a>
<a name="ln10135"> </a>
<a name="ln10136">				return find_substring(lr.c_str(), rr.c_str()) != 0;</a>
<a name="ln10137">			}</a>
<a name="ln10138"> </a>
<a name="ln10139">			case ast_func_boolean:</a>
<a name="ln10140">				return _left-&gt;eval_boolean(c, stack);</a>
<a name="ln10141"> </a>
<a name="ln10142">			case ast_func_not:</a>
<a name="ln10143">				return !_left-&gt;eval_boolean(c, stack);</a>
<a name="ln10144"> </a>
<a name="ln10145">			case ast_func_true:</a>
<a name="ln10146">				return true;</a>
<a name="ln10147"> </a>
<a name="ln10148">			case ast_func_false:</a>
<a name="ln10149">				return false;</a>
<a name="ln10150"> </a>
<a name="ln10151">			case ast_func_lang:</a>
<a name="ln10152">			{</a>
<a name="ln10153">				if (c.n.attribute()) return false;</a>
<a name="ln10154"> </a>
<a name="ln10155">				xpath_allocator_capture cr(stack.result);</a>
<a name="ln10156"> </a>
<a name="ln10157">				xpath_string lang = _left-&gt;eval_string(c, stack);</a>
<a name="ln10158"> </a>
<a name="ln10159">				for (xml_node n = c.n.node(); n; n = n.parent())</a>
<a name="ln10160">				{</a>
<a name="ln10161">					xml_attribute a = n.attribute(PUGIXML_TEXT(&quot;xml:lang&quot;));</a>
<a name="ln10162"> </a>
<a name="ln10163">					if (a)</a>
<a name="ln10164">					{</a>
<a name="ln10165">						const char_t* value = a.value();</a>
<a name="ln10166"> </a>
<a name="ln10167">						// strnicmp / strncasecmp is not portable</a>
<a name="ln10168">						for (const char_t* lit = lang.c_str(); *lit; ++lit)</a>
<a name="ln10169">						{</a>
<a name="ln10170">							if (tolower_ascii(*lit) != tolower_ascii(*value)) return false;</a>
<a name="ln10171">							++value;</a>
<a name="ln10172">						}</a>
<a name="ln10173"> </a>
<a name="ln10174">						return *value == 0 || *value == '-';</a>
<a name="ln10175">					}</a>
<a name="ln10176">				}</a>
<a name="ln10177"> </a>
<a name="ln10178">				return false;</a>
<a name="ln10179">			}</a>
<a name="ln10180"> </a>
<a name="ln10181">			case ast_opt_compare_attribute:</a>
<a name="ln10182">			{</a>
<a name="ln10183">				const char_t* value = (_right-&gt;_type == ast_string_constant) ? _right-&gt;_data.string : _right-&gt;_data.variable-&gt;get_string();</a>
<a name="ln10184"> </a>
<a name="ln10185">				xml_attribute attr = c.n.node().attribute(_left-&gt;_data.nodetest);</a>
<a name="ln10186"> </a>
<a name="ln10187">				return attr &amp;&amp; strequal(attr.value(), value) &amp;&amp; is_xpath_attribute(attr.name());</a>
<a name="ln10188">			}</a>
<a name="ln10189"> </a>
<a name="ln10190">			case ast_variable:</a>
<a name="ln10191">			{</a>
<a name="ln10192">				assert(_rettype == _data.variable-&gt;type());</a>
<a name="ln10193"> </a>
<a name="ln10194">				if (_rettype == xpath_type_boolean)</a>
<a name="ln10195">					return _data.variable-&gt;get_boolean();</a>
<a name="ln10196"> </a>
<a name="ln10197">				// fallthrough to type conversion</a>
<a name="ln10198">			}</a>
<a name="ln10199"> </a>
<a name="ln10200">			default:</a>
<a name="ln10201">			{</a>
<a name="ln10202">				switch (_rettype)</a>
<a name="ln10203">				{</a>
<a name="ln10204">				case xpath_type_number:</a>
<a name="ln10205">					return convert_number_to_boolean(eval_number(c, stack));</a>
<a name="ln10206"> </a>
<a name="ln10207">				case xpath_type_string:</a>
<a name="ln10208">				{</a>
<a name="ln10209">					xpath_allocator_capture cr(stack.result);</a>
<a name="ln10210"> </a>
<a name="ln10211">					return !eval_string(c, stack).empty();</a>
<a name="ln10212">				}</a>
<a name="ln10213"> </a>
<a name="ln10214">				case xpath_type_node_set:</a>
<a name="ln10215">				{</a>
<a name="ln10216">					xpath_allocator_capture cr(stack.result);</a>
<a name="ln10217"> </a>
<a name="ln10218">					return !eval_node_set(c, stack, nodeset_eval_any).empty();</a>
<a name="ln10219">				}</a>
<a name="ln10220"> </a>
<a name="ln10221">				default:</a>
<a name="ln10222">					assert(false &amp;&amp; &quot;Wrong expression for return type boolean&quot;);</a>
<a name="ln10223">					return false;</a>
<a name="ln10224">				}</a>
<a name="ln10225">			}</a>
<a name="ln10226">			}</a>
<a name="ln10227">		}</a>
<a name="ln10228"> </a>
<a name="ln10229">		double eval_number(const xpath_context&amp; c, const xpath_stack&amp; stack)</a>
<a name="ln10230">		{</a>
<a name="ln10231">			switch (_type)</a>
<a name="ln10232">			{</a>
<a name="ln10233">			case ast_op_add:</a>
<a name="ln10234">				return _left-&gt;eval_number(c, stack) + _right-&gt;eval_number(c, stack);</a>
<a name="ln10235"> </a>
<a name="ln10236">			case ast_op_subtract:</a>
<a name="ln10237">				return _left-&gt;eval_number(c, stack) - _right-&gt;eval_number(c, stack);</a>
<a name="ln10238"> </a>
<a name="ln10239">			case ast_op_multiply:</a>
<a name="ln10240">				return _left-&gt;eval_number(c, stack) * _right-&gt;eval_number(c, stack);</a>
<a name="ln10241"> </a>
<a name="ln10242">			case ast_op_divide:</a>
<a name="ln10243">				return _left-&gt;eval_number(c, stack) / _right-&gt;eval_number(c, stack);</a>
<a name="ln10244"> </a>
<a name="ln10245">			case ast_op_mod:</a>
<a name="ln10246">				return fmod(_left-&gt;eval_number(c, stack), _right-&gt;eval_number(c, stack));</a>
<a name="ln10247"> </a>
<a name="ln10248">			case ast_op_negate:</a>
<a name="ln10249">				return -_left-&gt;eval_number(c, stack);</a>
<a name="ln10250"> </a>
<a name="ln10251">			case ast_number_constant:</a>
<a name="ln10252">				return _data.number;</a>
<a name="ln10253"> </a>
<a name="ln10254">			case ast_func_last:</a>
<a name="ln10255">				return static_cast&lt;double&gt;(c.size);</a>
<a name="ln10256"> </a>
<a name="ln10257">			case ast_func_position:</a>
<a name="ln10258">				return static_cast&lt;double&gt;(c.position);</a>
<a name="ln10259"> </a>
<a name="ln10260">			case ast_func_count:</a>
<a name="ln10261">			{</a>
<a name="ln10262">				xpath_allocator_capture cr(stack.result);</a>
<a name="ln10263"> </a>
<a name="ln10264">				return static_cast&lt;double&gt;(_left-&gt;eval_node_set(c, stack, nodeset_eval_all).size());</a>
<a name="ln10265">			}</a>
<a name="ln10266"> </a>
<a name="ln10267">			case ast_func_string_length_0:</a>
<a name="ln10268">			{</a>
<a name="ln10269">				xpath_allocator_capture cr(stack.result);</a>
<a name="ln10270"> </a>
<a name="ln10271">				return static_cast&lt;double&gt;(string_value(c.n, stack.result).length());</a>
<a name="ln10272">			}</a>
<a name="ln10273"> </a>
<a name="ln10274">			case ast_func_string_length_1:</a>
<a name="ln10275">			{</a>
<a name="ln10276">				xpath_allocator_capture cr(stack.result);</a>
<a name="ln10277"> </a>
<a name="ln10278">				return static_cast&lt;double&gt;(_left-&gt;eval_string(c, stack).length());</a>
<a name="ln10279">			}</a>
<a name="ln10280"> </a>
<a name="ln10281">			case ast_func_number_0:</a>
<a name="ln10282">			{</a>
<a name="ln10283">				xpath_allocator_capture cr(stack.result);</a>
<a name="ln10284"> </a>
<a name="ln10285">				return convert_string_to_number(string_value(c.n, stack.result).c_str());</a>
<a name="ln10286">			}</a>
<a name="ln10287"> </a>
<a name="ln10288">			case ast_func_number_1:</a>
<a name="ln10289">				return _left-&gt;eval_number(c, stack);</a>
<a name="ln10290"> </a>
<a name="ln10291">			case ast_func_sum:</a>
<a name="ln10292">			{</a>
<a name="ln10293">				xpath_allocator_capture cr(stack.result);</a>
<a name="ln10294"> </a>
<a name="ln10295">				double r = 0;</a>
<a name="ln10296"> </a>
<a name="ln10297">				xpath_node_set_raw ns = _left-&gt;eval_node_set(c, stack, nodeset_eval_all);</a>
<a name="ln10298"> </a>
<a name="ln10299">				for (const xpath_node* it = ns.begin(); it != ns.end(); ++it)</a>
<a name="ln10300">				{</a>
<a name="ln10301">					xpath_allocator_capture cri(stack.result);</a>
<a name="ln10302"> </a>
<a name="ln10303">					r += convert_string_to_number(string_value(*it, stack.result).c_str());</a>
<a name="ln10304">				}</a>
<a name="ln10305"> </a>
<a name="ln10306">				return r;</a>
<a name="ln10307">			}</a>
<a name="ln10308"> </a>
<a name="ln10309">			case ast_func_floor:</a>
<a name="ln10310">			{</a>
<a name="ln10311">				double r = _left-&gt;eval_number(c, stack);</a>
<a name="ln10312"> </a>
<a name="ln10313">				return r == r ? floor(r) : r;</a>
<a name="ln10314">			}</a>
<a name="ln10315"> </a>
<a name="ln10316">			case ast_func_ceiling:</a>
<a name="ln10317">			{</a>
<a name="ln10318">				double r = _left-&gt;eval_number(c, stack);</a>
<a name="ln10319"> </a>
<a name="ln10320">				return r == r ? ceil(r) : r;</a>
<a name="ln10321">			}</a>
<a name="ln10322"> </a>
<a name="ln10323">			case ast_func_round:</a>
<a name="ln10324">				return round_nearest_nzero(_left-&gt;eval_number(c, stack));</a>
<a name="ln10325"> </a>
<a name="ln10326">			case ast_variable:</a>
<a name="ln10327">			{</a>
<a name="ln10328">				assert(_rettype == _data.variable-&gt;type());</a>
<a name="ln10329"> </a>
<a name="ln10330">				if (_rettype == xpath_type_number)</a>
<a name="ln10331">					return _data.variable-&gt;get_number();</a>
<a name="ln10332"> </a>
<a name="ln10333">				// fallthrough to type conversion</a>
<a name="ln10334">			}</a>
<a name="ln10335"> </a>
<a name="ln10336">			default:</a>
<a name="ln10337">			{</a>
<a name="ln10338">				switch (_rettype)</a>
<a name="ln10339">				{</a>
<a name="ln10340">				case xpath_type_boolean:</a>
<a name="ln10341">					return eval_boolean(c, stack) ? 1 : 0;</a>
<a name="ln10342"> </a>
<a name="ln10343">				case xpath_type_string:</a>
<a name="ln10344">				{</a>
<a name="ln10345">					xpath_allocator_capture cr(stack.result);</a>
<a name="ln10346"> </a>
<a name="ln10347">					return convert_string_to_number(eval_string(c, stack).c_str());</a>
<a name="ln10348">				}</a>
<a name="ln10349"> </a>
<a name="ln10350">				case xpath_type_node_set:</a>
<a name="ln10351">				{</a>
<a name="ln10352">					xpath_allocator_capture cr(stack.result);</a>
<a name="ln10353"> </a>
<a name="ln10354">					return convert_string_to_number(eval_string(c, stack).c_str());</a>
<a name="ln10355">				}</a>
<a name="ln10356"> </a>
<a name="ln10357">				default:</a>
<a name="ln10358">					assert(false &amp;&amp; &quot;Wrong expression for return type number&quot;);</a>
<a name="ln10359">					return 0;</a>
<a name="ln10360">				}</a>
<a name="ln10361"> </a>
<a name="ln10362">			}</a>
<a name="ln10363">			}</a>
<a name="ln10364">		}</a>
<a name="ln10365"> </a>
<a name="ln10366">		xpath_string eval_string_concat(const xpath_context&amp; c, const xpath_stack&amp; stack)</a>
<a name="ln10367">		{</a>
<a name="ln10368">			assert(_type == ast_func_concat);</a>
<a name="ln10369"> </a>
<a name="ln10370">			xpath_allocator_capture ct(stack.temp);</a>
<a name="ln10371"> </a>
<a name="ln10372">			// count the string number</a>
<a name="ln10373">			size_t count = 1;</a>
<a name="ln10374">			for (xpath_ast_node* nc = _right; nc; nc = nc-&gt;_next) count++;</a>
<a name="ln10375"> </a>
<a name="ln10376">			// gather all strings</a>
<a name="ln10377">			xpath_string static_buffer[4];</a>
<a name="ln10378">			xpath_string* buffer = static_buffer;</a>
<a name="ln10379"> </a>
<a name="ln10380">			// allocate on-heap for large concats</a>
<a name="ln10381">			if (count &gt; sizeof(static_buffer) / sizeof(static_buffer[0]))</a>
<a name="ln10382">			{</a>
<a name="ln10383">				buffer = static_cast&lt;xpath_string*&gt;(stack.temp-&gt;allocate(count * sizeof(xpath_string)));</a>
<a name="ln10384">				assert(buffer);</a>
<a name="ln10385">			}</a>
<a name="ln10386"> </a>
<a name="ln10387">			// evaluate all strings to temporary stack</a>
<a name="ln10388">			xpath_stack swapped_stack = {stack.temp, stack.result};</a>
<a name="ln10389"> </a>
<a name="ln10390">			buffer[0] = _left-&gt;eval_string(c, swapped_stack);</a>
<a name="ln10391"> </a>
<a name="ln10392">			size_t pos = 1;</a>
<a name="ln10393">			for (xpath_ast_node* n = _right; n; n = n-&gt;_next, ++pos) buffer[pos] = n-&gt;eval_string(c, swapped_stack);</a>
<a name="ln10394">			assert(pos == count);</a>
<a name="ln10395"> </a>
<a name="ln10396">			// get total length</a>
<a name="ln10397">			size_t length = 0;</a>
<a name="ln10398">			for (size_t i = 0; i &lt; count; ++i) length += buffer[i].length();</a>
<a name="ln10399"> </a>
<a name="ln10400">			// create final string</a>
<a name="ln10401">			char_t* result = static_cast&lt;char_t*&gt;(stack.result-&gt;allocate((length + 1) * sizeof(char_t)));</a>
<a name="ln10402">			assert(result);</a>
<a name="ln10403"> </a>
<a name="ln10404">			char_t* ri = result;</a>
<a name="ln10405"> </a>
<a name="ln10406">			for (size_t j = 0; j &lt; count; ++j)</a>
<a name="ln10407">				for (const char_t* bi = buffer[j].c_str(); *bi; ++bi)</a>
<a name="ln10408">					*ri++ = *bi;</a>
<a name="ln10409"> </a>
<a name="ln10410">			*ri = 0;</a>
<a name="ln10411"> </a>
<a name="ln10412">			return xpath_string::from_heap_preallocated(result, ri);</a>
<a name="ln10413">		}</a>
<a name="ln10414"> </a>
<a name="ln10415">		xpath_string eval_string(const xpath_context&amp; c, const xpath_stack&amp; stack)</a>
<a name="ln10416">		{</a>
<a name="ln10417">			switch (_type)</a>
<a name="ln10418">			{</a>
<a name="ln10419">			case ast_string_constant:</a>
<a name="ln10420">				return xpath_string::from_const(_data.string);</a>
<a name="ln10421"> </a>
<a name="ln10422">			case ast_func_local_name_0:</a>
<a name="ln10423">			{</a>
<a name="ln10424">				xpath_node na = c.n;</a>
<a name="ln10425"> </a>
<a name="ln10426">				return xpath_string::from_const(local_name(na));</a>
<a name="ln10427">			}</a>
<a name="ln10428"> </a>
<a name="ln10429">			case ast_func_local_name_1:</a>
<a name="ln10430">			{</a>
<a name="ln10431">				xpath_allocator_capture cr(stack.result);</a>
<a name="ln10432"> </a>
<a name="ln10433">				xpath_node_set_raw ns = _left-&gt;eval_node_set(c, stack, nodeset_eval_first);</a>
<a name="ln10434">				xpath_node na = ns.first();</a>
<a name="ln10435"> </a>
<a name="ln10436">				return xpath_string::from_const(local_name(na));</a>
<a name="ln10437">			}</a>
<a name="ln10438"> </a>
<a name="ln10439">			case ast_func_name_0:</a>
<a name="ln10440">			{</a>
<a name="ln10441">				xpath_node na = c.n;</a>
<a name="ln10442"> </a>
<a name="ln10443">				return xpath_string::from_const(qualified_name(na));</a>
<a name="ln10444">			}</a>
<a name="ln10445"> </a>
<a name="ln10446">			case ast_func_name_1:</a>
<a name="ln10447">			{</a>
<a name="ln10448">				xpath_allocator_capture cr(stack.result);</a>
<a name="ln10449"> </a>
<a name="ln10450">				xpath_node_set_raw ns = _left-&gt;eval_node_set(c, stack, nodeset_eval_first);</a>
<a name="ln10451">				xpath_node na = ns.first();</a>
<a name="ln10452"> </a>
<a name="ln10453">				return xpath_string::from_const(qualified_name(na));</a>
<a name="ln10454">			}</a>
<a name="ln10455"> </a>
<a name="ln10456">			case ast_func_namespace_uri_0:</a>
<a name="ln10457">			{</a>
<a name="ln10458">				xpath_node na = c.n;</a>
<a name="ln10459"> </a>
<a name="ln10460">				return xpath_string::from_const(namespace_uri(na));</a>
<a name="ln10461">			}</a>
<a name="ln10462"> </a>
<a name="ln10463">			case ast_func_namespace_uri_1:</a>
<a name="ln10464">			{</a>
<a name="ln10465">				xpath_allocator_capture cr(stack.result);</a>
<a name="ln10466"> </a>
<a name="ln10467">				xpath_node_set_raw ns = _left-&gt;eval_node_set(c, stack, nodeset_eval_first);</a>
<a name="ln10468">				xpath_node na = ns.first();</a>
<a name="ln10469"> </a>
<a name="ln10470">				return xpath_string::from_const(namespace_uri(na));</a>
<a name="ln10471">			}</a>
<a name="ln10472"> </a>
<a name="ln10473">			case ast_func_string_0:</a>
<a name="ln10474">				return string_value(c.n, stack.result);</a>
<a name="ln10475"> </a>
<a name="ln10476">			case ast_func_string_1:</a>
<a name="ln10477">				return _left-&gt;eval_string(c, stack);</a>
<a name="ln10478"> </a>
<a name="ln10479">			case ast_func_concat:</a>
<a name="ln10480">				return eval_string_concat(c, stack);</a>
<a name="ln10481"> </a>
<a name="ln10482">			case ast_func_substring_before:</a>
<a name="ln10483">			{</a>
<a name="ln10484">				xpath_allocator_capture cr(stack.temp);</a>
<a name="ln10485"> </a>
<a name="ln10486">				xpath_stack swapped_stack = {stack.temp, stack.result};</a>
<a name="ln10487"> </a>
<a name="ln10488">				xpath_string s = _left-&gt;eval_string(c, swapped_stack);</a>
<a name="ln10489">				xpath_string p = _right-&gt;eval_string(c, swapped_stack);</a>
<a name="ln10490"> </a>
<a name="ln10491">				const char_t* pos = find_substring(s.c_str(), p.c_str());</a>
<a name="ln10492"> </a>
<a name="ln10493">				return pos ? xpath_string::from_heap(s.c_str(), pos, stack.result) : xpath_string();</a>
<a name="ln10494">			}</a>
<a name="ln10495"> </a>
<a name="ln10496">			case ast_func_substring_after:</a>
<a name="ln10497">			{</a>
<a name="ln10498">				xpath_allocator_capture cr(stack.temp);</a>
<a name="ln10499"> </a>
<a name="ln10500">				xpath_stack swapped_stack = {stack.temp, stack.result};</a>
<a name="ln10501"> </a>
<a name="ln10502">				xpath_string s = _left-&gt;eval_string(c, swapped_stack);</a>
<a name="ln10503">				xpath_string p = _right-&gt;eval_string(c, swapped_stack);</a>
<a name="ln10504"> </a>
<a name="ln10505">				const char_t* pos = find_substring(s.c_str(), p.c_str());</a>
<a name="ln10506">				if (!pos) return xpath_string();</a>
<a name="ln10507"> </a>
<a name="ln10508">				const char_t* rbegin = pos + p.length();</a>
<a name="ln10509">				const char_t* rend = s.c_str() + s.length();</a>
<a name="ln10510"> </a>
<a name="ln10511">				return s.uses_heap() ? xpath_string::from_heap(rbegin, rend, stack.result) : xpath_string::from_const(rbegin);</a>
<a name="ln10512">			}</a>
<a name="ln10513"> </a>
<a name="ln10514">			case ast_func_substring_2:</a>
<a name="ln10515">			{</a>
<a name="ln10516">				xpath_allocator_capture cr(stack.temp);</a>
<a name="ln10517"> </a>
<a name="ln10518">				xpath_stack swapped_stack = {stack.temp, stack.result};</a>
<a name="ln10519"> </a>
<a name="ln10520">				xpath_string s = _left-&gt;eval_string(c, swapped_stack);</a>
<a name="ln10521">				size_t s_length = s.length();</a>
<a name="ln10522"> </a>
<a name="ln10523">				double first = round_nearest(_right-&gt;eval_number(c, stack));</a>
<a name="ln10524"> </a>
<a name="ln10525">				if (is_nan(first)) return xpath_string(); // NaN</a>
<a name="ln10526">				else if (first &gt;= s_length + 1) return xpath_string();</a>
<a name="ln10527"> </a>
<a name="ln10528">				size_t pos = first &lt; 1 ? 1 : static_cast&lt;size_t&gt;(first);</a>
<a name="ln10529">				assert(1 &lt;= pos &amp;&amp; pos &lt;= s_length + 1);</a>
<a name="ln10530"> </a>
<a name="ln10531">				const char_t* rbegin = s.c_str() + (pos - 1);</a>
<a name="ln10532">				const char_t* rend = s.c_str() + s.length();</a>
<a name="ln10533"> </a>
<a name="ln10534">				return s.uses_heap() ? xpath_string::from_heap(rbegin, rend, stack.result) : xpath_string::from_const(rbegin);</a>
<a name="ln10535">			}</a>
<a name="ln10536"> </a>
<a name="ln10537">			case ast_func_substring_3:</a>
<a name="ln10538">			{</a>
<a name="ln10539">				xpath_allocator_capture cr(stack.temp);</a>
<a name="ln10540"> </a>
<a name="ln10541">				xpath_stack swapped_stack = {stack.temp, stack.result};</a>
<a name="ln10542"> </a>
<a name="ln10543">				xpath_string s = _left-&gt;eval_string(c, swapped_stack);</a>
<a name="ln10544">				size_t s_length = s.length();</a>
<a name="ln10545"> </a>
<a name="ln10546">				double first = round_nearest(_right-&gt;eval_number(c, stack));</a>
<a name="ln10547">				double last = first + round_nearest(_right-&gt;_next-&gt;eval_number(c, stack));</a>
<a name="ln10548"> </a>
<a name="ln10549">				if (is_nan(first) || is_nan(last)) return xpath_string();</a>
<a name="ln10550">				else if (first &gt;= s_length + 1) return xpath_string();</a>
<a name="ln10551">				else if (first &gt;= last) return xpath_string();</a>
<a name="ln10552">				else if (last &lt; 1) return xpath_string();</a>
<a name="ln10553"> </a>
<a name="ln10554">				size_t pos = first &lt; 1 ? 1 : static_cast&lt;size_t&gt;(first);</a>
<a name="ln10555">				size_t end = last &gt;= s_length + 1 ? s_length + 1 : static_cast&lt;size_t&gt;(last);</a>
<a name="ln10556"> </a>
<a name="ln10557">				assert(1 &lt;= pos &amp;&amp; pos &lt;= end &amp;&amp; end &lt;= s_length + 1);</a>
<a name="ln10558">				const char_t* rbegin = s.c_str() + (pos - 1);</a>
<a name="ln10559">				const char_t* rend = s.c_str() + (end - 1);</a>
<a name="ln10560"> </a>
<a name="ln10561">				return (end == s_length + 1 &amp;&amp; !s.uses_heap()) ? xpath_string::from_const(rbegin) : xpath_string::from_heap(rbegin, rend, stack.result);</a>
<a name="ln10562">			}</a>
<a name="ln10563"> </a>
<a name="ln10564">			case ast_func_normalize_space_0:</a>
<a name="ln10565">			{</a>
<a name="ln10566">				xpath_string s = string_value(c.n, stack.result);</a>
<a name="ln10567"> </a>
<a name="ln10568">				char_t* begin = s.data(stack.result);</a>
<a name="ln10569">				char_t* end = normalize_space(begin);</a>
<a name="ln10570"> </a>
<a name="ln10571">				return xpath_string::from_heap_preallocated(begin, end);</a>
<a name="ln10572">			}</a>
<a name="ln10573"> </a>
<a name="ln10574">			case ast_func_normalize_space_1:</a>
<a name="ln10575">			{</a>
<a name="ln10576">				xpath_string s = _left-&gt;eval_string(c, stack);</a>
<a name="ln10577"> </a>
<a name="ln10578">				char_t* begin = s.data(stack.result);</a>
<a name="ln10579">				char_t* end = normalize_space(begin);</a>
<a name="ln10580"> </a>
<a name="ln10581">				return xpath_string::from_heap_preallocated(begin, end);</a>
<a name="ln10582">			}</a>
<a name="ln10583"> </a>
<a name="ln10584">			case ast_func_translate:</a>
<a name="ln10585">			{</a>
<a name="ln10586">				xpath_allocator_capture cr(stack.temp);</a>
<a name="ln10587"> </a>
<a name="ln10588">				xpath_stack swapped_stack = {stack.temp, stack.result};</a>
<a name="ln10589"> </a>
<a name="ln10590">				xpath_string s = _left-&gt;eval_string(c, stack);</a>
<a name="ln10591">				xpath_string from = _right-&gt;eval_string(c, swapped_stack);</a>
<a name="ln10592">				xpath_string to = _right-&gt;_next-&gt;eval_string(c, swapped_stack);</a>
<a name="ln10593"> </a>
<a name="ln10594">				char_t* begin = s.data(stack.result);</a>
<a name="ln10595">				char_t* end = translate(begin, from.c_str(), to.c_str(), to.length());</a>
<a name="ln10596"> </a>
<a name="ln10597">				return xpath_string::from_heap_preallocated(begin, end);</a>
<a name="ln10598">			}</a>
<a name="ln10599"> </a>
<a name="ln10600">			case ast_opt_translate_table:</a>
<a name="ln10601">			{</a>
<a name="ln10602">				xpath_string s = _left-&gt;eval_string(c, stack);</a>
<a name="ln10603"> </a>
<a name="ln10604">				char_t* begin = s.data(stack.result);</a>
<a name="ln10605">				char_t* end = translate_table(begin, _data.table);</a>
<a name="ln10606"> </a>
<a name="ln10607">				return xpath_string::from_heap_preallocated(begin, end);</a>
<a name="ln10608">			}</a>
<a name="ln10609"> </a>
<a name="ln10610">			case ast_variable:</a>
<a name="ln10611">			{</a>
<a name="ln10612">				assert(_rettype == _data.variable-&gt;type());</a>
<a name="ln10613"> </a>
<a name="ln10614">				if (_rettype == xpath_type_string)</a>
<a name="ln10615">					return xpath_string::from_const(_data.variable-&gt;get_string());</a>
<a name="ln10616"> </a>
<a name="ln10617">				// fallthrough to type conversion</a>
<a name="ln10618">			}</a>
<a name="ln10619"> </a>
<a name="ln10620">			default:</a>
<a name="ln10621">			{</a>
<a name="ln10622">				switch (_rettype)</a>
<a name="ln10623">				{</a>
<a name="ln10624">				case xpath_type_boolean:</a>
<a name="ln10625">					return xpath_string::from_const(eval_boolean(c, stack) ? PUGIXML_TEXT(&quot;true&quot;) : PUGIXML_TEXT(&quot;false&quot;));</a>
<a name="ln10626"> </a>
<a name="ln10627">				case xpath_type_number:</a>
<a name="ln10628">					return convert_number_to_string(eval_number(c, stack), stack.result);</a>
<a name="ln10629"> </a>
<a name="ln10630">				case xpath_type_node_set:</a>
<a name="ln10631">				{</a>
<a name="ln10632">					xpath_allocator_capture cr(stack.temp);</a>
<a name="ln10633"> </a>
<a name="ln10634">					xpath_stack swapped_stack = {stack.temp, stack.result};</a>
<a name="ln10635"> </a>
<a name="ln10636">					xpath_node_set_raw ns = eval_node_set(c, swapped_stack, nodeset_eval_first);</a>
<a name="ln10637">					return ns.empty() ? xpath_string() : string_value(ns.first(), stack.result);</a>
<a name="ln10638">				}</a>
<a name="ln10639"> </a>
<a name="ln10640">				default:</a>
<a name="ln10641">					assert(false &amp;&amp; &quot;Wrong expression for return type string&quot;);</a>
<a name="ln10642">					return xpath_string();</a>
<a name="ln10643">				}</a>
<a name="ln10644">			}</a>
<a name="ln10645">			}</a>
<a name="ln10646">		}</a>
<a name="ln10647"> </a>
<a name="ln10648">		xpath_node_set_raw eval_node_set(const xpath_context&amp; c, const xpath_stack&amp; stack, nodeset_eval_t eval)</a>
<a name="ln10649">		{</a>
<a name="ln10650">			switch (_type)</a>
<a name="ln10651">			{</a>
<a name="ln10652">			case ast_op_union:</a>
<a name="ln10653">			{</a>
<a name="ln10654">				xpath_allocator_capture cr(stack.temp);</a>
<a name="ln10655"> </a>
<a name="ln10656">				xpath_stack swapped_stack = {stack.temp, stack.result};</a>
<a name="ln10657"> </a>
<a name="ln10658">				xpath_node_set_raw ls = _left-&gt;eval_node_set(c, swapped_stack, eval);</a>
<a name="ln10659">				xpath_node_set_raw rs = _right-&gt;eval_node_set(c, stack, eval);</a>
<a name="ln10660"> </a>
<a name="ln10661">				// we can optimize merging two sorted sets, but this is a very rare operation, so don't bother</a>
<a name="ln10662">				rs.set_type(xpath_node_set::type_unsorted);</a>
<a name="ln10663"> </a>
<a name="ln10664">				rs.append(ls.begin(), ls.end(), stack.result);</a>
<a name="ln10665">				rs.remove_duplicates();</a>
<a name="ln10666"> </a>
<a name="ln10667">				return rs;</a>
<a name="ln10668">			}</a>
<a name="ln10669"> </a>
<a name="ln10670">			case ast_filter:</a>
<a name="ln10671">			{</a>
<a name="ln10672">				xpath_node_set_raw set = _left-&gt;eval_node_set(c, stack, _test == predicate_constant_one ? nodeset_eval_first : nodeset_eval_all);</a>
<a name="ln10673"> </a>
<a name="ln10674">				// either expression is a number or it contains position() call; sort by document order</a>
<a name="ln10675">				if (_test != predicate_posinv) set.sort_do();</a>
<a name="ln10676"> </a>
<a name="ln10677">				bool once = eval_once(set.type(), eval);</a>
<a name="ln10678"> </a>
<a name="ln10679">				apply_predicate(set, 0, stack, once);</a>
<a name="ln10680"> </a>
<a name="ln10681">				return set;</a>
<a name="ln10682">			}</a>
<a name="ln10683"> </a>
<a name="ln10684">			case ast_func_id:</a>
<a name="ln10685">				return xpath_node_set_raw();</a>
<a name="ln10686"> </a>
<a name="ln10687">			case ast_step:</a>
<a name="ln10688">			{</a>
<a name="ln10689">				switch (_axis)</a>
<a name="ln10690">				{</a>
<a name="ln10691">				case axis_ancestor:</a>
<a name="ln10692">					return step_do(c, stack, eval, axis_to_type&lt;axis_ancestor&gt;());</a>
<a name="ln10693"> </a>
<a name="ln10694">				case axis_ancestor_or_self:</a>
<a name="ln10695">					return step_do(c, stack, eval, axis_to_type&lt;axis_ancestor_or_self&gt;());</a>
<a name="ln10696"> </a>
<a name="ln10697">				case axis_attribute:</a>
<a name="ln10698">					return step_do(c, stack, eval, axis_to_type&lt;axis_attribute&gt;());</a>
<a name="ln10699"> </a>
<a name="ln10700">				case axis_child:</a>
<a name="ln10701">					return step_do(c, stack, eval, axis_to_type&lt;axis_child&gt;());</a>
<a name="ln10702"> </a>
<a name="ln10703">				case axis_descendant:</a>
<a name="ln10704">					return step_do(c, stack, eval, axis_to_type&lt;axis_descendant&gt;());</a>
<a name="ln10705"> </a>
<a name="ln10706">				case axis_descendant_or_self:</a>
<a name="ln10707">					return step_do(c, stack, eval, axis_to_type&lt;axis_descendant_or_self&gt;());</a>
<a name="ln10708"> </a>
<a name="ln10709">				case axis_following:</a>
<a name="ln10710">					return step_do(c, stack, eval, axis_to_type&lt;axis_following&gt;());</a>
<a name="ln10711"> </a>
<a name="ln10712">				case axis_following_sibling:</a>
<a name="ln10713">					return step_do(c, stack, eval, axis_to_type&lt;axis_following_sibling&gt;());</a>
<a name="ln10714"> </a>
<a name="ln10715">				case axis_namespace:</a>
<a name="ln10716">					// namespaced axis is not supported</a>
<a name="ln10717">					return xpath_node_set_raw();</a>
<a name="ln10718"> </a>
<a name="ln10719">				case axis_parent:</a>
<a name="ln10720">					return step_do(c, stack, eval, axis_to_type&lt;axis_parent&gt;());</a>
<a name="ln10721"> </a>
<a name="ln10722">				case axis_preceding:</a>
<a name="ln10723">					return step_do(c, stack, eval, axis_to_type&lt;axis_preceding&gt;());</a>
<a name="ln10724"> </a>
<a name="ln10725">				case axis_preceding_sibling:</a>
<a name="ln10726">					return step_do(c, stack, eval, axis_to_type&lt;axis_preceding_sibling&gt;());</a>
<a name="ln10727"> </a>
<a name="ln10728">				case axis_self:</a>
<a name="ln10729">					return step_do(c, stack, eval, axis_to_type&lt;axis_self&gt;());</a>
<a name="ln10730"> </a>
<a name="ln10731">				default:</a>
<a name="ln10732">					assert(false &amp;&amp; &quot;Unknown axis&quot;);</a>
<a name="ln10733">					return xpath_node_set_raw();</a>
<a name="ln10734">				}</a>
<a name="ln10735">			}</a>
<a name="ln10736"> </a>
<a name="ln10737">			case ast_step_root:</a>
<a name="ln10738">			{</a>
<a name="ln10739">				assert(!_right); // root step can't have any predicates</a>
<a name="ln10740"> </a>
<a name="ln10741">				xpath_node_set_raw ns;</a>
<a name="ln10742"> </a>
<a name="ln10743">				ns.set_type(xpath_node_set::type_sorted);</a>
<a name="ln10744"> </a>
<a name="ln10745">				if (c.n.node()) ns.push_back(c.n.node().root(), stack.result);</a>
<a name="ln10746">				else if (c.n.attribute()) ns.push_back(c.n.parent().root(), stack.result);</a>
<a name="ln10747"> </a>
<a name="ln10748">				return ns;</a>
<a name="ln10749">			}</a>
<a name="ln10750"> </a>
<a name="ln10751">			case ast_variable:</a>
<a name="ln10752">			{</a>
<a name="ln10753">				assert(_rettype == _data.variable-&gt;type());</a>
<a name="ln10754"> </a>
<a name="ln10755">				if (_rettype == xpath_type_node_set)</a>
<a name="ln10756">				{</a>
<a name="ln10757">					const xpath_node_set&amp; s = _data.variable-&gt;get_node_set();</a>
<a name="ln10758"> </a>
<a name="ln10759">					xpath_node_set_raw ns;</a>
<a name="ln10760"> </a>
<a name="ln10761">					ns.set_type(s.type());</a>
<a name="ln10762">					ns.append(s.begin(), s.end(), stack.result);</a>
<a name="ln10763"> </a>
<a name="ln10764">					return ns;</a>
<a name="ln10765">				}</a>
<a name="ln10766"> </a>
<a name="ln10767">				// fallthrough to type conversion</a>
<a name="ln10768">			}</a>
<a name="ln10769"> </a>
<a name="ln10770">			default:</a>
<a name="ln10771">				assert(false &amp;&amp; &quot;Wrong expression for return type node set&quot;);</a>
<a name="ln10772">				return xpath_node_set_raw();</a>
<a name="ln10773">			}</a>
<a name="ln10774">		}</a>
<a name="ln10775"> </a>
<a name="ln10776">		void optimize(xpath_allocator* alloc)</a>
<a name="ln10777">		{</a>
<a name="ln10778">			if (_left)</a>
<a name="ln10779">				_left-&gt;optimize(alloc);</a>
<a name="ln10780"> </a>
<a name="ln10781">			if (_right)</a>
<a name="ln10782">				_right-&gt;optimize(alloc);</a>
<a name="ln10783"> </a>
<a name="ln10784">			if (_next)</a>
<a name="ln10785">				_next-&gt;optimize(alloc);</a>
<a name="ln10786"> </a>
<a name="ln10787">			optimize_self(alloc);</a>
<a name="ln10788">		}</a>
<a name="ln10789"> </a>
<a name="ln10790">		void optimize_self(xpath_allocator* alloc)</a>
<a name="ln10791">		{</a>
<a name="ln10792">			// Rewrite [position()=expr] with [expr]</a>
<a name="ln10793">			// Note that this step has to go before classification to recognize [position()=1]</a>
<a name="ln10794">			if ((_type == ast_filter || _type == ast_predicate) &amp;&amp;</a>
<a name="ln10795">				_right-&gt;_type == ast_op_equal &amp;&amp; _right-&gt;_left-&gt;_type == ast_func_position &amp;&amp; _right-&gt;_right-&gt;_rettype == xpath_type_number)</a>
<a name="ln10796">			{</a>
<a name="ln10797">				_right = _right-&gt;_right;</a>
<a name="ln10798">			}</a>
<a name="ln10799"> </a>
<a name="ln10800">			// Classify filter/predicate ops to perform various optimizations during evaluation</a>
<a name="ln10801">			if (_type == ast_filter || _type == ast_predicate)</a>
<a name="ln10802">			{</a>
<a name="ln10803">				assert(_test == predicate_default);</a>
<a name="ln10804"> </a>
<a name="ln10805">				if (_right-&gt;_type == ast_number_constant &amp;&amp; _right-&gt;_data.number == 1.0)</a>
<a name="ln10806">					_test = predicate_constant_one;</a>
<a name="ln10807">				else if (_right-&gt;_rettype == xpath_type_number &amp;&amp; (_right-&gt;_type == ast_number_constant || _right-&gt;_type == ast_variable || _right-&gt;_type == ast_func_last))</a>
<a name="ln10808">					_test = predicate_constant;</a>
<a name="ln10809">				else if (_right-&gt;_rettype != xpath_type_number &amp;&amp; _right-&gt;is_posinv_expr())</a>
<a name="ln10810">					_test = predicate_posinv;</a>
<a name="ln10811">			}</a>
<a name="ln10812"> </a>
<a name="ln10813">			// Rewrite descendant-or-self::node()/child::foo with descendant::foo</a>
<a name="ln10814">			// The former is a full form of //foo, the latter is much faster since it executes the node test immediately</a>
<a name="ln10815">			// Do a similar kind of rewrite for self/descendant/descendant-or-self axes</a>
<a name="ln10816">			// Note that we only rewrite positionally invariant steps (//foo[1] != /descendant::foo[1])</a>
<a name="ln10817">			if (_type == ast_step &amp;&amp; (_axis == axis_child || _axis == axis_self || _axis == axis_descendant || _axis == axis_descendant_or_self) &amp;&amp; _left &amp;&amp;</a>
<a name="ln10818">				_left-&gt;_type == ast_step &amp;&amp; _left-&gt;_axis == axis_descendant_or_self &amp;&amp; _left-&gt;_test == nodetest_type_node &amp;&amp; !_left-&gt;_right &amp;&amp;</a>
<a name="ln10819">				is_posinv_step())</a>
<a name="ln10820">			{</a>
<a name="ln10821">				if (_axis == axis_child || _axis == axis_descendant)</a>
<a name="ln10822">					_axis = axis_descendant;</a>
<a name="ln10823">				else</a>
<a name="ln10824">					_axis = axis_descendant_or_self;</a>
<a name="ln10825"> </a>
<a name="ln10826">				_left = _left-&gt;_left;</a>
<a name="ln10827">			}</a>
<a name="ln10828"> </a>
<a name="ln10829">			// Use optimized lookup table implementation for translate() with constant arguments</a>
<a name="ln10830">			if (_type == ast_func_translate &amp;&amp; _right-&gt;_type == ast_string_constant &amp;&amp; _right-&gt;_next-&gt;_type == ast_string_constant)</a>
<a name="ln10831">			{</a>
<a name="ln10832">				unsigned char* table = translate_table_generate(alloc, _right-&gt;_data.string, _right-&gt;_next-&gt;_data.string);</a>
<a name="ln10833"> </a>
<a name="ln10834">				if (table)</a>
<a name="ln10835">				{</a>
<a name="ln10836">					_type = ast_opt_translate_table;</a>
<a name="ln10837">					_data.table = table;</a>
<a name="ln10838">				}</a>
<a name="ln10839">			}</a>
<a name="ln10840"> </a>
<a name="ln10841">			// Use optimized path for @attr = 'value' or @attr = $value</a>
<a name="ln10842">			if (_type == ast_op_equal &amp;&amp;</a>
<a name="ln10843">				_left-&gt;_type == ast_step &amp;&amp; _left-&gt;_axis == axis_attribute &amp;&amp; _left-&gt;_test == nodetest_name &amp;&amp; !_left-&gt;_left &amp;&amp; !_left-&gt;_right &amp;&amp;</a>
<a name="ln10844">				(_right-&gt;_type == ast_string_constant || (_right-&gt;_type == ast_variable &amp;&amp; _right-&gt;_rettype == xpath_type_string)))</a>
<a name="ln10845">			{</a>
<a name="ln10846">				_type = ast_opt_compare_attribute;</a>
<a name="ln10847">			}</a>
<a name="ln10848">		}</a>
<a name="ln10849"> </a>
<a name="ln10850">		bool is_posinv_expr() const</a>
<a name="ln10851">		{</a>
<a name="ln10852">			switch (_type)</a>
<a name="ln10853">			{</a>
<a name="ln10854">			case ast_func_position:</a>
<a name="ln10855">			case ast_func_last:</a>
<a name="ln10856">				return false;</a>
<a name="ln10857"> </a>
<a name="ln10858">			case ast_string_constant:</a>
<a name="ln10859">			case ast_number_constant:</a>
<a name="ln10860">			case ast_variable:</a>
<a name="ln10861">				return true;</a>
<a name="ln10862"> </a>
<a name="ln10863">			case ast_step:</a>
<a name="ln10864">			case ast_step_root:</a>
<a name="ln10865">				return true;</a>
<a name="ln10866"> </a>
<a name="ln10867">			case ast_predicate:</a>
<a name="ln10868">			case ast_filter:</a>
<a name="ln10869">				return true;</a>
<a name="ln10870"> </a>
<a name="ln10871">			default:</a>
<a name="ln10872">				if (_left &amp;&amp; !_left-&gt;is_posinv_expr()) return false;</a>
<a name="ln10873"> </a>
<a name="ln10874">				for (xpath_ast_node* n = _right; n; n = n-&gt;_next)</a>
<a name="ln10875">					if (!n-&gt;is_posinv_expr()) return false;</a>
<a name="ln10876"> </a>
<a name="ln10877">				return true;</a>
<a name="ln10878">			}</a>
<a name="ln10879">		}</a>
<a name="ln10880"> </a>
<a name="ln10881">		bool is_posinv_step() const</a>
<a name="ln10882">		{</a>
<a name="ln10883">			assert(_type == ast_step);</a>
<a name="ln10884"> </a>
<a name="ln10885">			for (xpath_ast_node* n = _right; n; n = n-&gt;_next)</a>
<a name="ln10886">			{</a>
<a name="ln10887">				assert(n-&gt;_type == ast_predicate);</a>
<a name="ln10888"> </a>
<a name="ln10889">				if (n-&gt;_test != predicate_posinv)</a>
<a name="ln10890">					return false;</a>
<a name="ln10891">			}</a>
<a name="ln10892"> </a>
<a name="ln10893">			return true;</a>
<a name="ln10894">		}</a>
<a name="ln10895"> </a>
<a name="ln10896">		xpath_value_type rettype() const</a>
<a name="ln10897">		{</a>
<a name="ln10898">			return static_cast&lt;xpath_value_type&gt;(_rettype);</a>
<a name="ln10899">		}</a>
<a name="ln10900">	};</a>
<a name="ln10901"> </a>
<a name="ln10902">	struct xpath_parser</a>
<a name="ln10903">	{</a>
<a name="ln10904">		xpath_allocator* _alloc;</a>
<a name="ln10905">		xpath_lexer _lexer;</a>
<a name="ln10906"> </a>
<a name="ln10907">		const char_t* _query;</a>
<a name="ln10908">		xpath_variable_set* _variables;</a>
<a name="ln10909"> </a>
<a name="ln10910">		xpath_parse_result* _result;</a>
<a name="ln10911"> </a>
<a name="ln10912">		char_t _scratch[32];</a>
<a name="ln10913"> </a>
<a name="ln10914">	#ifdef PUGIXML_NO_EXCEPTIONS</a>
<a name="ln10915">		jmp_buf _error_handler;</a>
<a name="ln10916">	#endif</a>
<a name="ln10917"> </a>
<a name="ln10918">		void throw_error(const char* message)</a>
<a name="ln10919">		{</a>
<a name="ln10920">			_result-&gt;error = message;</a>
<a name="ln10921">			_result-&gt;offset = _lexer.current_pos() - _query;</a>
<a name="ln10922"> </a>
<a name="ln10923">		#ifdef PUGIXML_NO_EXCEPTIONS</a>
<a name="ln10924">			longjmp(_error_handler, 1);</a>
<a name="ln10925">		#else</a>
<a name="ln10926">			throw xpath_exception(*_result);</a>
<a name="ln10927">		#endif</a>
<a name="ln10928">		}</a>
<a name="ln10929"> </a>
<a name="ln10930">		void throw_error_oom()</a>
<a name="ln10931">		{</a>
<a name="ln10932">		#ifdef PUGIXML_NO_EXCEPTIONS</a>
<a name="ln10933">			throw_error(&quot;Out of memory&quot;);</a>
<a name="ln10934">		#else</a>
<a name="ln10935">			throw std::bad_alloc();</a>
<a name="ln10936">		#endif</a>
<a name="ln10937">		}</a>
<a name="ln10938"> </a>
<a name="ln10939">		void* alloc_node()</a>
<a name="ln10940">		{</a>
<a name="ln10941">			void* result = _alloc-&gt;allocate_nothrow(sizeof(xpath_ast_node));</a>
<a name="ln10942"> </a>
<a name="ln10943">			if (!result) throw_error_oom();</a>
<a name="ln10944"> </a>
<a name="ln10945">			return result;</a>
<a name="ln10946">		}</a>
<a name="ln10947"> </a>
<a name="ln10948">		const char_t* alloc_string(const xpath_lexer_string&amp; value)</a>
<a name="ln10949">		{</a>
<a name="ln10950">			if (value.begin)</a>
<a name="ln10951">			{</a>
<a name="ln10952">				size_t length = static_cast&lt;size_t&gt;(value.end - value.begin);</a>
<a name="ln10953"> </a>
<a name="ln10954">				char_t* c = static_cast&lt;char_t*&gt;(_alloc-&gt;allocate_nothrow((length + 1) * sizeof(char_t)));</a>
<a name="ln10955">				if (!c) throw_error_oom();</a>
<a name="ln10956">				assert(c); // workaround for clang static analysis</a>
<a name="ln10957"> </a>
<a name="ln10958">				memcpy(c, value.begin, length * sizeof(char_t));</a>
<a name="ln10959">				c[length] = 0;</a>
<a name="ln10960"> </a>
<a name="ln10961">				return c;</a>
<a name="ln10962">			}</a>
<a name="ln10963">			else return 0;</a>
<a name="ln10964">		}</a>
<a name="ln10965"> </a>
<a name="ln10966">		xpath_ast_node* parse_function_helper(ast_type_t type0, ast_type_t type1, size_t argc, xpath_ast_node* args[2])</a>
<a name="ln10967">		{</a>
<a name="ln10968">			assert(argc &lt;= 1);</a>
<a name="ln10969"> </a>
<a name="ln10970">			if (argc == 1 &amp;&amp; args[0]-&gt;rettype() != xpath_type_node_set)</a>
<a name="ln10971">				throw_error(&quot;Function has to be applied to node set&quot;);</a>
<a name="ln10972"> </a>
<a name="ln10973">			return new (alloc_node()) xpath_ast_node(argc == 0 ? type0 : type1, xpath_type_string, args[0]);</a>
<a name="ln10974">		}</a>
<a name="ln10975"> </a>
<a name="ln10976">		xpath_ast_node* parse_function(const xpath_lexer_string&amp; name, size_t argc, xpath_ast_node* args[2])</a>
<a name="ln10977">		{</a>
<a name="ln10978">			switch (name.begin[0])</a>
<a name="ln10979">			{</a>
<a name="ln10980">			case 'b':</a>
<a name="ln10981">				if (name == PUGIXML_TEXT(&quot;boolean&quot;) &amp;&amp; argc == 1)</a>
<a name="ln10982">					return new (alloc_node()) xpath_ast_node(ast_func_boolean, xpath_type_boolean, args[0]);</a>
<a name="ln10983"> </a>
<a name="ln10984">				break;</a>
<a name="ln10985"> </a>
<a name="ln10986">			case 'c':</a>
<a name="ln10987">				if (name == PUGIXML_TEXT(&quot;count&quot;) &amp;&amp; argc == 1)</a>
<a name="ln10988">				{</a>
<a name="ln10989">					if (args[0]-&gt;rettype() != xpath_type_node_set)</a>
<a name="ln10990">						throw_error(&quot;Function has to be applied to node set&quot;);</a>
<a name="ln10991"> </a>
<a name="ln10992">					return new (alloc_node()) xpath_ast_node(ast_func_count, xpath_type_number, args[0]);</a>
<a name="ln10993">				}</a>
<a name="ln10994">				else if (name == PUGIXML_TEXT(&quot;contains&quot;) &amp;&amp; argc == 2)</a>
<a name="ln10995">					return new (alloc_node()) xpath_ast_node(ast_func_contains, xpath_type_boolean, args[0], args[1]);</a>
<a name="ln10996">				else if (name == PUGIXML_TEXT(&quot;concat&quot;) &amp;&amp; argc &gt;= 2)</a>
<a name="ln10997">					return new (alloc_node()) xpath_ast_node(ast_func_concat, xpath_type_string, args[0], args[1]);</a>
<a name="ln10998">				else if (name == PUGIXML_TEXT(&quot;ceiling&quot;) &amp;&amp; argc == 1)</a>
<a name="ln10999">					return new (alloc_node()) xpath_ast_node(ast_func_ceiling, xpath_type_number, args[0]);</a>
<a name="ln11000"> </a>
<a name="ln11001">				break;</a>
<a name="ln11002"> </a>
<a name="ln11003">			case 'f':</a>
<a name="ln11004">				if (name == PUGIXML_TEXT(&quot;false&quot;) &amp;&amp; argc == 0)</a>
<a name="ln11005">					return new (alloc_node()) xpath_ast_node(ast_func_false, xpath_type_boolean);</a>
<a name="ln11006">				else if (name == PUGIXML_TEXT(&quot;floor&quot;) &amp;&amp; argc == 1)</a>
<a name="ln11007">					return new (alloc_node()) xpath_ast_node(ast_func_floor, xpath_type_number, args[0]);</a>
<a name="ln11008"> </a>
<a name="ln11009">				break;</a>
<a name="ln11010"> </a>
<a name="ln11011">			case 'i':</a>
<a name="ln11012">				if (name == PUGIXML_TEXT(&quot;id&quot;) &amp;&amp; argc == 1)</a>
<a name="ln11013">					return new (alloc_node()) xpath_ast_node(ast_func_id, xpath_type_node_set, args[0]);</a>
<a name="ln11014"> </a>
<a name="ln11015">				break;</a>
<a name="ln11016"> </a>
<a name="ln11017">			case 'l':</a>
<a name="ln11018">				if (name == PUGIXML_TEXT(&quot;last&quot;) &amp;&amp; argc == 0)</a>
<a name="ln11019">					return new (alloc_node()) xpath_ast_node(ast_func_last, xpath_type_number);</a>
<a name="ln11020">				else if (name == PUGIXML_TEXT(&quot;lang&quot;) &amp;&amp; argc == 1)</a>
<a name="ln11021">					return new (alloc_node()) xpath_ast_node(ast_func_lang, xpath_type_boolean, args[0]);</a>
<a name="ln11022">				else if (name == PUGIXML_TEXT(&quot;local-name&quot;) &amp;&amp; argc &lt;= 1)</a>
<a name="ln11023">					return parse_function_helper(ast_func_local_name_0, ast_func_local_name_1, argc, args);</a>
<a name="ln11024"> </a>
<a name="ln11025">				break;</a>
<a name="ln11026"> </a>
<a name="ln11027">			case 'n':</a>
<a name="ln11028">				if (name == PUGIXML_TEXT(&quot;name&quot;) &amp;&amp; argc &lt;= 1)</a>
<a name="ln11029">					return parse_function_helper(ast_func_name_0, ast_func_name_1, argc, args);</a>
<a name="ln11030">				else if (name == PUGIXML_TEXT(&quot;namespace-uri&quot;) &amp;&amp; argc &lt;= 1)</a>
<a name="ln11031">					return parse_function_helper(ast_func_namespace_uri_0, ast_func_namespace_uri_1, argc, args);</a>
<a name="ln11032">				else if (name == PUGIXML_TEXT(&quot;normalize-space&quot;) &amp;&amp; argc &lt;= 1)</a>
<a name="ln11033">					return new (alloc_node()) xpath_ast_node(argc == 0 ? ast_func_normalize_space_0 : ast_func_normalize_space_1, xpath_type_string, args[0], args[1]);</a>
<a name="ln11034">				else if (name == PUGIXML_TEXT(&quot;not&quot;) &amp;&amp; argc == 1)</a>
<a name="ln11035">					return new (alloc_node()) xpath_ast_node(ast_func_not, xpath_type_boolean, args[0]);</a>
<a name="ln11036">				else if (name == PUGIXML_TEXT(&quot;number&quot;) &amp;&amp; argc &lt;= 1)</a>
<a name="ln11037">					return new (alloc_node()) xpath_ast_node(argc == 0 ? ast_func_number_0 : ast_func_number_1, xpath_type_number, args[0]);</a>
<a name="ln11038"> </a>
<a name="ln11039">				break;</a>
<a name="ln11040"> </a>
<a name="ln11041">			case 'p':</a>
<a name="ln11042">				if (name == PUGIXML_TEXT(&quot;position&quot;) &amp;&amp; argc == 0)</a>
<a name="ln11043">					return new (alloc_node()) xpath_ast_node(ast_func_position, xpath_type_number);</a>
<a name="ln11044"> </a>
<a name="ln11045">				break;</a>
<a name="ln11046"> </a>
<a name="ln11047">			case 'r':</a>
<a name="ln11048">				if (name == PUGIXML_TEXT(&quot;round&quot;) &amp;&amp; argc == 1)</a>
<a name="ln11049">					return new (alloc_node()) xpath_ast_node(ast_func_round, xpath_type_number, args[0]);</a>
<a name="ln11050"> </a>
<a name="ln11051">				break;</a>
<a name="ln11052"> </a>
<a name="ln11053">			case 's':</a>
<a name="ln11054">				if (name == PUGIXML_TEXT(&quot;string&quot;) &amp;&amp; argc &lt;= 1)</a>
<a name="ln11055">					return new (alloc_node()) xpath_ast_node(argc == 0 ? ast_func_string_0 : ast_func_string_1, xpath_type_string, args[0]);</a>
<a name="ln11056">				else if (name == PUGIXML_TEXT(&quot;string-length&quot;) &amp;&amp; argc &lt;= 1)</a>
<a name="ln11057">					return new (alloc_node()) xpath_ast_node(argc == 0 ? ast_func_string_length_0 : ast_func_string_length_1, xpath_type_number, args[0]);</a>
<a name="ln11058">				else if (name == PUGIXML_TEXT(&quot;starts-with&quot;) &amp;&amp; argc == 2)</a>
<a name="ln11059">					return new (alloc_node()) xpath_ast_node(ast_func_starts_with, xpath_type_boolean, args[0], args[1]);</a>
<a name="ln11060">				else if (name == PUGIXML_TEXT(&quot;substring-before&quot;) &amp;&amp; argc == 2)</a>
<a name="ln11061">					return new (alloc_node()) xpath_ast_node(ast_func_substring_before, xpath_type_string, args[0], args[1]);</a>
<a name="ln11062">				else if (name == PUGIXML_TEXT(&quot;substring-after&quot;) &amp;&amp; argc == 2)</a>
<a name="ln11063">					return new (alloc_node()) xpath_ast_node(ast_func_substring_after, xpath_type_string, args[0], args[1]);</a>
<a name="ln11064">				else if (name == PUGIXML_TEXT(&quot;substring&quot;) &amp;&amp; (argc == 2 || argc == 3))</a>
<a name="ln11065">					return new (alloc_node()) xpath_ast_node(argc == 2 ? ast_func_substring_2 : ast_func_substring_3, xpath_type_string, args[0], args[1]);</a>
<a name="ln11066">				else if (name == PUGIXML_TEXT(&quot;sum&quot;) &amp;&amp; argc == 1)</a>
<a name="ln11067">				{</a>
<a name="ln11068">					if (args[0]-&gt;rettype() != xpath_type_node_set) throw_error(&quot;Function has to be applied to node set&quot;);</a>
<a name="ln11069">					return new (alloc_node()) xpath_ast_node(ast_func_sum, xpath_type_number, args[0]);</a>
<a name="ln11070">				}</a>
<a name="ln11071"> </a>
<a name="ln11072">				break;</a>
<a name="ln11073"> </a>
<a name="ln11074">			case 't':</a>
<a name="ln11075">				if (name == PUGIXML_TEXT(&quot;translate&quot;) &amp;&amp; argc == 3)</a>
<a name="ln11076">					return new (alloc_node()) xpath_ast_node(ast_func_translate, xpath_type_string, args[0], args[1]);</a>
<a name="ln11077">				else if (name == PUGIXML_TEXT(&quot;true&quot;) &amp;&amp; argc == 0)</a>
<a name="ln11078">					return new (alloc_node()) xpath_ast_node(ast_func_true, xpath_type_boolean);</a>
<a name="ln11079"> </a>
<a name="ln11080">				break;</a>
<a name="ln11081"> </a>
<a name="ln11082">			default:</a>
<a name="ln11083">				break;</a>
<a name="ln11084">			}</a>
<a name="ln11085"> </a>
<a name="ln11086">			throw_error(&quot;Unrecognized function or wrong parameter count&quot;);</a>
<a name="ln11087"> </a>
<a name="ln11088">			return 0;</a>
<a name="ln11089">		}</a>
<a name="ln11090"> </a>
<a name="ln11091">		axis_t parse_axis_name(const xpath_lexer_string&amp; name, bool&amp; specified)</a>
<a name="ln11092">		{</a>
<a name="ln11093">			specified = true;</a>
<a name="ln11094"> </a>
<a name="ln11095">			switch (name.begin[0])</a>
<a name="ln11096">			{</a>
<a name="ln11097">			case 'a':</a>
<a name="ln11098">				if (name == PUGIXML_TEXT(&quot;ancestor&quot;))</a>
<a name="ln11099">					return axis_ancestor;</a>
<a name="ln11100">				else if (name == PUGIXML_TEXT(&quot;ancestor-or-self&quot;))</a>
<a name="ln11101">					return axis_ancestor_or_self;</a>
<a name="ln11102">				else if (name == PUGIXML_TEXT(&quot;attribute&quot;))</a>
<a name="ln11103">					return axis_attribute;</a>
<a name="ln11104"> </a>
<a name="ln11105">				break;</a>
<a name="ln11106"> </a>
<a name="ln11107">			case 'c':</a>
<a name="ln11108">				if (name == PUGIXML_TEXT(&quot;child&quot;))</a>
<a name="ln11109">					return axis_child;</a>
<a name="ln11110"> </a>
<a name="ln11111">				break;</a>
<a name="ln11112"> </a>
<a name="ln11113">			case 'd':</a>
<a name="ln11114">				if (name == PUGIXML_TEXT(&quot;descendant&quot;))</a>
<a name="ln11115">					return axis_descendant;</a>
<a name="ln11116">				else if (name == PUGIXML_TEXT(&quot;descendant-or-self&quot;))</a>
<a name="ln11117">					return axis_descendant_or_self;</a>
<a name="ln11118"> </a>
<a name="ln11119">				break;</a>
<a name="ln11120"> </a>
<a name="ln11121">			case 'f':</a>
<a name="ln11122">				if (name == PUGIXML_TEXT(&quot;following&quot;))</a>
<a name="ln11123">					return axis_following;</a>
<a name="ln11124">				else if (name == PUGIXML_TEXT(&quot;following-sibling&quot;))</a>
<a name="ln11125">					return axis_following_sibling;</a>
<a name="ln11126"> </a>
<a name="ln11127">				break;</a>
<a name="ln11128"> </a>
<a name="ln11129">			case 'n':</a>
<a name="ln11130">				if (name == PUGIXML_TEXT(&quot;namespace&quot;))</a>
<a name="ln11131">					return axis_namespace;</a>
<a name="ln11132"> </a>
<a name="ln11133">				break;</a>
<a name="ln11134"> </a>
<a name="ln11135">			case 'p':</a>
<a name="ln11136">				if (name == PUGIXML_TEXT(&quot;parent&quot;))</a>
<a name="ln11137">					return axis_parent;</a>
<a name="ln11138">				else if (name == PUGIXML_TEXT(&quot;preceding&quot;))</a>
<a name="ln11139">					return axis_preceding;</a>
<a name="ln11140">				else if (name == PUGIXML_TEXT(&quot;preceding-sibling&quot;))</a>
<a name="ln11141">					return axis_preceding_sibling;</a>
<a name="ln11142"> </a>
<a name="ln11143">				break;</a>
<a name="ln11144"> </a>
<a name="ln11145">			case 's':</a>
<a name="ln11146">				if (name == PUGIXML_TEXT(&quot;self&quot;))</a>
<a name="ln11147">					return axis_self;</a>
<a name="ln11148"> </a>
<a name="ln11149">				break;</a>
<a name="ln11150"> </a>
<a name="ln11151">			default:</a>
<a name="ln11152">				break;</a>
<a name="ln11153">			}</a>
<a name="ln11154"> </a>
<a name="ln11155">			specified = false;</a>
<a name="ln11156">			return axis_child;</a>
<a name="ln11157">		}</a>
<a name="ln11158"> </a>
<a name="ln11159">		nodetest_t parse_node_test_type(const xpath_lexer_string&amp; name)</a>
<a name="ln11160">		{</a>
<a name="ln11161">			switch (name.begin[0])</a>
<a name="ln11162">			{</a>
<a name="ln11163">			case 'c':</a>
<a name="ln11164">				if (name == PUGIXML_TEXT(&quot;comment&quot;))</a>
<a name="ln11165">					return nodetest_type_comment;</a>
<a name="ln11166"> </a>
<a name="ln11167">				break;</a>
<a name="ln11168"> </a>
<a name="ln11169">			case 'n':</a>
<a name="ln11170">				if (name == PUGIXML_TEXT(&quot;node&quot;))</a>
<a name="ln11171">					return nodetest_type_node;</a>
<a name="ln11172"> </a>
<a name="ln11173">				break;</a>
<a name="ln11174"> </a>
<a name="ln11175">			case 'p':</a>
<a name="ln11176">				if (name == PUGIXML_TEXT(&quot;processing-instruction&quot;))</a>
<a name="ln11177">					return nodetest_type_pi;</a>
<a name="ln11178"> </a>
<a name="ln11179">				break;</a>
<a name="ln11180"> </a>
<a name="ln11181">			case 't':</a>
<a name="ln11182">				if (name == PUGIXML_TEXT(&quot;text&quot;))</a>
<a name="ln11183">					return nodetest_type_text;</a>
<a name="ln11184"> </a>
<a name="ln11185">				break;</a>
<a name="ln11186"> </a>
<a name="ln11187">			default:</a>
<a name="ln11188">				break;</a>
<a name="ln11189">			}</a>
<a name="ln11190"> </a>
<a name="ln11191">			return nodetest_none;</a>
<a name="ln11192">		}</a>
<a name="ln11193"> </a>
<a name="ln11194">		// PrimaryExpr ::= VariableReference | '(' Expr ')' | Literal | Number | FunctionCall</a>
<a name="ln11195">		xpath_ast_node* parse_primary_expression()</a>
<a name="ln11196">		{</a>
<a name="ln11197">			switch (_lexer.current())</a>
<a name="ln11198">			{</a>
<a name="ln11199">			case lex_var_ref:</a>
<a name="ln11200">			{</a>
<a name="ln11201">				xpath_lexer_string name = _lexer.contents();</a>
<a name="ln11202"> </a>
<a name="ln11203">				if (!_variables)</a>
<a name="ln11204">					throw_error(&quot;Unknown variable: variable set is not provided&quot;);</a>
<a name="ln11205"> </a>
<a name="ln11206">				xpath_variable* var = 0;</a>
<a name="ln11207">				if (!get_variable_scratch(_scratch, _variables, name.begin, name.end, &amp;var))</a>
<a name="ln11208">					throw_error_oom();</a>
<a name="ln11209"> </a>
<a name="ln11210">				if (!var)</a>
<a name="ln11211">					throw_error(&quot;Unknown variable: variable set does not contain the given name&quot;);</a>
<a name="ln11212"> </a>
<a name="ln11213">				_lexer.next();</a>
<a name="ln11214"> </a>
<a name="ln11215">				return new (alloc_node()) xpath_ast_node(ast_variable, var-&gt;type(), var);</a>
<a name="ln11216">			}</a>
<a name="ln11217"> </a>
<a name="ln11218">			case lex_open_brace:</a>
<a name="ln11219">			{</a>
<a name="ln11220">				_lexer.next();</a>
<a name="ln11221"> </a>
<a name="ln11222">				xpath_ast_node* n = parse_expression();</a>
<a name="ln11223"> </a>
<a name="ln11224">				if (_lexer.current() != lex_close_brace)</a>
<a name="ln11225">					throw_error(&quot;Unmatched braces&quot;);</a>
<a name="ln11226"> </a>
<a name="ln11227">				_lexer.next();</a>
<a name="ln11228"> </a>
<a name="ln11229">				return n;</a>
<a name="ln11230">			}</a>
<a name="ln11231"> </a>
<a name="ln11232">			case lex_quoted_string:</a>
<a name="ln11233">			{</a>
<a name="ln11234">				const char_t* value = alloc_string(_lexer.contents());</a>
<a name="ln11235"> </a>
<a name="ln11236">				xpath_ast_node* n = new (alloc_node()) xpath_ast_node(ast_string_constant, xpath_type_string, value);</a>
<a name="ln11237">				_lexer.next();</a>
<a name="ln11238"> </a>
<a name="ln11239">				return n;</a>
<a name="ln11240">			}</a>
<a name="ln11241"> </a>
<a name="ln11242">			case lex_number:</a>
<a name="ln11243">			{</a>
<a name="ln11244">				double value = 0;</a>
<a name="ln11245"> </a>
<a name="ln11246">				if (!convert_string_to_number_scratch(_scratch, _lexer.contents().begin, _lexer.contents().end, &amp;value))</a>
<a name="ln11247">					throw_error_oom();</a>
<a name="ln11248"> </a>
<a name="ln11249">				xpath_ast_node* n = new (alloc_node()) xpath_ast_node(ast_number_constant, xpath_type_number, value);</a>
<a name="ln11250">				_lexer.next();</a>
<a name="ln11251"> </a>
<a name="ln11252">				return n;</a>
<a name="ln11253">			}</a>
<a name="ln11254"> </a>
<a name="ln11255">			case lex_string:</a>
<a name="ln11256">			{</a>
<a name="ln11257">				xpath_ast_node* args[2] = {0};</a>
<a name="ln11258">				size_t argc = 0;</a>
<a name="ln11259"> </a>
<a name="ln11260">				xpath_lexer_string function = _lexer.contents();</a>
<a name="ln11261">				_lexer.next();</a>
<a name="ln11262"> </a>
<a name="ln11263">				xpath_ast_node* last_arg = 0;</a>
<a name="ln11264"> </a>
<a name="ln11265">				if (_lexer.current() != lex_open_brace)</a>
<a name="ln11266">					throw_error(&quot;Unrecognized function call&quot;);</a>
<a name="ln11267">				_lexer.next();</a>
<a name="ln11268"> </a>
<a name="ln11269">				if (_lexer.current() != lex_close_brace)</a>
<a name="ln11270">					args[argc++] = parse_expression();</a>
<a name="ln11271"> </a>
<a name="ln11272">				while (_lexer.current() != lex_close_brace)</a>
<a name="ln11273">				{</a>
<a name="ln11274">					if (_lexer.current() != lex_comma)</a>
<a name="ln11275">						throw_error(&quot;No comma between function arguments&quot;);</a>
<a name="ln11276">					_lexer.next();</a>
<a name="ln11277"> </a>
<a name="ln11278">					xpath_ast_node* n = parse_expression();</a>
<a name="ln11279"> </a>
<a name="ln11280">					if (argc &lt; 2) args[argc] = n;</a>
<a name="ln11281">					else last_arg-&gt;set_next(n);</a>
<a name="ln11282"> </a>
<a name="ln11283">					argc++;</a>
<a name="ln11284">					last_arg = n;</a>
<a name="ln11285">				}</a>
<a name="ln11286"> </a>
<a name="ln11287">				_lexer.next();</a>
<a name="ln11288"> </a>
<a name="ln11289">				return parse_function(function, argc, args);</a>
<a name="ln11290">			}</a>
<a name="ln11291"> </a>
<a name="ln11292">			default:</a>
<a name="ln11293">				throw_error(&quot;Unrecognizable primary expression&quot;);</a>
<a name="ln11294"> </a>
<a name="ln11295">				return 0;</a>
<a name="ln11296">			}</a>
<a name="ln11297">		}</a>
<a name="ln11298"> </a>
<a name="ln11299">		// FilterExpr ::= PrimaryExpr | FilterExpr Predicate</a>
<a name="ln11300">		// Predicate ::= '[' PredicateExpr ']'</a>
<a name="ln11301">		// PredicateExpr ::= Expr</a>
<a name="ln11302">		xpath_ast_node* parse_filter_expression()</a>
<a name="ln11303">		{</a>
<a name="ln11304">			xpath_ast_node* n = parse_primary_expression();</a>
<a name="ln11305"> </a>
<a name="ln11306">			while (_lexer.current() == lex_open_square_brace)</a>
<a name="ln11307">			{</a>
<a name="ln11308">				_lexer.next();</a>
<a name="ln11309"> </a>
<a name="ln11310">				xpath_ast_node* expr = parse_expression();</a>
<a name="ln11311"> </a>
<a name="ln11312">				if (n-&gt;rettype() != xpath_type_node_set)</a>
<a name="ln11313">					throw_error(&quot;Predicate has to be applied to node set&quot;);</a>
<a name="ln11314"> </a>
<a name="ln11315">				n = new (alloc_node()) xpath_ast_node(ast_filter, n, expr, predicate_default);</a>
<a name="ln11316"> </a>
<a name="ln11317">				if (_lexer.current() != lex_close_square_brace)</a>
<a name="ln11318">					throw_error(&quot;Unmatched square brace&quot;);</a>
<a name="ln11319"> </a>
<a name="ln11320">				_lexer.next();</a>
<a name="ln11321">			}</a>
<a name="ln11322"> </a>
<a name="ln11323">			return n;</a>
<a name="ln11324">		}</a>
<a name="ln11325"> </a>
<a name="ln11326">		// Step ::= AxisSpecifier NodeTest Predicate* | AbbreviatedStep</a>
<a name="ln11327">		// AxisSpecifier ::= AxisName '::' | '@'?</a>
<a name="ln11328">		// NodeTest ::= NameTest | NodeType '(' ')' | 'processing-instruction' '(' Literal ')'</a>
<a name="ln11329">		// NameTest ::= '*' | NCName ':' '*' | QName</a>
<a name="ln11330">		// AbbreviatedStep ::= '.' | '..'</a>
<a name="ln11331">		xpath_ast_node* parse_step(xpath_ast_node* set)</a>
<a name="ln11332">		{</a>
<a name="ln11333">			if (set &amp;&amp; set-&gt;rettype() != xpath_type_node_set)</a>
<a name="ln11334">				throw_error(&quot;Step has to be applied to node set&quot;);</a>
<a name="ln11335"> </a>
<a name="ln11336">			bool axis_specified = false;</a>
<a name="ln11337">			axis_t axis = axis_child; // implied child axis</a>
<a name="ln11338"> </a>
<a name="ln11339">			if (_lexer.current() == lex_axis_attribute)</a>
<a name="ln11340">			{</a>
<a name="ln11341">				axis = axis_attribute;</a>
<a name="ln11342">				axis_specified = true;</a>
<a name="ln11343"> </a>
<a name="ln11344">				_lexer.next();</a>
<a name="ln11345">			}</a>
<a name="ln11346">			else if (_lexer.current() == lex_dot)</a>
<a name="ln11347">			{</a>
<a name="ln11348">				_lexer.next();</a>
<a name="ln11349"> </a>
<a name="ln11350">				return new (alloc_node()) xpath_ast_node(ast_step, set, axis_self, nodetest_type_node, 0);</a>
<a name="ln11351">			}</a>
<a name="ln11352">			else if (_lexer.current() == lex_double_dot)</a>
<a name="ln11353">			{</a>
<a name="ln11354">				_lexer.next();</a>
<a name="ln11355"> </a>
<a name="ln11356">				return new (alloc_node()) xpath_ast_node(ast_step, set, axis_parent, nodetest_type_node, 0);</a>
<a name="ln11357">			}</a>
<a name="ln11358"> </a>
<a name="ln11359">			nodetest_t nt_type = nodetest_none;</a>
<a name="ln11360">			xpath_lexer_string nt_name;</a>
<a name="ln11361"> </a>
<a name="ln11362">			if (_lexer.current() == lex_string)</a>
<a name="ln11363">			{</a>
<a name="ln11364">				// node name test</a>
<a name="ln11365">				nt_name = _lexer.contents();</a>
<a name="ln11366">				_lexer.next();</a>
<a name="ln11367"> </a>
<a name="ln11368">				// was it an axis name?</a>
<a name="ln11369">				if (_lexer.current() == lex_double_colon)</a>
<a name="ln11370">				{</a>
<a name="ln11371">					// parse axis name</a>
<a name="ln11372">					if (axis_specified)</a>
<a name="ln11373">						throw_error(&quot;Two axis specifiers in one step&quot;);</a>
<a name="ln11374"> </a>
<a name="ln11375">					axis = parse_axis_name(nt_name, axis_specified);</a>
<a name="ln11376"> </a>
<a name="ln11377">					if (!axis_specified)</a>
<a name="ln11378">						throw_error(&quot;Unknown axis&quot;);</a>
<a name="ln11379"> </a>
<a name="ln11380">					// read actual node test</a>
<a name="ln11381">					_lexer.next();</a>
<a name="ln11382"> </a>
<a name="ln11383">					if (_lexer.current() == lex_multiply)</a>
<a name="ln11384">					{</a>
<a name="ln11385">						nt_type = nodetest_all;</a>
<a name="ln11386">						nt_name = xpath_lexer_string();</a>
<a name="ln11387">						_lexer.next();</a>
<a name="ln11388">					}</a>
<a name="ln11389">					else if (_lexer.current() == lex_string)</a>
<a name="ln11390">					{</a>
<a name="ln11391">						nt_name = _lexer.contents();</a>
<a name="ln11392">						_lexer.next();</a>
<a name="ln11393">					}</a>
<a name="ln11394">					else throw_error(&quot;Unrecognized node test&quot;);</a>
<a name="ln11395">				}</a>
<a name="ln11396"> </a>
<a name="ln11397">				if (nt_type == nodetest_none)</a>
<a name="ln11398">				{</a>
<a name="ln11399">					// node type test or processing-instruction</a>
<a name="ln11400">					if (_lexer.current() == lex_open_brace)</a>
<a name="ln11401">					{</a>
<a name="ln11402">						_lexer.next();</a>
<a name="ln11403"> </a>
<a name="ln11404">						if (_lexer.current() == lex_close_brace)</a>
<a name="ln11405">						{</a>
<a name="ln11406">							_lexer.next();</a>
<a name="ln11407"> </a>
<a name="ln11408">							nt_type = parse_node_test_type(nt_name);</a>
<a name="ln11409"> </a>
<a name="ln11410">							if (nt_type == nodetest_none)</a>
<a name="ln11411">								throw_error(&quot;Unrecognized node type&quot;);</a>
<a name="ln11412"> </a>
<a name="ln11413">							nt_name = xpath_lexer_string();</a>
<a name="ln11414">						}</a>
<a name="ln11415">						else if (nt_name == PUGIXML_TEXT(&quot;processing-instruction&quot;))</a>
<a name="ln11416">						{</a>
<a name="ln11417">							if (_lexer.current() != lex_quoted_string)</a>
<a name="ln11418">								throw_error(&quot;Only literals are allowed as arguments to processing-instruction()&quot;);</a>
<a name="ln11419"> </a>
<a name="ln11420">							nt_type = nodetest_pi;</a>
<a name="ln11421">							nt_name = _lexer.contents();</a>
<a name="ln11422">							_lexer.next();</a>
<a name="ln11423"> </a>
<a name="ln11424">							if (_lexer.current() != lex_close_brace)</a>
<a name="ln11425">								throw_error(&quot;Unmatched brace near processing-instruction()&quot;);</a>
<a name="ln11426">							_lexer.next();</a>
<a name="ln11427">						}</a>
<a name="ln11428">						else</a>
<a name="ln11429">						{</a>
<a name="ln11430">							throw_error(&quot;Unmatched brace near node type test&quot;);</a>
<a name="ln11431">						}</a>
<a name="ln11432">					}</a>
<a name="ln11433">					// QName or NCName:*</a>
<a name="ln11434">					else</a>
<a name="ln11435">					{</a>
<a name="ln11436">						if (nt_name.end - nt_name.begin &gt; 2 &amp;&amp; nt_name.end[-2] == ':' &amp;&amp; nt_name.end[-1] == '*') // NCName:*</a>
<a name="ln11437">						{</a>
<a name="ln11438">							nt_name.end--; // erase *</a>
<a name="ln11439"> </a>
<a name="ln11440">							nt_type = nodetest_all_in_namespace;</a>
<a name="ln11441">						}</a>
<a name="ln11442">						else</a>
<a name="ln11443">						{</a>
<a name="ln11444">							nt_type = nodetest_name;</a>
<a name="ln11445">						}</a>
<a name="ln11446">					}</a>
<a name="ln11447">				}</a>
<a name="ln11448">			}</a>
<a name="ln11449">			else if (_lexer.current() == lex_multiply)</a>
<a name="ln11450">			{</a>
<a name="ln11451">				nt_type = nodetest_all;</a>
<a name="ln11452">				_lexer.next();</a>
<a name="ln11453">			}</a>
<a name="ln11454">			else</a>
<a name="ln11455">			{</a>
<a name="ln11456">				throw_error(&quot;Unrecognized node test&quot;);</a>
<a name="ln11457">			}</a>
<a name="ln11458"> </a>
<a name="ln11459">			const char_t* nt_name_copy = alloc_string(nt_name);</a>
<a name="ln11460">			xpath_ast_node* n = new (alloc_node()) xpath_ast_node(ast_step, set, axis, nt_type, nt_name_copy);</a>
<a name="ln11461"> </a>
<a name="ln11462">			xpath_ast_node* last = 0;</a>
<a name="ln11463"> </a>
<a name="ln11464">			while (_lexer.current() == lex_open_square_brace)</a>
<a name="ln11465">			{</a>
<a name="ln11466">				_lexer.next();</a>
<a name="ln11467"> </a>
<a name="ln11468">				xpath_ast_node* expr = parse_expression();</a>
<a name="ln11469"> </a>
<a name="ln11470">				xpath_ast_node* pred = new (alloc_node()) xpath_ast_node(ast_predicate, 0, expr, predicate_default);</a>
<a name="ln11471"> </a>
<a name="ln11472">				if (_lexer.current() != lex_close_square_brace)</a>
<a name="ln11473">					throw_error(&quot;Unmatched square brace&quot;);</a>
<a name="ln11474">				_lexer.next();</a>
<a name="ln11475"> </a>
<a name="ln11476">				if (last) last-&gt;set_next(pred);</a>
<a name="ln11477">				else n-&gt;set_right(pred);</a>
<a name="ln11478"> </a>
<a name="ln11479">				last = pred;</a>
<a name="ln11480">			}</a>
<a name="ln11481"> </a>
<a name="ln11482">			return n;</a>
<a name="ln11483">		}</a>
<a name="ln11484"> </a>
<a name="ln11485">		// RelativeLocationPath ::= Step | RelativeLocationPath '/' Step | RelativeLocationPath '//' Step</a>
<a name="ln11486">		xpath_ast_node* parse_relative_location_path(xpath_ast_node* set)</a>
<a name="ln11487">		{</a>
<a name="ln11488">			xpath_ast_node* n = parse_step(set);</a>
<a name="ln11489"> </a>
<a name="ln11490">			while (_lexer.current() == lex_slash || _lexer.current() == lex_double_slash)</a>
<a name="ln11491">			{</a>
<a name="ln11492">				lexeme_t l = _lexer.current();</a>
<a name="ln11493">				_lexer.next();</a>
<a name="ln11494"> </a>
<a name="ln11495">				if (l == lex_double_slash)</a>
<a name="ln11496">					n = new (alloc_node()) xpath_ast_node(ast_step, n, axis_descendant_or_self, nodetest_type_node, 0);</a>
<a name="ln11497"> </a>
<a name="ln11498">				n = parse_step(n);</a>
<a name="ln11499">			}</a>
<a name="ln11500"> </a>
<a name="ln11501">			return n;</a>
<a name="ln11502">		}</a>
<a name="ln11503"> </a>
<a name="ln11504">		// LocationPath ::= RelativeLocationPath | AbsoluteLocationPath</a>
<a name="ln11505">		// AbsoluteLocationPath ::= '/' RelativeLocationPath? | '//' RelativeLocationPath</a>
<a name="ln11506">		xpath_ast_node* parse_location_path()</a>
<a name="ln11507">		{</a>
<a name="ln11508">			if (_lexer.current() == lex_slash)</a>
<a name="ln11509">			{</a>
<a name="ln11510">				_lexer.next();</a>
<a name="ln11511"> </a>
<a name="ln11512">				xpath_ast_node* n = new (alloc_node()) xpath_ast_node(ast_step_root, xpath_type_node_set);</a>
<a name="ln11513"> </a>
<a name="ln11514">				// relative location path can start from axis_attribute, dot, double_dot, multiply and string lexemes; any other lexeme means standalone root path</a>
<a name="ln11515">				lexeme_t l = _lexer.current();</a>
<a name="ln11516"> </a>
<a name="ln11517">				if (l == lex_string || l == lex_axis_attribute || l == lex_dot || l == lex_double_dot || l == lex_multiply)</a>
<a name="ln11518">					return parse_relative_location_path(n);</a>
<a name="ln11519">				else</a>
<a name="ln11520">					return n;</a>
<a name="ln11521">			}</a>
<a name="ln11522">			else if (_lexer.current() == lex_double_slash)</a>
<a name="ln11523">			{</a>
<a name="ln11524">				_lexer.next();</a>
<a name="ln11525"> </a>
<a name="ln11526">				xpath_ast_node* n = new (alloc_node()) xpath_ast_node(ast_step_root, xpath_type_node_set);</a>
<a name="ln11527">				n = new (alloc_node()) xpath_ast_node(ast_step, n, axis_descendant_or_self, nodetest_type_node, 0);</a>
<a name="ln11528"> </a>
<a name="ln11529">				return parse_relative_location_path(n);</a>
<a name="ln11530">			}</a>
<a name="ln11531"> </a>
<a name="ln11532">			// else clause moved outside of if because of bogus warning 'control may reach end of non-void function being inlined' in gcc 4.0.1</a>
<a name="ln11533">			return parse_relative_location_path(0);</a>
<a name="ln11534">		}</a>
<a name="ln11535"> </a>
<a name="ln11536">		// PathExpr ::= LocationPath</a>
<a name="ln11537">		//				| FilterExpr</a>
<a name="ln11538">		//				| FilterExpr '/' RelativeLocationPath</a>
<a name="ln11539">		//				| FilterExpr '//' RelativeLocationPath</a>
<a name="ln11540">		// UnionExpr ::= PathExpr | UnionExpr '|' PathExpr</a>
<a name="ln11541">		// UnaryExpr ::= UnionExpr | '-' UnaryExpr</a>
<a name="ln11542">		xpath_ast_node* parse_path_or_unary_expression()</a>
<a name="ln11543">		{</a>
<a name="ln11544">			// Clarification.</a>
<a name="ln11545">			// PathExpr begins with either LocationPath or FilterExpr.</a>
<a name="ln11546">			// FilterExpr begins with PrimaryExpr</a>
<a name="ln11547">			// PrimaryExpr begins with '$' in case of it being a variable reference,</a>
<a name="ln11548">			// '(' in case of it being an expression, string literal, number constant or</a>
<a name="ln11549">			// function call.</a>
<a name="ln11550"> </a>
<a name="ln11551">			if (_lexer.current() == lex_var_ref || _lexer.current() == lex_open_brace ||</a>
<a name="ln11552">				_lexer.current() == lex_quoted_string || _lexer.current() == lex_number ||</a>
<a name="ln11553">				_lexer.current() == lex_string)</a>
<a name="ln11554">			{</a>
<a name="ln11555">				if (_lexer.current() == lex_string)</a>
<a name="ln11556">				{</a>
<a name="ln11557">					// This is either a function call, or not - if not, we shall proceed with location path</a>
<a name="ln11558">					const char_t* state = _lexer.state();</a>
<a name="ln11559"> </a>
<a name="ln11560">					while (PUGI__IS_CHARTYPE(*state, ct_space)) ++state;</a>
<a name="ln11561"> </a>
<a name="ln11562">					if (*state != '(') return parse_location_path();</a>
<a name="ln11563"> </a>
<a name="ln11564">					// This looks like a function call; however this still can be a node-test. Check it.</a>
<a name="ln11565">					if (parse_node_test_type(_lexer.contents()) != nodetest_none)</a>
<a name="ln11566">						return parse_location_path();</a>
<a name="ln11567">				}</a>
<a name="ln11568"> </a>
<a name="ln11569">				xpath_ast_node* n = parse_filter_expression();</a>
<a name="ln11570"> </a>
<a name="ln11571">				if (_lexer.current() == lex_slash || _lexer.current() == lex_double_slash)</a>
<a name="ln11572">				{</a>
<a name="ln11573">					lexeme_t l = _lexer.current();</a>
<a name="ln11574">					_lexer.next();</a>
<a name="ln11575"> </a>
<a name="ln11576">					if (l == lex_double_slash)</a>
<a name="ln11577">					{</a>
<a name="ln11578">						if (n-&gt;rettype() != xpath_type_node_set)</a>
<a name="ln11579">							throw_error(&quot;Step has to be applied to node set&quot;);</a>
<a name="ln11580"> </a>
<a name="ln11581">						n = new (alloc_node()) xpath_ast_node(ast_step, n, axis_descendant_or_self, nodetest_type_node, 0);</a>
<a name="ln11582">					}</a>
<a name="ln11583"> </a>
<a name="ln11584">					// select from location path</a>
<a name="ln11585">					return parse_relative_location_path(n);</a>
<a name="ln11586">				}</a>
<a name="ln11587"> </a>
<a name="ln11588">				return n;</a>
<a name="ln11589">			}</a>
<a name="ln11590">			else if (_lexer.current() == lex_minus)</a>
<a name="ln11591">			{</a>
<a name="ln11592">				_lexer.next();</a>
<a name="ln11593"> </a>
<a name="ln11594">				// precedence 7+ - only parses union expressions</a>
<a name="ln11595">				xpath_ast_node* expr = parse_expression_rec(parse_path_or_unary_expression(), 7);</a>
<a name="ln11596"> </a>
<a name="ln11597">				return new (alloc_node()) xpath_ast_node(ast_op_negate, xpath_type_number, expr);</a>
<a name="ln11598">			}</a>
<a name="ln11599">			else</a>
<a name="ln11600">			{</a>
<a name="ln11601">				return parse_location_path();</a>
<a name="ln11602">			}</a>
<a name="ln11603">		}</a>
<a name="ln11604"> </a>
<a name="ln11605">		struct binary_op_t</a>
<a name="ln11606">		{</a>
<a name="ln11607">			ast_type_t asttype;</a>
<a name="ln11608">			xpath_value_type rettype;</a>
<a name="ln11609">			int precedence;</a>
<a name="ln11610"> </a>
<a name="ln11611">			binary_op_t(): asttype(ast_unknown), rettype(xpath_type_none), precedence(0)</a>
<a name="ln11612">			{</a>
<a name="ln11613">			}</a>
<a name="ln11614"> </a>
<a name="ln11615">			binary_op_t(ast_type_t asttype_, xpath_value_type rettype_, int precedence_): asttype(asttype_), rettype(rettype_), precedence(precedence_)</a>
<a name="ln11616">			{</a>
<a name="ln11617">			}</a>
<a name="ln11618"> </a>
<a name="ln11619">			static binary_op_t parse(xpath_lexer&amp; lexer)</a>
<a name="ln11620">			{</a>
<a name="ln11621">				switch (lexer.current())</a>
<a name="ln11622">				{</a>
<a name="ln11623">				case lex_string:</a>
<a name="ln11624">					if (lexer.contents() == PUGIXML_TEXT(&quot;or&quot;))</a>
<a name="ln11625">						return binary_op_t(ast_op_or, xpath_type_boolean, 1);</a>
<a name="ln11626">					else if (lexer.contents() == PUGIXML_TEXT(&quot;and&quot;))</a>
<a name="ln11627">						return binary_op_t(ast_op_and, xpath_type_boolean, 2);</a>
<a name="ln11628">					else if (lexer.contents() == PUGIXML_TEXT(&quot;div&quot;))</a>
<a name="ln11629">						return binary_op_t(ast_op_divide, xpath_type_number, 6);</a>
<a name="ln11630">					else if (lexer.contents() == PUGIXML_TEXT(&quot;mod&quot;))</a>
<a name="ln11631">						return binary_op_t(ast_op_mod, xpath_type_number, 6);</a>
<a name="ln11632">					else</a>
<a name="ln11633">						return binary_op_t();</a>
<a name="ln11634"> </a>
<a name="ln11635">				case lex_equal:</a>
<a name="ln11636">					return binary_op_t(ast_op_equal, xpath_type_boolean, 3);</a>
<a name="ln11637"> </a>
<a name="ln11638">				case lex_not_equal:</a>
<a name="ln11639">					return binary_op_t(ast_op_not_equal, xpath_type_boolean, 3);</a>
<a name="ln11640"> </a>
<a name="ln11641">				case lex_less:</a>
<a name="ln11642">					return binary_op_t(ast_op_less, xpath_type_boolean, 4);</a>
<a name="ln11643"> </a>
<a name="ln11644">				case lex_greater:</a>
<a name="ln11645">					return binary_op_t(ast_op_greater, xpath_type_boolean, 4);</a>
<a name="ln11646"> </a>
<a name="ln11647">				case lex_less_or_equal:</a>
<a name="ln11648">					return binary_op_t(ast_op_less_or_equal, xpath_type_boolean, 4);</a>
<a name="ln11649"> </a>
<a name="ln11650">				case lex_greater_or_equal:</a>
<a name="ln11651">					return binary_op_t(ast_op_greater_or_equal, xpath_type_boolean, 4);</a>
<a name="ln11652"> </a>
<a name="ln11653">				case lex_plus:</a>
<a name="ln11654">					return binary_op_t(ast_op_add, xpath_type_number, 5);</a>
<a name="ln11655"> </a>
<a name="ln11656">				case lex_minus:</a>
<a name="ln11657">					return binary_op_t(ast_op_subtract, xpath_type_number, 5);</a>
<a name="ln11658"> </a>
<a name="ln11659">				case lex_multiply:</a>
<a name="ln11660">					return binary_op_t(ast_op_multiply, xpath_type_number, 6);</a>
<a name="ln11661"> </a>
<a name="ln11662">				case lex_union:</a>
<a name="ln11663">					return binary_op_t(ast_op_union, xpath_type_node_set, 7);</a>
<a name="ln11664"> </a>
<a name="ln11665">				default:</a>
<a name="ln11666">					return binary_op_t();</a>
<a name="ln11667">				}</a>
<a name="ln11668">			}</a>
<a name="ln11669">		};</a>
<a name="ln11670"> </a>
<a name="ln11671">		xpath_ast_node* parse_expression_rec(xpath_ast_node* lhs, int limit)</a>
<a name="ln11672">		{</a>
<a name="ln11673">			binary_op_t op = binary_op_t::parse(_lexer);</a>
<a name="ln11674"> </a>
<a name="ln11675">			while (op.asttype != ast_unknown &amp;&amp; op.precedence &gt;= limit)</a>
<a name="ln11676">			{</a>
<a name="ln11677">				_lexer.next();</a>
<a name="ln11678"> </a>
<a name="ln11679">				xpath_ast_node* rhs = parse_path_or_unary_expression();</a>
<a name="ln11680"> </a>
<a name="ln11681">				binary_op_t nextop = binary_op_t::parse(_lexer);</a>
<a name="ln11682"> </a>
<a name="ln11683">				while (nextop.asttype != ast_unknown &amp;&amp; nextop.precedence &gt; op.precedence)</a>
<a name="ln11684">				{</a>
<a name="ln11685">					rhs = parse_expression_rec(rhs, nextop.precedence);</a>
<a name="ln11686"> </a>
<a name="ln11687">					nextop = binary_op_t::parse(_lexer);</a>
<a name="ln11688">				}</a>
<a name="ln11689"> </a>
<a name="ln11690">				if (op.asttype == ast_op_union &amp;&amp; (lhs-&gt;rettype() != xpath_type_node_set || rhs-&gt;rettype() != xpath_type_node_set))</a>
<a name="ln11691">					throw_error(&quot;Union operator has to be applied to node sets&quot;);</a>
<a name="ln11692"> </a>
<a name="ln11693">				lhs = new (alloc_node()) xpath_ast_node(op.asttype, op.rettype, lhs, rhs);</a>
<a name="ln11694"> </a>
<a name="ln11695">				op = binary_op_t::parse(_lexer);</a>
<a name="ln11696">			}</a>
<a name="ln11697"> </a>
<a name="ln11698">			return lhs;</a>
<a name="ln11699">		}</a>
<a name="ln11700"> </a>
<a name="ln11701">		// Expr ::= OrExpr</a>
<a name="ln11702">		// OrExpr ::= AndExpr | OrExpr 'or' AndExpr</a>
<a name="ln11703">		// AndExpr ::= EqualityExpr | AndExpr 'and' EqualityExpr</a>
<a name="ln11704">		// EqualityExpr ::= RelationalExpr</a>
<a name="ln11705">		//					| EqualityExpr '=' RelationalExpr</a>
<a name="ln11706">		//					| EqualityExpr '!=' RelationalExpr</a>
<a name="ln11707">		// RelationalExpr ::= AdditiveExpr</a>
<a name="ln11708">		//					  | RelationalExpr '&lt;' AdditiveExpr</a>
<a name="ln11709">		//					  | RelationalExpr '&gt;' AdditiveExpr</a>
<a name="ln11710">		//					  | RelationalExpr '&lt;=' AdditiveExpr</a>
<a name="ln11711">		//					  | RelationalExpr '&gt;=' AdditiveExpr</a>
<a name="ln11712">		// AdditiveExpr ::= MultiplicativeExpr</a>
<a name="ln11713">		//					| AdditiveExpr '+' MultiplicativeExpr</a>
<a name="ln11714">		//					| AdditiveExpr '-' MultiplicativeExpr</a>
<a name="ln11715">		// MultiplicativeExpr ::= UnaryExpr</a>
<a name="ln11716">		//						  | MultiplicativeExpr '*' UnaryExpr</a>
<a name="ln11717">		//						  | MultiplicativeExpr 'div' UnaryExpr</a>
<a name="ln11718">		//						  | MultiplicativeExpr 'mod' UnaryExpr</a>
<a name="ln11719">		xpath_ast_node* parse_expression()</a>
<a name="ln11720">		{</a>
<a name="ln11721">			return parse_expression_rec(parse_path_or_unary_expression(), 0);</a>
<a name="ln11722">		}</a>
<a name="ln11723"> </a>
<a name="ln11724">		xpath_parser(const char_t* query, xpath_variable_set* variables, xpath_allocator* alloc, xpath_parse_result* result): _alloc(alloc), _lexer(query), _query(query), _variables(variables), _result(result)</a>
<a name="ln11725">		{</a>
<a name="ln11726">		}</a>
<a name="ln11727"> </a>
<a name="ln11728">		xpath_ast_node* parse()</a>
<a name="ln11729">		{</a>
<a name="ln11730">			xpath_ast_node* result = parse_expression();</a>
<a name="ln11731"> </a>
<a name="ln11732">			// check if there are unparsed tokens left</a>
<a name="ln11733">			if (_lexer.current() != lex_eof)</a>
<a name="ln11734">				throw_error(&quot;Incorrect query&quot;);</a>
<a name="ln11735"> </a>
<a name="ln11736">			return result;</a>
<a name="ln11737">		}</a>
<a name="ln11738"> </a>
<a name="ln11739">		static xpath_ast_node* parse(const char_t* query, xpath_variable_set* variables, xpath_allocator* alloc, xpath_parse_result* result)</a>
<a name="ln11740">		{</a>
<a name="ln11741">			xpath_parser parser(query, variables, alloc, result);</a>
<a name="ln11742"> </a>
<a name="ln11743">		#ifdef PUGIXML_NO_EXCEPTIONS</a>
<a name="ln11744">			int error = setjmp(parser._error_handler);</a>
<a name="ln11745"> </a>
<a name="ln11746">			return (error == 0) ? parser.parse() : 0;</a>
<a name="ln11747">		#else</a>
<a name="ln11748">			return parser.parse();</a>
<a name="ln11749">		#endif</a>
<a name="ln11750">		}</a>
<a name="ln11751">	};</a>
<a name="ln11752"> </a>
<a name="ln11753">	struct xpath_query_impl</a>
<a name="ln11754">	{</a>
<a name="ln11755">		static xpath_query_impl* create()</a>
<a name="ln11756">		{</a>
<a name="ln11757">			void* memory = xml_memory::allocate(sizeof(xpath_query_impl));</a>
<a name="ln11758">			if (!memory) return 0;</a>
<a name="ln11759"> </a>
<a name="ln11760">			return new (memory) xpath_query_impl();</a>
<a name="ln11761">		}</a>
<a name="ln11762"> </a>
<a name="ln11763">		static void destroy(xpath_query_impl* impl)</a>
<a name="ln11764">		{</a>
<a name="ln11765">			// free all allocated pages</a>
<a name="ln11766">			impl-&gt;alloc.release();</a>
<a name="ln11767"> </a>
<a name="ln11768">			// free allocator memory (with the first page)</a>
<a name="ln11769">			xml_memory::deallocate(impl);</a>
<a name="ln11770">		}</a>
<a name="ln11771"> </a>
<a name="ln11772">		xpath_query_impl(): root(0), alloc(&amp;block)</a>
<a name="ln11773">		{</a>
<a name="ln11774">			block.next = 0;</a>
<a name="ln11775">			block.capacity = sizeof(block.data);</a>
<a name="ln11776">		}</a>
<a name="ln11777"> </a>
<a name="ln11778">		xpath_ast_node* root;</a>
<a name="ln11779">		xpath_allocator alloc;</a>
<a name="ln11780">		xpath_memory_block block;</a>
<a name="ln11781">	};</a>
<a name="ln11782"> </a>
<a name="ln11783">	PUGI__FN xpath_string evaluate_string_impl(xpath_query_impl* impl, const xpath_node&amp; n, xpath_stack_data&amp; sd)</a>
<a name="ln11784">	{</a>
<a name="ln11785">		if (!impl) return xpath_string();</a>
<a name="ln11786"> </a>
<a name="ln11787">	#ifdef PUGIXML_NO_EXCEPTIONS</a>
<a name="ln11788">		if (setjmp(sd.error_handler)) return xpath_string();</a>
<a name="ln11789">	#endif</a>
<a name="ln11790"> </a>
<a name="ln11791">		xpath_context c(n, 1, 1);</a>
<a name="ln11792"> </a>
<a name="ln11793">		return impl-&gt;root-&gt;eval_string(c, sd.stack);</a>
<a name="ln11794">	}</a>
<a name="ln11795"> </a>
<a name="ln11796">	PUGI__FN impl::xpath_ast_node* evaluate_node_set_prepare(xpath_query_impl* impl)</a>
<a name="ln11797">	{</a>
<a name="ln11798">		if (!impl) return 0;</a>
<a name="ln11799"> </a>
<a name="ln11800">		if (impl-&gt;root-&gt;rettype() != xpath_type_node_set)</a>
<a name="ln11801">		{</a>
<a name="ln11802">		#ifdef PUGIXML_NO_EXCEPTIONS</a>
<a name="ln11803">			return 0;</a>
<a name="ln11804">		#else</a>
<a name="ln11805">			xpath_parse_result res;</a>
<a name="ln11806">			res.error = &quot;Expression does not evaluate to node set&quot;;</a>
<a name="ln11807"> </a>
<a name="ln11808">			throw xpath_exception(res);</a>
<a name="ln11809">		#endif</a>
<a name="ln11810">		}</a>
<a name="ln11811"> </a>
<a name="ln11812">		return impl-&gt;root;</a>
<a name="ln11813">	}</a>
<a name="ln11814">PUGI__NS_END</a>
<a name="ln11815"> </a>
<a name="ln11816">namespace pugi</a>
<a name="ln11817">{</a>
<a name="ln11818">#ifndef PUGIXML_NO_EXCEPTIONS</a>
<a name="ln11819">	PUGI__FN xpath_exception::xpath_exception(const xpath_parse_result&amp; result_): _result(result_)</a>
<a name="ln11820">	{</a>
<a name="ln11821">		assert(_result.error);</a>
<a name="ln11822">	}</a>
<a name="ln11823"> </a>
<a name="ln11824">	PUGI__FN const char* xpath_exception::what() const throw()</a>
<a name="ln11825">	{</a>
<a name="ln11826">		return _result.error;</a>
<a name="ln11827">	}</a>
<a name="ln11828"> </a>
<a name="ln11829">	PUGI__FN const xpath_parse_result&amp; xpath_exception::result() const</a>
<a name="ln11830">	{</a>
<a name="ln11831">		return _result;</a>
<a name="ln11832">	}</a>
<a name="ln11833">#endif</a>
<a name="ln11834"> </a>
<a name="ln11835">	PUGI__FN xpath_node::xpath_node()</a>
<a name="ln11836">	{</a>
<a name="ln11837">	}</a>
<a name="ln11838"> </a>
<a name="ln11839">	PUGI__FN xpath_node::xpath_node(const xml_node&amp; node_): _node(node_)</a>
<a name="ln11840">	{</a>
<a name="ln11841">	}</a>
<a name="ln11842"> </a>
<a name="ln11843">	PUGI__FN xpath_node::xpath_node(const xml_attribute&amp; attribute_, const xml_node&amp; parent_): _node(attribute_ ? parent_ : xml_node()), _attribute(attribute_)</a>
<a name="ln11844">	{</a>
<a name="ln11845">	}</a>
<a name="ln11846"> </a>
<a name="ln11847">	PUGI__FN xml_node xpath_node::node() const</a>
<a name="ln11848">	{</a>
<a name="ln11849">		return _attribute ? xml_node() : _node;</a>
<a name="ln11850">	}</a>
<a name="ln11851"> </a>
<a name="ln11852">	PUGI__FN xml_attribute xpath_node::attribute() const</a>
<a name="ln11853">	{</a>
<a name="ln11854">		return _attribute;</a>
<a name="ln11855">	}</a>
<a name="ln11856"> </a>
<a name="ln11857">	PUGI__FN xml_node xpath_node::parent() const</a>
<a name="ln11858">	{</a>
<a name="ln11859">		return _attribute ? _node : _node.parent();</a>
<a name="ln11860">	}</a>
<a name="ln11861"> </a>
<a name="ln11862">	PUGI__FN static void unspecified_bool_xpath_node(xpath_node***)</a>
<a name="ln11863">	{</a>
<a name="ln11864">	}</a>
<a name="ln11865"> </a>
<a name="ln11866">	PUGI__FN xpath_node::operator xpath_node::unspecified_bool_type() const</a>
<a name="ln11867">	{</a>
<a name="ln11868">		return (_node || _attribute) ? unspecified_bool_xpath_node : 0;</a>
<a name="ln11869">	}</a>
<a name="ln11870"> </a>
<a name="ln11871">	PUGI__FN bool xpath_node::operator!() const</a>
<a name="ln11872">	{</a>
<a name="ln11873">		return !(_node || _attribute);</a>
<a name="ln11874">	}</a>
<a name="ln11875"> </a>
<a name="ln11876">	PUGI__FN bool xpath_node::operator==(const xpath_node&amp; n) const</a>
<a name="ln11877">	{</a>
<a name="ln11878">		return _node == n._node &amp;&amp; _attribute == n._attribute;</a>
<a name="ln11879">	}</a>
<a name="ln11880"> </a>
<a name="ln11881">	PUGI__FN bool xpath_node::operator!=(const xpath_node&amp; n) const</a>
<a name="ln11882">	{</a>
<a name="ln11883">		return _node != n._node || _attribute != n._attribute;</a>
<a name="ln11884">	}</a>
<a name="ln11885"> </a>
<a name="ln11886">#ifdef __BORLANDC__</a>
<a name="ln11887">	PUGI__FN bool operator&amp;&amp;(const xpath_node&amp; lhs, bool rhs)</a>
<a name="ln11888">	{</a>
<a name="ln11889">		return (bool)lhs &amp;&amp; rhs;</a>
<a name="ln11890">	}</a>
<a name="ln11891"> </a>
<a name="ln11892">	PUGI__FN bool operator||(const xpath_node&amp; lhs, bool rhs)</a>
<a name="ln11893">	{</a>
<a name="ln11894">		return (bool)lhs || rhs;</a>
<a name="ln11895">	}</a>
<a name="ln11896">#endif</a>
<a name="ln11897"> </a>
<a name="ln11898">	PUGI__FN void xpath_node_set::_assign(const_iterator begin_, const_iterator end_, type_t type_)</a>
<a name="ln11899">	{</a>
<a name="ln11900">		assert(begin_ &lt;= end_);</a>
<a name="ln11901"> </a>
<a name="ln11902">		size_t size_ = static_cast&lt;size_t&gt;(end_ - begin_);</a>
<a name="ln11903"> </a>
<a name="ln11904">		if (size_ &lt;= 1)</a>
<a name="ln11905">		{</a>
<a name="ln11906">			// deallocate old buffer</a>
<a name="ln11907">			if (_begin != &amp;_storage) impl::xml_memory::deallocate(_begin);</a>
<a name="ln11908"> </a>
<a name="ln11909">			// use internal buffer</a>
<a name="ln11910">			if (begin_ != end_) _storage = *begin_;</a>
<a name="ln11911"> </a>
<a name="ln11912">			_begin = &amp;_storage;</a>
<a name="ln11913">			_end = &amp;_storage + size_;</a>
<a name="ln11914">			_type = type_;</a>
<a name="ln11915">		}</a>
<a name="ln11916">		else</a>
<a name="ln11917">		{</a>
<a name="ln11918">			// make heap copy</a>
<a name="ln11919">			xpath_node* storage = static_cast&lt;xpath_node*&gt;(impl::xml_memory::allocate(size_ * sizeof(xpath_node)));</a>
<a name="ln11920"> </a>
<a name="ln11921">			if (!storage)</a>
<a name="ln11922">			{</a>
<a name="ln11923">			#ifdef PUGIXML_NO_EXCEPTIONS</a>
<a name="ln11924">				return;</a>
<a name="ln11925">			#else</a>
<a name="ln11926">				throw std::bad_alloc();</a>
<a name="ln11927">			#endif</a>
<a name="ln11928">			}</a>
<a name="ln11929"> </a>
<a name="ln11930">			memcpy(storage, begin_, size_ * sizeof(xpath_node));</a>
<a name="ln11931"> </a>
<a name="ln11932">			// deallocate old buffer</a>
<a name="ln11933">			if (_begin != &amp;_storage) impl::xml_memory::deallocate(_begin);</a>
<a name="ln11934"> </a>
<a name="ln11935">			// finalize</a>
<a name="ln11936">			_begin = storage;</a>
<a name="ln11937">			_end = storage + size_;</a>
<a name="ln11938">			_type = type_;</a>
<a name="ln11939">		}</a>
<a name="ln11940">	}</a>
<a name="ln11941"> </a>
<a name="ln11942">#ifdef PUGIXML_HAS_MOVE</a>
<a name="ln11943">	PUGI__FN void xpath_node_set::_move(xpath_node_set&amp; rhs)</a>
<a name="ln11944">	{</a>
<a name="ln11945">		_type = rhs._type;</a>
<a name="ln11946">		_storage = rhs._storage;</a>
<a name="ln11947">		_begin = (rhs._begin == &amp;rhs._storage) ? &amp;_storage : rhs._begin;</a>
<a name="ln11948">		_end = _begin + (rhs._end - rhs._begin);</a>
<a name="ln11949"> </a>
<a name="ln11950">		rhs._type = type_unsorted;</a>
<a name="ln11951">		rhs._begin = &amp;rhs._storage;</a>
<a name="ln11952">		rhs._end = rhs._begin;</a>
<a name="ln11953">	}</a>
<a name="ln11954">#endif</a>
<a name="ln11955"> </a>
<a name="ln11956">	PUGI__FN xpath_node_set::xpath_node_set(): _type(type_unsorted), _begin(&amp;_storage), _end(&amp;_storage)</a>
<a name="ln11957">	{</a>
<a name="ln11958">	}</a>
<a name="ln11959"> </a>
<a name="ln11960">	PUGI__FN xpath_node_set::xpath_node_set(const_iterator begin_, const_iterator end_, type_t type_): _type(type_unsorted), _begin(&amp;_storage), _end(&amp;_storage)</a>
<a name="ln11961">	{</a>
<a name="ln11962">		_assign(begin_, end_, type_);</a>
<a name="ln11963">	}</a>
<a name="ln11964"> </a>
<a name="ln11965">	PUGI__FN xpath_node_set::~xpath_node_set()</a>
<a name="ln11966">	{</a>
<a name="ln11967">		if (_begin != &amp;_storage)</a>
<a name="ln11968">			impl::xml_memory::deallocate(_begin);</a>
<a name="ln11969">	}</a>
<a name="ln11970"> </a>
<a name="ln11971">	PUGI__FN xpath_node_set::xpath_node_set(const xpath_node_set&amp; ns): _type(type_unsorted), _begin(&amp;_storage), _end(&amp;_storage)</a>
<a name="ln11972">	{</a>
<a name="ln11973">		_assign(ns._begin, ns._end, ns._type);</a>
<a name="ln11974">	}</a>
<a name="ln11975"> </a>
<a name="ln11976">	PUGI__FN xpath_node_set&amp; xpath_node_set::operator=(const xpath_node_set&amp; ns)</a>
<a name="ln11977">	{</a>
<a name="ln11978">		if (this == &amp;ns) return *this;</a>
<a name="ln11979"> </a>
<a name="ln11980">		_assign(ns._begin, ns._end, ns._type);</a>
<a name="ln11981"> </a>
<a name="ln11982">		return *this;</a>
<a name="ln11983">	}</a>
<a name="ln11984"> </a>
<a name="ln11985">#ifdef PUGIXML_HAS_MOVE</a>
<a name="ln11986">	PUGI__FN xpath_node_set::xpath_node_set(xpath_node_set&amp;&amp; rhs): _type(type_unsorted), _begin(&amp;_storage), _end(&amp;_storage)</a>
<a name="ln11987">	{</a>
<a name="ln11988">		_move(rhs);</a>
<a name="ln11989">	}</a>
<a name="ln11990"> </a>
<a name="ln11991">	PUGI__FN xpath_node_set&amp; xpath_node_set::operator=(xpath_node_set&amp;&amp; rhs)</a>
<a name="ln11992">	{</a>
<a name="ln11993">		if (this == &amp;rhs) return *this;</a>
<a name="ln11994"> </a>
<a name="ln11995">		if (_begin != &amp;_storage)</a>
<a name="ln11996">			impl::xml_memory::deallocate(_begin);</a>
<a name="ln11997"> </a>
<a name="ln11998">		_move(rhs);</a>
<a name="ln11999"> </a>
<a name="ln12000">		return *this;</a>
<a name="ln12001">	}</a>
<a name="ln12002">#endif</a>
<a name="ln12003"> </a>
<a name="ln12004">	PUGI__FN xpath_node_set::type_t xpath_node_set::type() const</a>
<a name="ln12005">	{</a>
<a name="ln12006">		return _type;</a>
<a name="ln12007">	}</a>
<a name="ln12008"> </a>
<a name="ln12009">	PUGI__FN size_t xpath_node_set::size() const</a>
<a name="ln12010">	{</a>
<a name="ln12011">		return _end - _begin;</a>
<a name="ln12012">	}</a>
<a name="ln12013"> </a>
<a name="ln12014">	PUGI__FN bool xpath_node_set::empty() const</a>
<a name="ln12015">	{</a>
<a name="ln12016">		return _begin == _end;</a>
<a name="ln12017">	}</a>
<a name="ln12018"> </a>
<a name="ln12019">	PUGI__FN const xpath_node&amp; xpath_node_set::operator[](size_t index) const</a>
<a name="ln12020">	{</a>
<a name="ln12021">		assert(index &lt; size());</a>
<a name="ln12022">		return _begin[index];</a>
<a name="ln12023">	}</a>
<a name="ln12024"> </a>
<a name="ln12025">	PUGI__FN xpath_node_set::const_iterator xpath_node_set::begin() const</a>
<a name="ln12026">	{</a>
<a name="ln12027">		return _begin;</a>
<a name="ln12028">	}</a>
<a name="ln12029"> </a>
<a name="ln12030">	PUGI__FN xpath_node_set::const_iterator xpath_node_set::end() const</a>
<a name="ln12031">	{</a>
<a name="ln12032">		return _end;</a>
<a name="ln12033">	}</a>
<a name="ln12034"> </a>
<a name="ln12035">	PUGI__FN void xpath_node_set::sort(bool reverse)</a>
<a name="ln12036">	{</a>
<a name="ln12037">		_type = impl::xpath_sort(_begin, _end, _type, reverse);</a>
<a name="ln12038">	}</a>
<a name="ln12039"> </a>
<a name="ln12040">	PUGI__FN xpath_node xpath_node_set::first() const</a>
<a name="ln12041">	{</a>
<a name="ln12042">		return impl::xpath_first(_begin, _end, _type);</a>
<a name="ln12043">	}</a>
<a name="ln12044"> </a>
<a name="ln12045">	PUGI__FN xpath_parse_result::xpath_parse_result(): error(&quot;Internal error&quot;), offset(0)</a>
<a name="ln12046">	{</a>
<a name="ln12047">	}</a>
<a name="ln12048"> </a>
<a name="ln12049">	PUGI__FN xpath_parse_result::operator bool() const</a>
<a name="ln12050">	{</a>
<a name="ln12051">		return error == 0;</a>
<a name="ln12052">	}</a>
<a name="ln12053"> </a>
<a name="ln12054">	PUGI__FN const char* xpath_parse_result::description() const</a>
<a name="ln12055">	{</a>
<a name="ln12056">		return error ? error : &quot;No error&quot;;</a>
<a name="ln12057">	}</a>
<a name="ln12058"> </a>
<a name="ln12059">	PUGI__FN xpath_variable::xpath_variable(xpath_value_type type_): _type(type_), _next(0)</a>
<a name="ln12060">	{</a>
<a name="ln12061">	}</a>
<a name="ln12062"> </a>
<a name="ln12063">	PUGI__FN const char_t* xpath_variable::name() const</a>
<a name="ln12064">	{</a>
<a name="ln12065">		switch (_type)</a>
<a name="ln12066">		{</a>
<a name="ln12067">		case xpath_type_node_set:</a>
<a name="ln12068">			return static_cast&lt;const impl::xpath_variable_node_set*&gt;(this)-&gt;name;</a>
<a name="ln12069"> </a>
<a name="ln12070">		case xpath_type_number:</a>
<a name="ln12071">			return static_cast&lt;const impl::xpath_variable_number*&gt;(this)-&gt;name;</a>
<a name="ln12072"> </a>
<a name="ln12073">		case xpath_type_string:</a>
<a name="ln12074">			return static_cast&lt;const impl::xpath_variable_string*&gt;(this)-&gt;name;</a>
<a name="ln12075"> </a>
<a name="ln12076">		case xpath_type_boolean:</a>
<a name="ln12077">			return static_cast&lt;const impl::xpath_variable_boolean*&gt;(this)-&gt;name;</a>
<a name="ln12078"> </a>
<a name="ln12079">		default:</a>
<a name="ln12080">			assert(false &amp;&amp; &quot;Invalid variable type&quot;);</a>
<a name="ln12081">			return 0;</a>
<a name="ln12082">		}</a>
<a name="ln12083">	}</a>
<a name="ln12084"> </a>
<a name="ln12085">	PUGI__FN xpath_value_type xpath_variable::type() const</a>
<a name="ln12086">	{</a>
<a name="ln12087">		return _type;</a>
<a name="ln12088">	}</a>
<a name="ln12089"> </a>
<a name="ln12090">	PUGI__FN bool xpath_variable::get_boolean() const</a>
<a name="ln12091">	{</a>
<a name="ln12092">		return (_type == xpath_type_boolean) ? static_cast&lt;const impl::xpath_variable_boolean*&gt;(this)-&gt;value : false;</a>
<a name="ln12093">	}</a>
<a name="ln12094"> </a>
<a name="ln12095">	PUGI__FN double xpath_variable::get_number() const</a>
<a name="ln12096">	{</a>
<a name="ln12097">		return (_type == xpath_type_number) ? static_cast&lt;const impl::xpath_variable_number*&gt;(this)-&gt;value : impl::gen_nan();</a>
<a name="ln12098">	}</a>
<a name="ln12099"> </a>
<a name="ln12100">	PUGI__FN const char_t* xpath_variable::get_string() const</a>
<a name="ln12101">	{</a>
<a name="ln12102">		const char_t* value = (_type == xpath_type_string) ? static_cast&lt;const impl::xpath_variable_string*&gt;(this)-&gt;value : 0;</a>
<a name="ln12103">		return value ? value : PUGIXML_TEXT(&quot;&quot;);</a>
<a name="ln12104">	}</a>
<a name="ln12105"> </a>
<a name="ln12106">	PUGI__FN const xpath_node_set&amp; xpath_variable::get_node_set() const</a>
<a name="ln12107">	{</a>
<a name="ln12108">		return (_type == xpath_type_node_set) ? static_cast&lt;const impl::xpath_variable_node_set*&gt;(this)-&gt;value : impl::dummy_node_set;</a>
<a name="ln12109">	}</a>
<a name="ln12110"> </a>
<a name="ln12111">	PUGI__FN bool xpath_variable::set(bool value)</a>
<a name="ln12112">	{</a>
<a name="ln12113">		if (_type != xpath_type_boolean) return false;</a>
<a name="ln12114"> </a>
<a name="ln12115">		static_cast&lt;impl::xpath_variable_boolean*&gt;(this)-&gt;value = value;</a>
<a name="ln12116">		return true;</a>
<a name="ln12117">	}</a>
<a name="ln12118"> </a>
<a name="ln12119">	PUGI__FN bool xpath_variable::set(double value)</a>
<a name="ln12120">	{</a>
<a name="ln12121">		if (_type != xpath_type_number) return false;</a>
<a name="ln12122"> </a>
<a name="ln12123">		static_cast&lt;impl::xpath_variable_number*&gt;(this)-&gt;value = value;</a>
<a name="ln12124">		return true;</a>
<a name="ln12125">	}</a>
<a name="ln12126"> </a>
<a name="ln12127">	PUGI__FN bool xpath_variable::set(const char_t* value)</a>
<a name="ln12128">	{</a>
<a name="ln12129">		if (_type != xpath_type_string) return false;</a>
<a name="ln12130"> </a>
<a name="ln12131">		impl::xpath_variable_string* var = static_cast&lt;impl::xpath_variable_string*&gt;(this);</a>
<a name="ln12132"> </a>
<a name="ln12133">		// duplicate string</a>
<a name="ln12134">		size_t size = (impl::strlength(value) + 1) * sizeof(char_t);</a>
<a name="ln12135"> </a>
<a name="ln12136">		char_t* copy = static_cast&lt;char_t*&gt;(impl::xml_memory::allocate(size));</a>
<a name="ln12137">		if (!copy) return false;</a>
<a name="ln12138"> </a>
<a name="ln12139">		memcpy(copy, value, size);</a>
<a name="ln12140"> </a>
<a name="ln12141">		// replace old string</a>
<a name="ln12142">		if (var-&gt;value) impl::xml_memory::deallocate(var-&gt;value);</a>
<a name="ln12143">		var-&gt;value = copy;</a>
<a name="ln12144"> </a>
<a name="ln12145">		return true;</a>
<a name="ln12146">	}</a>
<a name="ln12147"> </a>
<a name="ln12148">	PUGI__FN bool xpath_variable::set(const xpath_node_set&amp; value)</a>
<a name="ln12149">	{</a>
<a name="ln12150">		if (_type != xpath_type_node_set) return false;</a>
<a name="ln12151"> </a>
<a name="ln12152">		static_cast&lt;impl::xpath_variable_node_set*&gt;(this)-&gt;value = value;</a>
<a name="ln12153">		return true;</a>
<a name="ln12154">	}</a>
<a name="ln12155"> </a>
<a name="ln12156">	PUGI__FN xpath_variable_set::xpath_variable_set()</a>
<a name="ln12157">	{</a>
<a name="ln12158">		for (size_t i = 0; i &lt; sizeof(_data) / sizeof(_data[0]); ++i)</a>
<a name="ln12159">			_data[i] = 0;</a>
<a name="ln12160">	}</a>
<a name="ln12161"> </a>
<a name="ln12162">	PUGI__FN xpath_variable_set::~xpath_variable_set()</a>
<a name="ln12163">	{</a>
<a name="ln12164">		for (size_t i = 0; i &lt; sizeof(_data) / sizeof(_data[0]); ++i)</a>
<a name="ln12165">			_destroy(_data[i]);</a>
<a name="ln12166">	}</a>
<a name="ln12167"> </a>
<a name="ln12168">	PUGI__FN xpath_variable_set::xpath_variable_set(const xpath_variable_set&amp; rhs)</a>
<a name="ln12169">	{</a>
<a name="ln12170">		for (size_t i = 0; i &lt; sizeof(_data) / sizeof(_data[0]); ++i)</a>
<a name="ln12171">			_data[i] = 0;</a>
<a name="ln12172"> </a>
<a name="ln12173">		_assign(rhs);</a>
<a name="ln12174">	}</a>
<a name="ln12175"> </a>
<a name="ln12176">	PUGI__FN xpath_variable_set&amp; xpath_variable_set::operator=(const xpath_variable_set&amp; rhs)</a>
<a name="ln12177">	{</a>
<a name="ln12178">		if (this == &amp;rhs) return *this;</a>
<a name="ln12179"> </a>
<a name="ln12180">		_assign(rhs);</a>
<a name="ln12181"> </a>
<a name="ln12182">		return *this;</a>
<a name="ln12183">	}</a>
<a name="ln12184"> </a>
<a name="ln12185">#ifdef PUGIXML_HAS_MOVE</a>
<a name="ln12186">	PUGI__FN xpath_variable_set::xpath_variable_set(xpath_variable_set&amp;&amp; rhs)</a>
<a name="ln12187">	{</a>
<a name="ln12188">		for (size_t i = 0; i &lt; sizeof(_data) / sizeof(_data[0]); ++i)</a>
<a name="ln12189">		{</a>
<a name="ln12190">			_data[i] = rhs._data[i];</a>
<a name="ln12191">			rhs._data[i] = 0;</a>
<a name="ln12192">		}</a>
<a name="ln12193">	}</a>
<a name="ln12194"> </a>
<a name="ln12195">	PUGI__FN xpath_variable_set&amp; xpath_variable_set::operator=(xpath_variable_set&amp;&amp; rhs)</a>
<a name="ln12196">	{</a>
<a name="ln12197">		for (size_t i = 0; i &lt; sizeof(_data) / sizeof(_data[0]); ++i)</a>
<a name="ln12198">		{</a>
<a name="ln12199">			_destroy(_data[i]);</a>
<a name="ln12200"> </a>
<a name="ln12201">			_data[i] = rhs._data[i];</a>
<a name="ln12202">			rhs._data[i] = 0;</a>
<a name="ln12203">		}</a>
<a name="ln12204"> </a>
<a name="ln12205">		return *this;</a>
<a name="ln12206">	}</a>
<a name="ln12207">#endif</a>
<a name="ln12208"> </a>
<a name="ln12209">	PUGI__FN void xpath_variable_set::_assign(const xpath_variable_set&amp; rhs)</a>
<a name="ln12210">	{</a>
<a name="ln12211">		xpath_variable_set temp;</a>
<a name="ln12212"> </a>
<a name="ln12213">		for (size_t i = 0; i &lt; sizeof(_data) / sizeof(_data[0]); ++i)</a>
<a name="ln12214">			if (rhs._data[i] &amp;&amp; !_clone(rhs._data[i], &amp;temp._data[i]))</a>
<a name="ln12215">				return;</a>
<a name="ln12216"> </a>
<a name="ln12217">		_swap(temp);</a>
<a name="ln12218">	}</a>
<a name="ln12219"> </a>
<a name="ln12220">	PUGI__FN void xpath_variable_set::_swap(xpath_variable_set&amp; rhs)</a>
<a name="ln12221">	{</a>
<a name="ln12222">		for (size_t i = 0; i &lt; sizeof(_data) / sizeof(_data[0]); ++i)</a>
<a name="ln12223">		{</a>
<a name="ln12224">			xpath_variable* chain = _data[i];</a>
<a name="ln12225"> </a>
<a name="ln12226">			_data[i] = rhs._data[i];</a>
<a name="ln12227">			rhs._data[i] = chain;</a>
<a name="ln12228">		}</a>
<a name="ln12229">	}</a>
<a name="ln12230"> </a>
<a name="ln12231">	PUGI__FN xpath_variable* xpath_variable_set::_find(const char_t* name) const</a>
<a name="ln12232">	{</a>
<a name="ln12233">		const size_t hash_size = sizeof(_data) / sizeof(_data[0]);</a>
<a name="ln12234">		size_t hash = impl::hash_string(name) % hash_size;</a>
<a name="ln12235"> </a>
<a name="ln12236">		// look for existing variable</a>
<a name="ln12237">		for (xpath_variable* var = _data[hash]; var; var = var-&gt;_next)</a>
<a name="ln12238">			if (impl::strequal(var-&gt;name(), name))</a>
<a name="ln12239">				return var;</a>
<a name="ln12240"> </a>
<a name="ln12241">		return 0;</a>
<a name="ln12242">	}</a>
<a name="ln12243"> </a>
<a name="ln12244">	PUGI__FN bool xpath_variable_set::_clone(xpath_variable* var, xpath_variable** out_result)</a>
<a name="ln12245">	{</a>
<a name="ln12246">		xpath_variable* last = 0;</a>
<a name="ln12247"> </a>
<a name="ln12248">		while (var)</a>
<a name="ln12249">		{</a>
<a name="ln12250">			// allocate storage for new variable</a>
<a name="ln12251">			xpath_variable* nvar = impl::new_xpath_variable(var-&gt;_type, var-&gt;name());</a>
<a name="ln12252">			if (!nvar) return false;</a>
<a name="ln12253"> </a>
<a name="ln12254">			// link the variable to the result immediately to handle failures gracefully</a>
<a name="ln12255">			if (last)</a>
<a name="ln12256">				last-&gt;_next = nvar;</a>
<a name="ln12257">			else</a>
<a name="ln12258">				*out_result = nvar;</a>
<a name="ln12259"> </a>
<a name="ln12260">			last = nvar;</a>
<a name="ln12261"> </a>
<a name="ln12262">			// copy the value; this can fail due to out-of-memory conditions</a>
<a name="ln12263">			if (!impl::copy_xpath_variable(nvar, var)) return false;</a>
<a name="ln12264"> </a>
<a name="ln12265">			var = var-&gt;_next;</a>
<a name="ln12266">		}</a>
<a name="ln12267"> </a>
<a name="ln12268">		return true;</a>
<a name="ln12269">	}</a>
<a name="ln12270"> </a>
<a name="ln12271">	PUGI__FN void xpath_variable_set::_destroy(xpath_variable* var)</a>
<a name="ln12272">	{</a>
<a name="ln12273">		while (var)</a>
<a name="ln12274">		{</a>
<a name="ln12275">			xpath_variable* next = var-&gt;_next;</a>
<a name="ln12276"> </a>
<a name="ln12277">			impl::delete_xpath_variable(var-&gt;_type, var);</a>
<a name="ln12278"> </a>
<a name="ln12279">			var = next;</a>
<a name="ln12280">		}</a>
<a name="ln12281">	}</a>
<a name="ln12282"> </a>
<a name="ln12283">	PUGI__FN xpath_variable* xpath_variable_set::add(const char_t* name, xpath_value_type type)</a>
<a name="ln12284">	{</a>
<a name="ln12285">		const size_t hash_size = sizeof(_data) / sizeof(_data[0]);</a>
<a name="ln12286">		size_t hash = impl::hash_string(name) % hash_size;</a>
<a name="ln12287"> </a>
<a name="ln12288">		// look for existing variable</a>
<a name="ln12289">		for (xpath_variable* var = _data[hash]; var; var = var-&gt;_next)</a>
<a name="ln12290">			if (impl::strequal(var-&gt;name(), name))</a>
<a name="ln12291">				return var-&gt;type() == type ? var : 0;</a>
<a name="ln12292"> </a>
<a name="ln12293">		// add new variable</a>
<a name="ln12294">		xpath_variable* result = impl::new_xpath_variable(type, name);</a>
<a name="ln12295"> </a>
<a name="ln12296">		if (result)</a>
<a name="ln12297">		{</a>
<a name="ln12298">			result-&gt;_next = _data[hash];</a>
<a name="ln12299"> </a>
<a name="ln12300">			_data[hash] = result;</a>
<a name="ln12301">		}</a>
<a name="ln12302"> </a>
<a name="ln12303">		return result;</a>
<a name="ln12304">	}</a>
<a name="ln12305"> </a>
<a name="ln12306">	PUGI__FN bool xpath_variable_set::set(const char_t* name, bool value)</a>
<a name="ln12307">	{</a>
<a name="ln12308">		xpath_variable* var = add(name, xpath_type_boolean);</a>
<a name="ln12309">		return var ? var-&gt;set(value) : false;</a>
<a name="ln12310">	}</a>
<a name="ln12311"> </a>
<a name="ln12312">	PUGI__FN bool xpath_variable_set::set(const char_t* name, double value)</a>
<a name="ln12313">	{</a>
<a name="ln12314">		xpath_variable* var = add(name, xpath_type_number);</a>
<a name="ln12315">		return var ? var-&gt;set(value) : false;</a>
<a name="ln12316">	}</a>
<a name="ln12317"> </a>
<a name="ln12318">	PUGI__FN bool xpath_variable_set::set(const char_t* name, const char_t* value)</a>
<a name="ln12319">	{</a>
<a name="ln12320">		xpath_variable* var = add(name, xpath_type_string);</a>
<a name="ln12321">		return var ? var-&gt;set(value) : false;</a>
<a name="ln12322">	}</a>
<a name="ln12323"> </a>
<a name="ln12324">	PUGI__FN bool xpath_variable_set::set(const char_t* name, const xpath_node_set&amp; value)</a>
<a name="ln12325">	{</a>
<a name="ln12326">		xpath_variable* var = add(name, xpath_type_node_set);</a>
<a name="ln12327">		return var ? var-&gt;set(value) : false;</a>
<a name="ln12328">	}</a>
<a name="ln12329"> </a>
<a name="ln12330">	PUGI__FN xpath_variable* xpath_variable_set::get(const char_t* name)</a>
<a name="ln12331">	{</a>
<a name="ln12332">		return _find(name);</a>
<a name="ln12333">	}</a>
<a name="ln12334"> </a>
<a name="ln12335">	PUGI__FN const xpath_variable* xpath_variable_set::get(const char_t* name) const</a>
<a name="ln12336">	{</a>
<a name="ln12337">		return _find(name);</a>
<a name="ln12338">	}</a>
<a name="ln12339"> </a>
<a name="ln12340">	PUGI__FN xpath_query::xpath_query(const char_t* query, xpath_variable_set* variables): _impl(0)</a>
<a name="ln12341">	{</a>
<a name="ln12342">		impl::xpath_query_impl* qimpl = impl::xpath_query_impl::create();</a>
<a name="ln12343"> </a>
<a name="ln12344">		if (!qimpl)</a>
<a name="ln12345">		{</a>
<a name="ln12346">		#ifdef PUGIXML_NO_EXCEPTIONS</a>
<a name="ln12347">			_result.error = &quot;Out of memory&quot;;</a>
<a name="ln12348">		#else</a>
<a name="ln12349">			throw std::bad_alloc();</a>
<a name="ln12350">		#endif</a>
<a name="ln12351">		}</a>
<a name="ln12352">		else</a>
<a name="ln12353">		{</a>
<a name="ln12354">			using impl::auto_deleter; // MSVC7 workaround</a>
<a name="ln12355">			auto_deleter&lt;impl::xpath_query_impl&gt; impl(qimpl, impl::xpath_query_impl::destroy);</a>
<a name="ln12356"> </a>
<a name="ln12357">			qimpl-&gt;root = impl::xpath_parser::parse(query, variables, &amp;qimpl-&gt;alloc, &amp;_result);</a>
<a name="ln12358"> </a>
<a name="ln12359">			if (qimpl-&gt;root)</a>
<a name="ln12360">			{</a>
<a name="ln12361">				qimpl-&gt;root-&gt;optimize(&amp;qimpl-&gt;alloc);</a>
<a name="ln12362"> </a>
<a name="ln12363">				_impl = impl.release();</a>
<a name="ln12364">				_result.error = 0;</a>
<a name="ln12365">			}</a>
<a name="ln12366">		}</a>
<a name="ln12367">	}</a>
<a name="ln12368"> </a>
<a name="ln12369">	PUGI__FN xpath_query::xpath_query(): _impl(0)</a>
<a name="ln12370">	{</a>
<a name="ln12371">	}</a>
<a name="ln12372"> </a>
<a name="ln12373">	PUGI__FN xpath_query::~xpath_query()</a>
<a name="ln12374">	{</a>
<a name="ln12375">		if (_impl)</a>
<a name="ln12376">			impl::xpath_query_impl::destroy(static_cast&lt;impl::xpath_query_impl*&gt;(_impl));</a>
<a name="ln12377">	}</a>
<a name="ln12378"> </a>
<a name="ln12379">#ifdef PUGIXML_HAS_MOVE</a>
<a name="ln12380">	PUGI__FN xpath_query::xpath_query(xpath_query&amp;&amp; rhs)</a>
<a name="ln12381">	{</a>
<a name="ln12382">		_impl = rhs._impl;</a>
<a name="ln12383">		_result = rhs._result;</a>
<a name="ln12384">		rhs._impl = 0;</a>
<a name="ln12385">		rhs._result = xpath_parse_result();</a>
<a name="ln12386">	}</a>
<a name="ln12387"> </a>
<a name="ln12388">	PUGI__FN xpath_query&amp; xpath_query::operator=(xpath_query&amp;&amp; rhs)</a>
<a name="ln12389">	{</a>
<a name="ln12390">		if (this == &amp;rhs) return *this;</a>
<a name="ln12391"> </a>
<a name="ln12392">		if (_impl)</a>
<a name="ln12393">			impl::xpath_query_impl::destroy(static_cast&lt;impl::xpath_query_impl*&gt;(_impl));</a>
<a name="ln12394"> </a>
<a name="ln12395">		_impl = rhs._impl;</a>
<a name="ln12396">		_result = rhs._result;</a>
<a name="ln12397">		rhs._impl = 0;</a>
<a name="ln12398">		rhs._result = xpath_parse_result();</a>
<a name="ln12399"> </a>
<a name="ln12400">		return *this;</a>
<a name="ln12401">	}</a>
<a name="ln12402">#endif</a>
<a name="ln12403"> </a>
<a name="ln12404">	PUGI__FN xpath_value_type xpath_query::return_type() const</a>
<a name="ln12405">	{</a>
<a name="ln12406">		if (!_impl) return xpath_type_none;</a>
<a name="ln12407"> </a>
<a name="ln12408">		return static_cast&lt;impl::xpath_query_impl*&gt;(_impl)-&gt;root-&gt;rettype();</a>
<a name="ln12409">	}</a>
<a name="ln12410"> </a>
<a name="ln12411">	PUGI__FN bool xpath_query::evaluate_boolean(const xpath_node&amp; n) const</a>
<a name="ln12412">	{</a>
<a name="ln12413">		if (!_impl) return false;</a>
<a name="ln12414"> </a>
<a name="ln12415">		impl::xpath_context c(n, 1, 1);</a>
<a name="ln12416">		impl::xpath_stack_data sd;</a>
<a name="ln12417"> </a>
<a name="ln12418">	#ifdef PUGIXML_NO_EXCEPTIONS</a>
<a name="ln12419">		if (setjmp(sd.error_handler)) return false;</a>
<a name="ln12420">	#endif</a>
<a name="ln12421"> </a>
<a name="ln12422">		return static_cast&lt;impl::xpath_query_impl*&gt;(_impl)-&gt;root-&gt;eval_boolean(c, sd.stack);</a>
<a name="ln12423">	}</a>
<a name="ln12424"> </a>
<a name="ln12425">	PUGI__FN double xpath_query::evaluate_number(const xpath_node&amp; n) const</a>
<a name="ln12426">	{</a>
<a name="ln12427">		if (!_impl) return impl::gen_nan();</a>
<a name="ln12428"> </a>
<a name="ln12429">		impl::xpath_context c(n, 1, 1);</a>
<a name="ln12430">		impl::xpath_stack_data sd;</a>
<a name="ln12431"> </a>
<a name="ln12432">	#ifdef PUGIXML_NO_EXCEPTIONS</a>
<a name="ln12433">		if (setjmp(sd.error_handler)) return impl::gen_nan();</a>
<a name="ln12434">	#endif</a>
<a name="ln12435"> </a>
<a name="ln12436">		return static_cast&lt;impl::xpath_query_impl*&gt;(_impl)-&gt;root-&gt;eval_number(c, sd.stack);</a>
<a name="ln12437">	}</a>
<a name="ln12438"> </a>
<a name="ln12439">#ifndef PUGIXML_NO_STL</a>
<a name="ln12440">	PUGI__FN string_t xpath_query::evaluate_string(const xpath_node&amp; n) const</a>
<a name="ln12441">	{</a>
<a name="ln12442">		impl::xpath_stack_data sd;</a>
<a name="ln12443"> </a>
<a name="ln12444">		impl::xpath_string r = impl::evaluate_string_impl(static_cast&lt;impl::xpath_query_impl*&gt;(_impl), n, sd);</a>
<a name="ln12445"> </a>
<a name="ln12446">		return string_t(r.c_str(), r.length());</a>
<a name="ln12447">	}</a>
<a name="ln12448">#endif</a>
<a name="ln12449"> </a>
<a name="ln12450">	PUGI__FN size_t xpath_query::evaluate_string(char_t* buffer, size_t capacity, const xpath_node&amp; n) const</a>
<a name="ln12451">	{</a>
<a name="ln12452">		impl::xpath_stack_data sd;</a>
<a name="ln12453"> </a>
<a name="ln12454">		impl::xpath_string r = impl::evaluate_string_impl(static_cast&lt;impl::xpath_query_impl*&gt;(_impl), n, sd);</a>
<a name="ln12455"> </a>
<a name="ln12456">		size_t full_size = r.length() + 1;</a>
<a name="ln12457"> </a>
<a name="ln12458">		if (capacity &gt; 0)</a>
<a name="ln12459">		{</a>
<a name="ln12460">			size_t size = (full_size &lt; capacity) ? full_size : capacity;</a>
<a name="ln12461">			assert(size &gt; 0);</a>
<a name="ln12462"> </a>
<a name="ln12463">			memcpy(buffer, r.c_str(), (size - 1) * sizeof(char_t));</a>
<a name="ln12464">			buffer[size - 1] = 0;</a>
<a name="ln12465">		}</a>
<a name="ln12466"> </a>
<a name="ln12467">		return full_size;</a>
<a name="ln12468">	}</a>
<a name="ln12469"> </a>
<a name="ln12470">	PUGI__FN xpath_node_set xpath_query::evaluate_node_set(const xpath_node&amp; n) const</a>
<a name="ln12471">	{</a>
<a name="ln12472">		impl::xpath_ast_node* root = impl::evaluate_node_set_prepare(static_cast&lt;impl::xpath_query_impl*&gt;(_impl));</a>
<a name="ln12473">		if (!root) return xpath_node_set();</a>
<a name="ln12474"> </a>
<a name="ln12475">		impl::xpath_context c(n, 1, 1);</a>
<a name="ln12476">		impl::xpath_stack_data sd;</a>
<a name="ln12477"> </a>
<a name="ln12478">	#ifdef PUGIXML_NO_EXCEPTIONS</a>
<a name="ln12479">		if (setjmp(sd.error_handler)) return xpath_node_set();</a>
<a name="ln12480">	#endif</a>
<a name="ln12481"> </a>
<a name="ln12482">		impl::xpath_node_set_raw r = root-&gt;eval_node_set(c, sd.stack, impl::nodeset_eval_all);</a>
<a name="ln12483"> </a>
<a name="ln12484">		return xpath_node_set(r.begin(), r.end(), r.type());</a>
<a name="ln12485">	}</a>
<a name="ln12486"> </a>
<a name="ln12487">	PUGI__FN xpath_node xpath_query::evaluate_node(const xpath_node&amp; n) const</a>
<a name="ln12488">	{</a>
<a name="ln12489">		impl::xpath_ast_node* root = impl::evaluate_node_set_prepare(static_cast&lt;impl::xpath_query_impl*&gt;(_impl));</a>
<a name="ln12490">		if (!root) return xpath_node();</a>
<a name="ln12491"> </a>
<a name="ln12492">		impl::xpath_context c(n, 1, 1);</a>
<a name="ln12493">		impl::xpath_stack_data sd;</a>
<a name="ln12494"> </a>
<a name="ln12495">	#ifdef PUGIXML_NO_EXCEPTIONS</a>
<a name="ln12496">		if (setjmp(sd.error_handler)) return xpath_node();</a>
<a name="ln12497">	#endif</a>
<a name="ln12498"> </a>
<a name="ln12499">		impl::xpath_node_set_raw r = root-&gt;eval_node_set(c, sd.stack, impl::nodeset_eval_first);</a>
<a name="ln12500"> </a>
<a name="ln12501">		return r.first();</a>
<a name="ln12502">	}</a>
<a name="ln12503"> </a>
<a name="ln12504">	PUGI__FN const xpath_parse_result&amp; xpath_query::result() const</a>
<a name="ln12505">	{</a>
<a name="ln12506">		return _result;</a>
<a name="ln12507">	}</a>
<a name="ln12508"> </a>
<a name="ln12509">	PUGI__FN static void unspecified_bool_xpath_query(xpath_query***)</a>
<a name="ln12510">	{</a>
<a name="ln12511">	}</a>
<a name="ln12512"> </a>
<a name="ln12513">	PUGI__FN xpath_query::operator xpath_query::unspecified_bool_type() const</a>
<a name="ln12514">	{</a>
<a name="ln12515">		return _impl ? unspecified_bool_xpath_query : 0;</a>
<a name="ln12516">	}</a>
<a name="ln12517"> </a>
<a name="ln12518">	PUGI__FN bool xpath_query::operator!() const</a>
<a name="ln12519">	{</a>
<a name="ln12520">		return !_impl;</a>
<a name="ln12521">	}</a>
<a name="ln12522"> </a>
<a name="ln12523">	PUGI__FN xpath_node xml_node::select_node(const char_t* query, xpath_variable_set* variables) const</a>
<a name="ln12524">	{</a>
<a name="ln12525">		xpath_query q(query, variables);</a>
<a name="ln12526">		return select_node(q);</a>
<a name="ln12527">	}</a>
<a name="ln12528"> </a>
<a name="ln12529">	PUGI__FN xpath_node xml_node::select_node(const xpath_query&amp; query) const</a>
<a name="ln12530">	{</a>
<a name="ln12531">		return query.evaluate_node(*this);</a>
<a name="ln12532">	}</a>
<a name="ln12533"> </a>
<a name="ln12534">	PUGI__FN xpath_node_set xml_node::select_nodes(const char_t* query, xpath_variable_set* variables) const</a>
<a name="ln12535">	{</a>
<a name="ln12536">		xpath_query q(query, variables);</a>
<a name="ln12537">		return select_nodes(q);</a>
<a name="ln12538">	}</a>
<a name="ln12539"> </a>
<a name="ln12540">	PUGI__FN xpath_node_set xml_node::select_nodes(const xpath_query&amp; query) const</a>
<a name="ln12541">	{</a>
<a name="ln12542">		return query.evaluate_node_set(*this);</a>
<a name="ln12543">	}</a>
<a name="ln12544"> </a>
<a name="ln12545">	PUGI__FN xpath_node xml_node::select_single_node(const char_t* query, xpath_variable_set* variables) const</a>
<a name="ln12546">	{</a>
<a name="ln12547">		xpath_query q(query, variables);</a>
<a name="ln12548">		return select_single_node(q);</a>
<a name="ln12549">	}</a>
<a name="ln12550"> </a>
<a name="ln12551">	PUGI__FN xpath_node xml_node::select_single_node(const xpath_query&amp; query) const</a>
<a name="ln12552">	{</a>
<a name="ln12553">		return query.evaluate_node(*this);</a>
<a name="ln12554">	}</a>
<a name="ln12555">}</a>
<a name="ln12556"> </a>
<a name="ln12557">#endif</a>
<a name="ln12558"> </a>
<a name="ln12559">#ifdef __BORLANDC__</a>
<a name="ln12560">#	pragma option pop</a>
<a name="ln12561">#endif</a>
<a name="ln12562"> </a>
<a name="ln12563">// Intel C++ does not properly keep warning state for function templates,</a>
<a name="ln12564">// so popping warning state at the end of translation unit leads to warnings in the middle.</a>
<a name="ln12565">#if defined(_MSC_VER) &amp;&amp; !defined(__INTEL_COMPILER)</a>
<a name="ln12566">#	pragma warning(pop)</a>
<a name="ln12567">#endif</a>
<a name="ln12568"> </a>
<a name="ln12569">// Undefine all local macros (makes sure we're not leaking macros in header-only mode)</a>
<a name="ln12570">#undef PUGI__NO_INLINE</a>
<a name="ln12571">#undef PUGI__UNLIKELY</a>
<a name="ln12572">#undef PUGI__STATIC_ASSERT</a>
<a name="ln12573">#undef PUGI__DMC_VOLATILE</a>
<a name="ln12574">#undef PUGI__MSVC_CRT_VERSION</a>
<a name="ln12575">#undef PUGI__NS_BEGIN</a>
<a name="ln12576">#undef PUGI__NS_END</a>
<a name="ln12577">#undef PUGI__FN</a>
<a name="ln12578">#undef PUGI__FN_NO_INLINE</a>
<a name="ln12579">#undef PUGI__GETHEADER_IMPL</a>
<a name="ln12580">#undef PUGI__GETPAGE_IMPL</a>
<a name="ln12581">#undef PUGI__GETPAGE</a>
<a name="ln12582">#undef PUGI__NODETYPE</a>
<a name="ln12583">#undef PUGI__IS_CHARTYPE_IMPL</a>
<a name="ln12584">#undef PUGI__IS_CHARTYPE</a>
<a name="ln12585">#undef PUGI__IS_CHARTYPEX</a>
<a name="ln12586">#undef PUGI__ENDSWITH</a>
<a name="ln12587">#undef PUGI__SKIPWS</a>
<a name="ln12588">#undef PUGI__OPTSET</a>
<a name="ln12589">#undef PUGI__PUSHNODE</a>
<a name="ln12590">#undef PUGI__POPNODE</a>
<a name="ln12591">#undef PUGI__SCANFOR</a>
<a name="ln12592">#undef PUGI__SCANWHILE</a>
<a name="ln12593">#undef PUGI__SCANWHILE_UNROLL</a>
<a name="ln12594">#undef PUGI__ENDSEG</a>
<a name="ln12595">#undef PUGI__THROW_ERROR</a>
<a name="ln12596">#undef PUGI__CHECK_ERROR</a>
<a name="ln12597"> </a>
<a name="ln12598">#endif</a>
<a name="ln12599"> </a>
<a name="ln12600">/**</a>
<a name="ln12601"> * Copyright (c) 2006-2016 Arseny Kapoulkine</a>
<a name="ln12602"> *</a>
<a name="ln12603"> * Permission is hereby granted, free of charge, to any person</a>
<a name="ln12604"> * obtaining a copy of this software and associated documentation</a>
<a name="ln12605"> * files (the &quot;Software&quot;), to deal in the Software without</a>
<a name="ln12606"> * restriction, including without limitation the rights to use,</a>
<a name="ln12607"> * copy, modify, merge, publish, distribute, sublicense, and/or sell</a>
<a name="ln12608"> * copies of the Software, and to permit persons to whom the</a>
<a name="ln12609"> * Software is furnished to do so, subject to the following</a>
<a name="ln12610"> * conditions:</a>
<a name="ln12611"> *</a>
<a name="ln12612"> * The above copyright notice and this permission notice shall be</a>
<a name="ln12613"> * included in all copies or substantial portions of the Software.</a>
<a name="ln12614"> *</a>
<a name="ln12615"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</a>
<a name="ln12616"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES</a>
<a name="ln12617"> * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</a>
<a name="ln12618"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT</a>
<a name="ln12619"> * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,</a>
<a name="ln12620"> * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</a>
<a name="ln12621"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR</a>
<a name="ln12622"> * OTHER DEALINGS IN THE SOFTWARE.</a>
<a name="ln12623"> */</a>

</code></pre>
<div class="balloon" rel="10075"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: _data.</p></div>
<div class="balloon" rel="10063"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: _data.</p></div>
<div class="balloon" rel="3676"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: buffer, scratch.</p></div>
<div class="balloon" rel="8455"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: name.</p></div>
<div class="balloon" rel="8445"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: name.</p></div>
<div class="balloon" rel="8465"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: name.</p></div>
<div class="balloon" rel="8480"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: name.</p></div>
<div class="balloon" rel="5614"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The '_root' pointer was used unsafely after it was verified against nullptr. Check lines: 5609, 5614.</p></div>
<div class="balloon" rel="10345"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 10345, 10352</p></div>
<div class="balloon" rel="11724"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: _scratch.</p></div>
<div class="balloon" rel="5604"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The '_root' pointer was used unsafely after it was verified against nullptr. Check lines: 5599, 5604.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
