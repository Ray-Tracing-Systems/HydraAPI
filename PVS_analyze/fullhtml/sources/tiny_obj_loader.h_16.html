
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>tiny_obj_loader.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">The MIT License (MIT)</a>
<a name="ln3"> </a>
<a name="ln4">Copyright (c) 2012-2018 Syoyo Fujita and many contributors.</a>
<a name="ln5"> </a>
<a name="ln6">Permission is hereby granted, free of charge, to any person obtaining a copy</a>
<a name="ln7">of this software and associated documentation files (the &quot;Software&quot;), to deal</a>
<a name="ln8">in the Software without restriction, including without limitation the rights</a>
<a name="ln9">to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</a>
<a name="ln10">copies of the Software, and to permit persons to whom the Software is</a>
<a name="ln11">furnished to do so, subject to the following conditions:</a>
<a name="ln12"> </a>
<a name="ln13">The above copyright notice and this permission notice shall be included in</a>
<a name="ln14">all copies or substantial portions of the Software.</a>
<a name="ln15"> </a>
<a name="ln16">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</a>
<a name="ln17">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</a>
<a name="ln18">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</a>
<a name="ln19">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</a>
<a name="ln20">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</a>
<a name="ln21">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</a>
<a name="ln22">THE SOFTWARE.</a>
<a name="ln23">*/</a>
<a name="ln24"> </a>
<a name="ln25">//</a>
<a name="ln26">// version 2.0.0 : Add new object oriented API. 1.x API is still provided.</a>
<a name="ln27">//                 * Support line primitive.</a>
<a name="ln28">//                 * Support points primitive.</a>
<a name="ln29">// version 1.4.0 : Modifed ParseTextureNameAndOption API</a>
<a name="ln30">// version 1.3.1 : Make ParseTextureNameAndOption API public</a>
<a name="ln31">// version 1.3.0 : Separate warning and error message(breaking API of LoadObj)</a>
<a name="ln32">// version 1.2.3 : Added color space extension('-colorspace') to tex opts.</a>
<a name="ln33">// version 1.2.2 : Parse multiple group names.</a>
<a name="ln34">// version 1.2.1 : Added initial support for line('l') primitive(PR #178)</a>
<a name="ln35">// version 1.2.0 : Hardened implementation(#175)</a>
<a name="ln36">// version 1.1.1 : Support smoothing groups(#162)</a>
<a name="ln37">// version 1.1.0 : Support parsing vertex color(#144)</a>
<a name="ln38">// version 1.0.8 : Fix parsing `g` tag just after `usemtl`(#138)</a>
<a name="ln39">// version 1.0.7 : Support multiple tex options(#126)</a>
<a name="ln40">// version 1.0.6 : Add TINYOBJLOADER_USE_DOUBLE option(#124)</a>
<a name="ln41">// version 1.0.5 : Ignore `Tr` when `d` exists in MTL(#43)</a>
<a name="ln42">// version 1.0.4 : Support multiple filenames for 'mtllib'(#112)</a>
<a name="ln43">// version 1.0.3 : Support parsing texture options(#85)</a>
<a name="ln44">// version 1.0.2 : Improve parsing speed by about a factor of 2 for large</a>
<a name="ln45">// files(#105)</a>
<a name="ln46">// version 1.0.1 : Fixes a shape is lost if obj ends with a 'usemtl'(#104)</a>
<a name="ln47">// version 1.0.0 : Change data structure. Change license from BSD to MIT.</a>
<a name="ln48">//</a>
<a name="ln49"> </a>
<a name="ln50">//</a>
<a name="ln51">// Use this in *one* .cc</a>
<a name="ln52">//   #define TINYOBJLOADER_IMPLEMENTATION</a>
<a name="ln53">//   #include &quot;tiny_obj_loader.h&quot;</a>
<a name="ln54">//</a>
<a name="ln55"> </a>
<a name="ln56">#ifndef TINY_OBJ_LOADER_H_</a>
<a name="ln57">#define TINY_OBJ_LOADER_H_</a>
<a name="ln58"> </a>
<a name="ln59">#include &lt;map&gt;</a>
<a name="ln60">#include &lt;string&gt;</a>
<a name="ln61">#include &lt;vector&gt;</a>
<a name="ln62"> </a>
<a name="ln63">namespace tinyobj {</a>
<a name="ln64"> </a>
<a name="ln65">#ifdef __clang__</a>
<a name="ln66">#pragma clang diagnostic push</a>
<a name="ln67">#if __has_warning(&quot;-Wzero-as-null-pointer-constant&quot;)</a>
<a name="ln68">#pragma clang diagnostic ignored &quot;-Wzero-as-null-pointer-constant&quot;</a>
<a name="ln69">#endif</a>
<a name="ln70"> </a>
<a name="ln71">#pragma clang diagnostic ignored &quot;-Wpadded&quot;</a>
<a name="ln72"> </a>
<a name="ln73">#endif</a>
<a name="ln74"> </a>
<a name="ln75">// https://en.wikipedia.org/wiki/Wavefront_.obj_file says ...</a>
<a name="ln76">//</a>
<a name="ln77">//  -blendu on | off                       # set horizontal texture blending</a>
<a name="ln78">//  (default on)</a>
<a name="ln79">//  -blendv on | off                       # set vertical texture blending</a>
<a name="ln80">//  (default on)</a>
<a name="ln81">//  -boost real_value                      # boost mip-map sharpness</a>
<a name="ln82">//  -mm base_value gain_value              # modify texture map values (default</a>
<a name="ln83">//  0 1)</a>
<a name="ln84">//                                         #     base_value = brightness,</a>
<a name="ln85">//                                         gain_value = contrast</a>
<a name="ln86">//  -o u [v [w]]                           # Origin offset             (default</a>
<a name="ln87">//  0 0 0)</a>
<a name="ln88">//  -s u [v [w]]                           # Scale                     (default</a>
<a name="ln89">//  1 1 1)</a>
<a name="ln90">//  -t u [v [w]]                           # Turbulence                (default</a>
<a name="ln91">//  0 0 0)</a>
<a name="ln92">//  -texres resolution                     # texture resolution to create</a>
<a name="ln93">//  -clamp on | off                        # only render texels in the clamped</a>
<a name="ln94">//  0-1 range (default off)</a>
<a name="ln95">//                                         #   When unclamped, textures are</a>
<a name="ln96">//                                         repeated across a surface,</a>
<a name="ln97">//                                         #   when clamped, only texels which</a>
<a name="ln98">//                                         fall within the 0-1</a>
<a name="ln99">//                                         #   range are rendered.</a>
<a name="ln100">//  -bm mult_value                         # bump multiplier (for bump maps</a>
<a name="ln101">//  only)</a>
<a name="ln102">//</a>
<a name="ln103">//  -imfchan r | g | b | m | l | z         # specifies which channel of the file</a>
<a name="ln104">//  is used to</a>
<a name="ln105">//                                         # create a scalar or bump texture.</a>
<a name="ln106">//                                         r:red, g:green,</a>
<a name="ln107">//                                         # b:blue, m:matte, l:luminance,</a>
<a name="ln108">//                                         z:z-depth..</a>
<a name="ln109">//                                         # (the default for bump is 'l' and</a>
<a name="ln110">//                                         for decal is 'm')</a>
<a name="ln111">//  bump -imfchan r bumpmap.tga            # says to use the red channel of</a>
<a name="ln112">//  bumpmap.tga as the bumpmap</a>
<a name="ln113">//</a>
<a name="ln114">// For reflection maps...</a>
<a name="ln115">//</a>
<a name="ln116">//   -type sphere                           # specifies a sphere for a &quot;refl&quot;</a>
<a name="ln117">//   reflection map</a>
<a name="ln118">//   -type cube_top    | cube_bottom |      # when using a cube map, the texture</a>
<a name="ln119">//   file for each</a>
<a name="ln120">//         cube_front  | cube_back   |      # side of the cube is specified</a>
<a name="ln121">//         separately</a>
<a name="ln122">//         cube_left   | cube_right</a>
<a name="ln123">//</a>
<a name="ln124">// TinyObjLoader extension.</a>
<a name="ln125">//</a>
<a name="ln126">//   -colorspace SPACE                      # Color space of the texture. e.g.</a>
<a name="ln127">//   'sRGB` or 'linear'</a>
<a name="ln128">//</a>
<a name="ln129"> </a>
<a name="ln130">#ifdef TINYOBJLOADER_USE_DOUBLE</a>
<a name="ln131">//#pragma message &quot;using double&quot;</a>
<a name="ln132">typedef double real_t;</a>
<a name="ln133">#else</a>
<a name="ln134">//#pragma message &quot;using float&quot;</a>
<a name="ln135">typedef float real_t;</a>
<a name="ln136">#endif</a>
<a name="ln137"> </a>
<a name="ln138">typedef enum {</a>
<a name="ln139">  TEXTURE_TYPE_NONE,  // default</a>
<a name="ln140">  TEXTURE_TYPE_SPHERE,</a>
<a name="ln141">  TEXTURE_TYPE_CUBE_TOP,</a>
<a name="ln142">  TEXTURE_TYPE_CUBE_BOTTOM,</a>
<a name="ln143">  TEXTURE_TYPE_CUBE_FRONT,</a>
<a name="ln144">  TEXTURE_TYPE_CUBE_BACK,</a>
<a name="ln145">  TEXTURE_TYPE_CUBE_LEFT,</a>
<a name="ln146">  TEXTURE_TYPE_CUBE_RIGHT</a>
<a name="ln147">} texture_type_t;</a>
<a name="ln148"> </a>
<a name="ln149">typedef struct {</a>
<a name="ln150">  texture_type_t type;      // -type (default TEXTURE_TYPE_NONE)</a>
<a name="ln151">  real_t sharpness;         // -boost (default 1.0?)</a>
<a name="ln152">  real_t brightness;        // base_value in -mm option (default 0)</a>
<a name="ln153">  real_t contrast;          // gain_value in -mm option (default 1)</a>
<a name="ln154">  real_t origin_offset[3];  // -o u [v [w]] (default 0 0 0)</a>
<a name="ln155">  real_t scale[3];          // -s u [v [w]] (default 1 1 1)</a>
<a name="ln156">  real_t turbulence[3];     // -t u [v [w]] (default 0 0 0)</a>
<a name="ln157">  // int   texture_resolution; // -texres resolution (default = ?) TODO</a>
<a name="ln158">  bool clamp;    // -clamp (default false)</a>
<a name="ln159">  char imfchan;  // -imfchan (the default for bump is 'l' and for decal is 'm')</a>
<a name="ln160">  bool blendu;   // -blendu (default on)</a>
<a name="ln161">  bool blendv;   // -blendv (default on)</a>
<a name="ln162">  real_t bump_multiplier;  // -bm (for bump maps only, default 1.0)</a>
<a name="ln163"> </a>
<a name="ln164">  // extension</a>
<a name="ln165">  std::string colorspace;  // Explicitly specify color space of stored texel</a>
<a name="ln166">                           // value. Usually `sRGB` or `linear` (default empty).</a>
<a name="ln167">} texture_option_t;</a>
<a name="ln168"> </a>
<a name="ln169">typedef struct {</a>
<a name="ln170">  std::string name;</a>
<a name="ln171"> </a>
<a name="ln172">  real_t ambient[3];</a>
<a name="ln173">  real_t diffuse[3];</a>
<a name="ln174">  real_t specular[3];</a>
<a name="ln175">  real_t transmittance[3];</a>
<a name="ln176">  real_t emission[3];</a>
<a name="ln177">  real_t shininess;</a>
<a name="ln178">  real_t ior;       // index of refraction</a>
<a name="ln179">  real_t dissolve;  // 1 == opaque; 0 == fully transparent</a>
<a name="ln180">  // illumination model (see http://www.fileformat.info/format/material/)</a>
<a name="ln181">  int illum;</a>
<a name="ln182"> </a>
<a name="ln183">  int dummy;  // Suppress padding warning.</a>
<a name="ln184"> </a>
<a name="ln185">  std::string ambient_texname;             // map_Ka</a>
<a name="ln186">  std::string diffuse_texname;             // map_Kd</a>
<a name="ln187">  std::string specular_texname;            // map_Ks</a>
<a name="ln188">  std::string specular_highlight_texname;  // map_Ns</a>
<a name="ln189">  std::string bump_texname;                // map_bump, map_Bump, bump</a>
<a name="ln190">  std::string displacement_texname;        // disp</a>
<a name="ln191">  std::string alpha_texname;               // map_d</a>
<a name="ln192">  std::string reflection_texname;          // refl</a>
<a name="ln193"> </a>
<a name="ln194">  texture_option_t ambient_texopt;</a>
<a name="ln195">  texture_option_t diffuse_texopt;</a>
<a name="ln196">  texture_option_t specular_texopt;</a>
<a name="ln197">  texture_option_t specular_highlight_texopt;</a>
<a name="ln198">  texture_option_t bump_texopt;</a>
<a name="ln199">  texture_option_t displacement_texopt;</a>
<a name="ln200">  texture_option_t alpha_texopt;</a>
<a name="ln201">  texture_option_t reflection_texopt;</a>
<a name="ln202"> </a>
<a name="ln203">  // PBR extension</a>
<a name="ln204">  // http://exocortex.com/blog/extending_wavefront_mtl_to_support_pbr</a>
<a name="ln205">  real_t roughness;            // [0, 1] default 0</a>
<a name="ln206">  real_t metallic;             // [0, 1] default 0</a>
<a name="ln207">  real_t sheen;                // [0, 1] default 0</a>
<a name="ln208">  real_t clearcoat_thickness;  // [0, 1] default 0</a>
<a name="ln209">  real_t clearcoat_roughness;  // [0, 1] default 0</a>
<a name="ln210">  real_t anisotropy;           // aniso. [0, 1] default 0</a>
<a name="ln211">  real_t anisotropy_rotation;  // anisor. [0, 1] default 0</a>
<a name="ln212">  real_t pad0;</a>
<a name="ln213">  std::string roughness_texname;  // map_Pr</a>
<a name="ln214">  std::string metallic_texname;   // map_Pm</a>
<a name="ln215">  std::string sheen_texname;      // map_Ps</a>
<a name="ln216">  std::string emissive_texname;   // map_Ke</a>
<a name="ln217">  std::string normal_texname;     // norm. For normal mapping.</a>
<a name="ln218"> </a>
<a name="ln219">  texture_option_t roughness_texopt;</a>
<a name="ln220">  texture_option_t metallic_texopt;</a>
<a name="ln221">  texture_option_t sheen_texopt;</a>
<a name="ln222">  texture_option_t emissive_texopt;</a>
<a name="ln223">  texture_option_t normal_texopt;</a>
<a name="ln224"> </a>
<a name="ln225">  int pad2;</a>
<a name="ln226"> </a>
<a name="ln227">  std::map&lt;std::string, std::string&gt; unknown_parameter;</a>
<a name="ln228"> </a>
<a name="ln229">#ifdef TINY_OBJ_LOADER_PYTHON_BINDING</a>
<a name="ln230">  // For pybind11</a>
<a name="ln231">  std::array&lt;double, 3&gt; GetDiffuse() {</a>
<a name="ln232">    std::array&lt;double, 3&gt; values;</a>
<a name="ln233">    values[0] = double(diffuse[0]);</a>
<a name="ln234">    values[1] = double(diffuse[1]);</a>
<a name="ln235">    values[2] = double(diffuse[2]);</a>
<a name="ln236"> </a>
<a name="ln237">    return values;</a>
<a name="ln238">  }</a>
<a name="ln239"> </a>
<a name="ln240">  std::array&lt;double, 3&gt; GetSpecular() {</a>
<a name="ln241">    std::array&lt;double, 3&gt; values;</a>
<a name="ln242">    values[0] = double(specular[0]);</a>
<a name="ln243">    values[1] = double(specular[1]);</a>
<a name="ln244">    values[2] = double(specular[2]);</a>
<a name="ln245"> </a>
<a name="ln246">    return values;</a>
<a name="ln247">  }</a>
<a name="ln248"> </a>
<a name="ln249">  std::array&lt;double, 3&gt; GetTransmittance() {</a>
<a name="ln250">    std::array&lt;double, 3&gt; values;</a>
<a name="ln251">    values[0] = double(transmittance[0]);</a>
<a name="ln252">    values[1] = double(transmittance[1]);</a>
<a name="ln253">    values[2] = double(transmittance[2]);</a>
<a name="ln254"> </a>
<a name="ln255">    return values;</a>
<a name="ln256">  }</a>
<a name="ln257"> </a>
<a name="ln258">  std::array&lt;double, 3&gt; GetEmission() {</a>
<a name="ln259">    std::array&lt;double, 3&gt; values;</a>
<a name="ln260">    values[0] = double(emission[0]);</a>
<a name="ln261">    values[1] = double(emission[1]);</a>
<a name="ln262">    values[2] = double(emission[2]);</a>
<a name="ln263"> </a>
<a name="ln264">    return values;</a>
<a name="ln265">  }</a>
<a name="ln266"> </a>
<a name="ln267">  std::array&lt;double, 3&gt; GetAmbient() {</a>
<a name="ln268">    std::array&lt;double, 3&gt; values;</a>
<a name="ln269">    values[0] = double(ambient[0]);</a>
<a name="ln270">    values[1] = double(ambient[1]);</a>
<a name="ln271">    values[2] = double(ambient[2]);</a>
<a name="ln272"> </a>
<a name="ln273">    return values;</a>
<a name="ln274">  }</a>
<a name="ln275"> </a>
<a name="ln276">  void SetDiffuse(std::array&lt;double, 3&gt; &amp;a) {</a>
<a name="ln277">    diffuse[0] = real_t(a[0]);</a>
<a name="ln278">    diffuse[1] = real_t(a[1]);</a>
<a name="ln279">    diffuse[2] = real_t(a[2]);</a>
<a name="ln280">  }</a>
<a name="ln281"> </a>
<a name="ln282">  void SetAmbient(std::array&lt;double, 3&gt; &amp;a) {</a>
<a name="ln283">    ambient[0] = real_t(a[0]);</a>
<a name="ln284">    ambient[1] = real_t(a[1]);</a>
<a name="ln285">    ambient[2] = real_t(a[2]);</a>
<a name="ln286">  }</a>
<a name="ln287"> </a>
<a name="ln288">  void SetSpecular(std::array&lt;double, 3&gt; &amp;a) {</a>
<a name="ln289">    specular[0] = real_t(a[0]);</a>
<a name="ln290">    specular[1] = real_t(a[1]);</a>
<a name="ln291">    specular[2] = real_t(a[2]);</a>
<a name="ln292">  }</a>
<a name="ln293"> </a>
<a name="ln294">  void SetTransmittance(std::array&lt;double, 3&gt; &amp;a) {</a>
<a name="ln295">    transmittance[0] = real_t(a[0]);</a>
<a name="ln296">    transmittance[1] = real_t(a[1]);</a>
<a name="ln297">    transmittance[2] = real_t(a[2]);</a>
<a name="ln298">  }</a>
<a name="ln299"> </a>
<a name="ln300">  std::string GetCustomParameter(const std::string &amp;key) {</a>
<a name="ln301">    std::map&lt;std::string, std::string&gt;::const_iterator it =</a>
<a name="ln302">        unknown_parameter.find(key);</a>
<a name="ln303"> </a>
<a name="ln304">    if (it != unknown_parameter.end()) {</a>
<a name="ln305">      return it-&gt;second;</a>
<a name="ln306">    }</a>
<a name="ln307">    return std::string();</a>
<a name="ln308">  }</a>
<a name="ln309"> </a>
<a name="ln310">#endif</a>
<a name="ln311"> </a>
<a name="ln312">} material_t;</a>
<a name="ln313"> </a>
<a name="ln314">typedef struct {</a>
<a name="ln315">  std::string name;</a>
<a name="ln316"> </a>
<a name="ln317">  std::vector&lt;int&gt; intValues;</a>
<a name="ln318">  std::vector&lt;real_t&gt; floatValues;</a>
<a name="ln319">  std::vector&lt;std::string&gt; stringValues;</a>
<a name="ln320">} tag_t;</a>
<a name="ln321"> </a>
<a name="ln322">// Index struct to support different indices for vtx/normal/texcoord.</a>
<a name="ln323">// -1 means not used.</a>
<a name="ln324">typedef struct {</a>
<a name="ln325">  int vertex_index;</a>
<a name="ln326">  int normal_index;</a>
<a name="ln327">  int texcoord_index;</a>
<a name="ln328">} index_t;</a>
<a name="ln329"> </a>
<a name="ln330">typedef struct {</a>
<a name="ln331">  std::vector&lt;index_t&gt; indices;</a>
<a name="ln332">  std::vector&lt;unsigned char&gt; num_face_vertices;  // The number of vertices per</a>
<a name="ln333">                                                 // face. 3 = polygon, 4 = quad,</a>
<a name="ln334">                                                 // ... Up to 255.</a>
<a name="ln335">  std::vector&lt;int&gt; material_ids;                 // per-face material ID</a>
<a name="ln336">  std::vector&lt;unsigned int&gt; smoothing_group_ids;  // per-face smoothing group</a>
<a name="ln337">                                                  // ID(0 = off. positive value</a>
<a name="ln338">                                                  // = group id)</a>
<a name="ln339">  std::vector&lt;tag_t&gt; tags;                        // SubD tag</a>
<a name="ln340">} mesh_t;</a>
<a name="ln341"> </a>
<a name="ln342">// typedef struct {</a>
<a name="ln343">//  std::vector&lt;int&gt; indices;  // pairs of indices for lines</a>
<a name="ln344">//} path_t;</a>
<a name="ln345"> </a>
<a name="ln346">typedef struct {</a>
<a name="ln347">  // Linear flattened indices.</a>
<a name="ln348">  std::vector&lt;index_t&gt; indices;        // indices for vertices(poly lines)</a>
<a name="ln349">  std::vector&lt;int&gt; num_line_vertices;  // The number of vertices per line.</a>
<a name="ln350">} lines_t;</a>
<a name="ln351"> </a>
<a name="ln352">typedef struct {</a>
<a name="ln353">  std::vector&lt;index_t&gt; indices;  // indices for points</a>
<a name="ln354">} points_t;</a>
<a name="ln355"> </a>
<a name="ln356">typedef struct {</a>
<a name="ln357">  std::string name;</a>
<a name="ln358">  mesh_t mesh;</a>
<a name="ln359">  lines_t lines;</a>
<a name="ln360">  points_t points;</a>
<a name="ln361">} shape_t;</a>
<a name="ln362"> </a>
<a name="ln363">// Vertex attributes</a>
<a name="ln364">struct attrib_t {</a>
<a name="ln365">  std::vector&lt;real_t&gt; vertices;  // 'v'(xyz)</a>
<a name="ln366"> </a>
<a name="ln367">  // For backward compatibility, we store vertex weight in separate array.</a>
<a name="ln368">  std::vector&lt;real_t&gt; vertex_weights;  // 'v'(w)</a>
<a name="ln369">  std::vector&lt;real_t&gt; normals;         // 'vn'</a>
<a name="ln370">  std::vector&lt;real_t&gt; texcoords;       // 'vt'(uv)</a>
<a name="ln371"> </a>
<a name="ln372">  // For backward compatibility, we store texture coordinate 'w' in separate</a>
<a name="ln373">  // array.</a>
<a name="ln374">  std::vector&lt;real_t&gt; texcoord_ws;  // 'vt'(w)</a>
<a name="ln375">  std::vector&lt;real_t&gt; colors;       // extension: vertex colors</a>
<a name="ln376"> </a>
<a name="ln377">  attrib_t() {}</a>
<a name="ln378"> </a>
<a name="ln379">  //</a>
<a name="ln380">  // For pybind11</a>
<a name="ln381">  //</a>
<a name="ln382">  const std::vector&lt;real_t&gt; &amp;GetVertices() const { return vertices; }</a>
<a name="ln383"> </a>
<a name="ln384">  const std::vector&lt;real_t&gt; &amp;GetVertexWeights() const { return vertex_weights; }</a>
<a name="ln385">};</a>
<a name="ln386"> </a>
<a name="ln387">typedef struct callback_t_ {</a>
<a name="ln388">  // W is optional and set to 1 if there is no `w` item in `v` line</a>
<a name="ln389">  void (*vertex_cb)(void *user_data, real_t x, real_t y, real_t z, real_t w);</a>
<a name="ln390">  void (*normal_cb)(void *user_data, real_t x, real_t y, real_t z);</a>
<a name="ln391"> </a>
<a name="ln392">  // y and z are optional and set to 0 if there is no `y` and/or `z` item(s) in</a>
<a name="ln393">  // `vt` line.</a>
<a name="ln394">  void (*texcoord_cb)(void *user_data, real_t x, real_t y, real_t z);</a>
<a name="ln395"> </a>
<a name="ln396">  // called per 'f' line. num_indices is the number of face indices(e.g. 3 for</a>
<a name="ln397">  // triangle, 4 for quad)</a>
<a name="ln398">  // 0 will be passed for undefined index in index_t members.</a>
<a name="ln399">  void (*index_cb)(void *user_data, index_t *indices, int num_indices);</a>
<a name="ln400">  // `name` material name, `material_id` = the array index of material_t[]. -1</a>
<a name="ln401">  // if</a>
<a name="ln402">  // a material not found in .mtl</a>
<a name="ln403">  void (*usemtl_cb)(void *user_data, const char *name, int material_id);</a>
<a name="ln404">  // `materials` = parsed material data.</a>
<a name="ln405">  void (*mtllib_cb)(void *user_data, const material_t *materials,</a>
<a name="ln406">                    int num_materials);</a>
<a name="ln407">  // There may be multiple group names</a>
<a name="ln408">  void (*group_cb)(void *user_data, const char **names, int num_names);</a>
<a name="ln409">  void (*object_cb)(void *user_data, const char *name);</a>
<a name="ln410"> </a>
<a name="ln411">  callback_t_()</a>
<a name="ln412">      : vertex_cb(NULL),</a>
<a name="ln413">        normal_cb(NULL),</a>
<a name="ln414">        texcoord_cb(NULL),</a>
<a name="ln415">        index_cb(NULL),</a>
<a name="ln416">        usemtl_cb(NULL),</a>
<a name="ln417">        mtllib_cb(NULL),</a>
<a name="ln418">        group_cb(NULL),</a>
<a name="ln419">        object_cb(NULL) {}</a>
<a name="ln420">} callback_t;</a>
<a name="ln421"> </a>
<a name="ln422">class MaterialReader {</a>
<a name="ln423"> public:</a>
<a name="ln424">  MaterialReader() {}</a>
<a name="ln425">  virtual ~MaterialReader();</a>
<a name="ln426"> </a>
<a name="ln427">  virtual bool operator()(const std::string &amp;matId,</a>
<a name="ln428">                          std::vector&lt;material_t&gt; *materials,</a>
<a name="ln429">                          std::map&lt;std::string, int&gt; *matMap, std::string *warn,</a>
<a name="ln430">                          std::string *err) = 0;</a>
<a name="ln431">};</a>
<a name="ln432"> </a>
<a name="ln433">///</a>
<a name="ln434">/// Read .mtl from a file.</a>
<a name="ln435">///</a>
<a name="ln436">class MaterialFileReader : public MaterialReader {</a>
<a name="ln437"> public:</a>
<a name="ln438">  explicit MaterialFileReader(const std::string &amp;mtl_basedir)</a>
<a name="ln439">      : m_mtlBaseDir(mtl_basedir) {}</a>
<a name="ln440">  virtual ~MaterialFileReader() {}</a>
<a name="ln441">  virtual bool operator()(const std::string &amp;matId,</a>
<a name="ln442">                          std::vector&lt;material_t&gt; *materials,</a>
<a name="ln443">                          std::map&lt;std::string, int&gt; *matMap, std::string *warn,</a>
<a name="ln444">                          std::string *err);</a>
<a name="ln445"> </a>
<a name="ln446"> private:</a>
<a name="ln447">  std::string m_mtlBaseDir;</a>
<a name="ln448">};</a>
<a name="ln449"> </a>
<a name="ln450">///</a>
<a name="ln451">/// Read .mtl from a stream.</a>
<a name="ln452">///</a>
<a name="ln453">class MaterialStreamReader : public MaterialReader {</a>
<a name="ln454"> public:</a>
<a name="ln455">  explicit MaterialStreamReader(std::istream &amp;inStream)</a>
<a name="ln456">      : m_inStream(inStream) {}</a>
<a name="ln457">  virtual ~MaterialStreamReader() {}</a>
<a name="ln458">  virtual bool operator()(const std::string &amp;matId,</a>
<a name="ln459">                          std::vector&lt;material_t&gt; *materials,</a>
<a name="ln460">                          std::map&lt;std::string, int&gt; *matMap, std::string *warn,</a>
<a name="ln461">                          std::string *err);</a>
<a name="ln462"> </a>
<a name="ln463"> private:</a>
<a name="ln464">  std::istream &amp;m_inStream;</a>
<a name="ln465">};</a>
<a name="ln466"> </a>
<a name="ln467">// v2 API</a>
<a name="ln468">struct ObjReaderConfig {</a>
<a name="ln469">  bool triangulate;  // triangulate polygon?</a>
<a name="ln470"> </a>
<a name="ln471">  /// Parse vertex color.</a>
<a name="ln472">  /// If vertex color is not present, its filled with default value.</a>
<a name="ln473">  /// false = no vertex color</a>
<a name="ln474">  /// This will increase memory of parsed .obj</a>
<a name="ln475">  bool vertex_color;</a>
<a name="ln476"> </a>
<a name="ln477">  ///</a>
<a name="ln478">  /// Search path to .mtl file.</a>
<a name="ln479">  /// Default = &quot;&quot; = search from the same directory of .obj file.</a>
<a name="ln480">  /// Valid only when loading .obj from a file.</a>
<a name="ln481">  ///</a>
<a name="ln482">  std::string mtl_search_path;</a>
<a name="ln483"> </a>
<a name="ln484">  ObjReaderConfig() : triangulate(true), vertex_color(true) {}</a>
<a name="ln485">};</a>
<a name="ln486"> </a>
<a name="ln487">///</a>
<a name="ln488">/// Wavefront .obj reader class(v2 API)</a>
<a name="ln489">///</a>
<a name="ln490">class ObjReader {</a>
<a name="ln491"> public:</a>
<a name="ln492">  ObjReader() : valid_(false) {}</a>
<a name="ln493">  ~ObjReader() {}</a>
<a name="ln494"> </a>
<a name="ln495">  ///</a>
<a name="ln496">  /// Load .obj and .mtl from a file.</a>
<a name="ln497">  ///</a>
<a name="ln498">  /// @param[in] filename wavefront .obj filename</a>
<a name="ln499">  /// @param[in] config Reader configuration</a>
<a name="ln500">  ///</a>
<a name="ln501">  bool ParseFromFile(const std::string &amp;filename,</a>
<a name="ln502">                     const ObjReaderConfig &amp;config = ObjReaderConfig());</a>
<a name="ln503"> </a>
<a name="ln504">  ///</a>
<a name="ln505">  /// Parse .obj from a text string.</a>
<a name="ln506">  /// Need to supply .mtl text string by `mtl_text`.</a>
<a name="ln507">  /// This function ignores `mtllib` line in .obj text.</a>
<a name="ln508">  ///</a>
<a name="ln509">  /// @param[in] obj_text wavefront .obj filename</a>
<a name="ln510">  /// @param[in] mtl_text wavefront .mtl filename</a>
<a name="ln511">  /// @param[in] config Reader configuration</a>
<a name="ln512">  ///</a>
<a name="ln513">  bool ParseFromString(const std::string &amp;obj_text, const std::string &amp;mtl_text,</a>
<a name="ln514">                       const ObjReaderConfig &amp;config = ObjReaderConfig());</a>
<a name="ln515"> </a>
<a name="ln516">  ///</a>
<a name="ln517">  /// .obj was loaded or parsed correctly.</a>
<a name="ln518">  ///</a>
<a name="ln519">  bool Valid() const { return valid_; }</a>
<a name="ln520"> </a>
<a name="ln521">  const attrib_t &amp;GetAttrib() const { return attrib_; }</a>
<a name="ln522"> </a>
<a name="ln523">  const std::vector&lt;shape_t&gt; &amp;GetShapes() const { return shapes_; }</a>
<a name="ln524"> </a>
<a name="ln525">  const std::vector&lt;material_t&gt; &amp;GetMaterials() const { return materials_; }</a>
<a name="ln526"> </a>
<a name="ln527">  ///</a>
<a name="ln528">  /// Warning message(may be filled after `Load` or `Parse`)</a>
<a name="ln529">  ///</a>
<a name="ln530">  const std::string &amp;Warning() const { return warning_; }</a>
<a name="ln531"> </a>
<a name="ln532">  ///</a>
<a name="ln533">  /// Error message(filled when `Load` or `Parse` failed)</a>
<a name="ln534">  ///</a>
<a name="ln535">  const std::string &amp;Error() const { return error_; }</a>
<a name="ln536"> </a>
<a name="ln537"> private:</a>
<a name="ln538">  bool valid_;</a>
<a name="ln539"> </a>
<a name="ln540">  attrib_t attrib_;</a>
<a name="ln541">  std::vector&lt;shape_t&gt; shapes_;</a>
<a name="ln542">  std::vector&lt;material_t&gt; materials_;</a>
<a name="ln543"> </a>
<a name="ln544">  std::string warning_;</a>
<a name="ln545">  std::string error_;</a>
<a name="ln546">};</a>
<a name="ln547"> </a>
<a name="ln548">/// ==&gt;&gt;========= Legacy v1 API =============================================</a>
<a name="ln549"> </a>
<a name="ln550">/// Loads .obj from a file.</a>
<a name="ln551">/// 'attrib', 'shapes' and 'materials' will be filled with parsed shape data</a>
<a name="ln552">/// 'shapes' will be filled with parsed shape data</a>
<a name="ln553">/// Returns true when loading .obj become success.</a>
<a name="ln554">/// Returns warning message into `warn`, and error message into `err`</a>
<a name="ln555">/// 'mtl_basedir' is optional, and used for base directory for .mtl file.</a>
<a name="ln556">/// In default(`NULL'), .mtl file is searched from an application's working</a>
<a name="ln557">/// directory.</a>
<a name="ln558">/// 'triangulate' is optional, and used whether triangulate polygon face in .obj</a>
<a name="ln559">/// or not.</a>
<a name="ln560">/// Option 'default_vcols_fallback' specifies whether vertex colors should</a>
<a name="ln561">/// always be defined, even if no colors are given (fallback to white).</a>
<a name="ln562">bool LoadObj(attrib_t *attrib, std::vector&lt;shape_t&gt; *shapes,</a>
<a name="ln563">             std::vector&lt;material_t&gt; *materials, std::string *warn,</a>
<a name="ln564">             std::string *err, const char *filename,</a>
<a name="ln565">             const char *mtl_basedir = NULL, bool triangulate = true,</a>
<a name="ln566">             bool default_vcols_fallback = true);</a>
<a name="ln567"> </a>
<a name="ln568">/// Loads .obj from a file with custom user callback.</a>
<a name="ln569">/// .mtl is loaded as usual and parsed material_t data will be passed to</a>
<a name="ln570">/// `callback.mtllib_cb`.</a>
<a name="ln571">/// Returns true when loading .obj/.mtl become success.</a>
<a name="ln572">/// Returns warning message into `warn`, and error message into `err`</a>
<a name="ln573">/// See `examples/callback_api/` for how to use this function.</a>
<a name="ln574">bool LoadObjWithCallback(std::istream &amp;inStream, const callback_t &amp;callback,</a>
<a name="ln575">                         void *user_data = NULL,</a>
<a name="ln576">                         MaterialReader *readMatFn = NULL,</a>
<a name="ln577">                         std::string *warn = NULL, std::string *err = NULL);</a>
<a name="ln578"> </a>
<a name="ln579">/// Loads object from a std::istream, uses `readMatFn` to retrieve</a>
<a name="ln580">/// std::istream for materials.</a>
<a name="ln581">/// Returns true when loading .obj become success.</a>
<a name="ln582">/// Returns warning and error message into `err`</a>
<a name="ln583">bool LoadObj(attrib_t *attrib, std::vector&lt;shape_t&gt; *shapes,</a>
<a name="ln584">             std::vector&lt;material_t&gt; *materials, std::string *warn,</a>
<a name="ln585">             std::string *err, std::istream *inStream,</a>
<a name="ln586">             MaterialReader *readMatFn = NULL, bool triangulate = true,</a>
<a name="ln587">             bool default_vcols_fallback = true);</a>
<a name="ln588"> </a>
<a name="ln589">/// Loads materials into std::map</a>
<a name="ln590">void LoadMtl(std::map&lt;std::string, int&gt; *material_map,</a>
<a name="ln591">             std::vector&lt;material_t&gt; *materials, std::istream *inStream,</a>
<a name="ln592">             std::string *warning, std::string *err);</a>
<a name="ln593"> </a>
<a name="ln594">///</a>
<a name="ln595">/// Parse texture name and texture option for custom texture parameter through</a>
<a name="ln596">/// material::unknown_parameter</a>
<a name="ln597">///</a>
<a name="ln598">/// @param[out] texname Parsed texture name</a>
<a name="ln599">/// @param[out] texopt Parsed texopt</a>
<a name="ln600">/// @param[in] linebuf Input string</a>
<a name="ln601">///</a>
<a name="ln602">bool ParseTextureNameAndOption(std::string *texname, texture_option_t *texopt,</a>
<a name="ln603">                               const char *linebuf);</a>
<a name="ln604"> </a>
<a name="ln605">/// =&lt;&lt;========== Legacy v1 API =============================================</a>
<a name="ln606"> </a>
<a name="ln607">}  // namespace tinyobj</a>
<a name="ln608"> </a>
<a name="ln609">#endif  // TINY_OBJ_LOADER_H_</a>
<a name="ln610"> </a>
<a name="ln611">#ifdef TINYOBJLOADER_IMPLEMENTATION</a>
<a name="ln612">#include &lt;cassert&gt;</a>
<a name="ln613">#include &lt;cctype&gt;</a>
<a name="ln614">#include &lt;cmath&gt;</a>
<a name="ln615">#include &lt;cstddef&gt;</a>
<a name="ln616">#include &lt;cstdlib&gt;</a>
<a name="ln617">#include &lt;cstring&gt;</a>
<a name="ln618">#include &lt;limits&gt;</a>
<a name="ln619">#include &lt;utility&gt;</a>
<a name="ln620"> </a>
<a name="ln621">#include &lt;fstream&gt;</a>
<a name="ln622">#include &lt;sstream&gt;</a>
<a name="ln623"> </a>
<a name="ln624">namespace tinyobj {</a>
<a name="ln625"> </a>
<a name="ln626">MaterialReader::~MaterialReader() {}</a>
<a name="ln627"> </a>
<a name="ln628">struct vertex_index_t {</a>
<a name="ln629">  int v_idx, vt_idx, vn_idx;</a>
<a name="ln630">  vertex_index_t() : v_idx(-1), vt_idx(-1), vn_idx(-1) {}</a>
<a name="ln631">  explicit vertex_index_t(int idx) : v_idx(idx), vt_idx(idx), vn_idx(idx) {}</a>
<a name="ln632">  vertex_index_t(int vidx, int vtidx, int vnidx)</a>
<a name="ln633">      : v_idx(vidx), vt_idx(vtidx), vn_idx(vnidx) {}</a>
<a name="ln634">};</a>
<a name="ln635"> </a>
<a name="ln636">// Internal data structure for face representation</a>
<a name="ln637">// index + smoothing group.</a>
<a name="ln638">struct face_t {</a>
<a name="ln639">  unsigned int</a>
<a name="ln640">      smoothing_group_id;  // smoothing group id. 0 = smoothing groupd is off.</a>
<a name="ln641">  int pad_;</a>
<a name="ln642">  std::vector&lt;vertex_index_t&gt; vertex_indices;  // face vertex indices.</a>
<a name="ln643"> </a>
<a name="ln644">  face_t() : smoothing_group_id(0), pad_(0) {}</a>
<a name="ln645">};</a>
<a name="ln646"> </a>
<a name="ln647">// Internal data structure for line representation</a>
<a name="ln648">struct __line_t {</a>
<a name="ln649">  // l v1/vt1 v2/vt2 ...</a>
<a name="ln650">  // In the specification, line primitrive does not have normal index, but</a>
<a name="ln651">  // TinyObjLoader allow it</a>
<a name="ln652">  std::vector&lt;vertex_index_t&gt; vertex_indices;</a>
<a name="ln653">};</a>
<a name="ln654"> </a>
<a name="ln655">// Internal data structure for points representation</a>
<a name="ln656">struct __points_t {</a>
<a name="ln657">  // p v1 v2 ...</a>
<a name="ln658">  // In the specification, point primitrive does not have normal index and</a>
<a name="ln659">  // texture coord index, but TinyObjLoader allow it.</a>
<a name="ln660">  std::vector&lt;vertex_index_t&gt; vertex_indices;</a>
<a name="ln661">};</a>
<a name="ln662"> </a>
<a name="ln663">struct tag_sizes {</a>
<a name="ln664">  tag_sizes() : num_ints(0), num_reals(0), num_strings(0) {}</a>
<a name="ln665">  int num_ints;</a>
<a name="ln666">  int num_reals;</a>
<a name="ln667">  int num_strings;</a>
<a name="ln668">};</a>
<a name="ln669"> </a>
<a name="ln670">struct obj_shape {</a>
<a name="ln671">  std::vector&lt;real_t&gt; v;</a>
<a name="ln672">  std::vector&lt;real_t&gt; vn;</a>
<a name="ln673">  std::vector&lt;real_t&gt; vt;</a>
<a name="ln674">};</a>
<a name="ln675"> </a>
<a name="ln676">//</a>
<a name="ln677">// Manages group of primitives(face, line, points, ...)</a>
<a name="ln678">struct PrimGroup {</a>
<a name="ln679">  std::vector&lt;face_t&gt; faceGroup;</a>
<a name="ln680">  std::vector&lt;__line_t&gt; lineGroup;</a>
<a name="ln681">  std::vector&lt;__points_t&gt; pointsGroup;</a>
<a name="ln682"> </a>
<a name="ln683">  void clear() {</a>
<a name="ln684">    faceGroup.clear();</a>
<a name="ln685">    lineGroup.clear();</a>
<a name="ln686">    pointsGroup.clear();</a>
<a name="ln687">  }</a>
<a name="ln688"> </a>
<a name="ln689">  bool IsEmpty() const {</a>
<a name="ln690">    return faceGroup.empty() &amp;&amp; lineGroup.empty() &amp;&amp; pointsGroup.empty();</a>
<a name="ln691">  }</a>
<a name="ln692"> </a>
<a name="ln693">  // TODO(syoyo): bspline, surface, ...</a>
<a name="ln694">};</a>
<a name="ln695"> </a>
<a name="ln696">// See</a>
<a name="ln697">// http://stackoverflow.com/questions/6089231/getting-std-ifstream-to-handle-lf-cr-and-crlf</a>
<a name="ln698">static std::istream &amp;safeGetline(std::istream &amp;is, std::string &amp;t) {</a>
<a name="ln699">  t.clear();</a>
<a name="ln700"> </a>
<a name="ln701">  // The characters in the stream are read one-by-one using a std::streambuf.</a>
<a name="ln702">  // That is faster than reading them one-by-one using the std::istream.</a>
<a name="ln703">  // Code that uses streambuf this way must be guarded by a sentry object.</a>
<a name="ln704">  // The sentry object performs various tasks,</a>
<a name="ln705">  // such as thread synchronization and updating the stream state.</a>
<a name="ln706"> </a>
<a name="ln707">  std::istream::sentry se(is, true);</a>
<a name="ln708">  std::streambuf *sb = is.rdbuf();</a>
<a name="ln709"> </a>
<a name="ln710">  if (se) {</a>
<a name="ln711">    for (;;) {</a>
<a name="ln712">      int c = sb-&gt;sbumpc();</a>
<a name="ln713">      switch (c) {</a>
<a name="ln714">        case '\n':</a>
<a name="ln715">          return is;</a>
<a name="ln716">        case '\r':</a>
<a name="ln717">          if (sb-&gt;sgetc() == '\n') sb-&gt;sbumpc();</a>
<a name="ln718">          return is;</a>
<a name="ln719">        case EOF:</a>
<a name="ln720">          // Also handle the case when the last line has no line ending</a>
<a name="ln721">          if (t.empty()) is.setstate(std::ios::eofbit);</a>
<a name="ln722">          return is;</a>
<a name="ln723">        default:</a>
<a name="ln724">          t += static_cast&lt;char&gt;(c);</a>
<a name="ln725">      }</a>
<a name="ln726">    }</a>
<a name="ln727">  }</a>
<a name="ln728"> </a>
<a name="ln729">  return is;</a>
<a name="ln730">}</a>
<a name="ln731"> </a>
<a name="ln732">#define IS_SPACE(x) (((x) == ' ') || ((x) == '\t'))</a>
<a name="ln733">#define IS_DIGIT(x) \</a>
<a name="ln734">  (static_cast&lt;unsigned int&gt;((x) - '0') &lt; static_cast&lt;unsigned int&gt;(10))</a>
<a name="ln735">#define IS_NEW_LINE(x) (((x) == '\r') || ((x) == '\n') || ((x) == '\0'))</a>
<a name="ln736"> </a>
<a name="ln737">// Make index zero-base, and also support relative index.</a>
<a name="ln738">static inline bool fixIndex(int idx, int n, int *ret) {</a>
<a name="ln739">  if (!ret) {</a>
<a name="ln740">    return false;</a>
<a name="ln741">  }</a>
<a name="ln742"> </a>
<a name="ln743">  if (idx &gt; 0) {</a>
<a name="ln744">    (*ret) = idx - 1;</a>
<a name="ln745">    return true;</a>
<a name="ln746">  }</a>
<a name="ln747"> </a>
<a name="ln748">  if (idx == 0) {</a>
<a name="ln749">    // zero is not allowed according to the spec.</a>
<a name="ln750">    return false;</a>
<a name="ln751">  }</a>
<a name="ln752"> </a>
<a name="ln753">  if (idx &lt; 0) {</a>
<a name="ln754">    (*ret) = n + idx;  // negative value = relative</a>
<a name="ln755">    return true;</a>
<a name="ln756">  }</a>
<a name="ln757"> </a>
<a name="ln758">  return false;  // never reach here.</a>
<a name="ln759">}</a>
<a name="ln760"> </a>
<a name="ln761">static inline std::string parseString(const char **token) {</a>
<a name="ln762">  std::string s;</a>
<a name="ln763">  (*token) += strspn((*token), &quot; \t&quot;);</a>
<a name="ln764">  size_t e = strcspn((*token), &quot; \t\r&quot;);</a>
<a name="ln765">  s = std::string((*token), &amp;(*token)[e]);</a>
<a name="ln766">  (*token) += e;</a>
<a name="ln767">  return s;</a>
<a name="ln768">}</a>
<a name="ln769"> </a>
<a name="ln770">static inline int parseInt(const char **token) {</a>
<a name="ln771">  (*token) += strspn((*token), &quot; \t&quot;);</a>
<a name="ln772">  int i = atoi((*token));</a>
<a name="ln773">  (*token) += strcspn((*token), &quot; \t\r&quot;);</a>
<a name="ln774">  return i;</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777">// Tries to parse a floating point number located at s.</a>
<a name="ln778">//</a>
<a name="ln779">// s_end should be a location in the string where reading should absolutely</a>
<a name="ln780">// stop. For example at the end of the string, to prevent buffer overflows.</a>
<a name="ln781">//</a>
<a name="ln782">// Parses the following EBNF grammar:</a>
<a name="ln783">//   sign    = &quot;+&quot; | &quot;-&quot; ;</a>
<a name="ln784">//   END     = ? anything not in digit ?</a>
<a name="ln785">//   digit   = &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot; ;</a>
<a name="ln786">//   integer = [sign] , digit , {digit} ;</a>
<a name="ln787">//   decimal = integer , [&quot;.&quot; , integer] ;</a>
<a name="ln788">//   float   = ( decimal , END ) | ( decimal , (&quot;E&quot; | &quot;e&quot;) , integer , END ) ;</a>
<a name="ln789">//</a>
<a name="ln790">//  Valid strings are for example:</a>
<a name="ln791">//   -0  +3.1417e+2  -0.0E-3  1.0324  -1.41   11e2</a>
<a name="ln792">//</a>
<a name="ln793">// If the parsing is a success, result is set to the parsed value and true</a>
<a name="ln794">// is returned.</a>
<a name="ln795">//</a>
<a name="ln796">// The function is greedy and will parse until any of the following happens:</a>
<a name="ln797">//  - a non-conforming character is encountered.</a>
<a name="ln798">//  - s_end is reached.</a>
<a name="ln799">//</a>
<a name="ln800">// The following situations triggers a failure:</a>
<a name="ln801">//  - s &gt;= s_end.</a>
<a name="ln802">//  - parse failure.</a>
<a name="ln803">//</a>
<a name="ln804">static bool tryParseDouble(const char *s, const char *s_end, double *result) {</a>
<a name="ln805">  if (s &gt;= s_end) {</a>
<a name="ln806">    return false;</a>
<a name="ln807">  }</a>
<a name="ln808"> </a>
<a name="ln809">  double mantissa = 0.0;</a>
<a name="ln810">  // This exponent is base 2 rather than 10.</a>
<a name="ln811">  // However the exponent we parse is supposed to be one of ten,</a>
<a name="ln812">  // thus we must take care to convert the exponent/and or the</a>
<a name="ln813">  // mantissa to a * 2^E, where a is the mantissa and E is the</a>
<a name="ln814">  // exponent.</a>
<a name="ln815">  // To get the final double we will use ldexp, it requires the</a>
<a name="ln816">  // exponent to be in base 2.</a>
<a name="ln817">  int exponent = 0;</a>
<a name="ln818"> </a>
<a name="ln819">  // NOTE: THESE MUST BE DECLARED HERE SINCE WE ARE NOT ALLOWED</a>
<a name="ln820">  // TO JUMP OVER DEFINITIONS.</a>
<a name="ln821">  char sign = '+';</a>
<a name="ln822">  char exp_sign = '+';</a>
<a name="ln823">  char const *curr = s;</a>
<a name="ln824"> </a>
<a name="ln825">  // How many characters were read in a loop.</a>
<a name="ln826">  int read = 0;</a>
<a name="ln827">  // Tells whether a loop terminated due to reaching s_end.</a>
<a name="ln828">  bool end_not_reached = false;</a>
<a name="ln829">  bool leading_decimal_dots = false;</a>
<a name="ln830"> </a>
<a name="ln831">  /*</a>
<a name="ln832">          BEGIN PARSING.</a>
<a name="ln833">  */</a>
<a name="ln834"> </a>
<a name="ln835">  // Find out what sign we've got.</a>
<a name="ln836">  if (*curr == '+' || *curr == '-') {</a>
<a name="ln837">    sign = *curr;</a>
<a name="ln838">    curr++;</a>
<a name="ln839">    if ((curr != s_end) &amp;&amp; (*curr == '.')) {</a>
<a name="ln840">      // accept. Somethig like `.7e+2`, `-.5234`</a>
<a name="ln841">      leading_decimal_dots = true;</a>
<a name="ln842">    }</a>
<a name="ln843">  } else if (IS_DIGIT(*curr)) { /* Pass through. */</a>
<a name="ln844">  } else if (*curr == '.') {</a>
<a name="ln845">    // accept. Somethig like `.7e+2`, `-.5234`</a>
<a name="ln846">    leading_decimal_dots = true;</a>
<a name="ln847">  } else {</a>
<a name="ln848">    goto fail;</a>
<a name="ln849">  }</a>
<a name="ln850"> </a>
<a name="ln851">  // Read the integer part.</a>
<a name="ln852">  end_not_reached = (curr != s_end);</a>
<a name="ln853">  if (!leading_decimal_dots) {</a>
<a name="ln854">    while (end_not_reached &amp;&amp; IS_DIGIT(*curr)) {</a>
<a name="ln855">      mantissa *= 10;</a>
<a name="ln856">      mantissa += static_cast&lt;int&gt;(*curr - 0x30);</a>
<a name="ln857">      curr++;</a>
<a name="ln858">      read++;</a>
<a name="ln859">      end_not_reached = (curr != s_end);</a>
<a name="ln860">    }</a>
<a name="ln861">  }</a>
<a name="ln862"> </a>
<a name="ln863">  // We must make sure we actually got something.</a>
<a name="ln864">  if (!leading_decimal_dots) {</a>
<a name="ln865">    if (read == 0) goto fail;</a>
<a name="ln866">  }</a>
<a name="ln867"> </a>
<a name="ln868">  // We allow numbers of form &quot;#&quot;, &quot;###&quot; etc.</a>
<a name="ln869">  if (!end_not_reached) goto assemble;</a>
<a name="ln870"> </a>
<a name="ln871">  // Read the decimal part.</a>
<a name="ln872">  if (*curr == '.') {</a>
<a name="ln873">    curr++;</a>
<a name="ln874">    read = 1;</a>
<a name="ln875">    end_not_reached = (curr != s_end);</a>
<a name="ln876">    while (end_not_reached &amp;&amp; IS_DIGIT(*curr)) {</a>
<a name="ln877">      static const double pow_lut[] = {</a>
<a name="ln878">          1.0, 0.1, 0.01, 0.001, 0.0001, 0.00001, 0.000001, 0.0000001,</a>
<a name="ln879">      };</a>
<a name="ln880">      const int lut_entries = sizeof pow_lut / sizeof pow_lut[0];</a>
<a name="ln881"> </a>
<a name="ln882">      // NOTE: Don't use powf here, it will absolutely murder precision.</a>
<a name="ln883">      mantissa += static_cast&lt;int&gt;(*curr - 0x30) *</a>
<a name="ln884">                  (read &lt; lut_entries ? pow_lut[read] : std::pow(10.0, -read));</a>
<a name="ln885">      read++;</a>
<a name="ln886">      curr++;</a>
<a name="ln887">      end_not_reached = (curr != s_end);</a>
<a name="ln888">    }</a>
<a name="ln889">  } else if (*curr == 'e' || *curr == 'E') {</a>
<a name="ln890">  } else {</a>
<a name="ln891">    goto assemble;</a>
<a name="ln892">  }</a>
<a name="ln893"> </a>
<a name="ln894">  if (!end_not_reached) goto assemble;</a>
<a name="ln895"> </a>
<a name="ln896">  // Read the exponent part.</a>
<a name="ln897">  if (*curr == 'e' || *curr == 'E') {</a>
<a name="ln898">    curr++;</a>
<a name="ln899">    // Figure out if a sign is present and if it is.</a>
<a name="ln900">    end_not_reached = (curr != s_end);</a>
<a name="ln901">    if (end_not_reached &amp;&amp; (*curr == '+' || *curr == '-')) {</a>
<a name="ln902">      exp_sign = *curr;</a>
<a name="ln903">      curr++;</a>
<a name="ln904">    } else if (IS_DIGIT(*curr)) { /* Pass through. */</a>
<a name="ln905">    } else {</a>
<a name="ln906">      // Empty E is not allowed.</a>
<a name="ln907">      goto fail;</a>
<a name="ln908">    }</a>
<a name="ln909"> </a>
<a name="ln910">    read = 0;</a>
<a name="ln911">    end_not_reached = (curr != s_end);</a>
<a name="ln912">    while (end_not_reached &amp;&amp; IS_DIGIT(*curr)) {</a>
<a name="ln913">      exponent *= 10;</a>
<a name="ln914">      exponent += static_cast&lt;int&gt;(*curr - 0x30);</a>
<a name="ln915">      curr++;</a>
<a name="ln916">      read++;</a>
<a name="ln917">      end_not_reached = (curr != s_end);</a>
<a name="ln918">    }</a>
<a name="ln919">    exponent *= (exp_sign == '+' ? 1 : -1);</a>
<a name="ln920">    if (read == 0) goto fail;</a>
<a name="ln921">  }</a>
<a name="ln922"> </a>
<a name="ln923">assemble:</a>
<a name="ln924">  *result = (sign == '+' ? 1 : -1) *</a>
<a name="ln925">            (exponent ? std::ldexp(mantissa * std::pow(5.0, exponent), exponent)</a>
<a name="ln926">                      : mantissa);</a>
<a name="ln927">  return true;</a>
<a name="ln928">fail:</a>
<a name="ln929">  return false;</a>
<a name="ln930">}</a>
<a name="ln931"> </a>
<a name="ln932">static inline real_t parseReal(const char **token, double default_value = 0.0) {</a>
<a name="ln933">  (*token) += strspn((*token), &quot; \t&quot;);</a>
<a name="ln934">  const char *end = (*token) + strcspn((*token), &quot; \t\r&quot;);</a>
<a name="ln935">  double val = default_value;</a>
<a name="ln936">  tryParseDouble((*token), end, &amp;val);</a>
<a name="ln937">  real_t f = static_cast&lt;real_t&gt;(val);</a>
<a name="ln938">  (*token) = end;</a>
<a name="ln939">  return f;</a>
<a name="ln940">}</a>
<a name="ln941"> </a>
<a name="ln942">static inline bool parseReal(const char **token, real_t *out) {</a>
<a name="ln943">  (*token) += strspn((*token), &quot; \t&quot;);</a>
<a name="ln944">  const char *end = (*token) + strcspn((*token), &quot; \t\r&quot;);</a>
<a name="ln945">  double val;</a>
<a name="ln946">  bool ret = tryParseDouble((*token), end, &amp;val);</a>
<a name="ln947">  if (ret) {</a>
<a name="ln948">    real_t f = static_cast&lt;real_t&gt;(val);</a>
<a name="ln949">    (*out) = f;</a>
<a name="ln950">  }</a>
<a name="ln951">  (*token) = end;</a>
<a name="ln952">  return ret;</a>
<a name="ln953">}</a>
<a name="ln954"> </a>
<a name="ln955">static inline void parseReal2(real_t *x, real_t *y, const char **token,</a>
<a name="ln956">                              const double default_x = 0.0,</a>
<a name="ln957">                              const double default_y = 0.0) {</a>
<a name="ln958">  (*x) = parseReal(token, default_x);</a>
<a name="ln959">  (*y) = parseReal(token, default_y);</a>
<a name="ln960">}</a>
<a name="ln961"> </a>
<a name="ln962">static inline void parseReal3(real_t *x, real_t *y, real_t *z,</a>
<a name="ln963">                              const char **token, const double default_x = 0.0,</a>
<a name="ln964">                              const double default_y = 0.0,</a>
<a name="ln965">                              const double default_z = 0.0) {</a>
<a name="ln966">  (*x) = parseReal(token, default_x);</a>
<a name="ln967">  (*y) = parseReal(token, default_y);</a>
<a name="ln968">  (*z) = parseReal(token, default_z);</a>
<a name="ln969">}</a>
<a name="ln970"> </a>
<a name="ln971">static inline void parseV(real_t *x, real_t *y, real_t *z, real_t *w,</a>
<a name="ln972">                          const char **token, const double default_x = 0.0,</a>
<a name="ln973">                          const double default_y = 0.0,</a>
<a name="ln974">                          const double default_z = 0.0,</a>
<a name="ln975">                          const double default_w = 1.0) {</a>
<a name="ln976">  (*x) = parseReal(token, default_x);</a>
<a name="ln977">  (*y) = parseReal(token, default_y);</a>
<a name="ln978">  (*z) = parseReal(token, default_z);</a>
<a name="ln979">  (*w) = parseReal(token, default_w);</a>
<a name="ln980">}</a>
<a name="ln981"> </a>
<a name="ln982">// Extension: parse vertex with colors(6 items)</a>
<a name="ln983">static inline bool parseVertexWithColor(real_t *x, real_t *y, real_t *z,</a>
<a name="ln984">                                        real_t *r, real_t *g, real_t *b,</a>
<a name="ln985">                                        const char **token,</a>
<a name="ln986">                                        const double default_x = 0.0,</a>
<a name="ln987">                                        const double default_y = 0.0,</a>
<a name="ln988">                                        const double default_z = 0.0) {</a>
<a name="ln989">  (*x) = parseReal(token, default_x);</a>
<a name="ln990">  (*y) = parseReal(token, default_y);</a>
<a name="ln991">  (*z) = parseReal(token, default_z);</a>
<a name="ln992"> </a>
<a name="ln993">  const bool found_color =</a>
<a name="ln994">      parseReal(token, r) &amp;&amp; parseReal(token, g) &amp;&amp; parseReal(token, b);</a>
<a name="ln995"> </a>
<a name="ln996">  if (!found_color) {</a>
<a name="ln997">    (*r) = (*g) = (*b) = 1.0;</a>
<a name="ln998">  }</a>
<a name="ln999"> </a>
<a name="ln1000">  return found_color;</a>
<a name="ln1001">}</a>
<a name="ln1002"> </a>
<a name="ln1003">static inline bool parseOnOff(const char **token, bool default_value = true) {</a>
<a name="ln1004">  (*token) += strspn((*token), &quot; \t&quot;);</a>
<a name="ln1005">  const char *end = (*token) + strcspn((*token), &quot; \t\r&quot;);</a>
<a name="ln1006"> </a>
<a name="ln1007">  bool ret = default_value;</a>
<a name="ln1008">  if ((0 == strncmp((*token), &quot;on&quot;, 2))) {</a>
<a name="ln1009">    ret = true;</a>
<a name="ln1010">  } else if ((0 == strncmp((*token), &quot;off&quot;, 3))) {</a>
<a name="ln1011">    ret = false;</a>
<a name="ln1012">  }</a>
<a name="ln1013"> </a>
<a name="ln1014">  (*token) = end;</a>
<a name="ln1015">  return ret;</a>
<a name="ln1016">}</a>
<a name="ln1017"> </a>
<a name="ln1018">static inline texture_type_t parseTextureType(</a>
<a name="ln1019">    const char **token, texture_type_t default_value = TEXTURE_TYPE_NONE) {</a>
<a name="ln1020">  (*token) += strspn((*token), &quot; \t&quot;);</a>
<a name="ln1021">  const char *end = (*token) + strcspn((*token), &quot; \t\r&quot;);</a>
<a name="ln1022">  texture_type_t ty = default_value;</a>
<a name="ln1023"> </a>
<a name="ln1024">  if ((0 == strncmp((*token), &quot;cube_top&quot;, strlen(&quot;cube_top&quot;)))) {</a>
<a name="ln1025">    ty = TEXTURE_TYPE_CUBE_TOP;</a>
<a name="ln1026">  } else if ((0 == strncmp((*token), &quot;cube_bottom&quot;, strlen(&quot;cube_bottom&quot;)))) {</a>
<a name="ln1027">    ty = TEXTURE_TYPE_CUBE_BOTTOM;</a>
<a name="ln1028">  } else if ((0 == strncmp((*token), &quot;cube_left&quot;, strlen(&quot;cube_left&quot;)))) {</a>
<a name="ln1029">    ty = TEXTURE_TYPE_CUBE_LEFT;</a>
<a name="ln1030">  } else if ((0 == strncmp((*token), &quot;cube_right&quot;, strlen(&quot;cube_right&quot;)))) {</a>
<a name="ln1031">    ty = TEXTURE_TYPE_CUBE_RIGHT;</a>
<a name="ln1032">  } else if ((0 == strncmp((*token), &quot;cube_front&quot;, strlen(&quot;cube_front&quot;)))) {</a>
<a name="ln1033">    ty = TEXTURE_TYPE_CUBE_FRONT;</a>
<a name="ln1034">  } else if ((0 == strncmp((*token), &quot;cube_back&quot;, strlen(&quot;cube_back&quot;)))) {</a>
<a name="ln1035">    ty = TEXTURE_TYPE_CUBE_BACK;</a>
<a name="ln1036">  } else if ((0 == strncmp((*token), &quot;sphere&quot;, strlen(&quot;sphere&quot;)))) {</a>
<a name="ln1037">    ty = TEXTURE_TYPE_SPHERE;</a>
<a name="ln1038">  }</a>
<a name="ln1039"> </a>
<a name="ln1040">  (*token) = end;</a>
<a name="ln1041">  return ty;</a>
<a name="ln1042">}</a>
<a name="ln1043"> </a>
<a name="ln1044">static tag_sizes parseTagTriple(const char **token) {</a>
<a name="ln1045">  tag_sizes ts;</a>
<a name="ln1046"> </a>
<a name="ln1047">  (*token) += strspn((*token), &quot; \t&quot;);</a>
<a name="ln1048">  ts.num_ints = atoi((*token));</a>
<a name="ln1049">  (*token) += strcspn((*token), &quot;/ \t\r&quot;);</a>
<a name="ln1050">  if ((*token)[0] != '/') {</a>
<a name="ln1051">    return ts;</a>
<a name="ln1052">  }</a>
<a name="ln1053"> </a>
<a name="ln1054">  (*token)++;  // Skip '/'</a>
<a name="ln1055"> </a>
<a name="ln1056">  (*token) += strspn((*token), &quot; \t&quot;);</a>
<a name="ln1057">  ts.num_reals = atoi((*token));</a>
<a name="ln1058">  (*token) += strcspn((*token), &quot;/ \t\r&quot;);</a>
<a name="ln1059">  if ((*token)[0] != '/') {</a>
<a name="ln1060">    return ts;</a>
<a name="ln1061">  }</a>
<a name="ln1062">  (*token)++;  // Skip '/'</a>
<a name="ln1063"> </a>
<a name="ln1064">  ts.num_strings = parseInt(token);</a>
<a name="ln1065"> </a>
<a name="ln1066">  return ts;</a>
<a name="ln1067">}</a>
<a name="ln1068"> </a>
<a name="ln1069">// Parse triples with index offsets: i, i/j/k, i//k, i/j</a>
<a name="ln1070">static bool parseTriple(const char **token, int vsize, int vnsize, int vtsize,</a>
<a name="ln1071">                        vertex_index_t *ret) {</a>
<a name="ln1072">  if (!ret) {</a>
<a name="ln1073">    return false;</a>
<a name="ln1074">  }</a>
<a name="ln1075"> </a>
<a name="ln1076">  vertex_index_t vi(-1);</a>
<a name="ln1077"> </a>
<a name="ln1078">  if (!fixIndex(atoi((*token)), vsize, &amp;(vi.v_idx))) {</a>
<a name="ln1079">    return false;</a>
<a name="ln1080">  }</a>
<a name="ln1081"> </a>
<a name="ln1082">  (*token) += strcspn((*token), &quot;/ \t\r&quot;);</a>
<a name="ln1083">  if ((*token)[0] != '/') {</a>
<a name="ln1084">    (*ret) = vi;</a>
<a name="ln1085">    return true;</a>
<a name="ln1086">  }</a>
<a name="ln1087">  (*token)++;</a>
<a name="ln1088"> </a>
<a name="ln1089">  // i//k</a>
<a name="ln1090">  if ((*token)[0] == '/') {</a>
<a name="ln1091">    (*token)++;</a>
<a name="ln1092">    if (!fixIndex(atoi((*token)), vnsize, &amp;(vi.vn_idx))) {</a>
<a name="ln1093">      return false;</a>
<a name="ln1094">    }</a>
<a name="ln1095">    (*token) += strcspn((*token), &quot;/ \t\r&quot;);</a>
<a name="ln1096">    (*ret) = vi;</a>
<a name="ln1097">    return true;</a>
<a name="ln1098">  }</a>
<a name="ln1099"> </a>
<a name="ln1100">  // i/j/k or i/j</a>
<a name="ln1101">  if (!fixIndex(atoi((*token)), vtsize, &amp;(vi.vt_idx))) {</a>
<a name="ln1102">    return false;</a>
<a name="ln1103">  }</a>
<a name="ln1104"> </a>
<a name="ln1105">  (*token) += strcspn((*token), &quot;/ \t\r&quot;);</a>
<a name="ln1106">  if ((*token)[0] != '/') {</a>
<a name="ln1107">    (*ret) = vi;</a>
<a name="ln1108">    return true;</a>
<a name="ln1109">  }</a>
<a name="ln1110"> </a>
<a name="ln1111">  // i/j/k</a>
<a name="ln1112">  (*token)++;  // skip '/'</a>
<a name="ln1113">  if (!fixIndex(atoi((*token)), vnsize, &amp;(vi.vn_idx))) {</a>
<a name="ln1114">    return false;</a>
<a name="ln1115">  }</a>
<a name="ln1116">  (*token) += strcspn((*token), &quot;/ \t\r&quot;);</a>
<a name="ln1117"> </a>
<a name="ln1118">  (*ret) = vi;</a>
<a name="ln1119"> </a>
<a name="ln1120">  return true;</a>
<a name="ln1121">}</a>
<a name="ln1122"> </a>
<a name="ln1123">// Parse raw triples: i, i/j/k, i//k, i/j</a>
<a name="ln1124">static vertex_index_t parseRawTriple(const char **token) {</a>
<a name="ln1125">  vertex_index_t vi(static_cast&lt;int&gt;(0));  // 0 is an invalid index in OBJ</a>
<a name="ln1126"> </a>
<a name="ln1127">  vi.v_idx = atoi((*token));</a>
<a name="ln1128">  (*token) += strcspn((*token), &quot;/ \t\r&quot;);</a>
<a name="ln1129">  if ((*token)[0] != '/') {</a>
<a name="ln1130">    return vi;</a>
<a name="ln1131">  }</a>
<a name="ln1132">  (*token)++;</a>
<a name="ln1133"> </a>
<a name="ln1134">  // i//k</a>
<a name="ln1135">  if ((*token)[0] == '/') {</a>
<a name="ln1136">    (*token)++;</a>
<a name="ln1137">    vi.vn_idx = atoi((*token));</a>
<a name="ln1138">    (*token) += strcspn((*token), &quot;/ \t\r&quot;);</a>
<a name="ln1139">    return vi;</a>
<a name="ln1140">  }</a>
<a name="ln1141"> </a>
<a name="ln1142">  // i/j/k or i/j</a>
<a name="ln1143">  vi.vt_idx = atoi((*token));</a>
<a name="ln1144">  (*token) += strcspn((*token), &quot;/ \t\r&quot;);</a>
<a name="ln1145">  if ((*token)[0] != '/') {</a>
<a name="ln1146">    return vi;</a>
<a name="ln1147">  }</a>
<a name="ln1148"> </a>
<a name="ln1149">  // i/j/k</a>
<a name="ln1150">  (*token)++;  // skip '/'</a>
<a name="ln1151">  vi.vn_idx = atoi((*token));</a>
<a name="ln1152">  (*token) += strcspn((*token), &quot;/ \t\r&quot;);</a>
<a name="ln1153">  return vi;</a>
<a name="ln1154">}</a>
<a name="ln1155"> </a>
<a name="ln1156">bool ParseTextureNameAndOption(std::string *texname, texture_option_t *texopt,</a>
<a name="ln1157">                               const char *linebuf) {</a>
<a name="ln1158">  // @todo { write more robust lexer and parser. }</a>
<a name="ln1159">  bool found_texname = false;</a>
<a name="ln1160">  std::string texture_name;</a>
<a name="ln1161"> </a>
<a name="ln1162">  const char *token = linebuf;  // Assume line ends with NULL</a>
<a name="ln1163"> </a>
<a name="ln1164">  while (!IS_NEW_LINE((*token))) {</a>
<a name="ln1165">    token += strspn(token, &quot; \t&quot;);  // skip space</a>
<a name="ln1166">    if ((0 == strncmp(token, &quot;-blendu&quot;, 7)) &amp;&amp; IS_SPACE((token[7]))) {</a>
<a name="ln1167">      token += 8;</a>
<a name="ln1168">      texopt-&gt;blendu = parseOnOff(&amp;token, /* default */ true);</a>
<a name="ln1169">    } else if ((0 == strncmp(token, &quot;-blendv&quot;, 7)) &amp;&amp; IS_SPACE((token[7]))) {</a>
<a name="ln1170">      token += 8;</a>
<a name="ln1171">      texopt-&gt;blendv = parseOnOff(&amp;token, /* default */ true);</a>
<a name="ln1172">    } else if ((0 == strncmp(token, &quot;-clamp&quot;, 6)) &amp;&amp; IS_SPACE((token[6]))) {</a>
<a name="ln1173">      token += 7;</a>
<a name="ln1174">      texopt-&gt;clamp = parseOnOff(&amp;token, /* default */ true);</a>
<a name="ln1175">    } else if ((0 == strncmp(token, &quot;-boost&quot;, 6)) &amp;&amp; IS_SPACE((token[6]))) {</a>
<a name="ln1176">      token += 7;</a>
<a name="ln1177">      texopt-&gt;sharpness = parseReal(&amp;token, 1.0);</a>
<a name="ln1178">    } else if ((0 == strncmp(token, &quot;-bm&quot;, 3)) &amp;&amp; IS_SPACE((token[3]))) {</a>
<a name="ln1179">      token += 4;</a>
<a name="ln1180">      texopt-&gt;bump_multiplier = parseReal(&amp;token, 1.0);</a>
<a name="ln1181">    } else if ((0 == strncmp(token, &quot;-o&quot;, 2)) &amp;&amp; IS_SPACE((token[2]))) {</a>
<a name="ln1182">      token += 3;</a>
<a name="ln1183">      parseReal3(&amp;(texopt-&gt;origin_offset[0]), &amp;(texopt-&gt;origin_offset[1]),</a>
<a name="ln1184">                 &amp;(texopt-&gt;origin_offset[2]), &amp;token);</a>
<a name="ln1185">    } else if ((0 == strncmp(token, &quot;-s&quot;, 2)) &amp;&amp; IS_SPACE((token[2]))) {</a>
<a name="ln1186">      token += 3;</a>
<a name="ln1187">      parseReal3(&amp;(texopt-&gt;scale[0]), &amp;(texopt-&gt;scale[1]), &amp;(texopt-&gt;scale[2]),</a>
<a name="ln1188">                 &amp;token, 1.0, 1.0, 1.0);</a>
<a name="ln1189">    } else if ((0 == strncmp(token, &quot;-t&quot;, 2)) &amp;&amp; IS_SPACE((token[2]))) {</a>
<a name="ln1190">      token += 3;</a>
<a name="ln1191">      parseReal3(&amp;(texopt-&gt;turbulence[0]), &amp;(texopt-&gt;turbulence[1]),</a>
<a name="ln1192">                 &amp;(texopt-&gt;turbulence[2]), &amp;token);</a>
<a name="ln1193">    } else if ((0 == strncmp(token, &quot;-type&quot;, 5)) &amp;&amp; IS_SPACE((token[5]))) {</a>
<a name="ln1194">      token += 5;</a>
<a name="ln1195">      texopt-&gt;type = parseTextureType((&amp;token), TEXTURE_TYPE_NONE);</a>
<a name="ln1196">    } else if ((0 == strncmp(token, &quot;-imfchan&quot;, 8)) &amp;&amp; IS_SPACE((token[8]))) {</a>
<a name="ln1197">      token += 9;</a>
<a name="ln1198">      token += strspn(token, &quot; \t&quot;);</a>
<a name="ln1199">      const char *end = token + strcspn(token, &quot; \t\r&quot;);</a>
<a name="ln1200">      if ((end - token) == 1) {  // Assume one char for -imfchan</a>
<a name="ln1201">        texopt-&gt;imfchan = (*token);</a>
<a name="ln1202">      }</a>
<a name="ln1203">      token = end;</a>
<a name="ln1204">    } else if ((0 == strncmp(token, &quot;-mm&quot;, 3)) &amp;&amp; IS_SPACE((token[3]))) {</a>
<a name="ln1205">      token += 4;</a>
<a name="ln1206">      parseReal2(&amp;(texopt-&gt;brightness), &amp;(texopt-&gt;contrast), &amp;token, 0.0, 1.0);</a>
<a name="ln1207">    } else if ((0 == strncmp(token, &quot;-colorspace&quot;, 11)) &amp;&amp;</a>
<a name="ln1208">               IS_SPACE((token[11]))) {</a>
<a name="ln1209">      token += 12;</a>
<a name="ln1210">      texopt-&gt;colorspace = parseString(&amp;token);</a>
<a name="ln1211">    } else {</a>
<a name="ln1212">// Assume texture filename</a>
<a name="ln1213">#if 0</a>
<a name="ln1214">      size_t len = strcspn(token, &quot; \t\r&quot;);  // untile next space</a>
<a name="ln1215">      texture_name = std::string(token, token + len);</a>
<a name="ln1216">      token += len;</a>
<a name="ln1217"> </a>
<a name="ln1218">      token += strspn(token, &quot; \t&quot;);  // skip space</a>
<a name="ln1219">#else</a>
<a name="ln1220">      // Read filename until line end to parse filename containing whitespace</a>
<a name="ln1221">      // TODO(syoyo): Support parsing texture option flag after the filename.</a>
<a name="ln1222">      texture_name = std::string(token);</a>
<a name="ln1223">      token += texture_name.length();</a>
<a name="ln1224">#endif</a>
<a name="ln1225"> </a>
<a name="ln1226">      found_texname = true;</a>
<a name="ln1227">    }</a>
<a name="ln1228">  }</a>
<a name="ln1229"> </a>
<a name="ln1230">  if (found_texname) {</a>
<a name="ln1231">    (*texname) = texture_name;</a>
<a name="ln1232">    return true;</a>
<a name="ln1233">  } else {</a>
<a name="ln1234">    return false;</a>
<a name="ln1235">  }</a>
<a name="ln1236">}</a>
<a name="ln1237"> </a>
<a name="ln1238">static void InitTexOpt(texture_option_t *texopt, const bool is_bump) {</a>
<a name="ln1239">  if (is_bump) {</a>
<a name="ln1240">    texopt-&gt;imfchan = 'l';</a>
<a name="ln1241">  } else {</a>
<a name="ln1242">    texopt-&gt;imfchan = 'm';</a>
<a name="ln1243">  }</a>
<a name="ln1244">  texopt-&gt;bump_multiplier = static_cast&lt;real_t&gt;(1.0);</a>
<a name="ln1245">  texopt-&gt;clamp = false;</a>
<a name="ln1246">  texopt-&gt;blendu = true;</a>
<a name="ln1247">  texopt-&gt;blendv = true;</a>
<a name="ln1248">  texopt-&gt;sharpness = static_cast&lt;real_t&gt;(1.0);</a>
<a name="ln1249">  texopt-&gt;brightness = static_cast&lt;real_t&gt;(0.0);</a>
<a name="ln1250">  texopt-&gt;contrast = static_cast&lt;real_t&gt;(1.0);</a>
<a name="ln1251">  texopt-&gt;origin_offset[0] = static_cast&lt;real_t&gt;(0.0);</a>
<a name="ln1252">  texopt-&gt;origin_offset[1] = static_cast&lt;real_t&gt;(0.0);</a>
<a name="ln1253">  texopt-&gt;origin_offset[2] = static_cast&lt;real_t&gt;(0.0);</a>
<a name="ln1254">  texopt-&gt;scale[0] = static_cast&lt;real_t&gt;(1.0);</a>
<a name="ln1255">  texopt-&gt;scale[1] = static_cast&lt;real_t&gt;(1.0);</a>
<a name="ln1256">  texopt-&gt;scale[2] = static_cast&lt;real_t&gt;(1.0);</a>
<a name="ln1257">  texopt-&gt;turbulence[0] = static_cast&lt;real_t&gt;(0.0);</a>
<a name="ln1258">  texopt-&gt;turbulence[1] = static_cast&lt;real_t&gt;(0.0);</a>
<a name="ln1259">  texopt-&gt;turbulence[2] = static_cast&lt;real_t&gt;(0.0);</a>
<a name="ln1260">  texopt-&gt;type = TEXTURE_TYPE_NONE;</a>
<a name="ln1261">}</a>
<a name="ln1262"> </a>
<a name="ln1263">static void InitMaterial(material_t *material) {</a>
<a name="ln1264">  InitTexOpt(&amp;material-&gt;ambient_texopt, /* is_bump */ false);</a>
<a name="ln1265">  InitTexOpt(&amp;material-&gt;diffuse_texopt, /* is_bump */ false);</a>
<a name="ln1266">  InitTexOpt(&amp;material-&gt;specular_texopt, /* is_bump */ false);</a>
<a name="ln1267">  InitTexOpt(&amp;material-&gt;specular_highlight_texopt, /* is_bump */ false);</a>
<a name="ln1268">  InitTexOpt(&amp;material-&gt;bump_texopt, /* is_bump */ true);</a>
<a name="ln1269">  InitTexOpt(&amp;material-&gt;displacement_texopt, /* is_bump */ false);</a>
<a name="ln1270">  InitTexOpt(&amp;material-&gt;alpha_texopt, /* is_bump */ false);</a>
<a name="ln1271">  InitTexOpt(&amp;material-&gt;reflection_texopt, /* is_bump */ false);</a>
<a name="ln1272">  InitTexOpt(&amp;material-&gt;roughness_texopt, /* is_bump */ false);</a>
<a name="ln1273">  InitTexOpt(&amp;material-&gt;metallic_texopt, /* is_bump */ false);</a>
<a name="ln1274">  InitTexOpt(&amp;material-&gt;sheen_texopt, /* is_bump */ false);</a>
<a name="ln1275">  InitTexOpt(&amp;material-&gt;emissive_texopt, /* is_bump */ false);</a>
<a name="ln1276">  InitTexOpt(&amp;material-&gt;normal_texopt,</a>
<a name="ln1277">             /* is_bump */ false);  // @fixme { is_bump will be true? }</a>
<a name="ln1278">  material-&gt;name = &quot;&quot;;</a>
<a name="ln1279">  material-&gt;ambient_texname = &quot;&quot;;</a>
<a name="ln1280">  material-&gt;diffuse_texname = &quot;&quot;;</a>
<a name="ln1281">  material-&gt;specular_texname = &quot;&quot;;</a>
<a name="ln1282">  material-&gt;specular_highlight_texname = &quot;&quot;;</a>
<a name="ln1283">  material-&gt;bump_texname = &quot;&quot;;</a>
<a name="ln1284">  material-&gt;displacement_texname = &quot;&quot;;</a>
<a name="ln1285">  material-&gt;reflection_texname = &quot;&quot;;</a>
<a name="ln1286">  material-&gt;alpha_texname = &quot;&quot;;</a>
<a name="ln1287">  for (int i = 0; i &lt; 3; i++) {</a>
<a name="ln1288">    material-&gt;ambient[i] = static_cast&lt;real_t&gt;(0.0);</a>
<a name="ln1289">    material-&gt;diffuse[i] = static_cast&lt;real_t&gt;(0.0);</a>
<a name="ln1290">    material-&gt;specular[i] = static_cast&lt;real_t&gt;(0.0);</a>
<a name="ln1291">    material-&gt;transmittance[i] = static_cast&lt;real_t&gt;(0.0);</a>
<a name="ln1292">    material-&gt;emission[i] = static_cast&lt;real_t&gt;(0.0);</a>
<a name="ln1293">  }</a>
<a name="ln1294">  material-&gt;illum = 0;</a>
<a name="ln1295">  material-&gt;dissolve = static_cast&lt;real_t&gt;(1.0);</a>
<a name="ln1296">  material-&gt;shininess = static_cast&lt;real_t&gt;(1.0);</a>
<a name="ln1297">  material-&gt;ior = static_cast&lt;real_t&gt;(1.0);</a>
<a name="ln1298"> </a>
<a name="ln1299">  material-&gt;roughness = static_cast&lt;real_t&gt;(0.0);</a>
<a name="ln1300">  material-&gt;metallic = static_cast&lt;real_t&gt;(0.0);</a>
<a name="ln1301">  material-&gt;sheen = static_cast&lt;real_t&gt;(0.0);</a>
<a name="ln1302">  material-&gt;clearcoat_thickness = static_cast&lt;real_t&gt;(0.0);</a>
<a name="ln1303">  material-&gt;clearcoat_roughness = static_cast&lt;real_t&gt;(0.0);</a>
<a name="ln1304">  material-&gt;anisotropy_rotation = static_cast&lt;real_t&gt;(0.0);</a>
<a name="ln1305">  material-&gt;anisotropy = static_cast&lt;real_t&gt;(0.0);</a>
<a name="ln1306">  material-&gt;roughness_texname = &quot;&quot;;</a>
<a name="ln1307">  material-&gt;metallic_texname = &quot;&quot;;</a>
<a name="ln1308">  material-&gt;sheen_texname = &quot;&quot;;</a>
<a name="ln1309">  material-&gt;emissive_texname = &quot;&quot;;</a>
<a name="ln1310">  material-&gt;normal_texname = &quot;&quot;;</a>
<a name="ln1311"> </a>
<a name="ln1312">  material-&gt;unknown_parameter.clear();</a>
<a name="ln1313">}</a>
<a name="ln1314"> </a>
<a name="ln1315">// code from https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html</a>
<a name="ln1316">template &lt;typename T&gt;</a>
<a name="ln1317">static int pnpoly(int nvert, T *vertx, T *verty, T testx, T testy) {</a>
<a name="ln1318">  int i, j, c = 0;</a>
<a name="ln1319">  for (i = 0, j = nvert - 1; i &lt; nvert; j = i++) {</a>
<a name="ln1320">    if (((verty[i] &gt; testy) != (verty[j] &gt; testy)) &amp;&amp;</a>
<a name="ln1321">        (testx &lt;</a>
<a name="ln1322">         (vertx[j] - vertx[i]) * (testy - verty[i]) / (verty[j] - verty[i]) +</a>
<a name="ln1323">             vertx[i]))</a>
<a name="ln1324">      c = !c;</a>
<a name="ln1325">  }</a>
<a name="ln1326">  return c;</a>
<a name="ln1327">}</a>
<a name="ln1328"> </a>
<a name="ln1329">// TODO(syoyo): refactor function.</a>
<a name="ln1330">static bool exportGroupsToShape(shape_t *shape, const PrimGroup &amp;prim_group,</a>
<a name="ln1331">                                const std::vector&lt;tag_t&gt; &amp;tags,</a>
<a name="ln1332">                                const int material_id, const std::string &amp;name,</a>
<a name="ln1333">                                bool triangulate,</a>
<a name="ln1334">                                const std::vector&lt;real_t&gt; &amp;v) {</a>
<a name="ln1335">  if (prim_group.IsEmpty()) {</a>
<a name="ln1336">    return false;</a>
<a name="ln1337">  }</a>
<a name="ln1338"> </a>
<a name="ln1339">  shape-&gt;name = name;</a>
<a name="ln1340"> </a>
<a name="ln1341">  // polygon</a>
<a name="ln1342">  if (!prim_group.faceGroup.empty()) {</a>
<a name="ln1343">    // Flatten vertices and indices</a>
<a name="ln1344">    for (size_t i = 0; i &lt; prim_group.faceGroup.size(); i++) {</a>
<a name="ln1345">      const face_t &amp;face = prim_group.faceGroup[i];</a>
<a name="ln1346"> </a>
<a name="ln1347">      size_t npolys = face.vertex_indices.size();</a>
<a name="ln1348"> </a>
<a name="ln1349">      if (npolys &lt; 3) {</a>
<a name="ln1350">        // Face must have 3+ vertices.</a>
<a name="ln1351">        continue;</a>
<a name="ln1352">      }</a>
<a name="ln1353"> </a>
<a name="ln1354">      vertex_index_t i0 = face.vertex_indices[0];</a>
<a name="ln1355">      vertex_index_t i1(-1);</a>
<a name="ln1356">      vertex_index_t i2 = face.vertex_indices[1];</a>
<a name="ln1357"> </a>
<a name="ln1358">      if (triangulate) {</a>
<a name="ln1359">        // find the two axes to work in</a>
<a name="ln1360">        size_t axes[2] = {1, 2};</a>
<a name="ln1361">        for (size_t k = 0; k &lt; npolys; ++k) {</a>
<a name="ln1362">          i0 = face.vertex_indices[(k + 0) % npolys];</a>
<a name="ln1363">          i1 = face.vertex_indices[(k + 1) % npolys];</a>
<a name="ln1364">          i2 = face.vertex_indices[(k + 2) % npolys];</a>
<a name="ln1365">          size_t vi0 = size_t(i0.v_idx);</a>
<a name="ln1366">          size_t vi1 = size_t(i1.v_idx);</a>
<a name="ln1367">          size_t vi2 = size_t(i2.v_idx);</a>
<a name="ln1368"> </a>
<a name="ln1369">          if (((3 * vi0 + 2) &gt;= v.size()) || ((3 * vi1 + 2) &gt;= v.size()) ||</a>
<a name="ln1370">              ((3 * vi2 + 2) &gt;= v.size())) {</a>
<a name="ln1371">            // Invalid triangle.</a>
<a name="ln1372">            // FIXME(syoyo): Is it ok to simply skip this invalid triangle?</a>
<a name="ln1373">            continue;</a>
<a name="ln1374">          }</a>
<a name="ln1375">          real_t v0x = v[vi0 * 3 + 0];</a>
<a name="ln1376">          real_t v0y = v[vi0 * 3 + 1];</a>
<a name="ln1377">          real_t v0z = v[vi0 * 3 + 2];</a>
<a name="ln1378">          real_t v1x = v[vi1 * 3 + 0];</a>
<a name="ln1379">          real_t v1y = v[vi1 * 3 + 1];</a>
<a name="ln1380">          real_t v1z = v[vi1 * 3 + 2];</a>
<a name="ln1381">          real_t v2x = v[vi2 * 3 + 0];</a>
<a name="ln1382">          real_t v2y = v[vi2 * 3 + 1];</a>
<a name="ln1383">          real_t v2z = v[vi2 * 3 + 2];</a>
<a name="ln1384">          real_t e0x = v1x - v0x;</a>
<a name="ln1385">          real_t e0y = v1y - v0y;</a>
<a name="ln1386">          real_t e0z = v1z - v0z;</a>
<a name="ln1387">          real_t e1x = v2x - v1x;</a>
<a name="ln1388">          real_t e1y = v2y - v1y;</a>
<a name="ln1389">          real_t e1z = v2z - v1z;</a>
<a name="ln1390">          real_t cx = std::fabs(e0y * e1z - e0z * e1y);</a>
<a name="ln1391">          real_t cy = std::fabs(e0z * e1x - e0x * e1z);</a>
<a name="ln1392">          real_t cz = std::fabs(e0x * e1y - e0y * e1x);</a>
<a name="ln1393">          const real_t epsilon = std::numeric_limits&lt;real_t&gt;::epsilon();</a>
<a name="ln1394">          if (cx &gt; epsilon || cy &gt; epsilon || cz &gt; epsilon) {</a>
<a name="ln1395">            // found a corner</a>
<a name="ln1396">            if (cx &gt; cy &amp;&amp; cx &gt; cz) {</a>
<a name="ln1397">            } else {</a>
<a name="ln1398">              axes[0] = 0;</a>
<a name="ln1399">              if (cz &gt; cx &amp;&amp; cz &gt; cy) axes[1] = 1;</a>
<a name="ln1400">            }</a>
<a name="ln1401">            break;</a>
<a name="ln1402">          }</a>
<a name="ln1403">        }</a>
<a name="ln1404"> </a>
<a name="ln1405">        real_t area = 0;</a>
<a name="ln1406">        for (size_t k = 0; k &lt; npolys; ++k) {</a>
<a name="ln1407">          i0 = face.vertex_indices[(k + 0) % npolys];</a>
<a name="ln1408">          i1 = face.vertex_indices[(k + 1) % npolys];</a>
<a name="ln1409">          size_t vi0 = size_t(i0.v_idx);</a>
<a name="ln1410">          size_t vi1 = size_t(i1.v_idx);</a>
<a name="ln1411">          if (((vi0 * 3 + axes[0]) &gt;= v.size()) ||</a>
<a name="ln1412">              ((vi0 * 3 + axes[1]) &gt;= v.size()) ||</a>
<a name="ln1413">              ((vi1 * 3 + axes[0]) &gt;= v.size()) ||</a>
<a name="ln1414">              ((vi1 * 3 + axes[1]) &gt;= v.size())) {</a>
<a name="ln1415">            // Invalid index.</a>
<a name="ln1416">            continue;</a>
<a name="ln1417">          }</a>
<a name="ln1418">          real_t v0x = v[vi0 * 3 + axes[0]];</a>
<a name="ln1419">          real_t v0y = v[vi0 * 3 + axes[1]];</a>
<a name="ln1420">          real_t v1x = v[vi1 * 3 + axes[0]];</a>
<a name="ln1421">          real_t v1y = v[vi1 * 3 + axes[1]];</a>
<a name="ln1422">          area += (v0x * v1y - v0y * v1x) * static_cast&lt;real_t&gt;(0.5);</a>
<a name="ln1423">        }</a>
<a name="ln1424"> </a>
<a name="ln1425">        face_t remainingFace = face;  // copy</a>
<a name="ln1426">        size_t guess_vert = 0;</a>
<a name="ln1427">        vertex_index_t ind[3];</a>
<a name="ln1428">        real_t vx[3];</a>
<a name="ln1429">        real_t vy[3];</a>
<a name="ln1430"> </a>
<a name="ln1431">        // How many iterations can we do without decreasing the remaining</a>
<a name="ln1432">        // vertices.</a>
<a name="ln1433">        size_t remainingIterations = face.vertex_indices.size();</a>
<a name="ln1434">        size_t previousRemainingVertices = remainingFace.vertex_indices.size();</a>
<a name="ln1435"> </a>
<a name="ln1436">        while (remainingFace.vertex_indices.size() &gt; 3 &amp;&amp;</a>
<a name="ln1437">               remainingIterations &gt; 0) {</a>
<a name="ln1438">          npolys = remainingFace.vertex_indices.size();</a>
<a name="ln1439">          if (guess_vert &gt;= npolys) {</a>
<a name="ln1440">            guess_vert -= npolys;</a>
<a name="ln1441">          }</a>
<a name="ln1442"> </a>
<a name="ln1443">          if (previousRemainingVertices != npolys) {</a>
<a name="ln1444">            // The number of remaining vertices decreased. Reset counters.</a>
<a name="ln1445">            previousRemainingVertices = npolys;</a>
<a name="ln1446">            remainingIterations = npolys;</a>
<a name="ln1447">          } else {</a>
<a name="ln1448">            // We didn't consume a vertex on previous iteration, reduce the</a>
<a name="ln1449">            // available iterations.</a>
<a name="ln1450">            remainingIterations--;</a>
<a name="ln1451">          }</a>
<a name="ln1452"> </a>
<a name="ln1453">          for (size_t k = 0; k &lt; 3; k++) {</a>
<a name="ln1454">            ind[k] = remainingFace.vertex_indices[(guess_vert + k) % npolys];</a>
<a name="ln1455">            size_t vi = size_t(ind[k].v_idx);</a>
<a name="ln1456">            if (((vi * 3 + axes[0]) &gt;= v.size()) ||</a>
<a name="ln1457">                ((vi * 3 + axes[1]) &gt;= v.size())) {</a>
<a name="ln1458">              // ???</a>
<a name="ln1459">              vx[k] = static_cast&lt;real_t&gt;(0.0);</a>
<a name="ln1460">              vy[k] = static_cast&lt;real_t&gt;(0.0);</a>
<a name="ln1461">            } else {</a>
<a name="ln1462">              vx[k] = v[vi * 3 + axes[0]];</a>
<a name="ln1463">              vy[k] = v[vi * 3 + axes[1]];</a>
<a name="ln1464">            }</a>
<a name="ln1465">          }</a>
<a name="ln1466">          real_t e0x = vx[1] - vx[0];</a>
<a name="ln1467">          real_t e0y = vy[1] - vy[0];</a>
<a name="ln1468">          real_t e1x = vx[2] - vx[1];</a>
<a name="ln1469">          real_t e1y = vy[2] - vy[1];</a>
<a name="ln1470">          real_t cross = e0x * e1y - e0y * e1x;</a>
<a name="ln1471">          // if an internal angle</a>
<a name="ln1472">          if (cross * area &lt; static_cast&lt;real_t&gt;(0.0)) {</a>
<a name="ln1473">            guess_vert += 1;</a>
<a name="ln1474">            continue;</a>
<a name="ln1475">          }</a>
<a name="ln1476"> </a>
<a name="ln1477">          // check all other verts in case they are inside this triangle</a>
<a name="ln1478">          bool overlap = false;</a>
<a name="ln1479">          for (size_t otherVert = 3; otherVert &lt; npolys; ++otherVert) {</a>
<a name="ln1480">            size_t idx = (guess_vert + otherVert) % npolys;</a>
<a name="ln1481"> </a>
<a name="ln1482">            if (idx &gt;= remainingFace.vertex_indices.size()) {</a>
<a name="ln1483">              // ???</a>
<a name="ln1484">              continue;</a>
<a name="ln1485">            }</a>
<a name="ln1486"> </a>
<a name="ln1487">            size_t ovi = size_t(remainingFace.vertex_indices[idx].v_idx);</a>
<a name="ln1488"> </a>
<a name="ln1489">            if (((ovi * 3 + axes[0]) &gt;= v.size()) ||</a>
<a name="ln1490">                ((ovi * 3 + axes[1]) &gt;= v.size())) {</a>
<a name="ln1491">              // ???</a>
<a name="ln1492">              continue;</a>
<a name="ln1493">            }</a>
<a name="ln1494">            real_t tx = v[ovi * 3 + axes[0]];</a>
<a name="ln1495">            real_t ty = v[ovi * 3 + axes[1]];</a>
<a name="ln1496">            if (pnpoly(3, vx, vy, tx, ty)) {</a>
<a name="ln1497">              overlap = true;</a>
<a name="ln1498">              break;</a>
<a name="ln1499">            }</a>
<a name="ln1500">          }</a>
<a name="ln1501"> </a>
<a name="ln1502">          if (overlap) {</a>
<a name="ln1503">            guess_vert += 1;</a>
<a name="ln1504">            continue;</a>
<a name="ln1505">          }</a>
<a name="ln1506"> </a>
<a name="ln1507">          // this triangle is an ear</a>
<a name="ln1508">          {</a>
<a name="ln1509">            index_t idx0, idx1, idx2;</a>
<a name="ln1510">            idx0.vertex_index = ind[0].v_idx;</a>
<a name="ln1511">            idx0.normal_index = ind[0].vn_idx;</a>
<a name="ln1512">            idx0.texcoord_index = ind[0].vt_idx;</a>
<a name="ln1513">            idx1.vertex_index = ind[1].v_idx;</a>
<a name="ln1514">            idx1.normal_index = ind[1].vn_idx;</a>
<a name="ln1515">            idx1.texcoord_index = ind[1].vt_idx;</a>
<a name="ln1516">            idx2.vertex_index = ind[2].v_idx;</a>
<a name="ln1517">            idx2.normal_index = ind[2].vn_idx;</a>
<a name="ln1518">            idx2.texcoord_index = ind[2].vt_idx;</a>
<a name="ln1519"> </a>
<a name="ln1520">            shape-&gt;mesh.indices.push_back(idx0);</a>
<a name="ln1521">            shape-&gt;mesh.indices.push_back(idx1);</a>
<a name="ln1522">            shape-&gt;mesh.indices.push_back(idx2);</a>
<a name="ln1523"> </a>
<a name="ln1524">            shape-&gt;mesh.num_face_vertices.push_back(3);</a>
<a name="ln1525">            shape-&gt;mesh.material_ids.push_back(material_id);</a>
<a name="ln1526">            shape-&gt;mesh.smoothing_group_ids.push_back(face.smoothing_group_id);</a>
<a name="ln1527">          }</a>
<a name="ln1528"> </a>
<a name="ln1529">          // remove v1 from the list</a>
<a name="ln1530">          size_t removed_vert_index = (guess_vert + 1) % npolys;</a>
<a name="ln1531">          while (removed_vert_index + 1 &lt; npolys) {</a>
<a name="ln1532">            remainingFace.vertex_indices[removed_vert_index] =</a>
<a name="ln1533">                remainingFace.vertex_indices[removed_vert_index + 1];</a>
<a name="ln1534">            removed_vert_index += 1;</a>
<a name="ln1535">          }</a>
<a name="ln1536">          remainingFace.vertex_indices.pop_back();</a>
<a name="ln1537">        }</a>
<a name="ln1538"> </a>
<a name="ln1539">        if (remainingFace.vertex_indices.size() == 3) {</a>
<a name="ln1540">          i0 = remainingFace.vertex_indices[0];</a>
<a name="ln1541">          i1 = remainingFace.vertex_indices[1];</a>
<a name="ln1542">          i2 = remainingFace.vertex_indices[2];</a>
<a name="ln1543">          {</a>
<a name="ln1544">            index_t idx0, idx1, idx2;</a>
<a name="ln1545">            idx0.vertex_index = i0.v_idx;</a>
<a name="ln1546">            idx0.normal_index = i0.vn_idx;</a>
<a name="ln1547">            idx0.texcoord_index = i0.vt_idx;</a>
<a name="ln1548">            idx1.vertex_index = i1.v_idx;</a>
<a name="ln1549">            idx1.normal_index = i1.vn_idx;</a>
<a name="ln1550">            idx1.texcoord_index = i1.vt_idx;</a>
<a name="ln1551">            idx2.vertex_index = i2.v_idx;</a>
<a name="ln1552">            idx2.normal_index = i2.vn_idx;</a>
<a name="ln1553">            idx2.texcoord_index = i2.vt_idx;</a>
<a name="ln1554"> </a>
<a name="ln1555">            shape-&gt;mesh.indices.push_back(idx0);</a>
<a name="ln1556">            shape-&gt;mesh.indices.push_back(idx1);</a>
<a name="ln1557">            shape-&gt;mesh.indices.push_back(idx2);</a>
<a name="ln1558"> </a>
<a name="ln1559">            shape-&gt;mesh.num_face_vertices.push_back(3);</a>
<a name="ln1560">            shape-&gt;mesh.material_ids.push_back(material_id);</a>
<a name="ln1561">            shape-&gt;mesh.smoothing_group_ids.push_back(face.smoothing_group_id);</a>
<a name="ln1562">          }</a>
<a name="ln1563">        }</a>
<a name="ln1564">      } else {</a>
<a name="ln1565">        for (size_t k = 0; k &lt; npolys; k++) {</a>
<a name="ln1566">          index_t idx;</a>
<a name="ln1567">          idx.vertex_index = face.vertex_indices[k].v_idx;</a>
<a name="ln1568">          idx.normal_index = face.vertex_indices[k].vn_idx;</a>
<a name="ln1569">          idx.texcoord_index = face.vertex_indices[k].vt_idx;</a>
<a name="ln1570">          shape-&gt;mesh.indices.push_back(idx);</a>
<a name="ln1571">        }</a>
<a name="ln1572"> </a>
<a name="ln1573">        shape-&gt;mesh.num_face_vertices.push_back(</a>
<a name="ln1574">            static_cast&lt;unsigned char&gt;(npolys));</a>
<a name="ln1575">        shape-&gt;mesh.material_ids.push_back(material_id);  // per face</a>
<a name="ln1576">        shape-&gt;mesh.smoothing_group_ids.push_back(</a>
<a name="ln1577">            face.smoothing_group_id);  // per face</a>
<a name="ln1578">      }</a>
<a name="ln1579">    }</a>
<a name="ln1580"> </a>
<a name="ln1581">    shape-&gt;mesh.tags = tags;</a>
<a name="ln1582">  }</a>
<a name="ln1583"> </a>
<a name="ln1584">  // line</a>
<a name="ln1585">  if (!prim_group.lineGroup.empty()) {</a>
<a name="ln1586">    // Flatten indices</a>
<a name="ln1587">    for (size_t i = 0; i &lt; prim_group.lineGroup.size(); i++) {</a>
<a name="ln1588">      for (size_t j = 0; j &lt; prim_group.lineGroup[i].vertex_indices.size();</a>
<a name="ln1589">           j++) {</a>
<a name="ln1590">        const vertex_index_t &amp;vi = prim_group.lineGroup[i].vertex_indices[j];</a>
<a name="ln1591"> </a>
<a name="ln1592">        index_t idx;</a>
<a name="ln1593">        idx.vertex_index = vi.v_idx;</a>
<a name="ln1594">        idx.normal_index = vi.vn_idx;</a>
<a name="ln1595">        idx.texcoord_index = vi.vt_idx;</a>
<a name="ln1596"> </a>
<a name="ln1597">        shape-&gt;lines.indices.push_back(idx);</a>
<a name="ln1598">      }</a>
<a name="ln1599"> </a>
<a name="ln1600">      shape-&gt;lines.num_line_vertices.push_back(</a>
<a name="ln1601">          int(prim_group.lineGroup[i].vertex_indices.size()));</a>
<a name="ln1602">    }</a>
<a name="ln1603">  }</a>
<a name="ln1604"> </a>
<a name="ln1605">  // points</a>
<a name="ln1606">  if (!prim_group.pointsGroup.empty()) {</a>
<a name="ln1607">    // Flatten &amp; convert indices</a>
<a name="ln1608">    for (size_t i = 0; i &lt; prim_group.pointsGroup.size(); i++) {</a>
<a name="ln1609">      for (size_t j = 0; j &lt; prim_group.pointsGroup[i].vertex_indices.size();</a>
<a name="ln1610">           j++) {</a>
<a name="ln1611">        const vertex_index_t &amp;vi = prim_group.pointsGroup[i].vertex_indices[j];</a>
<a name="ln1612"> </a>
<a name="ln1613">        index_t idx;</a>
<a name="ln1614">        idx.vertex_index = vi.v_idx;</a>
<a name="ln1615">        idx.normal_index = vi.vn_idx;</a>
<a name="ln1616">        idx.texcoord_index = vi.vt_idx;</a>
<a name="ln1617"> </a>
<a name="ln1618">        shape-&gt;points.indices.push_back(idx);</a>
<a name="ln1619">      }</a>
<a name="ln1620">    }</a>
<a name="ln1621">  }</a>
<a name="ln1622"> </a>
<a name="ln1623">  return true;</a>
<a name="ln1624">}</a>
<a name="ln1625"> </a>
<a name="ln1626">// Split a string with specified delimiter character.</a>
<a name="ln1627">// http://stackoverflow.com/questions/236129/split-a-string-in-c</a>
<a name="ln1628">static void SplitString(const std::string &amp;s, char delim,</a>
<a name="ln1629">                        std::vector&lt;std::string&gt; &amp;elems) {</a>
<a name="ln1630">  std::stringstream ss;</a>
<a name="ln1631">  ss.str(s);</a>
<a name="ln1632">  std::string item;</a>
<a name="ln1633">  while (std::getline(ss, item, delim)) {</a>
<a name="ln1634">    elems.push_back(item);</a>
<a name="ln1635">  }</a>
<a name="ln1636">}</a>
<a name="ln1637"> </a>
<a name="ln1638">void LoadMtl(std::map&lt;std::string, int&gt; *material_map,</a>
<a name="ln1639">             std::vector&lt;material_t&gt; *materials, std::istream *inStream,</a>
<a name="ln1640">             std::string *warning, std::string *err) {</a>
<a name="ln1641">  (void)err;</a>
<a name="ln1642"> </a>
<a name="ln1643">  // Create a default material anyway.</a>
<a name="ln1644">  material_t material;</a>
<a name="ln1645">  InitMaterial(&amp;material);</a>
<a name="ln1646"> </a>
<a name="ln1647">  // Issue 43. `d` wins against `Tr` since `Tr` is not in the MTL specification.</a>
<a name="ln1648">  bool has_d = false;</a>
<a name="ln1649">  bool has_tr = false;</a>
<a name="ln1650"> </a>
<a name="ln1651">  std::stringstream warn_ss;</a>
<a name="ln1652"> </a>
<a name="ln1653">  size_t line_no = 0;</a>
<a name="ln1654">  std::string linebuf;</a>
<a name="ln1655">  while (inStream-&gt;peek() != -1) {</a>
<a name="ln1656">    safeGetline(*inStream, linebuf);</a>
<a name="ln1657">    line_no++;</a>
<a name="ln1658"> </a>
<a name="ln1659">    // Trim trailing whitespace.</a>
<a name="ln1660">    if (linebuf.size() &gt; 0) {</a>
<a name="ln1661">      linebuf = linebuf.substr(0, linebuf.find_last_not_of(&quot; \t&quot;) + 1);</a>
<a name="ln1662">    }</a>
<a name="ln1663"> </a>
<a name="ln1664">    // Trim newline '\r\n' or '\n'</a>
<a name="ln1665">    if (linebuf.size() &gt; 0) {</a>
<a name="ln1666">      if (linebuf[linebuf.size() - 1] == '\n')</a>
<a name="ln1667">        linebuf.erase(linebuf.size() - 1);</a>
<a name="ln1668">    }</a>
<a name="ln1669">    if (linebuf.size() &gt; 0) {</a>
<a name="ln1670">      if (linebuf[linebuf.size() - 1] == '\r')</a>
<a name="ln1671">        linebuf.erase(linebuf.size() - 1);</a>
<a name="ln1672">    }</a>
<a name="ln1673"> </a>
<a name="ln1674">    // Skip if empty line.</a>
<a name="ln1675">    if (linebuf.empty()) {</a>
<a name="ln1676">      continue;</a>
<a name="ln1677">    }</a>
<a name="ln1678"> </a>
<a name="ln1679">    // Skip leading space.</a>
<a name="ln1680">    const char *token = linebuf.c_str();</a>
<a name="ln1681">    token += strspn(token, &quot; \t&quot;);</a>
<a name="ln1682"> </a>
<a name="ln1683">    assert(token);</a>
<a name="ln1684">    if (token[0] == '\0') continue;  // empty line</a>
<a name="ln1685"> </a>
<a name="ln1686">    if (token[0] == '#') continue;  // comment line</a>
<a name="ln1687"> </a>
<a name="ln1688">    // new mtl</a>
<a name="ln1689">    if ((0 == strncmp(token, &quot;newmtl&quot;, 6)) &amp;&amp; IS_SPACE((token[6]))) {</a>
<a name="ln1690">      // flush previous material.</a>
<a name="ln1691">      if (!material.name.empty()) {</a>
<a name="ln1692">        material_map-&gt;insert(std::pair&lt;std::string, int&gt;(</a>
<a name="ln1693">            material.name, static_cast&lt;int&gt;(materials-&gt;size())));</a>
<a name="ln1694">        materials-&gt;push_back(material);</a>
<a name="ln1695">      }</a>
<a name="ln1696"> </a>
<a name="ln1697">      // initial temporary material</a>
<a name="ln1698">      InitMaterial(&amp;material);</a>
<a name="ln1699"> </a>
<a name="ln1700">      has_d = false;</a>
<a name="ln1701">      has_tr = false;</a>
<a name="ln1702"> </a>
<a name="ln1703">      // set new mtl name</a>
<a name="ln1704">      token += 7;</a>
<a name="ln1705">      {</a>
<a name="ln1706">        std::stringstream sstr;</a>
<a name="ln1707">        sstr &lt;&lt; token;</a>
<a name="ln1708">        material.name = sstr.str();</a>
<a name="ln1709">      }</a>
<a name="ln1710">      continue;</a>
<a name="ln1711">    }</a>
<a name="ln1712"> </a>
<a name="ln1713">    // ambient</a>
<a name="ln1714">    if (token[0] == 'K' &amp;&amp; token[1] == 'a' &amp;&amp; IS_SPACE((token[2]))) {</a>
<a name="ln1715">      token += 2;</a>
<a name="ln1716">      real_t r, g, b;</a>
<a name="ln1717">      parseReal3(&amp;r, &amp;g, &amp;b, &amp;token);</a>
<a name="ln1718">      material.ambient[0] = r;</a>
<a name="ln1719">      material.ambient[1] = g;</a>
<a name="ln1720">      material.ambient[2] = b;</a>
<a name="ln1721">      continue;</a>
<a name="ln1722">    }</a>
<a name="ln1723"> </a>
<a name="ln1724">    // diffuse</a>
<a name="ln1725">    if (token[0] == 'K' &amp;&amp; token[1] == 'd' &amp;&amp; IS_SPACE((token[2]))) {</a>
<a name="ln1726">      token += 2;</a>
<a name="ln1727">      real_t r, g, b;</a>
<a name="ln1728">      parseReal3(&amp;r, &amp;g, &amp;b, &amp;token);</a>
<a name="ln1729">      material.diffuse[0] = r;</a>
<a name="ln1730">      material.diffuse[1] = g;</a>
<a name="ln1731">      material.diffuse[2] = b;</a>
<a name="ln1732">      continue;</a>
<a name="ln1733">    }</a>
<a name="ln1734"> </a>
<a name="ln1735">    // specular</a>
<a name="ln1736">    if (token[0] == 'K' &amp;&amp; token[1] == 's' &amp;&amp; IS_SPACE((token[2]))) {</a>
<a name="ln1737">      token += 2;</a>
<a name="ln1738">      real_t r, g, b;</a>
<a name="ln1739">      parseReal3(&amp;r, &amp;g, &amp;b, &amp;token);</a>
<a name="ln1740">      material.specular[0] = r;</a>
<a name="ln1741">      material.specular[1] = g;</a>
<a name="ln1742">      material.specular[2] = b;</a>
<a name="ln1743">      continue;</a>
<a name="ln1744">    }</a>
<a name="ln1745"> </a>
<a name="ln1746">    // transmittance</a>
<a name="ln1747">    if ((token[0] == 'K' &amp;&amp; token[1] == 't' &amp;&amp; IS_SPACE((token[2]))) ||</a>
<a name="ln1748">        (token[0] == 'T' &amp;&amp; token[1] == 'f' &amp;&amp; IS_SPACE((token[2])))) {</a>
<a name="ln1749">      token += 2;</a>
<a name="ln1750">      real_t r, g, b;</a>
<a name="ln1751">      parseReal3(&amp;r, &amp;g, &amp;b, &amp;token);</a>
<a name="ln1752">      material.transmittance[0] = r;</a>
<a name="ln1753">      material.transmittance[1] = g;</a>
<a name="ln1754">      material.transmittance[2] = b;</a>
<a name="ln1755">      continue;</a>
<a name="ln1756">    }</a>
<a name="ln1757"> </a>
<a name="ln1758">    // ior(index of refraction)</a>
<a name="ln1759">    if (token[0] == 'N' &amp;&amp; token[1] == 'i' &amp;&amp; IS_SPACE((token[2]))) {</a>
<a name="ln1760">      token += 2;</a>
<a name="ln1761">      material.ior = parseReal(&amp;token);</a>
<a name="ln1762">      continue;</a>
<a name="ln1763">    }</a>
<a name="ln1764"> </a>
<a name="ln1765">    // emission</a>
<a name="ln1766">    if (token[0] == 'K' &amp;&amp; token[1] == 'e' &amp;&amp; IS_SPACE(token[2])) {</a>
<a name="ln1767">      token += 2;</a>
<a name="ln1768">      real_t r, g, b;</a>
<a name="ln1769">      parseReal3(&amp;r, &amp;g, &amp;b, &amp;token);</a>
<a name="ln1770">      material.emission[0] = r;</a>
<a name="ln1771">      material.emission[1] = g;</a>
<a name="ln1772">      material.emission[2] = b;</a>
<a name="ln1773">      continue;</a>
<a name="ln1774">    }</a>
<a name="ln1775"> </a>
<a name="ln1776">    // shininess</a>
<a name="ln1777">    if (token[0] == 'N' &amp;&amp; token[1] == 's' &amp;&amp; IS_SPACE(token[2])) {</a>
<a name="ln1778">      token += 2;</a>
<a name="ln1779">      material.shininess = parseReal(&amp;token);</a>
<a name="ln1780">      continue;</a>
<a name="ln1781">    }</a>
<a name="ln1782"> </a>
<a name="ln1783">    // illum model</a>
<a name="ln1784">    if (0 == strncmp(token, &quot;illum&quot;, 5) &amp;&amp; IS_SPACE(token[5])) {</a>
<a name="ln1785">      token += 6;</a>
<a name="ln1786">      material.illum = parseInt(&amp;token);</a>
<a name="ln1787">      continue;</a>
<a name="ln1788">    }</a>
<a name="ln1789"> </a>
<a name="ln1790">    // dissolve</a>
<a name="ln1791">    if ((token[0] == 'd' &amp;&amp; IS_SPACE(token[1]))) {</a>
<a name="ln1792">      token += 1;</a>
<a name="ln1793">      material.dissolve = parseReal(&amp;token);</a>
<a name="ln1794"> </a>
<a name="ln1795">      if (has_tr) {</a>
<a name="ln1796">        warn_ss &lt;&lt; &quot;Both `d` and `Tr` parameters defined for \&quot;&quot;</a>
<a name="ln1797">                &lt;&lt; material.name</a>
<a name="ln1798">                &lt;&lt; &quot;\&quot;. Use the value of `d` for dissolve (line &quot; &lt;&lt; line_no</a>
<a name="ln1799">                &lt;&lt; &quot; in .mtl.)&quot; &lt;&lt; std::endl;</a>
<a name="ln1800">      }</a>
<a name="ln1801">      has_d = true;</a>
<a name="ln1802">      continue;</a>
<a name="ln1803">    }</a>
<a name="ln1804">    if (token[0] == 'T' &amp;&amp; token[1] == 'r' &amp;&amp; IS_SPACE(token[2])) {</a>
<a name="ln1805">      token += 2;</a>
<a name="ln1806">      if (has_d) {</a>
<a name="ln1807">        // `d` wins. Ignore `Tr` value.</a>
<a name="ln1808">        warn_ss &lt;&lt; &quot;Both `d` and `Tr` parameters defined for \&quot;&quot;</a>
<a name="ln1809">                &lt;&lt; material.name</a>
<a name="ln1810">                &lt;&lt; &quot;\&quot;. Use the value of `d` for dissolve (line &quot; &lt;&lt; line_no</a>
<a name="ln1811">                &lt;&lt; &quot; in .mtl.)&quot; &lt;&lt; std::endl;</a>
<a name="ln1812">      } else {</a>
<a name="ln1813">        // We invert value of Tr(assume Tr is in range [0, 1])</a>
<a name="ln1814">        // NOTE: Interpretation of Tr is application(exporter) dependent. For</a>
<a name="ln1815">        // some application(e.g. 3ds max obj exporter), Tr = d(Issue 43)</a>
<a name="ln1816">        material.dissolve = static_cast&lt;real_t&gt;(1.0) - parseReal(&amp;token);</a>
<a name="ln1817">      }</a>
<a name="ln1818">      has_tr = true;</a>
<a name="ln1819">      continue;</a>
<a name="ln1820">    }</a>
<a name="ln1821"> </a>
<a name="ln1822">    // PBR: roughness</a>
<a name="ln1823">    if (token[0] == 'P' &amp;&amp; token[1] == 'r' &amp;&amp; IS_SPACE(token[2])) {</a>
<a name="ln1824">      token += 2;</a>
<a name="ln1825">      material.roughness = parseReal(&amp;token);</a>
<a name="ln1826">      continue;</a>
<a name="ln1827">    }</a>
<a name="ln1828"> </a>
<a name="ln1829">    // PBR: metallic</a>
<a name="ln1830">    if (token[0] == 'P' &amp;&amp; token[1] == 'm' &amp;&amp; IS_SPACE(token[2])) {</a>
<a name="ln1831">      token += 2;</a>
<a name="ln1832">      material.metallic = parseReal(&amp;token);</a>
<a name="ln1833">      continue;</a>
<a name="ln1834">    }</a>
<a name="ln1835"> </a>
<a name="ln1836">    // PBR: sheen</a>
<a name="ln1837">    if (token[0] == 'P' &amp;&amp; token[1] == 's' &amp;&amp; IS_SPACE(token[2])) {</a>
<a name="ln1838">      token += 2;</a>
<a name="ln1839">      material.sheen = parseReal(&amp;token);</a>
<a name="ln1840">      continue;</a>
<a name="ln1841">    }</a>
<a name="ln1842"> </a>
<a name="ln1843">    // PBR: clearcoat thickness</a>
<a name="ln1844">    if (token[0] == 'P' &amp;&amp; token[1] == 'c' &amp;&amp; IS_SPACE(token[2])) {</a>
<a name="ln1845">      token += 2;</a>
<a name="ln1846">      material.clearcoat_thickness = parseReal(&amp;token);</a>
<a name="ln1847">      continue;</a>
<a name="ln1848">    }</a>
<a name="ln1849"> </a>
<a name="ln1850">    // PBR: clearcoat roughness</a>
<a name="ln1851">    if ((0 == strncmp(token, &quot;Pcr&quot;, 3)) &amp;&amp; IS_SPACE(token[3])) {</a>
<a name="ln1852">      token += 4;</a>
<a name="ln1853">      material.clearcoat_roughness = parseReal(&amp;token);</a>
<a name="ln1854">      continue;</a>
<a name="ln1855">    }</a>
<a name="ln1856"> </a>
<a name="ln1857">    // PBR: anisotropy</a>
<a name="ln1858">    if ((0 == strncmp(token, &quot;aniso&quot;, 5)) &amp;&amp; IS_SPACE(token[5])) {</a>
<a name="ln1859">      token += 6;</a>
<a name="ln1860">      material.anisotropy = parseReal(&amp;token);</a>
<a name="ln1861">      continue;</a>
<a name="ln1862">    }</a>
<a name="ln1863"> </a>
<a name="ln1864">    // PBR: anisotropy rotation</a>
<a name="ln1865">    if ((0 == strncmp(token, &quot;anisor&quot;, 6)) &amp;&amp; IS_SPACE(token[6])) {</a>
<a name="ln1866">      token += 7;</a>
<a name="ln1867">      material.anisotropy_rotation = parseReal(&amp;token);</a>
<a name="ln1868">      continue;</a>
<a name="ln1869">    }</a>
<a name="ln1870"> </a>
<a name="ln1871">    // ambient texture</a>
<a name="ln1872">    if ((0 == strncmp(token, &quot;map_Ka&quot;, 6)) &amp;&amp; IS_SPACE(token[6])) {</a>
<a name="ln1873">      token += 7;</a>
<a name="ln1874">      ParseTextureNameAndOption(&amp;(material.ambient_texname),</a>
<a name="ln1875">                                &amp;(material.ambient_texopt), token);</a>
<a name="ln1876">      continue;</a>
<a name="ln1877">    }</a>
<a name="ln1878"> </a>
<a name="ln1879">    // diffuse texture</a>
<a name="ln1880">    if ((0 == strncmp(token, &quot;map_Kd&quot;, 6)) &amp;&amp; IS_SPACE(token[6])) {</a>
<a name="ln1881">      token += 7;</a>
<a name="ln1882">      ParseTextureNameAndOption(&amp;(material.diffuse_texname),</a>
<a name="ln1883">                                &amp;(material.diffuse_texopt), token);</a>
<a name="ln1884">      continue;</a>
<a name="ln1885">    }</a>
<a name="ln1886"> </a>
<a name="ln1887">    // specular texture</a>
<a name="ln1888">    if ((0 == strncmp(token, &quot;map_Ks&quot;, 6)) &amp;&amp; IS_SPACE(token[6])) {</a>
<a name="ln1889">      token += 7;</a>
<a name="ln1890">      ParseTextureNameAndOption(&amp;(material.specular_texname),</a>
<a name="ln1891">                                &amp;(material.specular_texopt), token);</a>
<a name="ln1892">      continue;</a>
<a name="ln1893">    }</a>
<a name="ln1894"> </a>
<a name="ln1895">    // specular highlight texture</a>
<a name="ln1896">    if ((0 == strncmp(token, &quot;map_Ns&quot;, 6)) &amp;&amp; IS_SPACE(token[6])) {</a>
<a name="ln1897">      token += 7;</a>
<a name="ln1898">      ParseTextureNameAndOption(&amp;(material.specular_highlight_texname),</a>
<a name="ln1899">                                &amp;(material.specular_highlight_texopt), token);</a>
<a name="ln1900">      continue;</a>
<a name="ln1901">    }</a>
<a name="ln1902"> </a>
<a name="ln1903">    // bump texture</a>
<a name="ln1904">    if ((0 == strncmp(token, &quot;map_bump&quot;, 8)) &amp;&amp; IS_SPACE(token[8])) {</a>
<a name="ln1905">      token += 9;</a>
<a name="ln1906">      ParseTextureNameAndOption(&amp;(material.bump_texname),</a>
<a name="ln1907">                                &amp;(material.bump_texopt), token);</a>
<a name="ln1908">      continue;</a>
<a name="ln1909">    }</a>
<a name="ln1910"> </a>
<a name="ln1911">    // bump texture</a>
<a name="ln1912">    if ((0 == strncmp(token, &quot;map_Bump&quot;, 8)) &amp;&amp; IS_SPACE(token[8])) {</a>
<a name="ln1913">      token += 9;</a>
<a name="ln1914">      ParseTextureNameAndOption(&amp;(material.bump_texname),</a>
<a name="ln1915">                                &amp;(material.bump_texopt), token);</a>
<a name="ln1916">      continue;</a>
<a name="ln1917">    }</a>
<a name="ln1918"> </a>
<a name="ln1919">    // bump texture</a>
<a name="ln1920">    if ((0 == strncmp(token, &quot;bump&quot;, 4)) &amp;&amp; IS_SPACE(token[4])) {</a>
<a name="ln1921">      token += 5;</a>
<a name="ln1922">      ParseTextureNameAndOption(&amp;(material.bump_texname),</a>
<a name="ln1923">                                &amp;(material.bump_texopt), token);</a>
<a name="ln1924">      continue;</a>
<a name="ln1925">    }</a>
<a name="ln1926"> </a>
<a name="ln1927">    // alpha texture</a>
<a name="ln1928">    if ((0 == strncmp(token, &quot;map_d&quot;, 5)) &amp;&amp; IS_SPACE(token[5])) {</a>
<a name="ln1929">      token += 6;</a>
<a name="ln1930">      material.alpha_texname = token;</a>
<a name="ln1931">      ParseTextureNameAndOption(&amp;(material.alpha_texname),</a>
<a name="ln1932">                                &amp;(material.alpha_texopt), token);</a>
<a name="ln1933">      continue;</a>
<a name="ln1934">    }</a>
<a name="ln1935"> </a>
<a name="ln1936">    // displacement texture</a>
<a name="ln1937">    if ((0 == strncmp(token, &quot;disp&quot;, 4)) &amp;&amp; IS_SPACE(token[4])) {</a>
<a name="ln1938">      token += 5;</a>
<a name="ln1939">      ParseTextureNameAndOption(&amp;(material.displacement_texname),</a>
<a name="ln1940">                                &amp;(material.displacement_texopt), token);</a>
<a name="ln1941">      continue;</a>
<a name="ln1942">    }</a>
<a name="ln1943"> </a>
<a name="ln1944">    // reflection map</a>
<a name="ln1945">    if ((0 == strncmp(token, &quot;refl&quot;, 4)) &amp;&amp; IS_SPACE(token[4])) {</a>
<a name="ln1946">      token += 5;</a>
<a name="ln1947">      ParseTextureNameAndOption(&amp;(material.reflection_texname),</a>
<a name="ln1948">                                &amp;(material.reflection_texopt), token);</a>
<a name="ln1949">      continue;</a>
<a name="ln1950">    }</a>
<a name="ln1951"> </a>
<a name="ln1952">    // PBR: roughness texture</a>
<a name="ln1953">    if ((0 == strncmp(token, &quot;map_Pr&quot;, 6)) &amp;&amp; IS_SPACE(token[6])) {</a>
<a name="ln1954">      token += 7;</a>
<a name="ln1955">      ParseTextureNameAndOption(&amp;(material.roughness_texname),</a>
<a name="ln1956">                                &amp;(material.roughness_texopt), token);</a>
<a name="ln1957">      continue;</a>
<a name="ln1958">    }</a>
<a name="ln1959"> </a>
<a name="ln1960">    // PBR: metallic texture</a>
<a name="ln1961">    if ((0 == strncmp(token, &quot;map_Pm&quot;, 6)) &amp;&amp; IS_SPACE(token[6])) {</a>
<a name="ln1962">      token += 7;</a>
<a name="ln1963">      ParseTextureNameAndOption(&amp;(material.metallic_texname),</a>
<a name="ln1964">                                &amp;(material.metallic_texopt), token);</a>
<a name="ln1965">      continue;</a>
<a name="ln1966">    }</a>
<a name="ln1967"> </a>
<a name="ln1968">    // PBR: sheen texture</a>
<a name="ln1969">    if ((0 == strncmp(token, &quot;map_Ps&quot;, 6)) &amp;&amp; IS_SPACE(token[6])) {</a>
<a name="ln1970">      token += 7;</a>
<a name="ln1971">      ParseTextureNameAndOption(&amp;(material.sheen_texname),</a>
<a name="ln1972">                                &amp;(material.sheen_texopt), token);</a>
<a name="ln1973">      continue;</a>
<a name="ln1974">    }</a>
<a name="ln1975"> </a>
<a name="ln1976">    // PBR: emissive texture</a>
<a name="ln1977">    if ((0 == strncmp(token, &quot;map_Ke&quot;, 6)) &amp;&amp; IS_SPACE(token[6])) {</a>
<a name="ln1978">      token += 7;</a>
<a name="ln1979">      ParseTextureNameAndOption(&amp;(material.emissive_texname),</a>
<a name="ln1980">                                &amp;(material.emissive_texopt), token);</a>
<a name="ln1981">      continue;</a>
<a name="ln1982">    }</a>
<a name="ln1983"> </a>
<a name="ln1984">    // PBR: normal map texture</a>
<a name="ln1985">    if ((0 == strncmp(token, &quot;norm&quot;, 4)) &amp;&amp; IS_SPACE(token[4])) {</a>
<a name="ln1986">      token += 5;</a>
<a name="ln1987">      ParseTextureNameAndOption(&amp;(material.normal_texname),</a>
<a name="ln1988">                                &amp;(material.normal_texopt), token);</a>
<a name="ln1989">      continue;</a>
<a name="ln1990">    }</a>
<a name="ln1991"> </a>
<a name="ln1992">    // unknown parameter</a>
<a name="ln1993">    const char *_space = strchr(token, ' ');</a>
<a name="ln1994">    if (!_space) {</a>
<a name="ln1995">      _space = strchr(token, '\t');</a>
<a name="ln1996">    }</a>
<a name="ln1997">    if (_space) {</a>
<a name="ln1998">      std::ptrdiff_t len = _space - token;</a>
<a name="ln1999">      std::string key(token, static_cast&lt;size_t&gt;(len));</a>
<a name="ln2000">      std::string value = _space + 1;</a>
<a name="ln2001">      material.unknown_parameter.insert(</a>
<a name="ln2002">          std::pair&lt;std::string, std::string&gt;(key, value));</a>
<a name="ln2003">    }</a>
<a name="ln2004">  }</a>
<a name="ln2005">  // flush last material.</a>
<a name="ln2006">  material_map-&gt;insert(std::pair&lt;std::string, int&gt;(</a>
<a name="ln2007">      material.name, static_cast&lt;int&gt;(materials-&gt;size())));</a>
<a name="ln2008">  materials-&gt;push_back(material);</a>
<a name="ln2009"> </a>
<a name="ln2010">  if (warning) {</a>
<a name="ln2011">    (*warning) = warn_ss.str();</a>
<a name="ln2012">  }</a>
<a name="ln2013">}</a>
<a name="ln2014"> </a>
<a name="ln2015">bool MaterialFileReader::operator()(const std::string &amp;matId,</a>
<a name="ln2016">                                    std::vector&lt;material_t&gt; *materials,</a>
<a name="ln2017">                                    std::map&lt;std::string, int&gt; *matMap,</a>
<a name="ln2018">                                    std::string *warn, std::string *err) {</a>
<a name="ln2019">  std::string filepath;</a>
<a name="ln2020"> </a>
<a name="ln2021">  if (!m_mtlBaseDir.empty()) {</a>
<a name="ln2022">    filepath = std::string(m_mtlBaseDir) + matId;</a>
<a name="ln2023">  } else {</a>
<a name="ln2024">    filepath = matId;</a>
<a name="ln2025">  }</a>
<a name="ln2026"> </a>
<a name="ln2027">  std::ifstream matIStream(filepath.c_str());</a>
<a name="ln2028">  if (!matIStream) {</a>
<a name="ln2029">    std::stringstream ss;</a>
<a name="ln2030">    ss &lt;&lt; &quot;Material file [ &quot; &lt;&lt; filepath &lt;&lt; &quot; ] not found.&quot; &lt;&lt; std::endl;</a>
<a name="ln2031">    if (warn) {</a>
<a name="ln2032">      (*warn) += ss.str();</a>
<a name="ln2033">    }</a>
<a name="ln2034">    return false;</a>
<a name="ln2035">  }</a>
<a name="ln2036"> </a>
<a name="ln2037">  LoadMtl(matMap, materials, &amp;matIStream, warn, err);</a>
<a name="ln2038"> </a>
<a name="ln2039">  return true;</a>
<a name="ln2040">}</a>
<a name="ln2041"> </a>
<a name="ln2042">bool MaterialStreamReader::operator()(const std::string &amp;matId,</a>
<a name="ln2043">                                      std::vector&lt;material_t&gt; *materials,</a>
<a name="ln2044">                                      std::map&lt;std::string, int&gt; *matMap,</a>
<a name="ln2045">                                      std::string *warn, std::string *err) {</a>
<a name="ln2046">  (void)err;</a>
<a name="ln2047">  (void)matId;</a>
<a name="ln2048">  if (!m_inStream) {</a>
<a name="ln2049">    std::stringstream ss;</a>
<a name="ln2050">    ss &lt;&lt; &quot;Material stream in error state. &quot; &lt;&lt; std::endl;</a>
<a name="ln2051">    if (warn) {</a>
<a name="ln2052">      (*warn) += ss.str();</a>
<a name="ln2053">    }</a>
<a name="ln2054">    return false;</a>
<a name="ln2055">  }</a>
<a name="ln2056"> </a>
<a name="ln2057">  LoadMtl(matMap, materials, &amp;m_inStream, warn, err);</a>
<a name="ln2058"> </a>
<a name="ln2059">  return true;</a>
<a name="ln2060">}</a>
<a name="ln2061"> </a>
<a name="ln2062">bool LoadObj(attrib_t *attrib, std::vector&lt;shape_t&gt; *shapes,</a>
<a name="ln2063">             std::vector&lt;material_t&gt; *materials, std::string *warn,</a>
<a name="ln2064">             std::string *err, const char *filename, const char *mtl_basedir,</a>
<a name="ln2065">             bool trianglulate, bool default_vcols_fallback) {</a>
<a name="ln2066">  attrib-&gt;vertices.clear();</a>
<a name="ln2067">  attrib-&gt;normals.clear();</a>
<a name="ln2068">  attrib-&gt;texcoords.clear();</a>
<a name="ln2069">  attrib-&gt;colors.clear();</a>
<a name="ln2070">  shapes-&gt;clear();</a>
<a name="ln2071"> </a>
<a name="ln2072">  std::stringstream errss;</a>
<a name="ln2073"> </a>
<a name="ln2074">  std::ifstream ifs(filename);</a>
<a name="ln2075">  if (!ifs) {</a>
<a name="ln2076">    errss &lt;&lt; &quot;Cannot open file [&quot; &lt;&lt; filename &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;</a>
<a name="ln2077">    if (err) {</a>
<a name="ln2078">      (*err) = errss.str();</a>
<a name="ln2079">    }</a>
<a name="ln2080">    return false;</a>
<a name="ln2081">  }</a>
<a name="ln2082"> </a>
<a name="ln2083">  std::string baseDir = mtl_basedir ? mtl_basedir : &quot;&quot;;</a>
<a name="ln2084">  if (!baseDir.empty()) {</a>
<a name="ln2085">#ifndef _WIN32</a>
<a name="ln2086">    const char dirsep = '/';</a>
<a name="ln2087">#else</a>
<a name="ln2088">    const char dirsep = '\\';</a>
<a name="ln2089">#endif</a>
<a name="ln2090">    if (baseDir[baseDir.length() - 1] != dirsep) baseDir += dirsep;</a>
<a name="ln2091">  }</a>
<a name="ln2092">  MaterialFileReader matFileReader(baseDir);</a>
<a name="ln2093"> </a>
<a name="ln2094">  return LoadObj(attrib, shapes, materials, warn, err, &amp;ifs, &amp;matFileReader,</a>
<a name="ln2095">                 trianglulate, default_vcols_fallback);</a>
<a name="ln2096">}</a>
<a name="ln2097"> </a>
<a name="ln2098">bool LoadObj(attrib_t *attrib, std::vector&lt;shape_t&gt; *shapes,</a>
<a name="ln2099">             std::vector&lt;material_t&gt; *materials, std::string *warn,</a>
<a name="ln2100">             std::string *err, std::istream *inStream,</a>
<a name="ln2101">             MaterialReader *readMatFn /*= NULL*/, bool triangulate,</a>
<a name="ln2102">             bool default_vcols_fallback) {</a>
<a name="ln2103">  std::stringstream errss;</a>
<a name="ln2104"> </a>
<a name="ln2105">  std::vector&lt;real_t&gt; v;</a>
<a name="ln2106">  std::vector&lt;real_t&gt; vn;</a>
<a name="ln2107">  std::vector&lt;real_t&gt; vt;</a>
<a name="ln2108">  std::vector&lt;real_t&gt; vc;</a>
<a name="ln2109">  std::vector&lt;tag_t&gt; tags;</a>
<a name="ln2110">  PrimGroup prim_group;</a>
<a name="ln2111">  std::string name;</a>
<a name="ln2112"> </a>
<a name="ln2113">  // material</a>
<a name="ln2114">  std::map&lt;std::string, int&gt; material_map;</a>
<a name="ln2115">  int material = -1;</a>
<a name="ln2116"> </a>
<a name="ln2117">  // smoothing group id</a>
<a name="ln2118">  unsigned int current_smoothing_id =</a>
<a name="ln2119">      0;  // Initial value. 0 means no smoothing.</a>
<a name="ln2120"> </a>
<a name="ln2121">  int greatest_v_idx = -1;</a>
<a name="ln2122">  int greatest_vn_idx = -1;</a>
<a name="ln2123">  int greatest_vt_idx = -1;</a>
<a name="ln2124"> </a>
<a name="ln2125">  shape_t shape;</a>
<a name="ln2126"> </a>
<a name="ln2127">  bool found_all_colors = true;</a>
<a name="ln2128"> </a>
<a name="ln2129">  size_t line_num = 0;</a>
<a name="ln2130">  std::string linebuf;</a>
<a name="ln2131">  while (inStream-&gt;peek() != -1) {</a>
<a name="ln2132">    safeGetline(*inStream, linebuf);</a>
<a name="ln2133"> </a>
<a name="ln2134">    line_num++;</a>
<a name="ln2135"> </a>
<a name="ln2136">    // Trim newline '\r\n' or '\n'</a>
<a name="ln2137">    if (linebuf.size() &gt; 0) {</a>
<a name="ln2138">      if (linebuf[linebuf.size() - 1] == '\n')</a>
<a name="ln2139">        linebuf.erase(linebuf.size() - 1);</a>
<a name="ln2140">    }</a>
<a name="ln2141">    if (linebuf.size() &gt; 0) {</a>
<a name="ln2142">      if (linebuf[linebuf.size() - 1] == '\r')</a>
<a name="ln2143">        linebuf.erase(linebuf.size() - 1);</a>
<a name="ln2144">    }</a>
<a name="ln2145"> </a>
<a name="ln2146">    // Skip if empty line.</a>
<a name="ln2147">    if (linebuf.empty()) {</a>
<a name="ln2148">      continue;</a>
<a name="ln2149">    }</a>
<a name="ln2150"> </a>
<a name="ln2151">    // Skip leading space.</a>
<a name="ln2152">    const char *token = linebuf.c_str();</a>
<a name="ln2153">    token += strspn(token, &quot; \t&quot;);</a>
<a name="ln2154"> </a>
<a name="ln2155">    assert(token);</a>
<a name="ln2156">    if (token[0] == '\0') continue;  // empty line</a>
<a name="ln2157"> </a>
<a name="ln2158">    if (token[0] == '#') continue;  // comment line</a>
<a name="ln2159"> </a>
<a name="ln2160">    // vertex</a>
<a name="ln2161">    if (token[0] == 'v' &amp;&amp; IS_SPACE((token[1]))) {</a>
<a name="ln2162">      token += 2;</a>
<a name="ln2163">      real_t x, y, z;</a>
<a name="ln2164">      real_t r, g, b;</a>
<a name="ln2165"> </a>
<a name="ln2166">      found_all_colors &amp;= parseVertexWithColor(&amp;x, &amp;y, &amp;z, &amp;r, &amp;g, &amp;b, &amp;token);</a>
<a name="ln2167"> </a>
<a name="ln2168">      v.push_back(x);</a>
<a name="ln2169">      v.push_back(y);</a>
<a name="ln2170">      v.push_back(z);</a>
<a name="ln2171"> </a>
<a name="ln2172">      if (found_all_colors || default_vcols_fallback) {</a>
<a name="ln2173">        vc.push_back(r);</a>
<a name="ln2174">        vc.push_back(g);</a>
<a name="ln2175">        vc.push_back(b);</a>
<a name="ln2176">      }</a>
<a name="ln2177"> </a>
<a name="ln2178">      continue;</a>
<a name="ln2179">    }</a>
<a name="ln2180"> </a>
<a name="ln2181">    // normal</a>
<a name="ln2182">    if (token[0] == 'v' &amp;&amp; token[1] == 'n' &amp;&amp; IS_SPACE((token[2]))) {</a>
<a name="ln2183">      token += 3;</a>
<a name="ln2184">      real_t x, y, z;</a>
<a name="ln2185">      parseReal3(&amp;x, &amp;y, &amp;z, &amp;token);</a>
<a name="ln2186">      vn.push_back(x);</a>
<a name="ln2187">      vn.push_back(y);</a>
<a name="ln2188">      vn.push_back(z);</a>
<a name="ln2189">      continue;</a>
<a name="ln2190">    }</a>
<a name="ln2191"> </a>
<a name="ln2192">    // texcoord</a>
<a name="ln2193">    if (token[0] == 'v' &amp;&amp; token[1] == 't' &amp;&amp; IS_SPACE((token[2]))) {</a>
<a name="ln2194">      token += 3;</a>
<a name="ln2195">      real_t x, y;</a>
<a name="ln2196">      parseReal2(&amp;x, &amp;y, &amp;token);</a>
<a name="ln2197">      vt.push_back(x);</a>
<a name="ln2198">      vt.push_back(y);</a>
<a name="ln2199">      continue;</a>
<a name="ln2200">    }</a>
<a name="ln2201"> </a>
<a name="ln2202">    // line</a>
<a name="ln2203">    if (token[0] == 'l' &amp;&amp; IS_SPACE((token[1]))) {</a>
<a name="ln2204">      token += 2;</a>
<a name="ln2205"> </a>
<a name="ln2206">      __line_t line;</a>
<a name="ln2207"> </a>
<a name="ln2208">      while (!IS_NEW_LINE(token[0])) {</a>
<a name="ln2209">        vertex_index_t vi;</a>
<a name="ln2210">        if (!parseTriple(&amp;token, static_cast&lt;int&gt;(v.size() / 3),</a>
<a name="ln2211">                         static_cast&lt;int&gt;(vn.size() / 3),</a>
<a name="ln2212">                         static_cast&lt;int&gt;(vt.size() / 2), &amp;vi)) {</a>
<a name="ln2213">          if (err) {</a>
<a name="ln2214">            std::stringstream ss;</a>
<a name="ln2215">            ss &lt;&lt; &quot;Failed parse `l' line(e.g. zero value for vertex index. &quot;</a>
<a name="ln2216">                  &quot;line &quot;</a>
<a name="ln2217">               &lt;&lt; line_num &lt;&lt; &quot;.)\n&quot;;</a>
<a name="ln2218">            (*err) += ss.str();</a>
<a name="ln2219">          }</a>
<a name="ln2220">          return false;</a>
<a name="ln2221">        }</a>
<a name="ln2222"> </a>
<a name="ln2223">        line.vertex_indices.push_back(vi);</a>
<a name="ln2224"> </a>
<a name="ln2225">        size_t n = strspn(token, &quot; \t\r&quot;);</a>
<a name="ln2226">        token += n;</a>
<a name="ln2227">      }</a>
<a name="ln2228"> </a>
<a name="ln2229">      prim_group.lineGroup.push_back(line);</a>
<a name="ln2230"> </a>
<a name="ln2231">      continue;</a>
<a name="ln2232">    }</a>
<a name="ln2233"> </a>
<a name="ln2234">    // points</a>
<a name="ln2235">    if (token[0] == 'p' &amp;&amp; IS_SPACE((token[1]))) {</a>
<a name="ln2236">      token += 2;</a>
<a name="ln2237"> </a>
<a name="ln2238">      __points_t pts;</a>
<a name="ln2239"> </a>
<a name="ln2240">      while (!IS_NEW_LINE(token[0])) {</a>
<a name="ln2241">        vertex_index_t vi;</a>
<a name="ln2242">        if (!parseTriple(&amp;token, static_cast&lt;int&gt;(v.size() / 3),</a>
<a name="ln2243">                         static_cast&lt;int&gt;(vn.size() / 3),</a>
<a name="ln2244">                         static_cast&lt;int&gt;(vt.size() / 2), &amp;vi)) {</a>
<a name="ln2245">          if (err) {</a>
<a name="ln2246">            std::stringstream ss;</a>
<a name="ln2247">            ss &lt;&lt; &quot;Failed parse `p' line(e.g. zero value for vertex index. &quot;</a>
<a name="ln2248">                  &quot;line &quot;</a>
<a name="ln2249">               &lt;&lt; line_num &lt;&lt; &quot;.)\n&quot;;</a>
<a name="ln2250">            (*err) += ss.str();</a>
<a name="ln2251">          }</a>
<a name="ln2252">          return false;</a>
<a name="ln2253">        }</a>
<a name="ln2254"> </a>
<a name="ln2255">        pts.vertex_indices.push_back(vi);</a>
<a name="ln2256"> </a>
<a name="ln2257">        size_t n = strspn(token, &quot; \t\r&quot;);</a>
<a name="ln2258">        token += n;</a>
<a name="ln2259">      }</a>
<a name="ln2260"> </a>
<a name="ln2261">      prim_group.pointsGroup.push_back(pts);</a>
<a name="ln2262"> </a>
<a name="ln2263">      continue;</a>
<a name="ln2264">    }</a>
<a name="ln2265"> </a>
<a name="ln2266">    // face</a>
<a name="ln2267">    if (token[0] == 'f' &amp;&amp; IS_SPACE((token[1]))) {</a>
<a name="ln2268">      token += 2;</a>
<a name="ln2269">      token += strspn(token, &quot; \t&quot;);</a>
<a name="ln2270"> </a>
<a name="ln2271">      face_t face;</a>
<a name="ln2272"> </a>
<a name="ln2273">      face.smoothing_group_id = current_smoothing_id;</a>
<a name="ln2274">      face.vertex_indices.reserve(3);</a>
<a name="ln2275"> </a>
<a name="ln2276">      while (!IS_NEW_LINE(token[0])) {</a>
<a name="ln2277">        vertex_index_t vi;</a>
<a name="ln2278">        if (!parseTriple(&amp;token, static_cast&lt;int&gt;(v.size() / 3),</a>
<a name="ln2279">                         static_cast&lt;int&gt;(vn.size() / 3),</a>
<a name="ln2280">                         static_cast&lt;int&gt;(vt.size() / 2), &amp;vi)) {</a>
<a name="ln2281">          if (err) {</a>
<a name="ln2282">            std::stringstream ss;</a>
<a name="ln2283">            ss &lt;&lt; &quot;Failed parse `f' line(e.g. zero value for face index. line &quot;</a>
<a name="ln2284">               &lt;&lt; line_num &lt;&lt; &quot;.)\n&quot;;</a>
<a name="ln2285">            (*err) += ss.str();</a>
<a name="ln2286">          }</a>
<a name="ln2287">          return false;</a>
<a name="ln2288">        }</a>
<a name="ln2289"> </a>
<a name="ln2290">        greatest_v_idx = greatest_v_idx &gt; vi.v_idx ? greatest_v_idx : vi.v_idx;</a>
<a name="ln2291">        greatest_vn_idx =</a>
<a name="ln2292">            greatest_vn_idx &gt; vi.vn_idx ? greatest_vn_idx : vi.vn_idx;</a>
<a name="ln2293">        greatest_vt_idx =</a>
<a name="ln2294">            greatest_vt_idx &gt; vi.vt_idx ? greatest_vt_idx : vi.vt_idx;</a>
<a name="ln2295"> </a>
<a name="ln2296">        face.vertex_indices.push_back(vi);</a>
<a name="ln2297">        size_t n = strspn(token, &quot; \t\r&quot;);</a>
<a name="ln2298">        token += n;</a>
<a name="ln2299">      }</a>
<a name="ln2300"> </a>
<a name="ln2301">      // replace with emplace_back + std::move on C++11</a>
<a name="ln2302">      prim_group.faceGroup.push_back(face);</a>
<a name="ln2303"> </a>
<a name="ln2304">      continue;</a>
<a name="ln2305">    }</a>
<a name="ln2306"> </a>
<a name="ln2307">    // use mtl</a>
<a name="ln2308">    if ((0 == strncmp(token, &quot;usemtl&quot;, 6)) &amp;&amp; IS_SPACE((token[6]))) {</a>
<a name="ln2309">      token += 7;</a>
<a name="ln2310">      std::stringstream ss;</a>
<a name="ln2311">      ss &lt;&lt; token;</a>
<a name="ln2312">      std::string namebuf = ss.str();</a>
<a name="ln2313"> </a>
<a name="ln2314">      int newMaterialId = -1;</a>
<a name="ln2315">      if (material_map.find(namebuf) != material_map.end()) {</a>
<a name="ln2316">        newMaterialId = material_map[namebuf];</a>
<a name="ln2317">      } else {</a>
<a name="ln2318">        // { error!! material not found }</a>
<a name="ln2319">      }</a>
<a name="ln2320"> </a>
<a name="ln2321">      if (newMaterialId != material) {</a>
<a name="ln2322">        // Create per-face material. Thus we don't add `shape` to `shapes` at</a>
<a name="ln2323">        // this time.</a>
<a name="ln2324">        // just clear `faceGroup` after `exportGroupsToShape()` call.</a>
<a name="ln2325">        exportGroupsToShape(&amp;shape, prim_group, tags, material, name,</a>
<a name="ln2326">                            triangulate, v);</a>
<a name="ln2327">        prim_group.faceGroup.clear();</a>
<a name="ln2328">        material = newMaterialId;</a>
<a name="ln2329">      }</a>
<a name="ln2330"> </a>
<a name="ln2331">      continue;</a>
<a name="ln2332">    }</a>
<a name="ln2333"> </a>
<a name="ln2334">    // load mtl</a>
<a name="ln2335">    if ((0 == strncmp(token, &quot;mtllib&quot;, 6)) &amp;&amp; IS_SPACE((token[6]))) {</a>
<a name="ln2336">      if (readMatFn) {</a>
<a name="ln2337">        token += 7;</a>
<a name="ln2338"> </a>
<a name="ln2339">        std::vector&lt;std::string&gt; filenames;</a>
<a name="ln2340">        SplitString(std::string(token), ' ', filenames);</a>
<a name="ln2341"> </a>
<a name="ln2342">        if (filenames.empty()) {</a>
<a name="ln2343">          if (warn) {</a>
<a name="ln2344">            std::stringstream ss;</a>
<a name="ln2345">            ss &lt;&lt; &quot;Looks like empty filename for mtllib. Use default &quot;</a>
<a name="ln2346">                  &quot;material (line &quot;</a>
<a name="ln2347">               &lt;&lt; line_num &lt;&lt; &quot;.)\n&quot;;</a>
<a name="ln2348"> </a>
<a name="ln2349">            (*warn) += ss.str();</a>
<a name="ln2350">          }</a>
<a name="ln2351">        } else {</a>
<a name="ln2352">          bool found = false;</a>
<a name="ln2353">          for (size_t s = 0; s &lt; filenames.size(); s++) {</a>
<a name="ln2354">            std::string warn_mtl;</a>
<a name="ln2355">            std::string err_mtl;</a>
<a name="ln2356">            bool ok = (*readMatFn)(filenames[s].c_str(), materials,</a>
<a name="ln2357">                                   &amp;material_map, &amp;warn_mtl, &amp;err_mtl);</a>
<a name="ln2358">            if (warn &amp;&amp; (!warn_mtl.empty())) {</a>
<a name="ln2359">              (*warn) += warn_mtl;</a>
<a name="ln2360">            }</a>
<a name="ln2361"> </a>
<a name="ln2362">            if (err &amp;&amp; (!err_mtl.empty())) {</a>
<a name="ln2363">              (*err) += err_mtl;</a>
<a name="ln2364">            }</a>
<a name="ln2365"> </a>
<a name="ln2366">            if (ok) {</a>
<a name="ln2367">              found = true;</a>
<a name="ln2368">              break;</a>
<a name="ln2369">            }</a>
<a name="ln2370">          }</a>
<a name="ln2371"> </a>
<a name="ln2372">          if (!found) {</a>
<a name="ln2373">            if (warn) {</a>
<a name="ln2374">              (*warn) +=</a>
<a name="ln2375">                  &quot;Failed to load material file(s). Use default &quot;</a>
<a name="ln2376">                  &quot;material.\n&quot;;</a>
<a name="ln2377">            }</a>
<a name="ln2378">          }</a>
<a name="ln2379">        }</a>
<a name="ln2380">      }</a>
<a name="ln2381"> </a>
<a name="ln2382">      continue;</a>
<a name="ln2383">    }</a>
<a name="ln2384"> </a>
<a name="ln2385">    // group name</a>
<a name="ln2386">    if (token[0] == 'g' &amp;&amp; IS_SPACE((token[1]))) {</a>
<a name="ln2387">      // flush previous face group.</a>
<a name="ln2388">      bool ret = exportGroupsToShape(&amp;shape, prim_group, tags, material, name,</a>
<a name="ln2389">                                     triangulate, v);</a>
<a name="ln2390">      (void)ret;  // return value not used.</a>
<a name="ln2391"> </a>
<a name="ln2392">      if (shape.mesh.indices.size() &gt; 0) {</a>
<a name="ln2393">        shapes-&gt;push_back(shape);</a>
<a name="ln2394">      }</a>
<a name="ln2395"> </a>
<a name="ln2396">      shape = shape_t();</a>
<a name="ln2397"> </a>
<a name="ln2398">      // material = -1;</a>
<a name="ln2399">      prim_group.clear();</a>
<a name="ln2400"> </a>
<a name="ln2401">      std::vector&lt;std::string&gt; names;</a>
<a name="ln2402"> </a>
<a name="ln2403">      while (!IS_NEW_LINE(token[0])) {</a>
<a name="ln2404">        std::string str = parseString(&amp;token);</a>
<a name="ln2405">        names.push_back(str);</a>
<a name="ln2406">        token += strspn(token, &quot; \t\r&quot;);  // skip tag</a>
<a name="ln2407">      }</a>
<a name="ln2408"> </a>
<a name="ln2409">      // names[0] must be 'g'</a>
<a name="ln2410"> </a>
<a name="ln2411">      if (names.size() &lt; 2) {</a>
<a name="ln2412">        // 'g' with empty names</a>
<a name="ln2413">        if (warn) {</a>
<a name="ln2414">          std::stringstream ss;</a>
<a name="ln2415">          ss &lt;&lt; &quot;Empty group name. line: &quot; &lt;&lt; line_num &lt;&lt; &quot;\n&quot;;</a>
<a name="ln2416">          (*warn) += ss.str();</a>
<a name="ln2417">          name = &quot;&quot;;</a>
<a name="ln2418">        }</a>
<a name="ln2419">      } else {</a>
<a name="ln2420">        std::stringstream ss;</a>
<a name="ln2421">        ss &lt;&lt; names[1];</a>
<a name="ln2422"> </a>
<a name="ln2423">        // tinyobjloader does not support multiple groups for a primitive.</a>
<a name="ln2424">        // Currently we concatinate multiple group names with a space to get</a>
<a name="ln2425">        // single group name.</a>
<a name="ln2426"> </a>
<a name="ln2427">        for (size_t i = 2; i &lt; names.size(); i++) {</a>
<a name="ln2428">          ss &lt;&lt; &quot; &quot; &lt;&lt; names[i];</a>
<a name="ln2429">        }</a>
<a name="ln2430"> </a>
<a name="ln2431">        name = ss.str();</a>
<a name="ln2432">      }</a>
<a name="ln2433"> </a>
<a name="ln2434">      continue;</a>
<a name="ln2435">    }</a>
<a name="ln2436"> </a>
<a name="ln2437">    // object name</a>
<a name="ln2438">    if (token[0] == 'o' &amp;&amp; IS_SPACE((token[1]))) {</a>
<a name="ln2439">      // flush previous face group.</a>
<a name="ln2440">      bool ret = exportGroupsToShape(&amp;shape, prim_group, tags, material, name,</a>
<a name="ln2441">                                     triangulate, v);</a>
<a name="ln2442">      if (ret) {</a>
<a name="ln2443">        shapes-&gt;push_back(shape);</a>
<a name="ln2444">      }</a>
<a name="ln2445"> </a>
<a name="ln2446">      // material = -1;</a>
<a name="ln2447">      prim_group.clear();</a>
<a name="ln2448">      shape = shape_t();</a>
<a name="ln2449"> </a>
<a name="ln2450">      // @todo { multiple object name? }</a>
<a name="ln2451">      token += 2;</a>
<a name="ln2452">      std::stringstream ss;</a>
<a name="ln2453">      ss &lt;&lt; token;</a>
<a name="ln2454">      name = ss.str();</a>
<a name="ln2455"> </a>
<a name="ln2456">      continue;</a>
<a name="ln2457">    }</a>
<a name="ln2458"> </a>
<a name="ln2459">    if (token[0] == 't' &amp;&amp; IS_SPACE(token[1])) {</a>
<a name="ln2460">      const int max_tag_nums = 8192;  // FIXME(syoyo): Parameterize.</a>
<a name="ln2461">      tag_t tag;</a>
<a name="ln2462"> </a>
<a name="ln2463">      token += 2;</a>
<a name="ln2464"> </a>
<a name="ln2465">      tag.name = parseString(&amp;token);</a>
<a name="ln2466"> </a>
<a name="ln2467">      tag_sizes ts = parseTagTriple(&amp;token);</a>
<a name="ln2468"> </a>
<a name="ln2469">      if (ts.num_ints &lt; 0) {</a>
<a name="ln2470">        ts.num_ints = 0;</a>
<a name="ln2471">      }</a>
<a name="ln2472">      if (ts.num_ints &gt; max_tag_nums) {</a>
<a name="ln2473">        ts.num_ints = max_tag_nums;</a>
<a name="ln2474">      }</a>
<a name="ln2475"> </a>
<a name="ln2476">      if (ts.num_reals &lt; 0) {</a>
<a name="ln2477">        ts.num_reals = 0;</a>
<a name="ln2478">      }</a>
<a name="ln2479">      if (ts.num_reals &gt; max_tag_nums) {</a>
<a name="ln2480">        ts.num_reals = max_tag_nums;</a>
<a name="ln2481">      }</a>
<a name="ln2482"> </a>
<a name="ln2483">      if (ts.num_strings &lt; 0) {</a>
<a name="ln2484">        ts.num_strings = 0;</a>
<a name="ln2485">      }</a>
<a name="ln2486">      if (ts.num_strings &gt; max_tag_nums) {</a>
<a name="ln2487">        ts.num_strings = max_tag_nums;</a>
<a name="ln2488">      }</a>
<a name="ln2489"> </a>
<a name="ln2490">      tag.intValues.resize(static_cast&lt;size_t&gt;(ts.num_ints));</a>
<a name="ln2491"> </a>
<a name="ln2492">      for (size_t i = 0; i &lt; static_cast&lt;size_t&gt;(ts.num_ints); ++i) {</a>
<a name="ln2493">        tag.intValues[i] = parseInt(&amp;token);</a>
<a name="ln2494">      }</a>
<a name="ln2495"> </a>
<a name="ln2496">      tag.floatValues.resize(static_cast&lt;size_t&gt;(ts.num_reals));</a>
<a name="ln2497">      for (size_t i = 0; i &lt; static_cast&lt;size_t&gt;(ts.num_reals); ++i) {</a>
<a name="ln2498">        tag.floatValues[i] = parseReal(&amp;token);</a>
<a name="ln2499">      }</a>
<a name="ln2500"> </a>
<a name="ln2501">      tag.stringValues.resize(static_cast&lt;size_t&gt;(ts.num_strings));</a>
<a name="ln2502">      for (size_t i = 0; i &lt; static_cast&lt;size_t&gt;(ts.num_strings); ++i) {</a>
<a name="ln2503">        tag.stringValues[i] = parseString(&amp;token);</a>
<a name="ln2504">      }</a>
<a name="ln2505"> </a>
<a name="ln2506">      tags.push_back(tag);</a>
<a name="ln2507"> </a>
<a name="ln2508">      continue;</a>
<a name="ln2509">    }</a>
<a name="ln2510"> </a>
<a name="ln2511">    if (token[0] == 's' &amp;&amp; IS_SPACE(token[1])) {</a>
<a name="ln2512">      // smoothing group id</a>
<a name="ln2513">      token += 2;</a>
<a name="ln2514"> </a>
<a name="ln2515">      // skip space.</a>
<a name="ln2516">      token += strspn(token, &quot; \t&quot;);  // skip space</a>
<a name="ln2517"> </a>
<a name="ln2518">      if (token[0] == '\0') {</a>
<a name="ln2519">        continue;</a>
<a name="ln2520">      }</a>
<a name="ln2521"> </a>
<a name="ln2522">      if (token[0] == '\r' || token[1] == '\n') {</a>
<a name="ln2523">        continue;</a>
<a name="ln2524">      }</a>
<a name="ln2525"> </a>
<a name="ln2526">      if (strlen(token) &gt;= 3) {</a>
<a name="ln2527">        if (token[0] == 'o' &amp;&amp; token[1] == 'f' &amp;&amp; token[2] == 'f') {</a>
<a name="ln2528">          current_smoothing_id = 0;</a>
<a name="ln2529">        }</a>
<a name="ln2530">      } else {</a>
<a name="ln2531">        // assume number</a>
<a name="ln2532">        int smGroupId = parseInt(&amp;token);</a>
<a name="ln2533">        if (smGroupId &lt; 0) {</a>
<a name="ln2534">          // parse error. force set to 0.</a>
<a name="ln2535">          // FIXME(syoyo): Report warning.</a>
<a name="ln2536">          current_smoothing_id = 0;</a>
<a name="ln2537">        } else {</a>
<a name="ln2538">          current_smoothing_id = static_cast&lt;unsigned int&gt;(smGroupId);</a>
<a name="ln2539">        }</a>
<a name="ln2540">      }</a>
<a name="ln2541"> </a>
<a name="ln2542">      continue;</a>
<a name="ln2543">    }  // smoothing group id</a>
<a name="ln2544"> </a>
<a name="ln2545">    // Ignore unknown command.</a>
<a name="ln2546">  }</a>
<a name="ln2547"> </a>
<a name="ln2548">  // not all vertices have colors, no default colors desired? -&gt; clear colors</a>
<a name="ln2549">  if (!found_all_colors &amp;&amp; !default_vcols_fallback) {</a>
<a name="ln2550">    vc.clear();</a>
<a name="ln2551">  }</a>
<a name="ln2552"> </a>
<a name="ln2553">  if (greatest_v_idx &gt;= static_cast&lt;int&gt;(v.size() / 3)) {</a>
<a name="ln2554">    if (warn) {</a>
<a name="ln2555">      std::stringstream ss;</a>
<a name="ln2556">      ss &lt;&lt; &quot;Vertex indices out of bounds (line &quot; &lt;&lt; line_num &lt;&lt; &quot;.)\n&quot;</a>
<a name="ln2557">         &lt;&lt; std::endl;</a>
<a name="ln2558">      (*warn) += ss.str();</a>
<a name="ln2559">    }</a>
<a name="ln2560">  }</a>
<a name="ln2561">  if (greatest_vn_idx &gt;= static_cast&lt;int&gt;(vn.size() / 3)) {</a>
<a name="ln2562">    if (warn) {</a>
<a name="ln2563">      std::stringstream ss;</a>
<a name="ln2564">      ss &lt;&lt; &quot;Vertex normal indices out of bounds (line &quot; &lt;&lt; line_num &lt;&lt; &quot;.)\n&quot;</a>
<a name="ln2565">         &lt;&lt; std::endl;</a>
<a name="ln2566">      (*warn) += ss.str();</a>
<a name="ln2567">    }</a>
<a name="ln2568">  }</a>
<a name="ln2569">  if (greatest_vt_idx &gt;= static_cast&lt;int&gt;(vt.size() / 2)) {</a>
<a name="ln2570">    if (warn) {</a>
<a name="ln2571">      std::stringstream ss;</a>
<a name="ln2572">      ss &lt;&lt; &quot;Vertex texcoord indices out of bounds (line &quot; &lt;&lt; line_num &lt;&lt; &quot;.)\n&quot;</a>
<a name="ln2573">         &lt;&lt; std::endl;</a>
<a name="ln2574">      (*warn) += ss.str();</a>
<a name="ln2575">    }</a>
<a name="ln2576">  }</a>
<a name="ln2577"> </a>
<a name="ln2578">  bool ret = exportGroupsToShape(&amp;shape, prim_group, tags, material, name,</a>
<a name="ln2579">                                 triangulate, v);</a>
<a name="ln2580">  // exportGroupsToShape return false when `usemtl` is called in the last</a>
<a name="ln2581">  // line.</a>
<a name="ln2582">  // we also add `shape` to `shapes` when `shape.mesh` has already some</a>
<a name="ln2583">  // faces(indices)</a>
<a name="ln2584">  if (ret || shape.mesh.indices</a>
<a name="ln2585">                 .size()) {  // FIXME(syoyo): Support other prims(e.g. lines)</a>
<a name="ln2586">    shapes-&gt;push_back(shape);</a>
<a name="ln2587">  }</a>
<a name="ln2588">  prim_group.clear();  // for safety</a>
<a name="ln2589"> </a>
<a name="ln2590">  if (err) {</a>
<a name="ln2591">    (*err) += errss.str();</a>
<a name="ln2592">  }</a>
<a name="ln2593"> </a>
<a name="ln2594">  attrib-&gt;vertices.swap(v);</a>
<a name="ln2595">  attrib-&gt;vertex_weights.swap(v);</a>
<a name="ln2596">  attrib-&gt;normals.swap(vn);</a>
<a name="ln2597">  attrib-&gt;texcoords.swap(vt);</a>
<a name="ln2598">  attrib-&gt;texcoord_ws.swap(vt);</a>
<a name="ln2599">  attrib-&gt;colors.swap(vc);</a>
<a name="ln2600"> </a>
<a name="ln2601">  return true;</a>
<a name="ln2602">}</a>
<a name="ln2603"> </a>
<a name="ln2604">bool LoadObjWithCallback(std::istream &amp;inStream, const callback_t &amp;callback,</a>
<a name="ln2605">                         void *user_data /*= NULL*/,</a>
<a name="ln2606">                         MaterialReader *readMatFn /*= NULL*/,</a>
<a name="ln2607">                         std::string *warn, /* = NULL*/</a>
<a name="ln2608">                         std::string *err /*= NULL*/) {</a>
<a name="ln2609">  std::stringstream errss;</a>
<a name="ln2610"> </a>
<a name="ln2611">  // material</a>
<a name="ln2612">  std::map&lt;std::string, int&gt; material_map;</a>
<a name="ln2613">  int material_id = -1;  // -1 = invalid</a>
<a name="ln2614"> </a>
<a name="ln2615">  std::vector&lt;index_t&gt; indices;</a>
<a name="ln2616">  std::vector&lt;material_t&gt; materials;</a>
<a name="ln2617">  std::vector&lt;std::string&gt; names;</a>
<a name="ln2618">  names.reserve(2);</a>
<a name="ln2619">  std::vector&lt;const char *&gt; names_out;</a>
<a name="ln2620"> </a>
<a name="ln2621">  std::string linebuf;</a>
<a name="ln2622">  while (inStream.peek() != -1) {</a>
<a name="ln2623">    safeGetline(inStream, linebuf);</a>
<a name="ln2624"> </a>
<a name="ln2625">    // Trim newline '\r\n' or '\n'</a>
<a name="ln2626">    if (linebuf.size() &gt; 0) {</a>
<a name="ln2627">      if (linebuf[linebuf.size() - 1] == '\n')</a>
<a name="ln2628">        linebuf.erase(linebuf.size() - 1);</a>
<a name="ln2629">    }</a>
<a name="ln2630">    if (linebuf.size() &gt; 0) {</a>
<a name="ln2631">      if (linebuf[linebuf.size() - 1] == '\r')</a>
<a name="ln2632">        linebuf.erase(linebuf.size() - 1);</a>
<a name="ln2633">    }</a>
<a name="ln2634"> </a>
<a name="ln2635">    // Skip if empty line.</a>
<a name="ln2636">    if (linebuf.empty()) {</a>
<a name="ln2637">      continue;</a>
<a name="ln2638">    }</a>
<a name="ln2639"> </a>
<a name="ln2640">    // Skip leading space.</a>
<a name="ln2641">    const char *token = linebuf.c_str();</a>
<a name="ln2642">    token += strspn(token, &quot; \t&quot;);</a>
<a name="ln2643"> </a>
<a name="ln2644">    assert(token);</a>
<a name="ln2645">    if (token[0] == '\0') continue;  // empty line</a>
<a name="ln2646"> </a>
<a name="ln2647">    if (token[0] == '#') continue;  // comment line</a>
<a name="ln2648"> </a>
<a name="ln2649">    // vertex</a>
<a name="ln2650">    if (token[0] == 'v' &amp;&amp; IS_SPACE((token[1]))) {</a>
<a name="ln2651">      token += 2;</a>
<a name="ln2652">      // TODO(syoyo): Support parsing vertex color extension.</a>
<a name="ln2653">      real_t x, y, z, w;  // w is optional. default = 1.0</a>
<a name="ln2654">      parseV(&amp;x, &amp;y, &amp;z, &amp;w, &amp;token);</a>
<a name="ln2655">      if (callback.vertex_cb) {</a>
<a name="ln2656">        callback.vertex_cb(user_data, x, y, z, w);</a>
<a name="ln2657">      }</a>
<a name="ln2658">      continue;</a>
<a name="ln2659">    }</a>
<a name="ln2660"> </a>
<a name="ln2661">    // normal</a>
<a name="ln2662">    if (token[0] == 'v' &amp;&amp; token[1] == 'n' &amp;&amp; IS_SPACE((token[2]))) {</a>
<a name="ln2663">      token += 3;</a>
<a name="ln2664">      real_t x, y, z;</a>
<a name="ln2665">      parseReal3(&amp;x, &amp;y, &amp;z, &amp;token);</a>
<a name="ln2666">      if (callback.normal_cb) {</a>
<a name="ln2667">        callback.normal_cb(user_data, x, y, z);</a>
<a name="ln2668">      }</a>
<a name="ln2669">      continue;</a>
<a name="ln2670">    }</a>
<a name="ln2671"> </a>
<a name="ln2672">    // texcoord</a>
<a name="ln2673">    if (token[0] == 'v' &amp;&amp; token[1] == 't' &amp;&amp; IS_SPACE((token[2]))) {</a>
<a name="ln2674">      token += 3;</a>
<a name="ln2675">      real_t x, y, z;  // y and z are optional. default = 0.0</a>
<a name="ln2676">      parseReal3(&amp;x, &amp;y, &amp;z, &amp;token);</a>
<a name="ln2677">      if (callback.texcoord_cb) {</a>
<a name="ln2678">        callback.texcoord_cb(user_data, x, y, z);</a>
<a name="ln2679">      }</a>
<a name="ln2680">      continue;</a>
<a name="ln2681">    }</a>
<a name="ln2682"> </a>
<a name="ln2683">    // face</a>
<a name="ln2684">    if (token[0] == 'f' &amp;&amp; IS_SPACE((token[1]))) {</a>
<a name="ln2685">      token += 2;</a>
<a name="ln2686">      token += strspn(token, &quot; \t&quot;);</a>
<a name="ln2687"> </a>
<a name="ln2688">      indices.clear();</a>
<a name="ln2689">      while (!IS_NEW_LINE(token[0])) {</a>
<a name="ln2690">        vertex_index_t vi = parseRawTriple(&amp;token);</a>
<a name="ln2691"> </a>
<a name="ln2692">        index_t idx;</a>
<a name="ln2693">        idx.vertex_index = vi.v_idx;</a>
<a name="ln2694">        idx.normal_index = vi.vn_idx;</a>
<a name="ln2695">        idx.texcoord_index = vi.vt_idx;</a>
<a name="ln2696"> </a>
<a name="ln2697">        indices.push_back(idx);</a>
<a name="ln2698">        size_t n = strspn(token, &quot; \t\r&quot;);</a>
<a name="ln2699">        token += n;</a>
<a name="ln2700">      }</a>
<a name="ln2701"> </a>
<a name="ln2702">      if (callback.index_cb &amp;&amp; indices.size() &gt; 0) {</a>
<a name="ln2703">        callback.index_cb(user_data, &amp;indices.at(0),</a>
<a name="ln2704">                          static_cast&lt;int&gt;(indices.size()));</a>
<a name="ln2705">      }</a>
<a name="ln2706"> </a>
<a name="ln2707">      continue;</a>
<a name="ln2708">    }</a>
<a name="ln2709"> </a>
<a name="ln2710">    // use mtl</a>
<a name="ln2711">    if ((0 == strncmp(token, &quot;usemtl&quot;, 6)) &amp;&amp; IS_SPACE((token[6]))) {</a>
<a name="ln2712">      token += 7;</a>
<a name="ln2713">      std::stringstream ss;</a>
<a name="ln2714">      ss &lt;&lt; token;</a>
<a name="ln2715">      std::string namebuf = ss.str();</a>
<a name="ln2716"> </a>
<a name="ln2717">      int newMaterialId = -1;</a>
<a name="ln2718">      if (material_map.find(namebuf) != material_map.end()) {</a>
<a name="ln2719">        newMaterialId = material_map[namebuf];</a>
<a name="ln2720">      } else {</a>
<a name="ln2721">        // { error!! material not found }</a>
<a name="ln2722">      }</a>
<a name="ln2723"> </a>
<a name="ln2724">      if (newMaterialId != material_id) {</a>
<a name="ln2725">        material_id = newMaterialId;</a>
<a name="ln2726">      }</a>
<a name="ln2727"> </a>
<a name="ln2728">      if (callback.usemtl_cb) {</a>
<a name="ln2729">        callback.usemtl_cb(user_data, namebuf.c_str(), material_id);</a>
<a name="ln2730">      }</a>
<a name="ln2731"> </a>
<a name="ln2732">      continue;</a>
<a name="ln2733">    }</a>
<a name="ln2734"> </a>
<a name="ln2735">    // load mtl</a>
<a name="ln2736">    if ((0 == strncmp(token, &quot;mtllib&quot;, 6)) &amp;&amp; IS_SPACE((token[6]))) {</a>
<a name="ln2737">      if (readMatFn) {</a>
<a name="ln2738">        token += 7;</a>
<a name="ln2739"> </a>
<a name="ln2740">        std::vector&lt;std::string&gt; filenames;</a>
<a name="ln2741">        SplitString(std::string(token), ' ', filenames);</a>
<a name="ln2742"> </a>
<a name="ln2743">        if (filenames.empty()) {</a>
<a name="ln2744">          if (warn) {</a>
<a name="ln2745">            (*warn) +=</a>
<a name="ln2746">                &quot;Looks like empty filename for mtllib. Use default &quot;</a>
<a name="ln2747">                &quot;material. \n&quot;;</a>
<a name="ln2748">          }</a>
<a name="ln2749">        } else {</a>
<a name="ln2750">          bool found = false;</a>
<a name="ln2751">          for (size_t s = 0; s &lt; filenames.size(); s++) {</a>
<a name="ln2752">            std::string warn_mtl;</a>
<a name="ln2753">            std::string err_mtl;</a>
<a name="ln2754">            bool ok = (*readMatFn)(filenames[s].c_str(), &amp;materials,</a>
<a name="ln2755">                                   &amp;material_map, &amp;warn_mtl, &amp;err_mtl);</a>
<a name="ln2756"> </a>
<a name="ln2757">            if (warn &amp;&amp; (!warn_mtl.empty())) {</a>
<a name="ln2758">              (*warn) += warn_mtl;  // This should be warn message.</a>
<a name="ln2759">            }</a>
<a name="ln2760"> </a>
<a name="ln2761">            if (err &amp;&amp; (!err_mtl.empty())) {</a>
<a name="ln2762">              (*err) += err_mtl;</a>
<a name="ln2763">            }</a>
<a name="ln2764"> </a>
<a name="ln2765">            if (ok) {</a>
<a name="ln2766">              found = true;</a>
<a name="ln2767">              break;</a>
<a name="ln2768">            }</a>
<a name="ln2769">          }</a>
<a name="ln2770"> </a>
<a name="ln2771">          if (!found) {</a>
<a name="ln2772">            if (warn) {</a>
<a name="ln2773">              (*warn) +=</a>
<a name="ln2774">                  &quot;Failed to load material file(s). Use default &quot;</a>
<a name="ln2775">                  &quot;material.\n&quot;;</a>
<a name="ln2776">            }</a>
<a name="ln2777">          } else {</a>
<a name="ln2778">            if (callback.mtllib_cb) {</a>
<a name="ln2779">              callback.mtllib_cb(user_data, &amp;materials.at(0),</a>
<a name="ln2780">                                 static_cast&lt;int&gt;(materials.size()));</a>
<a name="ln2781">            }</a>
<a name="ln2782">          }</a>
<a name="ln2783">        }</a>
<a name="ln2784">      }</a>
<a name="ln2785"> </a>
<a name="ln2786">      continue;</a>
<a name="ln2787">    }</a>
<a name="ln2788"> </a>
<a name="ln2789">    // group name</a>
<a name="ln2790">    if (token[0] == 'g' &amp;&amp; IS_SPACE((token[1]))) {</a>
<a name="ln2791">      names.clear();</a>
<a name="ln2792"> </a>
<a name="ln2793">      while (!IS_NEW_LINE(token[0])) {</a>
<a name="ln2794">        std::string str = parseString(&amp;token);</a>
<a name="ln2795">        names.push_back(str);</a>
<a name="ln2796">        token += strspn(token, &quot; \t\r&quot;);  // skip tag</a>
<a name="ln2797">      }</a>
<a name="ln2798"> </a>
<a name="ln2799">      assert(names.size() &gt; 0);</a>
<a name="ln2800"> </a>
<a name="ln2801">      if (callback.group_cb) {</a>
<a name="ln2802">        if (names.size() &gt; 1) {</a>
<a name="ln2803">          // create const char* array.</a>
<a name="ln2804">          names_out.resize(names.size() - 1);</a>
<a name="ln2805">          for (size_t j = 0; j &lt; names_out.size(); j++) {</a>
<a name="ln2806">            names_out[j] = names[j + 1].c_str();</a>
<a name="ln2807">          }</a>
<a name="ln2808">          callback.group_cb(user_data, &amp;names_out.at(0),</a>
<a name="ln2809">                            static_cast&lt;int&gt;(names_out.size()));</a>
<a name="ln2810"> </a>
<a name="ln2811">        } else {</a>
<a name="ln2812">          callback.group_cb(user_data, NULL, 0);</a>
<a name="ln2813">        }</a>
<a name="ln2814">      }</a>
<a name="ln2815"> </a>
<a name="ln2816">      continue;</a>
<a name="ln2817">    }</a>
<a name="ln2818"> </a>
<a name="ln2819">    // object name</a>
<a name="ln2820">    if (token[0] == 'o' &amp;&amp; IS_SPACE((token[1]))) {</a>
<a name="ln2821">      // @todo { multiple object name? }</a>
<a name="ln2822">      token += 2;</a>
<a name="ln2823"> </a>
<a name="ln2824">      std::stringstream ss;</a>
<a name="ln2825">      ss &lt;&lt; token;</a>
<a name="ln2826">      std::string object_name = ss.str();</a>
<a name="ln2827"> </a>
<a name="ln2828">      if (callback.object_cb) {</a>
<a name="ln2829">        callback.object_cb(user_data, object_name.c_str());</a>
<a name="ln2830">      }</a>
<a name="ln2831"> </a>
<a name="ln2832">      continue;</a>
<a name="ln2833">    }</a>
<a name="ln2834"> </a>
<a name="ln2835">#if 0  // @todo</a>
<a name="ln2836">    if (token[0] == 't' &amp;&amp; IS_SPACE(token[1])) {</a>
<a name="ln2837">      tag_t tag;</a>
<a name="ln2838"> </a>
<a name="ln2839">      token += 2;</a>
<a name="ln2840">      std::stringstream ss;</a>
<a name="ln2841">      ss &lt;&lt; token;</a>
<a name="ln2842">      tag.name = ss.str();</a>
<a name="ln2843"> </a>
<a name="ln2844">      token += tag.name.size() + 1;</a>
<a name="ln2845"> </a>
<a name="ln2846">      tag_sizes ts = parseTagTriple(&amp;token);</a>
<a name="ln2847"> </a>
<a name="ln2848">      tag.intValues.resize(static_cast&lt;size_t&gt;(ts.num_ints));</a>
<a name="ln2849"> </a>
<a name="ln2850">      for (size_t i = 0; i &lt; static_cast&lt;size_t&gt;(ts.num_ints); ++i) {</a>
<a name="ln2851">        tag.intValues[i] = atoi(token);</a>
<a name="ln2852">        token += strcspn(token, &quot;/ \t\r&quot;) + 1;</a>
<a name="ln2853">      }</a>
<a name="ln2854"> </a>
<a name="ln2855">      tag.floatValues.resize(static_cast&lt;size_t&gt;(ts.num_reals));</a>
<a name="ln2856">      for (size_t i = 0; i &lt; static_cast&lt;size_t&gt;(ts.num_reals); ++i) {</a>
<a name="ln2857">        tag.floatValues[i] = parseReal(&amp;token);</a>
<a name="ln2858">        token += strcspn(token, &quot;/ \t\r&quot;) + 1;</a>
<a name="ln2859">      }</a>
<a name="ln2860"> </a>
<a name="ln2861">      tag.stringValues.resize(static_cast&lt;size_t&gt;(ts.num_strings));</a>
<a name="ln2862">      for (size_t i = 0; i &lt; static_cast&lt;size_t&gt;(ts.num_strings); ++i) {</a>
<a name="ln2863">        std::stringstream ss;</a>
<a name="ln2864">        ss &lt;&lt; token;</a>
<a name="ln2865">        tag.stringValues[i] = ss.str();</a>
<a name="ln2866">        token += tag.stringValues[i].size() + 1;</a>
<a name="ln2867">      }</a>
<a name="ln2868"> </a>
<a name="ln2869">      tags.push_back(tag);</a>
<a name="ln2870">    }</a>
<a name="ln2871">#endif</a>
<a name="ln2872"> </a>
<a name="ln2873">    // Ignore unknown command.</a>
<a name="ln2874">  }</a>
<a name="ln2875"> </a>
<a name="ln2876">  if (err) {</a>
<a name="ln2877">    (*err) += errss.str();</a>
<a name="ln2878">  }</a>
<a name="ln2879"> </a>
<a name="ln2880">  return true;</a>
<a name="ln2881">}</a>
<a name="ln2882"> </a>
<a name="ln2883">bool ObjReader::ParseFromFile(const std::string &amp;filename,</a>
<a name="ln2884">                              const ObjReaderConfig &amp;config) {</a>
<a name="ln2885">  std::string mtl_search_path;</a>
<a name="ln2886"> </a>
<a name="ln2887">  if (config.mtl_search_path.empty()) {</a>
<a name="ln2888">    //</a>
<a name="ln2889">    // split at last '/'(for unixish system) or '\\'(for windows) to get</a>
<a name="ln2890">    // the base directory of .obj file</a>
<a name="ln2891">    //</a>
<a name="ln2892">    if (filename.find_last_of(&quot;/\\&quot;) != std::string::npos) {</a>
<a name="ln2893">      mtl_search_path = filename.substr(0, filename.find_last_of(&quot;/\\&quot;));</a>
<a name="ln2894">    }</a>
<a name="ln2895">  }</a>
<a name="ln2896"> </a>
<a name="ln2897">  valid_ = LoadObj(&amp;attrib_, &amp;shapes_, &amp;materials_, &amp;warning_, &amp;error_,</a>
<a name="ln2898">                   filename.c_str(), mtl_search_path.c_str(),</a>
<a name="ln2899">                   config.triangulate, config.vertex_color);</a>
<a name="ln2900"> </a>
<a name="ln2901">  return valid_;</a>
<a name="ln2902">}</a>
<a name="ln2903"> </a>
<a name="ln2904">bool ObjReader::ParseFromString(const std::string &amp;obj_text,</a>
<a name="ln2905">                                const std::string &amp;mtl_text,</a>
<a name="ln2906">                                const ObjReaderConfig &amp;config) {</a>
<a name="ln2907">  std::stringbuf obj_buf(obj_text);</a>
<a name="ln2908">  std::stringbuf mtl_buf(mtl_text);</a>
<a name="ln2909"> </a>
<a name="ln2910">  std::istream obj_ifs(&amp;obj_buf);</a>
<a name="ln2911">  std::istream mtl_ifs(&amp;mtl_buf);</a>
<a name="ln2912"> </a>
<a name="ln2913">  MaterialStreamReader mtl_ss(mtl_ifs);</a>
<a name="ln2914"> </a>
<a name="ln2915">  valid_ = LoadObj(&amp;attrib_, &amp;shapes_, &amp;materials_, &amp;warning_, &amp;error_,</a>
<a name="ln2916">                   &amp;obj_ifs, &amp;mtl_ss, config.triangulate, config.vertex_color);</a>
<a name="ln2917"> </a>
<a name="ln2918">  return valid_;</a>
<a name="ln2919">}</a>
<a name="ln2920"> </a>
<a name="ln2921">#ifdef __clang__</a>
<a name="ln2922">#pragma clang diagnostic pop</a>
<a name="ln2923">#endif</a>
<a name="ln2924">}  // namespace tinyobj</a>
<a name="ln2925"> </a>
<a name="ln2926">#endif</a>

</code></pre>
<div class="balloon" rel="753"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'idx < 0' is always true.</p></div>
<div class="balloon" rel="864"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v581/" target="_blank">V581</a> The conditional expressions of the 'if' statements situated alongside each other are identical. Check lines: 853, 864.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
