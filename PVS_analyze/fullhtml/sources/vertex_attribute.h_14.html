
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>vertex_attribute.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">Corto</a>
<a name="ln3"> </a>
<a name="ln4">Copyright(C) 2017 - Federico Ponchio</a>
<a name="ln5">ISTI - Italian National Research Council - Visual Computing Lab</a>
<a name="ln6"> </a>
<a name="ln7">This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">it under the terms of the GNU Lesser General Public License as published by</a>
<a name="ln9">the Free Software Foundation; either version 3 of the License, or</a>
<a name="ln10">(at your option) any later version.</a>
<a name="ln11"> </a>
<a name="ln12">This program is distributed in the hope that it will be useful,</a>
<a name="ln13">but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  You should have received </a>
<a name="ln15">a copy of the GNU General Public License along with Corto.</a>
<a name="ln16">If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#ifndef CRT_VERTEX_ATTRIBUTE_H</a>
<a name="ln20">#define CRT_VERTEX_ATTRIBUTE_H</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;map&gt;</a>
<a name="ln23">#include &lt;string&gt;</a>
<a name="ln24"> #include &lt;algorithm&gt;</a>
<a name="ln25">#include &quot;cstream.h&quot;</a>
<a name="ln26">#include &quot;index_attribute.h&quot;</a>
<a name="ln27"> </a>
<a name="ln28">#ifdef WIN32</a>
<a name="ln29">#undef min</a>
<a name="ln30">#undef max</a>
<a name="ln31">#endif</a>
<a name="ln32"> </a>
<a name="ln33">namespace crt {</a>
<a name="ln34"> </a>
<a name="ln35">class VertexAttribute {</a>
<a name="ln36">public:</a>
<a name="ln37">	enum Format { UINT32 = 0, INT32, UINT16, INT16, UINT8, INT8, FLOAT, DOUBLE };</a>
<a name="ln38">	enum Strategy { PARALLEL = 0x1, CORRELATED = 0x2 };</a>
<a name="ln39">	enum CODEC { GENERIC_CODEC = 1, NORMAL_CODEC = 2, COLOR_CODEC = 3, CUSTOM_CODEC = 100 };</a>
<a name="ln40"> </a>
<a name="ln41">	char *buffer;     //output data buffer, input is not needed</a>
<a name="ln42">	int N;            //number of components</a>
<a name="ln43">	float q;          //quantization step</a>
<a name="ln44">	int strategy;</a>
<a name="ln45"> </a>
<a name="ln46">	Format format;    //input or output format</a>
<a name="ln47">	uint32_t size;    //compressed size (for stats and other nefarious purpouses)</a>
<a name="ln48">	int bits;    //quantization in bits;</a>
<a name="ln49"> </a>
<a name="ln50">	VertexAttribute(): buffer(nullptr), N(0), q(0.0f), strategy(0), format(INT32), size(0) {}</a>
<a name="ln51">	virtual ~VertexAttribute(){}</a>
<a name="ln52"> </a>
<a name="ln53">	virtual int codec() = 0; //identifies attribute class.</a>
<a name="ln54"> </a>
<a name="ln55">	//quantize and store as values</a>
<a name="ln56">	virtual void quantize(uint32_t nvert, const char *buffer) = 0;</a>
<a name="ln57">	//used by attributes which leverage other attributes (normals, for example)</a>
<a name="ln58">	virtual void preDelta(uint32_t /*nvert*/, uint32_t /*nface*/, std::map&lt;std::string, VertexAttribute *&gt; &amp;/*attrs*/, IndexAttribute &amp;/*index*/) {}</a>
<a name="ln59">	//use parallelogram prediction or just diff from v0</a>
<a name="ln60">	virtual void deltaEncode(std::vector&lt;Quad&gt; &amp;context) = 0;</a>
<a name="ln61">	//compress diffs and write to stream</a>
<a name="ln62">	virtual void encode(uint32_t nvert, OutStream &amp;stream) = 0;</a>
<a name="ln63"> </a>
<a name="ln64">	//read quantized data from streams</a>
<a name="ln65">	virtual void decode(uint32_t nvert, InStream &amp;stream) = 0;</a>
<a name="ln66">	//use parallelogram prediction to recover values</a>
<a name="ln67">	virtual void deltaDecode(uint32_t nvert, std::vector&lt;Face&gt; &amp;faces) = 0;</a>
<a name="ln68">	//use other attributes to estimate (normals for example)</a>
<a name="ln69">	virtual void postDelta(uint32_t /*nvert*/, uint32_t /*nface*/, std::map&lt;std::string, VertexAttribute *&gt; &amp;/*attrs*/, IndexAttribute &amp;/*index*/) {}</a>
<a name="ln70">	//reverse quantization operations</a>
<a name="ln71">	virtual void dequantize(uint32_t nvert) = 0;</a>
<a name="ln72">};</a>
<a name="ln73"> </a>
<a name="ln74"> </a>
<a name="ln75">//T should be int, short or char (for colors for example)</a>
<a name="ln76">template &lt;class T&gt; class GenericAttr: public VertexAttribute {</a>
<a name="ln77">public:</a>
<a name="ln78">	std::vector&lt;T&gt; values, diffs;</a>
<a name="ln79"> </a>
<a name="ln80">	GenericAttr(int dim) { N = dim; }</a>
<a name="ln81">	virtual ~GenericAttr(){}</a>
<a name="ln82">	virtual int codec() { return GENERIC_CODEC; }</a>
<a name="ln83"> </a>
<a name="ln84">	virtual void quantize(uint32_t nvert, const char *buffer) {</a>
<a name="ln85">		uint32_t n = N*nvert;</a>
<a name="ln86"> </a>
<a name="ln87">		values.resize(n);</a>
<a name="ln88">		diffs.resize(n);</a>
<a name="ln89">		switch(format) {</a>
<a name="ln90">		case INT32:</a>
<a name="ln91">			for(uint32_t i = 0; i &lt; n; i++)</a>
<a name="ln92">				values[i] = ((const int32_t *)buffer)[i]/q;</a>
<a name="ln93">			break;</a>
<a name="ln94">		case INT16:</a>
<a name="ln95">			for(uint32_t i = 0; i &lt; n; i++)</a>
<a name="ln96">				values[i] = ((const int16_t *)buffer)[i]/q;</a>
<a name="ln97">			break;</a>
<a name="ln98">		case INT8:</a>
<a name="ln99">			for(uint32_t i = 0; i &lt; n; i++)</a>
<a name="ln100">				values[i] = ((const int16_t *)buffer)[i]/q;</a>
<a name="ln101">			break;</a>
<a name="ln102">		case FLOAT:</a>
<a name="ln103">			for(uint32_t i = 0; i &lt; n; i++)</a>
<a name="ln104">				values[i] = ((const float *)buffer)[i]/q;</a>
<a name="ln105">			break;</a>
<a name="ln106">		case DOUBLE:</a>
<a name="ln107">			for(uint32_t i = 0; i &lt; n; i++)</a>
<a name="ln108">				values[i] = ((const double *)buffer)[i]/q;</a>
<a name="ln109">			break;</a>
<a name="ln110">		default: throw &quot;Unsupported format.&quot;;</a>
<a name="ln111">		}</a>
<a name="ln112">		bits = 0;</a>
<a name="ln113">		for(int k = 0; k &lt; N; k++) {</a>
<a name="ln114">			int min = values[k];</a>
<a name="ln115">			int max = min;</a>
<a name="ln116">			for(uint32_t i = k; i &lt; n; i +=N) {</a>
<a name="ln117">				if(min &gt; values[i]) min = values[i];</a>
<a name="ln118">				if(max &lt; values[i]) max = values[i];</a>
<a name="ln119">			}</a>
<a name="ln120">			max -= min;</a>
<a name="ln121">			bits = std::max(bits, ilog2(max-1) + 1);</a>
<a name="ln122">//			cout &lt;&lt; &quot;max: &quot; &lt;&lt; max &lt;&lt; &quot; &quot; &lt;&lt; &quot; bits: &quot; &lt;&lt; bits &lt;&lt; endl;</a>
<a name="ln123"> </a>
<a name="ln124">		}</a>
<a name="ln125">	}</a>
<a name="ln126"> </a>
<a name="ln127">	virtual void deltaEncode(std::vector&lt;Quad&gt; &amp;context) {</a>
<a name="ln128">		for(int c = 0; c &lt; N; c++)</a>
<a name="ln129">			diffs[c] = values[context[0].t*N + c];</a>
<a name="ln130">		for(uint32_t i = 1; i &lt; context.size(); i++) {</a>
<a name="ln131">			Quad &amp;q = context[i];</a>
<a name="ln132">			if(q.a != q.b &amp;&amp; (strategy &amp; PARALLEL)) {</a>
<a name="ln133">				for(int c = 0; c &lt; N; c++)</a>
<a name="ln134">					diffs[i*N + c] = values[q.t*N + c] - (values[q.a*N + c] + values[q.b*N + c] - values[q.c*N + c]);</a>
<a name="ln135">			} else {</a>
<a name="ln136">				for(int c = 0; c &lt; N; c++)</a>
<a name="ln137">					diffs[i*N + c] = values[q.t*N + c] - values[q.a*N + c];</a>
<a name="ln138">			}</a>
<a name="ln139">		}</a>
<a name="ln140">		diffs.resize(context.size()*N); //unreferenced vertices</a>
<a name="ln141">	}</a>
<a name="ln142"> </a>
<a name="ln143">	virtual void encode(uint32_t nvert, OutStream &amp;stream) {</a>
<a name="ln144">		stream.restart();</a>
<a name="ln145">		if(strategy &amp; CORRELATED)</a>
<a name="ln146">			stream.encodeArray&lt;T&gt;(nvert, diffs.data(), N);</a>
<a name="ln147">		else</a>
<a name="ln148">			stream.encodeValues&lt;T&gt;(nvert, diffs.data(), N);</a>
<a name="ln149"> </a>
<a name="ln150">		size = stream.elapsed();</a>
<a name="ln151">	}</a>
<a name="ln152"> </a>
<a name="ln153">	virtual void decode(uint32_t /*nvert */, InStream &amp;stream) {</a>
<a name="ln154">		if(strategy &amp; CORRELATED)</a>
<a name="ln155">			stream.decodeArray&lt;T&gt;((T *)buffer, N);</a>
<a name="ln156">		else</a>
<a name="ln157">			stream.decodeValues&lt;T&gt;((T *)buffer, N);</a>
<a name="ln158">	}</a>
<a name="ln159"> </a>
<a name="ln160">	virtual void deltaDecode(uint32_t nvert, std::vector&lt;Face&gt; &amp;context) {</a>
<a name="ln161">		if(!buffer) return;</a>
<a name="ln162"> </a>
<a name="ln163">		T *values = (T *)buffer;</a>
<a name="ln164"> </a>
<a name="ln165">		if(strategy &amp; PARALLEL) { //parallelogram prediction</a>
<a name="ln166">			for(uint32_t i = 1; i &lt; context.size(); i++) {</a>
<a name="ln167">				Face &amp;f = context[i];</a>
<a name="ln168">				for(int c = 0; c &lt; N; c++)</a>
<a name="ln169">					values[i*N + c] += values[f.a*N + c] + values[f.b*N + c] - values[f.c*N + c];</a>
<a name="ln170">			}</a>
<a name="ln171">		} else if(context.size()) {  //mesh but not parallelogram prediction</a>
<a name="ln172">			for(uint32_t i = 1; i &lt; context.size(); i++) {</a>
<a name="ln173">				Face &amp;f = context[i];</a>
<a name="ln174">				for(int c = 0; c &lt; N; c++)</a>
<a name="ln175">					values[i*N + c] += values[f.a*N + c];</a>
<a name="ln176">			}</a>
<a name="ln177">		} else {       //point clouds assuming values are already sorted by proximity.</a>
<a name="ln178">			for(uint32_t i = N; i &lt; nvert*N; i++) {</a>
<a name="ln179">				values[i] += values[i - N];</a>
<a name="ln180">			}</a>
<a name="ln181">		}</a>
<a name="ln182">	}</a>
<a name="ln183"> </a>
<a name="ln184">	virtual void dequantize(uint32_t nvert) {</a>
<a name="ln185">		if(!buffer) return;</a>
<a name="ln186"> </a>
<a name="ln187">		T *coords = (T *)buffer;</a>
<a name="ln188">		uint32_t n = N*nvert;</a>
<a name="ln189">		switch(format) {</a>
<a name="ln190">		case FLOAT:</a>
<a name="ln191">			for(uint32_t i = 0; i &lt; n; i++)</a>
<a name="ln192">				((float *)buffer)[i] = coords[i]*q;</a>
<a name="ln193">			break;</a>
<a name="ln194"> </a>
<a name="ln195">		case INT16:</a>
<a name="ln196">			for(uint32_t i = 0; i &lt; n; i++)</a>
<a name="ln197">				((uint16_t *)buffer)[i] *= q;</a>
<a name="ln198">			break;</a>
<a name="ln199"> </a>
<a name="ln200">		case INT32:</a>
<a name="ln201">			for(uint32_t i = 0; i &lt; n; i++)</a>
<a name="ln202">				((uint32_t *)buffer)[i] *= q;</a>
<a name="ln203">			break;</a>
<a name="ln204"> </a>
<a name="ln205">		case INT8:</a>
<a name="ln206">			for(uint32_t i = 0; i &lt; n; i++)</a>
<a name="ln207">				((char *)buffer)[i] *= q;</a>
<a name="ln208">			break;</a>
<a name="ln209"> </a>
<a name="ln210">		case DOUBLE:</a>
<a name="ln211">			for(uint32_t i = 0; i &lt; n; i++)</a>
<a name="ln212">				((double *)buffer)[i] = coords[i]*q;</a>
<a name="ln213">			break;</a>
<a name="ln214"> </a>
<a name="ln215">		case UINT16:</a>
<a name="ln216">			for(uint32_t i = 0; i &lt; n; i++)</a>
<a name="ln217">				((uint16_t *)buffer)[i] *= q;</a>
<a name="ln218">			break;</a>
<a name="ln219"> </a>
<a name="ln220">		case UINT32:</a>
<a name="ln221">			for(uint32_t i = 0; i &lt; n; i++)</a>
<a name="ln222">				((uint32_t *)buffer)[i] *= q;</a>
<a name="ln223">			break;</a>
<a name="ln224"> </a>
<a name="ln225">		case UINT8:</a>
<a name="ln226">			for(uint32_t i = 0; i &lt; n; i++)</a>
<a name="ln227">				((char *)buffer)[i] *= q;</a>
<a name="ln228">			break;</a>
<a name="ln229">		}</a>
<a name="ln230">	}</a>
<a name="ln231">};</a>
<a name="ln232"> </a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">#endif // CRT_VERTEX_ATTRIBUTE_H</a>

</code></pre>
<div class="balloon" rel="50"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: bits.</p></div>
<div class="balloon" rel="206"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 206, 226</p></div>
<div class="balloon" rel="201"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 201, 221</p></div>
<div class="balloon" rel="196"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 196, 216</p></div>
<div class="balloon" rel="95"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 95, 99</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
