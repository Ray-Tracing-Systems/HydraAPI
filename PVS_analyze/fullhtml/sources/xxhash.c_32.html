
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>xxhash.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">xxHash - Fast Hash algorithm</a>
<a name="ln3">Copyright (C) 2012-2015, Yann Collet</a>
<a name="ln4"> </a>
<a name="ln5">BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)</a>
<a name="ln6"> </a>
<a name="ln7">Redistribution and use in source and binary forms, with or without</a>
<a name="ln8">modification, are permitted provided that the following conditions are</a>
<a name="ln9">met:</a>
<a name="ln10"> </a>
<a name="ln11">* Redistributions of source code must retain the above copyright</a>
<a name="ln12">notice, this list of conditions and the following disclaimer.</a>
<a name="ln13">* Redistributions in binary form must reproduce the above</a>
<a name="ln14">copyright notice, this list of conditions and the following disclaimer</a>
<a name="ln15">in the documentation and/or other materials provided with the</a>
<a name="ln16">distribution.</a>
<a name="ln17"> </a>
<a name="ln18">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</a>
<a name="ln19">&quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</a>
<a name="ln20">LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</a>
<a name="ln21">A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</a>
<a name="ln22">OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</a>
<a name="ln23">SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</a>
<a name="ln24">LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</a>
<a name="ln25">DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</a>
<a name="ln26">THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</a>
<a name="ln27">(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</a>
<a name="ln28">OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln29"> </a>
<a name="ln30">You can contact the author at :</a>
<a name="ln31">- xxHash source repository : https://github.com/Cyan4973/xxHash</a>
<a name="ln32">*/</a>
<a name="ln33"> </a>
<a name="ln34"> </a>
<a name="ln35">/**************************************</a>
<a name="ln36">*  Tuning parameters</a>
<a name="ln37">**************************************/</a>
<a name="ln38">/* Unaligned memory access is automatically enabled for &quot;common&quot; CPU, such as x86.</a>
<a name="ln39"> * For others CPU, the compiler will be more cautious, and AppendToTheEnd extra code to ensure aligned access is respected.</a>
<a name="ln40"> * If you know your target CPU supports unaligned memory access, you want to force this option manually to improve performance.</a>
<a name="ln41"> * You can also enable this parameter if you know your input data will always be aligned (boundaries of 4, for U32).</a>
<a name="ln42"> */</a>
<a name="ln43">#if defined(__ARM_FEATURE_UNALIGNED) || defined(__i386) || defined(_M_IX86) || defined(__x86_64__) || defined(_M_X64)</a>
<a name="ln44">#  define XXH_USE_UNALIGNED_ACCESS 1</a>
<a name="ln45">#endif</a>
<a name="ln46"> </a>
<a name="ln47">/* XXH_ACCEPT_NULL_INPUT_POINTER :</a>
<a name="ln48"> * If the input pointer is a null pointer, xxHash default behavior is to trigger a memory access error, since it is a bad pointer.</a>
<a name="ln49"> * When this option is enabled, xxHash output for null input pointers will be the same as a null-length input.</a>
<a name="ln50"> * By default, this option is disabled. To enable it, uncomment below define :</a>
<a name="ln51"> */</a>
<a name="ln52">/* #define XXH_ACCEPT_NULL_INPUT_POINTER 1 */</a>
<a name="ln53"> </a>
<a name="ln54">/* XXH_FORCE_NATIVE_FORMAT :</a>
<a name="ln55"> * By default, xxHash library provides endian-independant Hash values, based on little-endian convention.</a>
<a name="ln56"> * Results are therefore identical for little-endian and big-endian CPU.</a>
<a name="ln57"> * This comes at a performance cost for big-endian CPU, since some swapping is required to emulate little-endian format.</a>
<a name="ln58"> * Should endian-independance be of no importance for your application, you may set the #define below to 1.</a>
<a name="ln59"> * It will improve speed for Big-endian CPU.</a>
<a name="ln60"> * This option has no impact on Little_Endian CPU.</a>
<a name="ln61"> */</a>
<a name="ln62">#define XXH_FORCE_NATIVE_FORMAT 0</a>
<a name="ln63"> </a>
<a name="ln64"> </a>
<a name="ln65">/**************************************</a>
<a name="ln66">*  Compiler Specific Options</a>
<a name="ln67">***************************************/</a>
<a name="ln68">#ifdef WIN32    /* Visual Studio */</a>
<a name="ln69">#  pragma warning(disable : 4127)      /* disable: C4127: conditional expression is constant */</a>
<a name="ln70">#  define FORCE_INLINE static __forceinline</a>
<a name="ln71">#else</a>
<a name="ln72">#  if defined (__STDC_VERSION__) &amp;&amp; __STDC_VERSION__ &gt;= 199901L   /* C99 */</a>
<a name="ln73">#    ifdef __GNUC__</a>
<a name="ln74">#      define FORCE_INLINE static inline __attribute__((always_inline))</a>
<a name="ln75">#    else</a>
<a name="ln76">#      define FORCE_INLINE static inline</a>
<a name="ln77">#    endif</a>
<a name="ln78">#  else</a>
<a name="ln79">#    define FORCE_INLINE static</a>
<a name="ln80">#  endif /* __STDC_VERSION__ */</a>
<a name="ln81">#endif</a>
<a name="ln82"> </a>
<a name="ln83"> </a>
<a name="ln84">/**************************************</a>
<a name="ln85">*  Includes &amp; Memory related functions</a>
<a name="ln86">***************************************/</a>
<a name="ln87">#include &quot;xxhash.h&quot;</a>
<a name="ln88">/* Modify the local functions below should you wish to use some other memory routines */</a>
<a name="ln89">/* for malloc(), free() */</a>
<a name="ln90">#include &lt;stdlib.h&gt;</a>
<a name="ln91">static void* XXH_malloc(size_t s) { return malloc(s); }</a>
<a name="ln92">static void  XXH_free  (void* p)  { free(p); }</a>
<a name="ln93">/* for memcpy() */</a>
<a name="ln94">#include &lt;string.h&gt;</a>
<a name="ln95">static void* XXH_memcpy(void* dest, const void* src, size_t size) { return memcpy(dest,src,size); }</a>
<a name="ln96"> </a>
<a name="ln97"> </a>
<a name="ln98">/**************************************</a>
<a name="ln99">*  Basic Types</a>
<a name="ln100">***************************************/</a>
<a name="ln101">#if defined (__STDC_VERSION__) &amp;&amp; __STDC_VERSION__ &gt;= 199901L   /* C99 */</a>
<a name="ln102"># include &lt;stdint.h&gt;</a>
<a name="ln103">  typedef uint8_t  BYTE;</a>
<a name="ln104">  typedef uint16_t U16;</a>
<a name="ln105">  typedef uint32_t U32;</a>
<a name="ln106">  typedef  int32_t S32;</a>
<a name="ln107">  typedef uint64_t U64;</a>
<a name="ln108">#else</a>
<a name="ln109">  typedef unsigned char      BYTE;</a>
<a name="ln110">  typedef unsigned short     U16;</a>
<a name="ln111">  typedef unsigned int       U32;</a>
<a name="ln112">  typedef   signed int       S32;</a>
<a name="ln113">  typedef unsigned long long U64;</a>
<a name="ln114">#endif</a>
<a name="ln115"> </a>
<a name="ln116">static U32 XXH_read32(const void* memPtr)</a>
<a name="ln117">{</a>
<a name="ln118">    U32 val32;</a>
<a name="ln119">    memcpy(&amp;val32, memPtr, 4);</a>
<a name="ln120">    return val32;</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123">static U64 XXH_read64(const void* memPtr)</a>
<a name="ln124">{</a>
<a name="ln125">    U64 val64;</a>
<a name="ln126">    memcpy(&amp;val64, memPtr, 8);</a>
<a name="ln127">    return val64;</a>
<a name="ln128">}</a>
<a name="ln129"> </a>
<a name="ln130"> </a>
<a name="ln131"> </a>
<a name="ln132">/******************************************</a>
<a name="ln133">*  Compiler-specific Functions and Macros</a>
<a name="ln134">******************************************/</a>
<a name="ln135">#define GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)</a>
<a name="ln136"> </a>
<a name="ln137">/* Note : although _rotl exists for minGW (GCC under windows), performance seems poor */</a>
<a name="ln138">#if defined(WIN32)</a>
<a name="ln139">#  define XXH_rotl32(x,r) _rotl(x,r)</a>
<a name="ln140">#  define XXH_rotl64(x,r) _rotl64(x,r)</a>
<a name="ln141">#else</a>
<a name="ln142">#  define XXH_rotl32(x,r) ((x &lt;&lt; r) | (x &gt;&gt; (32 - r)))</a>
<a name="ln143">#  define XXH_rotl64(x,r) ((x &lt;&lt; r) | (x &gt;&gt; (64 - r)))</a>
<a name="ln144">#endif</a>
<a name="ln145"> </a>
<a name="ln146">#if defined(WIN32)     /* Visual Studio */</a>
<a name="ln147">#  define XXH_swap32 _byteswap_ulong</a>
<a name="ln148">#  define XXH_swap64 _byteswap_uint64</a>
<a name="ln149">#elif GCC_VERSION &gt;= 403</a>
<a name="ln150">#  define XXH_swap32 __builtin_bswap32</a>
<a name="ln151">#  define XXH_swap64 __builtin_bswap64</a>
<a name="ln152">#else</a>
<a name="ln153">static U32 XXH_swap32 (U32 x)</a>
<a name="ln154">{</a>
<a name="ln155">    return  ((x &lt;&lt; 24) &amp; 0xff000000 ) |</a>
<a name="ln156">            ((x &lt;&lt;  8) &amp; 0x00ff0000 ) |</a>
<a name="ln157">            ((x &gt;&gt;  8) &amp; 0x0000ff00 ) |</a>
<a name="ln158">            ((x &gt;&gt; 24) &amp; 0x000000ff );</a>
<a name="ln159">}</a>
<a name="ln160">static U64 XXH_swap64 (U64 x)</a>
<a name="ln161">{</a>
<a name="ln162">    return  ((x &lt;&lt; 56) &amp; 0xff00000000000000ULL) |</a>
<a name="ln163">            ((x &lt;&lt; 40) &amp; 0x00ff000000000000ULL) |</a>
<a name="ln164">            ((x &lt;&lt; 24) &amp; 0x0000ff0000000000ULL) |</a>
<a name="ln165">            ((x &lt;&lt; 8)  &amp; 0x000000ff00000000ULL) |</a>
<a name="ln166">            ((x &gt;&gt; 8)  &amp; 0x00000000ff000000ULL) |</a>
<a name="ln167">            ((x &gt;&gt; 24) &amp; 0x0000000000ff0000ULL) |</a>
<a name="ln168">            ((x &gt;&gt; 40) &amp; 0x000000000000ff00ULL) |</a>
<a name="ln169">            ((x &gt;&gt; 56) &amp; 0x00000000000000ffULL);</a>
<a name="ln170">}</a>
<a name="ln171">#endif</a>
<a name="ln172"> </a>
<a name="ln173"> </a>
<a name="ln174">/***************************************</a>
<a name="ln175">*  Architecture Macros</a>
<a name="ln176">***************************************/</a>
<a name="ln177">typedef enum { XXH_bigEndian=0, XXH_littleEndian=1 } XXH_endianess;</a>
<a name="ln178">#ifndef XXH_CPU_LITTLE_ENDIAN   /* XXH_CPU_LITTLE_ENDIAN can be defined externally, for example using a compiler switch */</a>
<a name="ln179">static const int one = 1;</a>
<a name="ln180">#   define XXH_CPU_LITTLE_ENDIAN   (*(const char*)(&amp;one))</a>
<a name="ln181">#endif</a>
<a name="ln182"> </a>
<a name="ln183"> </a>
<a name="ln184">/*****************************</a>
<a name="ln185">*  Memory reads</a>
<a name="ln186">*****************************/</a>
<a name="ln187">typedef enum { XXH_aligned, XXH_unaligned } XXH_alignment;</a>
<a name="ln188"> </a>
<a name="ln189">FORCE_INLINE U32 XXH_readLE32_align(const void* ptr, XXH_endianess endian, XXH_alignment align)</a>
<a name="ln190">{</a>
<a name="ln191">    if (align==XXH_unaligned)</a>
<a name="ln192">        return endian==XXH_littleEndian ? XXH_read32(ptr) : XXH_swap32(XXH_read32(ptr));</a>
<a name="ln193">    else</a>
<a name="ln194">        return endian==XXH_littleEndian ? *(const U32*)ptr : XXH_swap32(*(const U32*)ptr);</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">FORCE_INLINE U32 XXH_readLE32(const void* ptr, XXH_endianess endian)</a>
<a name="ln198">{</a>
<a name="ln199">    return XXH_readLE32_align(ptr, endian, XXH_unaligned);</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202">FORCE_INLINE U64 XXH_readLE64_align(const void* ptr, XXH_endianess endian, XXH_alignment align)</a>
<a name="ln203">{</a>
<a name="ln204">    if (align==XXH_unaligned)</a>
<a name="ln205">        return endian==XXH_littleEndian ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));</a>
<a name="ln206">    else</a>
<a name="ln207">        return endian==XXH_littleEndian ? *(const U64*)ptr : XXH_swap64(*(const U64*)ptr);</a>
<a name="ln208">}</a>
<a name="ln209"> </a>
<a name="ln210">FORCE_INLINE U64 XXH_readLE64(const void* ptr, XXH_endianess endian)</a>
<a name="ln211">{</a>
<a name="ln212">    return XXH_readLE64_align(ptr, endian, XXH_unaligned);</a>
<a name="ln213">}</a>
<a name="ln214"> </a>
<a name="ln215"> </a>
<a name="ln216">/***************************************</a>
<a name="ln217">*  Macros</a>
<a name="ln218">***************************************/</a>
<a name="ln219">#define XXH_STATIC_ASSERT(c)   { enum { XXH_static_assert = 1/(!!(c)) }; }    /* use only *after* variable declarations */</a>
<a name="ln220"> </a>
<a name="ln221"> </a>
<a name="ln222">/***************************************</a>
<a name="ln223">*  Constants</a>
<a name="ln224">***************************************/</a>
<a name="ln225">#define PRIME32_1   2654435761U</a>
<a name="ln226">#define PRIME32_2   2246822519U</a>
<a name="ln227">#define PRIME32_3   3266489917U</a>
<a name="ln228">#define PRIME32_4    668265263U</a>
<a name="ln229">#define PRIME32_5    374761393U</a>
<a name="ln230"> </a>
<a name="ln231">#define PRIME64_1 11400714785074694791ULL</a>
<a name="ln232">#define PRIME64_2 14029467366897019727ULL</a>
<a name="ln233">#define PRIME64_3  1609587929392839161ULL</a>
<a name="ln234">#define PRIME64_4  9650029242287828579ULL</a>
<a name="ln235">#define PRIME64_5  2870177450012600261ULL</a>
<a name="ln236"> </a>
<a name="ln237"> </a>
<a name="ln238">/*****************************</a>
<a name="ln239">*  Simple Hash Functions</a>
<a name="ln240">*****************************/</a>
<a name="ln241">FORCE_INLINE U32 XXH32_endian_align(const void* input, size_t len, U32 seed, XXH_endianess endian, XXH_alignment align)</a>
<a name="ln242">{</a>
<a name="ln243">    const BYTE* p = (const BYTE*)input;</a>
<a name="ln244">    const BYTE* bEnd = p + len;</a>
<a name="ln245">    U32 h32;</a>
<a name="ln246">#define XXH_get32bits(p) XXH_readLE32_align(p, endian, align)</a>
<a name="ln247"> </a>
<a name="ln248">#ifdef XXH_ACCEPT_NULL_INPUT_POINTER</a>
<a name="ln249">    if (p==NULL)</a>
<a name="ln250">    {</a>
<a name="ln251">        len=0;</a>
<a name="ln252">        bEnd=p=(const BYTE*)(size_t)16;</a>
<a name="ln253">    }</a>
<a name="ln254">#endif</a>
<a name="ln255"> </a>
<a name="ln256">    if (len&gt;=16)</a>
<a name="ln257">    {</a>
<a name="ln258">        const BYTE* const limit = bEnd - 16;</a>
<a name="ln259">        U32 v1 = seed + PRIME32_1 + PRIME32_2;</a>
<a name="ln260">        U32 v2 = seed + PRIME32_2;</a>
<a name="ln261">        U32 v3 = seed + 0;</a>
<a name="ln262">        U32 v4 = seed - PRIME32_1;</a>
<a name="ln263"> </a>
<a name="ln264">        do</a>
<a name="ln265">        {</a>
<a name="ln266">            v1 += XXH_get32bits(p) * PRIME32_2;</a>
<a name="ln267">            v1 = XXH_rotl32(v1, 13);</a>
<a name="ln268">            v1 *= PRIME32_1;</a>
<a name="ln269">            p+=4;</a>
<a name="ln270">            v2 += XXH_get32bits(p) * PRIME32_2;</a>
<a name="ln271">            v2 = XXH_rotl32(v2, 13);</a>
<a name="ln272">            v2 *= PRIME32_1;</a>
<a name="ln273">            p+=4;</a>
<a name="ln274">            v3 += XXH_get32bits(p) * PRIME32_2;</a>
<a name="ln275">            v3 = XXH_rotl32(v3, 13);</a>
<a name="ln276">            v3 *= PRIME32_1;</a>
<a name="ln277">            p+=4;</a>
<a name="ln278">            v4 += XXH_get32bits(p) * PRIME32_2;</a>
<a name="ln279">            v4 = XXH_rotl32(v4, 13);</a>
<a name="ln280">            v4 *= PRIME32_1;</a>
<a name="ln281">            p+=4;</a>
<a name="ln282">        }</a>
<a name="ln283">        while (p&lt;=limit);</a>
<a name="ln284"> </a>
<a name="ln285">        h32 = XXH_rotl32(v1, 1) + XXH_rotl32(v2, 7) + XXH_rotl32(v3, 12) + XXH_rotl32(v4, 18);</a>
<a name="ln286">    }</a>
<a name="ln287">    else</a>
<a name="ln288">    {</a>
<a name="ln289">        h32  = seed + PRIME32_5;</a>
<a name="ln290">    }</a>
<a name="ln291"> </a>
<a name="ln292">    h32 += (U32) len;</a>
<a name="ln293"> </a>
<a name="ln294">    while (p+4&lt;=bEnd)</a>
<a name="ln295">    {</a>
<a name="ln296">        h32 += XXH_get32bits(p) * PRIME32_3;</a>
<a name="ln297">        h32  = XXH_rotl32(h32, 17) * PRIME32_4 ;</a>
<a name="ln298">        p+=4;</a>
<a name="ln299">    }</a>
<a name="ln300"> </a>
<a name="ln301">    while (p&lt;bEnd)</a>
<a name="ln302">    {</a>
<a name="ln303">        h32 += (*p) * PRIME32_5;</a>
<a name="ln304">        h32 = XXH_rotl32(h32, 11) * PRIME32_1 ;</a>
<a name="ln305">        p++;</a>
<a name="ln306">    }</a>
<a name="ln307"> </a>
<a name="ln308">    h32 ^= h32 &gt;&gt; 15;</a>
<a name="ln309">    h32 *= PRIME32_2;</a>
<a name="ln310">    h32 ^= h32 &gt;&gt; 13;</a>
<a name="ln311">    h32 *= PRIME32_3;</a>
<a name="ln312">    h32 ^= h32 &gt;&gt; 16;</a>
<a name="ln313"> </a>
<a name="ln314">    return h32;</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317"> </a>
<a name="ln318">unsigned XXH32 (const void* input, size_t len, unsigned seed)</a>
<a name="ln319">{</a>
<a name="ln320">#if 0</a>
<a name="ln321">    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */</a>
<a name="ln322">    XXH32_state_t state;</a>
<a name="ln323">    XXH32_reset(&amp;state, seed);</a>
<a name="ln324">    XXH32_update(&amp;state, input, len);</a>
<a name="ln325">    return XXH32_digest(&amp;state);</a>
<a name="ln326">#else</a>
<a name="ln327">    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;</a>
<a name="ln328"> </a>
<a name="ln329">#  if !defined(XXH_USE_UNALIGNED_ACCESS)</a>
<a name="ln330">    if ((((size_t)input) &amp; 3) == 0)   /* Input is 4-bytes aligned, leverage the speed benefit */</a>
<a name="ln331">    {</a>
<a name="ln332">        if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)</a>
<a name="ln333">            return XXH32_endian_align(input, len, seed, XXH_littleEndian, XXH_aligned);</a>
<a name="ln334">        else</a>
<a name="ln335">            return XXH32_endian_align(input, len, seed, XXH_bigEndian, XXH_aligned);</a>
<a name="ln336">    }</a>
<a name="ln337">#  endif</a>
<a name="ln338"> </a>
<a name="ln339">    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)</a>
<a name="ln340">        return XXH32_endian_align(input, len, seed, XXH_littleEndian, XXH_unaligned);</a>
<a name="ln341">    else</a>
<a name="ln342">        return XXH32_endian_align(input, len, seed, XXH_bigEndian, XXH_unaligned);</a>
<a name="ln343">#endif</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346">FORCE_INLINE U64 XXH64_endian_align(const void* input, size_t len, U64 seed, XXH_endianess endian, XXH_alignment align)</a>
<a name="ln347">{</a>
<a name="ln348">    const BYTE* p = (const BYTE*)input;</a>
<a name="ln349">    const BYTE* bEnd = p + len;</a>
<a name="ln350">    U64 h64;</a>
<a name="ln351">#define XXH_get64bits(p) XXH_readLE64_align(p, endian, align)</a>
<a name="ln352"> </a>
<a name="ln353">#ifdef XXH_ACCEPT_NULL_INPUT_POINTER</a>
<a name="ln354">    if (p==NULL)</a>
<a name="ln355">    {</a>
<a name="ln356">        len=0;</a>
<a name="ln357">        bEnd=p=(const BYTE*)(size_t)32;</a>
<a name="ln358">    }</a>
<a name="ln359">#endif</a>
<a name="ln360"> </a>
<a name="ln361">    if (len&gt;=32)</a>
<a name="ln362">    {</a>
<a name="ln363">        const BYTE* const limit = bEnd - 32;</a>
<a name="ln364">        U64 v1 = seed + PRIME64_1 + PRIME64_2;</a>
<a name="ln365">        U64 v2 = seed + PRIME64_2;</a>
<a name="ln366">        U64 v3 = seed + 0;</a>
<a name="ln367">        U64 v4 = seed - PRIME64_1;</a>
<a name="ln368"> </a>
<a name="ln369">        do</a>
<a name="ln370">        {</a>
<a name="ln371">            v1 += XXH_get64bits(p) * PRIME64_2;</a>
<a name="ln372">            p+=8;</a>
<a name="ln373">            v1 = XXH_rotl64(v1, 31);</a>
<a name="ln374">            v1 *= PRIME64_1;</a>
<a name="ln375">            v2 += XXH_get64bits(p) * PRIME64_2;</a>
<a name="ln376">            p+=8;</a>
<a name="ln377">            v2 = XXH_rotl64(v2, 31);</a>
<a name="ln378">            v2 *= PRIME64_1;</a>
<a name="ln379">            v3 += XXH_get64bits(p) * PRIME64_2;</a>
<a name="ln380">            p+=8;</a>
<a name="ln381">            v3 = XXH_rotl64(v3, 31);</a>
<a name="ln382">            v3 *= PRIME64_1;</a>
<a name="ln383">            v4 += XXH_get64bits(p) * PRIME64_2;</a>
<a name="ln384">            p+=8;</a>
<a name="ln385">            v4 = XXH_rotl64(v4, 31);</a>
<a name="ln386">            v4 *= PRIME64_1;</a>
<a name="ln387">        }</a>
<a name="ln388">        while (p&lt;=limit);</a>
<a name="ln389"> </a>
<a name="ln390">        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);</a>
<a name="ln391"> </a>
<a name="ln392">        v1 *= PRIME64_2;</a>
<a name="ln393">        v1 = XXH_rotl64(v1, 31);</a>
<a name="ln394">        v1 *= PRIME64_1;</a>
<a name="ln395">        h64 ^= v1;</a>
<a name="ln396">        h64 = h64 * PRIME64_1 + PRIME64_4;</a>
<a name="ln397"> </a>
<a name="ln398">        v2 *= PRIME64_2;</a>
<a name="ln399">        v2 = XXH_rotl64(v2, 31);</a>
<a name="ln400">        v2 *= PRIME64_1;</a>
<a name="ln401">        h64 ^= v2;</a>
<a name="ln402">        h64 = h64 * PRIME64_1 + PRIME64_4;</a>
<a name="ln403"> </a>
<a name="ln404">        v3 *= PRIME64_2;</a>
<a name="ln405">        v3 = XXH_rotl64(v3, 31);</a>
<a name="ln406">        v3 *= PRIME64_1;</a>
<a name="ln407">        h64 ^= v3;</a>
<a name="ln408">        h64 = h64 * PRIME64_1 + PRIME64_4;</a>
<a name="ln409"> </a>
<a name="ln410">        v4 *= PRIME64_2;</a>
<a name="ln411">        v4 = XXH_rotl64(v4, 31);</a>
<a name="ln412">        v4 *= PRIME64_1;</a>
<a name="ln413">        h64 ^= v4;</a>
<a name="ln414">        h64 = h64 * PRIME64_1 + PRIME64_4;</a>
<a name="ln415">    }</a>
<a name="ln416">    else</a>
<a name="ln417">    {</a>
<a name="ln418">        h64  = seed + PRIME64_5;</a>
<a name="ln419">    }</a>
<a name="ln420"> </a>
<a name="ln421">    h64 += (U64) len;</a>
<a name="ln422"> </a>
<a name="ln423">    while (p+8&lt;=bEnd)</a>
<a name="ln424">    {</a>
<a name="ln425">        U64 k1 = XXH_get64bits(p);</a>
<a name="ln426">        k1 *= PRIME64_2;</a>
<a name="ln427">        k1 = XXH_rotl64(k1,31);</a>
<a name="ln428">        k1 *= PRIME64_1;</a>
<a name="ln429">        h64 ^= k1;</a>
<a name="ln430">        h64 = XXH_rotl64(h64,27) * PRIME64_1 + PRIME64_4;</a>
<a name="ln431">        p+=8;</a>
<a name="ln432">    }</a>
<a name="ln433"> </a>
<a name="ln434">    if (p+4&lt;=bEnd)</a>
<a name="ln435">    {</a>
<a name="ln436">        h64 ^= (U64)(XXH_get32bits(p)) * PRIME64_1;</a>
<a name="ln437">        h64 = XXH_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;</a>
<a name="ln438">        p+=4;</a>
<a name="ln439">    }</a>
<a name="ln440"> </a>
<a name="ln441">    while (p&lt;bEnd)</a>
<a name="ln442">    {</a>
<a name="ln443">        h64 ^= (*p) * PRIME64_5;</a>
<a name="ln444">        h64 = XXH_rotl64(h64, 11) * PRIME64_1;</a>
<a name="ln445">        p++;</a>
<a name="ln446">    }</a>
<a name="ln447"> </a>
<a name="ln448">    h64 ^= h64 &gt;&gt; 33;</a>
<a name="ln449">    h64 *= PRIME64_2;</a>
<a name="ln450">    h64 ^= h64 &gt;&gt; 29;</a>
<a name="ln451">    h64 *= PRIME64_3;</a>
<a name="ln452">    h64 ^= h64 &gt;&gt; 32;</a>
<a name="ln453"> </a>
<a name="ln454">    return h64;</a>
<a name="ln455">}</a>
<a name="ln456"> </a>
<a name="ln457"> </a>
<a name="ln458">unsigned long long XXH64 (const void* input, size_t len, unsigned long long seed)</a>
<a name="ln459">{</a>
<a name="ln460">#if 0</a>
<a name="ln461">    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */</a>
<a name="ln462">    XXH64_state_t state;</a>
<a name="ln463">    XXH64_reset(&amp;state, seed);</a>
<a name="ln464">    XXH64_update(&amp;state, input, len);</a>
<a name="ln465">    return XXH64_digest(&amp;state);</a>
<a name="ln466">#else</a>
<a name="ln467">    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;</a>
<a name="ln468"> </a>
<a name="ln469">#  if !defined(XXH_USE_UNALIGNED_ACCESS)</a>
<a name="ln470">    if ((((size_t)input) &amp; 7)==0)   /* Input is aligned, let's leverage the speed advantage */</a>
<a name="ln471">    {</a>
<a name="ln472">        if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)</a>
<a name="ln473">            return XXH64_endian_align(input, len, seed, XXH_littleEndian, XXH_aligned);</a>
<a name="ln474">        else</a>
<a name="ln475">            return XXH64_endian_align(input, len, seed, XXH_bigEndian, XXH_aligned);</a>
<a name="ln476">    }</a>
<a name="ln477">#  endif</a>
<a name="ln478"> </a>
<a name="ln479">    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)</a>
<a name="ln480">        return XXH64_endian_align(input, len, seed, XXH_littleEndian, XXH_unaligned);</a>
<a name="ln481">    else</a>
<a name="ln482">        return XXH64_endian_align(input, len, seed, XXH_bigEndian, XXH_unaligned);</a>
<a name="ln483">#endif</a>
<a name="ln484">}</a>
<a name="ln485"> </a>
<a name="ln486">/****************************************************</a>
<a name="ln487">*  Advanced Hash Functions</a>
<a name="ln488">****************************************************/</a>
<a name="ln489"> </a>
<a name="ln490">/*** Allocation ***/</a>
<a name="ln491">typedef struct</a>
<a name="ln492">{</a>
<a name="ln493">    U64 total_len;</a>
<a name="ln494">    U32 seed;</a>
<a name="ln495">    U32 v1;</a>
<a name="ln496">    U32 v2;</a>
<a name="ln497">    U32 v3;</a>
<a name="ln498">    U32 v4;</a>
<a name="ln499">    U32 mem32[4];   /* defined as U32 for alignment */</a>
<a name="ln500">    U32 memsize;</a>
<a name="ln501">} XXH_istate32_t;</a>
<a name="ln502"> </a>
<a name="ln503">typedef struct</a>
<a name="ln504">{</a>
<a name="ln505">    U64 total_len;</a>
<a name="ln506">    U64 seed;</a>
<a name="ln507">    U64 v1;</a>
<a name="ln508">    U64 v2;</a>
<a name="ln509">    U64 v3;</a>
<a name="ln510">    U64 v4;</a>
<a name="ln511">    U64 mem64[4];   /* defined as U64 for alignment */</a>
<a name="ln512">    U32 memsize;</a>
<a name="ln513">} XXH_istate64_t;</a>
<a name="ln514"> </a>
<a name="ln515"> </a>
<a name="ln516">XXH32_state_t* XXH32_createState(void)</a>
<a name="ln517">{</a>
<a name="ln518">    XXH_STATIC_ASSERT(sizeof(XXH32_state_t) &gt;= sizeof(XXH_istate32_t));   /* A compilation error here means XXH32_state_t is not large enough */</a>
<a name="ln519">    return (XXH32_state_t*)XXH_malloc(sizeof(XXH32_state_t));</a>
<a name="ln520">}</a>
<a name="ln521">XXH_errorcode XXH32_freeState(XXH32_state_t* statePtr)</a>
<a name="ln522">{</a>
<a name="ln523">    XXH_free(statePtr);</a>
<a name="ln524">    return XXH_OK;</a>
<a name="ln525">}</a>
<a name="ln526"> </a>
<a name="ln527">XXH64_state_t* XXH64_createState(void)</a>
<a name="ln528">{</a>
<a name="ln529">    XXH_STATIC_ASSERT(sizeof(XXH64_state_t) &gt;= sizeof(XXH_istate64_t));   /* A compilation error here means XXH64_state_t is not large enough */</a>
<a name="ln530">    return (XXH64_state_t*)XXH_malloc(sizeof(XXH64_state_t));</a>
<a name="ln531">}</a>
<a name="ln532">XXH_errorcode XXH64_freeState(XXH64_state_t* statePtr)</a>
<a name="ln533">{</a>
<a name="ln534">    XXH_free(statePtr);</a>
<a name="ln535">    return XXH_OK;</a>
<a name="ln536">}</a>
<a name="ln537"> </a>
<a name="ln538"> </a>
<a name="ln539">/*** Hash feed ***/</a>
<a name="ln540"> </a>
<a name="ln541">XXH_errorcode XXH32_reset(XXH32_state_t* state_in, U32 seed)</a>
<a name="ln542">{</a>
<a name="ln543">    XXH_istate32_t* state = (XXH_istate32_t*) state_in;</a>
<a name="ln544">    state-&gt;seed = seed;</a>
<a name="ln545">    state-&gt;v1 = seed + PRIME32_1 + PRIME32_2;</a>
<a name="ln546">    state-&gt;v2 = seed + PRIME32_2;</a>
<a name="ln547">    state-&gt;v3 = seed + 0;</a>
<a name="ln548">    state-&gt;v4 = seed - PRIME32_1;</a>
<a name="ln549">    state-&gt;total_len = 0;</a>
<a name="ln550">    state-&gt;memsize = 0;</a>
<a name="ln551">    return XXH_OK;</a>
<a name="ln552">}</a>
<a name="ln553"> </a>
<a name="ln554">XXH_errorcode XXH64_reset(XXH64_state_t* state_in, unsigned long long seed)</a>
<a name="ln555">{</a>
<a name="ln556">    XXH_istate64_t* state = (XXH_istate64_t*) state_in;</a>
<a name="ln557">    state-&gt;seed = seed;</a>
<a name="ln558">    state-&gt;v1 = seed + PRIME64_1 + PRIME64_2;</a>
<a name="ln559">    state-&gt;v2 = seed + PRIME64_2;</a>
<a name="ln560">    state-&gt;v3 = seed + 0;</a>
<a name="ln561">    state-&gt;v4 = seed - PRIME64_1;</a>
<a name="ln562">    state-&gt;total_len = 0;</a>
<a name="ln563">    state-&gt;memsize = 0;</a>
<a name="ln564">    return XXH_OK;</a>
<a name="ln565">}</a>
<a name="ln566"> </a>
<a name="ln567"> </a>
<a name="ln568">FORCE_INLINE XXH_errorcode XXH32_update_endian (XXH32_state_t* state_in, const void* input, size_t len, XXH_endianess endian)</a>
<a name="ln569">{</a>
<a name="ln570">    XXH_istate32_t* state = (XXH_istate32_t *) state_in;</a>
<a name="ln571">    const BYTE* p = (const BYTE*)input;</a>
<a name="ln572">    const BYTE* const bEnd = p + len;</a>
<a name="ln573"> </a>
<a name="ln574">#ifdef XXH_ACCEPT_NULL_INPUT_POINTER</a>
<a name="ln575">    if (input==NULL) return XXH_ERROR;</a>
<a name="ln576">#endif</a>
<a name="ln577"> </a>
<a name="ln578">    state-&gt;total_len += len;</a>
<a name="ln579"> </a>
<a name="ln580">    if (state-&gt;memsize + len &lt; 16)   /* fill in tmp buffer */</a>
<a name="ln581">    {</a>
<a name="ln582">        XXH_memcpy((BYTE*)(state-&gt;mem32) + state-&gt;memsize, input, len);</a>
<a name="ln583">        state-&gt;memsize += (U32)len;</a>
<a name="ln584">        return XXH_OK;</a>
<a name="ln585">    }</a>
<a name="ln586"> </a>
<a name="ln587">    if (state-&gt;memsize)   /* some data left from previous Update */</a>
<a name="ln588">    {</a>
<a name="ln589">        XXH_memcpy((BYTE*)(state-&gt;mem32) + state-&gt;memsize, input, 16-state-&gt;memsize);</a>
<a name="ln590">        {</a>
<a name="ln591">            const U32* p32 = state-&gt;mem32;</a>
<a name="ln592">            state-&gt;v1 += XXH_readLE32(p32, endian) * PRIME32_2;</a>
<a name="ln593">            state-&gt;v1 = XXH_rotl32(state-&gt;v1, 13);</a>
<a name="ln594">            state-&gt;v1 *= PRIME32_1;</a>
<a name="ln595">            p32++;</a>
<a name="ln596">            state-&gt;v2 += XXH_readLE32(p32, endian) * PRIME32_2;</a>
<a name="ln597">            state-&gt;v2 = XXH_rotl32(state-&gt;v2, 13);</a>
<a name="ln598">            state-&gt;v2 *= PRIME32_1;</a>
<a name="ln599">            p32++;</a>
<a name="ln600">            state-&gt;v3 += XXH_readLE32(p32, endian) * PRIME32_2;</a>
<a name="ln601">            state-&gt;v3 = XXH_rotl32(state-&gt;v3, 13);</a>
<a name="ln602">            state-&gt;v3 *= PRIME32_1;</a>
<a name="ln603">            p32++;</a>
<a name="ln604">            state-&gt;v4 += XXH_readLE32(p32, endian) * PRIME32_2;</a>
<a name="ln605">            state-&gt;v4 = XXH_rotl32(state-&gt;v4, 13);</a>
<a name="ln606">            state-&gt;v4 *= PRIME32_1;</a>
<a name="ln607">            p32++;</a>
<a name="ln608">        }</a>
<a name="ln609">        p += 16-state-&gt;memsize;</a>
<a name="ln610">        state-&gt;memsize = 0;</a>
<a name="ln611">    }</a>
<a name="ln612"> </a>
<a name="ln613">    if (p &lt;= bEnd-16)</a>
<a name="ln614">    {</a>
<a name="ln615">        const BYTE* const limit = bEnd - 16;</a>
<a name="ln616">        U32 v1 = state-&gt;v1;</a>
<a name="ln617">        U32 v2 = state-&gt;v2;</a>
<a name="ln618">        U32 v3 = state-&gt;v3;</a>
<a name="ln619">        U32 v4 = state-&gt;v4;</a>
<a name="ln620"> </a>
<a name="ln621">        do</a>
<a name="ln622">        {</a>
<a name="ln623">            v1 += XXH_readLE32(p, endian) * PRIME32_2;</a>
<a name="ln624">            v1 = XXH_rotl32(v1, 13);</a>
<a name="ln625">            v1 *= PRIME32_1;</a>
<a name="ln626">            p+=4;</a>
<a name="ln627">            v2 += XXH_readLE32(p, endian) * PRIME32_2;</a>
<a name="ln628">            v2 = XXH_rotl32(v2, 13);</a>
<a name="ln629">            v2 *= PRIME32_1;</a>
<a name="ln630">            p+=4;</a>
<a name="ln631">            v3 += XXH_readLE32(p, endian) * PRIME32_2;</a>
<a name="ln632">            v3 = XXH_rotl32(v3, 13);</a>
<a name="ln633">            v3 *= PRIME32_1;</a>
<a name="ln634">            p+=4;</a>
<a name="ln635">            v4 += XXH_readLE32(p, endian) * PRIME32_2;</a>
<a name="ln636">            v4 = XXH_rotl32(v4, 13);</a>
<a name="ln637">            v4 *= PRIME32_1;</a>
<a name="ln638">            p+=4;</a>
<a name="ln639">        }</a>
<a name="ln640">        while (p&lt;=limit);</a>
<a name="ln641"> </a>
<a name="ln642">        state-&gt;v1 = v1;</a>
<a name="ln643">        state-&gt;v2 = v2;</a>
<a name="ln644">        state-&gt;v3 = v3;</a>
<a name="ln645">        state-&gt;v4 = v4;</a>
<a name="ln646">    }</a>
<a name="ln647"> </a>
<a name="ln648">    if (p &lt; bEnd)</a>
<a name="ln649">    {</a>
<a name="ln650">        XXH_memcpy(state-&gt;mem32, p, bEnd-p);</a>
<a name="ln651">        state-&gt;memsize = (int)(bEnd-p);</a>
<a name="ln652">    }</a>
<a name="ln653"> </a>
<a name="ln654">    return XXH_OK;</a>
<a name="ln655">}</a>
<a name="ln656"> </a>
<a name="ln657">XXH_errorcode XXH32_update (XXH32_state_t* state_in, const void* input, size_t len)</a>
<a name="ln658">{</a>
<a name="ln659">    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;</a>
<a name="ln660"> </a>
<a name="ln661">    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)</a>
<a name="ln662">        return XXH32_update_endian(state_in, input, len, XXH_littleEndian);</a>
<a name="ln663">    else</a>
<a name="ln664">        return XXH32_update_endian(state_in, input, len, XXH_bigEndian);</a>
<a name="ln665">}</a>
<a name="ln666"> </a>
<a name="ln667"> </a>
<a name="ln668"> </a>
<a name="ln669">FORCE_INLINE U32 XXH32_digest_endian (const XXH32_state_t* state_in, XXH_endianess endian)</a>
<a name="ln670">{</a>
<a name="ln671">    const XXH_istate32_t* state = (const XXH_istate32_t*) state_in;</a>
<a name="ln672">    const BYTE * p = (const BYTE*)state-&gt;mem32;</a>
<a name="ln673">    const BYTE* bEnd = (const BYTE*)(state-&gt;mem32) + state-&gt;memsize;</a>
<a name="ln674">    U32 h32;</a>
<a name="ln675"> </a>
<a name="ln676">    if (state-&gt;total_len &gt;= 16)</a>
<a name="ln677">    {</a>
<a name="ln678">        h32 = XXH_rotl32(state-&gt;v1, 1) + XXH_rotl32(state-&gt;v2, 7) + XXH_rotl32(state-&gt;v3, 12) + XXH_rotl32(state-&gt;v4, 18);</a>
<a name="ln679">    }</a>
<a name="ln680">    else</a>
<a name="ln681">    {</a>
<a name="ln682">        h32  = state-&gt;seed + PRIME32_5;</a>
<a name="ln683">    }</a>
<a name="ln684"> </a>
<a name="ln685">    h32 += (U32) state-&gt;total_len;</a>
<a name="ln686"> </a>
<a name="ln687">    while (p+4&lt;=bEnd)</a>
<a name="ln688">    {</a>
<a name="ln689">        h32 += XXH_readLE32(p, endian) * PRIME32_3;</a>
<a name="ln690">        h32  = XXH_rotl32(h32, 17) * PRIME32_4;</a>
<a name="ln691">        p+=4;</a>
<a name="ln692">    }</a>
<a name="ln693"> </a>
<a name="ln694">    while (p&lt;bEnd)</a>
<a name="ln695">    {</a>
<a name="ln696">        h32 += (*p) * PRIME32_5;</a>
<a name="ln697">        h32 = XXH_rotl32(h32, 11) * PRIME32_1;</a>
<a name="ln698">        p++;</a>
<a name="ln699">    }</a>
<a name="ln700"> </a>
<a name="ln701">    h32 ^= h32 &gt;&gt; 15;</a>
<a name="ln702">    h32 *= PRIME32_2;</a>
<a name="ln703">    h32 ^= h32 &gt;&gt; 13;</a>
<a name="ln704">    h32 *= PRIME32_3;</a>
<a name="ln705">    h32 ^= h32 &gt;&gt; 16;</a>
<a name="ln706"> </a>
<a name="ln707">    return h32;</a>
<a name="ln708">}</a>
<a name="ln709"> </a>
<a name="ln710"> </a>
<a name="ln711">U32 XXH32_digest (const XXH32_state_t* state_in)</a>
<a name="ln712">{</a>
<a name="ln713">    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;</a>
<a name="ln714"> </a>
<a name="ln715">    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)</a>
<a name="ln716">        return XXH32_digest_endian(state_in, XXH_littleEndian);</a>
<a name="ln717">    else</a>
<a name="ln718">        return XXH32_digest_endian(state_in, XXH_bigEndian);</a>
<a name="ln719">}</a>
<a name="ln720"> </a>
<a name="ln721"> </a>
<a name="ln722">FORCE_INLINE XXH_errorcode XXH64_update_endian (XXH64_state_t* state_in, const void* input, size_t len, XXH_endianess endian)</a>
<a name="ln723">{</a>
<a name="ln724">    XXH_istate64_t * state = (XXH_istate64_t *) state_in;</a>
<a name="ln725">    const BYTE* p = (const BYTE*)input;</a>
<a name="ln726">    const BYTE* const bEnd = p + len;</a>
<a name="ln727"> </a>
<a name="ln728">#ifdef XXH_ACCEPT_NULL_INPUT_POINTER</a>
<a name="ln729">    if (input==NULL) return XXH_ERROR;</a>
<a name="ln730">#endif</a>
<a name="ln731"> </a>
<a name="ln732">    state-&gt;total_len += len;</a>
<a name="ln733"> </a>
<a name="ln734">    if (state-&gt;memsize + len &lt; 32)   /* fill in tmp buffer */</a>
<a name="ln735">    {</a>
<a name="ln736">        XXH_memcpy(((BYTE*)state-&gt;mem64) + state-&gt;memsize, input, len);</a>
<a name="ln737">        state-&gt;memsize += (U32)len;</a>
<a name="ln738">        return XXH_OK;</a>
<a name="ln739">    }</a>
<a name="ln740"> </a>
<a name="ln741">    if (state-&gt;memsize)   /* some data left from previous Update */</a>
<a name="ln742">    {</a>
<a name="ln743">        XXH_memcpy(((BYTE*)state-&gt;mem64) + state-&gt;memsize, input, 32-state-&gt;memsize);</a>
<a name="ln744">        {</a>
<a name="ln745">            const U64* p64 = state-&gt;mem64;</a>
<a name="ln746">            state-&gt;v1 += XXH_readLE64(p64, endian) * PRIME64_2;</a>
<a name="ln747">            state-&gt;v1 = XXH_rotl64(state-&gt;v1, 31);</a>
<a name="ln748">            state-&gt;v1 *= PRIME64_1;</a>
<a name="ln749">            p64++;</a>
<a name="ln750">            state-&gt;v2 += XXH_readLE64(p64, endian) * PRIME64_2;</a>
<a name="ln751">            state-&gt;v2 = XXH_rotl64(state-&gt;v2, 31);</a>
<a name="ln752">            state-&gt;v2 *= PRIME64_1;</a>
<a name="ln753">            p64++;</a>
<a name="ln754">            state-&gt;v3 += XXH_readLE64(p64, endian) * PRIME64_2;</a>
<a name="ln755">            state-&gt;v3 = XXH_rotl64(state-&gt;v3, 31);</a>
<a name="ln756">            state-&gt;v3 *= PRIME64_1;</a>
<a name="ln757">            p64++;</a>
<a name="ln758">            state-&gt;v4 += XXH_readLE64(p64, endian) * PRIME64_2;</a>
<a name="ln759">            state-&gt;v4 = XXH_rotl64(state-&gt;v4, 31);</a>
<a name="ln760">            state-&gt;v4 *= PRIME64_1;</a>
<a name="ln761">            p64++;</a>
<a name="ln762">        }</a>
<a name="ln763">        p += 32-state-&gt;memsize;</a>
<a name="ln764">        state-&gt;memsize = 0;</a>
<a name="ln765">    }</a>
<a name="ln766"> </a>
<a name="ln767">    if (p+32 &lt;= bEnd)</a>
<a name="ln768">    {</a>
<a name="ln769">        const BYTE* const limit = bEnd - 32;</a>
<a name="ln770">        U64 v1 = state-&gt;v1;</a>
<a name="ln771">        U64 v2 = state-&gt;v2;</a>
<a name="ln772">        U64 v3 = state-&gt;v3;</a>
<a name="ln773">        U64 v4 = state-&gt;v4;</a>
<a name="ln774"> </a>
<a name="ln775">        do</a>
<a name="ln776">        {</a>
<a name="ln777">            v1 += XXH_readLE64(p, endian) * PRIME64_2;</a>
<a name="ln778">            v1 = XXH_rotl64(v1, 31);</a>
<a name="ln779">            v1 *= PRIME64_1;</a>
<a name="ln780">            p+=8;</a>
<a name="ln781">            v2 += XXH_readLE64(p, endian) * PRIME64_2;</a>
<a name="ln782">            v2 = XXH_rotl64(v2, 31);</a>
<a name="ln783">            v2 *= PRIME64_1;</a>
<a name="ln784">            p+=8;</a>
<a name="ln785">            v3 += XXH_readLE64(p, endian) * PRIME64_2;</a>
<a name="ln786">            v3 = XXH_rotl64(v3, 31);</a>
<a name="ln787">            v3 *= PRIME64_1;</a>
<a name="ln788">            p+=8;</a>
<a name="ln789">            v4 += XXH_readLE64(p, endian) * PRIME64_2;</a>
<a name="ln790">            v4 = XXH_rotl64(v4, 31);</a>
<a name="ln791">            v4 *= PRIME64_1;</a>
<a name="ln792">            p+=8;</a>
<a name="ln793">        }</a>
<a name="ln794">        while (p&lt;=limit);</a>
<a name="ln795"> </a>
<a name="ln796">        state-&gt;v1 = v1;</a>
<a name="ln797">        state-&gt;v2 = v2;</a>
<a name="ln798">        state-&gt;v3 = v3;</a>
<a name="ln799">        state-&gt;v4 = v4;</a>
<a name="ln800">    }</a>
<a name="ln801"> </a>
<a name="ln802">    if (p &lt; bEnd)</a>
<a name="ln803">    {</a>
<a name="ln804">        XXH_memcpy(state-&gt;mem64, p, bEnd-p);</a>
<a name="ln805">        state-&gt;memsize = (int)(bEnd-p);</a>
<a name="ln806">    }</a>
<a name="ln807"> </a>
<a name="ln808">    return XXH_OK;</a>
<a name="ln809">}</a>
<a name="ln810"> </a>
<a name="ln811">XXH_errorcode XXH64_update (XXH64_state_t* state_in, const void* input, size_t len)</a>
<a name="ln812">{</a>
<a name="ln813">    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;</a>
<a name="ln814"> </a>
<a name="ln815">    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)</a>
<a name="ln816">        return XXH64_update_endian(state_in, input, len, XXH_littleEndian);</a>
<a name="ln817">    else</a>
<a name="ln818">        return XXH64_update_endian(state_in, input, len, XXH_bigEndian);</a>
<a name="ln819">}</a>
<a name="ln820"> </a>
<a name="ln821"> </a>
<a name="ln822"> </a>
<a name="ln823">FORCE_INLINE U64 XXH64_digest_endian (const XXH64_state_t* state_in, XXH_endianess endian)</a>
<a name="ln824">{</a>
<a name="ln825">    const XXH_istate64_t * state = (const XXH_istate64_t *) state_in;</a>
<a name="ln826">    const BYTE * p = (const BYTE*)state-&gt;mem64;</a>
<a name="ln827">    const BYTE* bEnd = (const BYTE*)state-&gt;mem64 + state-&gt;memsize;</a>
<a name="ln828">    U64 h64;</a>
<a name="ln829"> </a>
<a name="ln830">    if (state-&gt;total_len &gt;= 32)</a>
<a name="ln831">    {</a>
<a name="ln832">        U64 v1 = state-&gt;v1;</a>
<a name="ln833">        U64 v2 = state-&gt;v2;</a>
<a name="ln834">        U64 v3 = state-&gt;v3;</a>
<a name="ln835">        U64 v4 = state-&gt;v4;</a>
<a name="ln836"> </a>
<a name="ln837">        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);</a>
<a name="ln838"> </a>
<a name="ln839">        v1 *= PRIME64_2;</a>
<a name="ln840">        v1 = XXH_rotl64(v1, 31);</a>
<a name="ln841">        v1 *= PRIME64_1;</a>
<a name="ln842">        h64 ^= v1;</a>
<a name="ln843">        h64 = h64*PRIME64_1 + PRIME64_4;</a>
<a name="ln844"> </a>
<a name="ln845">        v2 *= PRIME64_2;</a>
<a name="ln846">        v2 = XXH_rotl64(v2, 31);</a>
<a name="ln847">        v2 *= PRIME64_1;</a>
<a name="ln848">        h64 ^= v2;</a>
<a name="ln849">        h64 = h64*PRIME64_1 + PRIME64_4;</a>
<a name="ln850"> </a>
<a name="ln851">        v3 *= PRIME64_2;</a>
<a name="ln852">        v3 = XXH_rotl64(v3, 31);</a>
<a name="ln853">        v3 *= PRIME64_1;</a>
<a name="ln854">        h64 ^= v3;</a>
<a name="ln855">        h64 = h64*PRIME64_1 + PRIME64_4;</a>
<a name="ln856"> </a>
<a name="ln857">        v4 *= PRIME64_2;</a>
<a name="ln858">        v4 = XXH_rotl64(v4, 31);</a>
<a name="ln859">        v4 *= PRIME64_1;</a>
<a name="ln860">        h64 ^= v4;</a>
<a name="ln861">        h64 = h64*PRIME64_1 + PRIME64_4;</a>
<a name="ln862">    }</a>
<a name="ln863">    else</a>
<a name="ln864">    {</a>
<a name="ln865">        h64  = state-&gt;seed + PRIME64_5;</a>
<a name="ln866">    }</a>
<a name="ln867"> </a>
<a name="ln868">    h64 += (U64) state-&gt;total_len;</a>
<a name="ln869"> </a>
<a name="ln870">    while (p+8&lt;=bEnd)</a>
<a name="ln871">    {</a>
<a name="ln872">        U64 k1 = XXH_readLE64(p, endian);</a>
<a name="ln873">        k1 *= PRIME64_2;</a>
<a name="ln874">        k1 = XXH_rotl64(k1,31);</a>
<a name="ln875">        k1 *= PRIME64_1;</a>
<a name="ln876">        h64 ^= k1;</a>
<a name="ln877">        h64 = XXH_rotl64(h64,27) * PRIME64_1 + PRIME64_4;</a>
<a name="ln878">        p+=8;</a>
<a name="ln879">    }</a>
<a name="ln880"> </a>
<a name="ln881">    if (p+4&lt;=bEnd)</a>
<a name="ln882">    {</a>
<a name="ln883">        h64 ^= (U64)(XXH_readLE32(p, endian)) * PRIME64_1;</a>
<a name="ln884">        h64 = XXH_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;</a>
<a name="ln885">        p+=4;</a>
<a name="ln886">    }</a>
<a name="ln887"> </a>
<a name="ln888">    while (p&lt;bEnd)</a>
<a name="ln889">    {</a>
<a name="ln890">        h64 ^= (*p) * PRIME64_5;</a>
<a name="ln891">        h64 = XXH_rotl64(h64, 11) * PRIME64_1;</a>
<a name="ln892">        p++;</a>
<a name="ln893">    }</a>
<a name="ln894"> </a>
<a name="ln895">    h64 ^= h64 &gt;&gt; 33;</a>
<a name="ln896">    h64 *= PRIME64_2;</a>
<a name="ln897">    h64 ^= h64 &gt;&gt; 29;</a>
<a name="ln898">    h64 *= PRIME64_3;</a>
<a name="ln899">    h64 ^= h64 &gt;&gt; 32;</a>
<a name="ln900"> </a>
<a name="ln901">    return h64;</a>
<a name="ln902">}</a>
<a name="ln903"> </a>
<a name="ln904"> </a>
<a name="ln905">unsigned long long XXH64_digest (const XXH64_state_t* state_in)</a>
<a name="ln906">{</a>
<a name="ln907">    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;</a>
<a name="ln908"> </a>
<a name="ln909">    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)</a>
<a name="ln910">        return XXH64_digest_endian(state_in, XXH_littleEndian);</a>
<a name="ln911">    else</a>
<a name="ln912">        return XXH64_digest_endian(state_in, XXH_bigEndian);</a>
<a name="ln913">}</a>
<a name="ln914"> </a>
<a name="ln915"> </a>

</code></pre>
<div class="balloon" rel="109"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v677/" target="_blank">V677</a> Custom declaration of a standard 'BYTE' type. The system header file should be used: #include <WinDef.h>.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
