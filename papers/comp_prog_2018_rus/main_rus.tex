\documentclass[a4paper,twoside,11pt]{article}
\usepackage[cp1251]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{fancyhdr}
\usepackage{newprog1e}
\usepackage{amsfonts,amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{graphics}
\graphicspath{{images/}}
\tolerance=1000

\newcommand{\defi}{\stackrel{\mathrm{def}}{=}}

\numberwithin{equation}{section}
\newtheorem{theorem}{Теорема}

\newtheorem{definition}{Определение}
\newtheorem{theorem_ru}{Теорема}
\newtheorem{statement}{Утверждение}

\journalnumber{4}
\curyear{2016}
\authorlist{V.A. Frolov$^{1,2}$, V. V. Sanzharov$^{3}$,  V.A. Galaktionov$^1$}
\titlehead{Современные проблемы интеграции в приложениях компьютерной графики и пути их решения.}
\headerdef

\udk{004.421.6}
\rubrika{COMPUTER GRAPHICS}
\dateinput{15.01.2016}

\rusabstr{ В данной работе предлагается концепция создания интеграционного слоя программного обеспечения (ПО) между 3D-редактором и расчётным ядром рендер-системы в виде специализированной базы данных (БД). Данная концепция ориентирована на поддержку таких функуциональных требований как быстрое обновление сцены, многопоточность, работа с контентом, не помещающимся в оперативную память, импорт и экспорт произвольных параметров, сериализация, удобная отладка и сетевой рендеринг. Такая БД может быть использована в том числе и для передачи информации между различными 3D редакторами. }

\author{
{\bfseries В. A. Фролов $^{1,2}$, В. В. Санжаров $^{3}$,  В. А. Галактионов $^1$,}
\\ {\itshape $^1$ Институт прикладной математики имени М.В. Келдыша РАН. Москва, Россия.}
\\ {\itshape $^2$ Московский государственный университет. Москва, Россия. }
\\ {\itshape $^3$ Российский государственный университет нефти и газа (национальный исследовательский университет) имени И. М. Губкина. Москва, Россия. }
\\ {\itshape E-mail: vfrolov@graphics.cs.msu.ru, vs@asugubkin.ru, vlgal@gin.keldysh.ru }}
\title{Современные проблемы интеграции в приложениях компьютерной графики и пути их решения.}
%\thanks{~}

% data storage back-end

\date{}

\begin{document}

\maketitle
\setcounter{page}{3}


\section{Введение} \label{intro}

Компьютерная графика - одна из немногих областей, в которой создание эффективного программного обеспечения не только не потеряло актуальность с ростом вычислительных мощностей за последние 20 лет, но и породило целое направление исследований \cite{hpg}. Объемы данных выросли с мегабайт до гигабайт, а производительность с мега-флопсов до тера-флопсов. Но дело не только в этих цифрах. На совершенно новый уровень вышло взамодействие с пользователем в приложениях создания цифрового контента. 

Перечислим основные требования, предъявляемые к современному ПО данного типа (примерами такого ПО являются широко известные 3D редакторы 3ds Max, Maya, Blender, Houdini, Fabric Engine и др.). 

\paragraph{Современные требования к процессу создания 3D контента}

\begin{enumerate}
	
	\item \underline{Интерактивность} процесса создания 3D контента (концепция WYSIWYG). Удобство работы в интерактивном режиме против неинтерактивного можно сравнить с редактированием документа в MS Word и \LaTeX. Хотя последний имеет преимущества, скорость создания документов в MS Word значительно выше.
	
	\item \underline{Отсутствие ограничений на память}. Вся 3D сцена может не помещаться в оперативную память одного компьютера. При этом процесс редактирования и сопутствующий ему процесс рендеринга (хотя бы в режиме предпросмотра) не должны обладать задержками \cite{outofcore}. 
	
	\item \underline{Изменчивость параметров} и расширяемость обоих систем (и редактора и рендера). Специфичность разных проектов требует работы с различными моделями и алгоритмами компьютерной графики как при создании контента, так и при его отображении (например, больная тема всех редакторов - мех, волосы, частицы). Часто студии визуальных эффектов (VFX) пишут свои плагины как для ПО 3D моделирования, так и для рендера \cite{mrhair}.
	
	\item \underline{Сериализация}, импорт и экспорт. Создание сложной сцены художником происходит не за один день и требует постоянно возвращаться к своим наработкам - необходимо уметь имортировать и экспортировать материалы и геометрических объекты из ранее созданной сцены в новую или обратно. В киноиндустрии почти всегда необходима возможность экспорта/импорта контента между разным ПО \cite{usd}.
	
	\item \underline{Механизмы отладки} и тестирования. При работе над сложным проектом неизбежно выявление ранее неизвестных ошибок, которые проявляются лишь при определёненой последовательности действий в 3D редакторе или рендере. Чтобы находить и исправлять такие ошибки, нужно уметь хранить историю изменений.
	
	\item \underline{Распределённый рендеринг} и явная передача изменений. Изменения производимые в редакторе должны быть видны рендеру не только на одной машине, но и на других  машинах, задействованных в рендеринге. Передача всей сцены целиком по сети в этом случае недопустима. Необходимо уметь \underline{отслеживать и передовать изменения явно}. 
	
\end{enumerate}

\subsection{Специфика области}

Важно отметить, что обозначенная совокупность требований характерна именно для рассматриваемой области - приложений создания цифрового контента (3D и 2D редакторы), поскольку в других типичных приложениях компьютерной графики данные требования встречаются лишь частично. Рассмотрим некоторые примеры.

\begin{enumerate}
	
	\item Упомянутый ранее \underline{MS Word} является, пожалуй, наиболее близким аналогом трёхмерного редактора. В таком ПО необходимо выполнять все перечисленные требования кроме двух: №2 и №7. Редко можно встретить документ, не помещающийся в оперативную память компьютера или требующий вычислительный кластер для каких-то внутренних рассчётных целей. Для 3D редакторов подобная ситуация --- норма.
	
	\item Cовременные \underline{компьютерные игры}, \underline{симуляторы и. т. д.}, с другой стороны, являются чрезвычайно сложными программными системами, объём визуализируемого 3D контента в которых почти всегда не помещается в оперативную память или память GPU. Однако в данном типе приложений отсутствует требование вариативности параметров (№3). Весь отображаемый контент оптимизируется и подготавливается для отображения заранее (зачастую совместными усилиями художника и программиста), а все используемые мат. модели жёстко фиксированы (типы геометрии, материалы, источники, алгоритмы отображения). Изменить какую-либо 3D модель или текстуру в процессе игры невозможно, да и не требуется. В редакторах это, с другой стороны, является основной функциональностью, как и возможность расширять модели материалов и источников произвольными параметрами.

    \item В приложениях, традиционно работающих с \underline{базами данных} выполняются многие из описанных выше требований, однако, как правило, не выполняется требование №1. Такие приложения ориентированы в основном на быстрый поиск семантически значимой информации и на транзакции, обеспечивающие целостность базы при одновременной работе нескольких пользователей. Быстро добавлять информацию в базу данных большими порциями не требуется. Помимо этого, распределённость базы (требование №7) здесь также отличается. Пользователю базы данных, как правило, не нужно уметь получать на своей машине состояние базы целиком (или какой-то значительной её части). Тем более не нужно дублировать состояние базы данных на различных машинах (разве что частично в целях повышения отказоустойчивости). В рендер-системах ситуация обратная. Для того чтобы получить реалистичное изображение рендер-системе необходимо иметь доступ ко всей сцене целиком. Причём все машины, участвующие в распределённом рендеринге должны получить одно и то же состояние сцены. С другой стороны, рендер-системе не нужен механизм транзакций, поскольку экспорт контента из редактора в рендер-систему всегда идёт из единственного приложения (что, правда \textbf{не исключает многопточности} самого процесса экспорта).

\end{enumerate}

\section{Предыдущие работы}


\paragraph{Wavefront OBJ, Filmbox FBX и другие.}

Старейшим способом передачи 3D контента между приложениями являются текстовые или бинарные файлы с \textit{жёстко определённым} форматом. Например, простой но ограниченный формат OBJ \cite{obj_format} или более сложный, но гибкий FBX \cite{adsk_fbx}. Жёстко предопределённые форматы файлов - это палка от двух концах. Чем больше гибкость и функциональность формата, тем выше его сложность. При этом, невозможно заранее предугадать что может понадобиться разработчикам 3D редактора или движка рендера в будущем. Какие будут параметры у материалов, появятся ли новые типы геометрических примитивов, источников - и.т.д.

\paragraph{OpenCollada, Alembic и аналоги.}

OpenCollada является шагом вперёд по сравнению с предыдущими форматами. Основное отличие этой технологии от жёстко заданных форматов хранения сцен в том, что OpenCollada является расширяемой технологией с чётко определённым стандартом хранения объектов (называемым <<COLLADA>>) в XML \cite{opencollada}. Разработчики имеют возможность расширять экспорт и импорт, \textit{добавляя в него свои параметры} благодаря открытому исходному коду и использованию XML описаний - как на стороне 3D редактора, так и на стороне рендер-движка. Более современным форматом c той же идеологией является \textbf{Alembic}, который был представлен в 2011 на конференции SIGGRAPH \cite{sigg2011_abc}. Основная задача формата Alembic - эффективное хранение сложной анимации, полученной различными способами - анимацией по ключевым кадрам, флюидной, тканевой или какой-либо другой симуляцией. При этом поддержка материалов, на сегодняшний день, находится на стадии прототипа \cite{abc}.

\paragraph{Недостатки <<просто файлов>>.}

Ни один из обычных форматов хранения 3D сцены не удовлетворяет и в принципе не может удовлетворять требованиям, предъявляемым к интеграционному слою ПО, описанным в начале статьи, покрывая в лучшем случае 2-3 требования (обычно это изменчивость параметров, сериализация и отладка/тестирование). Чтобы двигаться дальше, необходимы дополнительные средства для обеспечения возможности работы с большими сценами, отслеживания изменений и хранения их истории, эффективного обмена информацией по сети, - и, наконец самое главное, - необходима возможность \textit{быстрой передачи изменений} без перезаписи файла целиком.

\paragraph{Передача через DRAM и DLL плагины.}

Очевидной противоположностью файлов в плане интеграции является передача структур данных через разделяемую или обыкновенную оперативную память. Отдельно стоит упомянуть создание тесно интегрированных DLL плагинов. Такие плагины, как правило, напрямую вызывают виртуальные функции 3D редактора во время своей работы, не импортируя вообще ничего. Например, рендер-плагин может вызывать функцию материала $Shade$, реализованную в редакторе. Обладая всеми преимуществами тесной интеграции, такой подход прежде всего ограничивает производительность, масштабируемость и не гарантирует корректность. Автор рендер-плагина никогда не может быть уверен в том, что функция $Shade$ реализована достаточно эффективно или что она вообще работает (имеет \textit{нужную разработчику рендера} функциональность). Наконец, при таком способе интеграции внутреннее устройство рендер-системы начинает сильно зависеть от редактора \cite{barladian1}, что усложняет отладку и интеграцию в другие 3D редакторы.

Оба описанных выше способа интеграции обладают очевидной простотой и, как правило, высоким быстродействием. Однако, они позволяют выполнить только два требования - интерактивность и изменчивость параметров.

\paragraph{SDB.}

Более подробное рассмотрение некоторых перечисленных нами требований может быть найдено в \cite{sdb}. Полагаясь на собственный опыт, авторы \cite{sdb} заключили что движок рендер-системы должен существовать в форме некоторого API к базе данных и описали требуемую функциональность такой базы данных. Реализация, удовлетворяющая описанным требованиям, однако, не была представлена, оставляя таким образом открытое пространство для будующих исследований.

\paragraph{USD.}

Разработка компании Pixar под названием USD (Universal Scene Description) появилась в открытом доступе как open-source проект в 2016 году \cite{usd}. Данная технология прежде всего предназначена для организации одновременной работы коллективов художников над одним большим проектом (таким как 3D контент для полнометражного анимационного фильма). Эта технология предполагает, что контент создаётся \textit{разными людьми в разных приложениях}. 

USD представлояет из себя набор файлов в формате подобном JSON и некоторый механизм для организации таких файлов через механизм ссылок и композиций. Например, композиция сцены-локации и сцены с анимированным персонажем. Подобная организация сцены обеспечивает эффективную одновременную работу разных людей над её составляющими - слоями, которые затем могут быть скомбинированы в финальный результат и/или переиспользованы в других сценах. Кроме того, иерархия, дополняемая каждым из приложений, используемом в рабочем процессе студии, позволяет проследить историю создания сцены и дает возможность создавать несколько версий всей сцены или её компонентов. Также сылочная система и механизм отложенной загрузки позволяют работать с большими сценами \cite{usd}.

Хотя USD удовлетворяет многим описанными в начале статьи требованиям, использовать эту технологию как прослойку между 3D редактором и рендером в чистом виде затруднительно, поскольку она создавалась не для этого. Основная проблема -  отсутствие возможности быстрого обновления. В USD отсутствуют глобальные идентификаторы объектов и при \textit{каждом изменении} необходимо запускать специальную рекурсивную процедуру обхода дерева файлов, чтобы собрать итоговую иерархию сцены. Кроме того, возможность перезаписать любой файл затрудняет реализацию сетевого рендера, поскольку появляется ситуация, когда файл на одной машине имеет новое состояние, а на другой - старое.

\paragraph{Multiverse.}

Парадоксально, что даже если и рендер и редактор имеют средства для работы с большими сценами, это ещё не означает что они смогут работать вместе, поскольку эти средства, как правило, различны. Разрабатываемая компанией J-Cube система Multiverse \cite{multiverse} в решении этой проблемы идёт немного дальше чем можно было бы предположить. Multiverse не просто предоставляет возможность построить интеграцию если \textbf{и} рендер \textbf{и} редактор обладают поддержкой больших сцен, она позволяет это сделать, - даже если редактор не обладает такой возможностью. Для этого Multiverse берет на себя работу по загрузке и обращению к геометрии на стороне самих приложений создания цифрового контента (т.е. на стороне редактора) и реализует концепцию отложенной загрузки.

Недостаток такого подхода в том, что Multiverse становится слишком тесно интегрирован с редактором, реализуя многие из его функций. Если такая система как Multiverse \textit{уже интегрирована} в редактор, это позволяет использовать её как интеграционный слой с рендером. Но если это не так, объем работы по интеграции Multiverse в редактор может быть в десятки раз больше, чем в любом другого способе интеграции. Система Multiverse на сегодняшний день интегрирована в ПО Maya и Katana, однако отсутствует (и судя по всему даже не планируется) поддержка 3DS Max, Blender и различных инженерных редакторов вроде Rhino 3D, CATIA, Компас 3D. 

\paragraph{Bunsen.}

Разрабатываемая компанией The Foundry система Bunsen \cite{bunsen_gtc} - это облачный редактор, который позволяет импортировать данные из большого числа известных программных продуктов, как используемых в индустрии развлечений (3ds Max и Maya), так и из инженерных (Rhino и Revit). При этом традиционным редакторам отводится роль создания отдельных элементов сцены, а Bunsen берет на себя роль редактора-сборщика. Интерфейс системы Bunsen доступен через браузер и позволяет нескольким пользователей одновременно работать над редактированием сцены с использованием технологий виртуальной реальности.

Bunsen предоставляет пользователю возможности по обработки загруженных данных подходящим для его задач способом при помощи построения \textit{графа обработки загружаемых данных}. Под обработкой в данном случае подразумеваются такие функции как, например, преобразование сплайнов в полигоны, оптимизация полигональной сетки, назначение материалов на объекты, применение уровней детализации (Level-Of-Detail или LOD). Изменения отслеживаются на уровне файлов загружаемых в систему из внешнего ПО. Если пользователь изменил часть сцены, например в программе Revit, он должен экспортировать эту часть заново. Bunsen зафиксирует, что файл изменен и пропустит его через граф обработки. Далее, полученная после прохождения по графу обработки, сцена перенаправляется в выбранное средство визуализации - интерактивный или <<оффлайн>> рендер. 

Многие детали работы данной системы пока неизвестны, так как она находится в процессе активной разработки и недоступна для широкой аудитории \cite{bunsen_gtc}. 

\paragraph{Holodeck.}

Аналогом системы Bunsen можно назвать находящуюся на данный момент в стадии бета-тестирования систему Holodeck от компании Nvidia \cite{holodeck_gtc, holodeck_gtcdc}. Holodeck представляет собой VR среду для совместного дизайна и проектирования, созданную на основе Unreal Engine (так же как и Bunsen) и интегрированную с другими технологиями компании - PhysX, VRWorks, DesignWorks. Для импорта контента используется механизм плагинов - 3d модели, материалы и текстуры экспортируются в специальный формат из ПО 3ds Max или Maya (на момент анонсирования бета-версии), после чего они могут быть импортированы в саму систему Holodeck. При этом при создании контента требуется использование рендер-системы Iray и материалов из библиотеки vMaterials, описанных на языке MDL (material definition language) \cite{holodeck_website}.
Механизм взаимодействия пользователей использует клиент-серверную архитектуру, доступную в Unreal Engine - один из пользователей является хостом, а остальные - клиентами, подключающимися к нему. Действия пользователей по изменению сцены синхронизируется с сервером, а непосредственно рендеринг происходит на машине каждого из пользователей, что обуславливает высокие требования к аппаратному обеспечению (GeForce GTX 1080 Ti, Titan Xp, или Quadro P6000 \cite{holodeck_website}).

Holodeck находится в стадии раннего бета-тестирования, поэтому, как и в случае с Bunsen, подробности о ней пока неизвестны. Тем не менее, одновременное появление таких двух решений от крупных компаний показывает востребованность интеграционных решений, ориентированных на новые возможности и удобство пользователя, о чём мы говорили в начале статьи.

\subsection{Резюме по существующим решениям}

В заключении обзора следует сказать, что все рассмотренные выше методы и технологии призваны в той или иной мере решать проблему <<разных форматов>> или <<разного представления>> данных, которую в некотором смысле можно назвать фундаментальной. 

Фундамент этой проблемы заключается в том, что большинство операции экспорта контента из редактора в рендер-систему долгие и ресурсоёмкие по определению. Поэтому ускорить или как-то упростить эти операции затруднительно. Например, загрузка большой текстуры с диска будет долгой практически при любых возможных оптимизациях, а преобразование сплайновых поверхностей в полигональную сетку требует времени и памяти, и является необходимым этапом экспорта, т.к. большинство рендер-систем не умеют работать со сплайновыми поверхностями напрямую. 

Очевидное решение заключается в том, чтобы не экспортировтаь повторно то, что уже было экспортировано хотя бы раз, а во время длительных процессов экспорта стараться не блокировать вызывающую программу редактора. Чтобы это было возможно, все изменения вносимые в визуализируемую сцену должны быть: \textbf{(1) явными}, \textbf{(2) чётко выделенными} и \textbf{(3) асинхронными} (чтобы редактор мог реагировать на действия пользователя во время экспорта).

\section{Предложенный подход}

Концепция, предлагаемая в данной работе, может быть выражена словосочетанием <<объектная база данных с возможностями системы контроля версий и no-overwrite стратегией внесения изменений>> (рис. \ref{svn1}). Мы полагаем, что между 3D редактором и рендер-движком должен находиться специальный слой ПО (программный интерфейс, API, рис.  \ref{calls}), обеспечивающий максимально прозрачную и простую реализацию требований, пречисленных в начале статьи.

\begin{figure}[h]
	\centering{\includegraphics[width=1.0\linewidth]{svn1.png}}
	\caption{Работа над созданием 3D контента выглядит с точки зрения промежуточного слоя ПО так же, как работа над исходными кодами программных систем.}
	\label{svn1}
\end{figure}

Описание одного <<замороженного>> состояния сцены выглядит как один XML файл с названием <<state\_001.xml>> в некоторой директории <<myscene>> плюс множество бинарных или текстовых файлов в произвольном формате, находящихся в директории <<myscene/data>>. Как правило, в подпапке <<data>> лежат текстуры и геометрия.  

Внутри XML файл подразделяется на \textit{библиотеку данных} и \textit{набор сцен}. Библиотека данных хранит ссылки на все внешние файлы, содержащиеся в папке <<data>> и содержит описание материалов, источников, геометрии и текстур. Непосредственно \textit{сцена} представляет из себя набор копий (или <<инстансов>> от англ instance) геометрических объектов и источников, находящихся в \textit{библиотеке данных}. Инстансы не создаются как физические копии, а описываются как ссылка на геометрический объект из \textit{бибилиотеки данных} + матрица трансформации и список переназначения материалов (если необходимо создавать копии одного объекта с разными материалами).

Сразу обратим внимание на то, что ни XML файл с описанием объектов сцены, ни сами объекты не обязаны в действительно помещаться на диск. В момент передачи из редактора в рендер большинство из них могут находиться в разделяемой памяти ОС (рис. \ref{svn2}). К этому вопросу мы ещё вернёмся в разделе <<виртуальный буфер>>, т.к. он является ключевым в нашей концепции в том, что касается интерактивности. 

\begin{figure}[h]
	\centering{\includegraphics[width=1.0\linewidth]{svn2.png}}
	\caption{Новые или изменённые объекты всегда храняться в кэше на основе разделяемой памяти ОС.}
	\label{svn2}
\end{figure}

\paragraph{Внесение изменений.}

Отличительной чертой предлагаемой технологии является явное отслеживание и явная запись изменений.
Предлагаемый API для каждого типа объекта предоставляет 3 метода - это $Create$, $Open$ и $Close$ (аналогично файловой системе ОС). Метод $Create$ создаёт пустой объект. Пара методов $Open$ и $Close$ позволяют этот объект изменить. 

При вызове метода $Open$ для существующего объекта автоматически создаётся копия его XML параметров, либо пустая копия (зависит от <<режима открытия>> объекта методом $Open$). Пользователь работает с копией параметров, изменяя XML представление в оперативной памяти. Для этого он пользуется функциями из библиотеки pugixml \cite{pugixml} - ручная обработка XML не требуется (хотя и допустима). После окончания работы с объектом пользователь его закрывает методом $Close$. С этого момента новое состояние объекта считается <<готовым к принятию>>, но оно по прежнему хранится как отдельная копия. 

Можно сказать, что если текущее состояние объекта хранится в файле <<state\_001.xml>>, тогда новое состояние объекта хранится в отдельном файле <<change\_001.xml>> (рис. \ref{svn1}), хотя сами файлы при этом не обязаны быть сохранены на диск - они могут находиться в динамическом представлении, используемом библиотекой pugixml.

Пользователь имеет право изменить таким образом любое количество любых объектов (в том числе изменить состояние одного объекта несколько раз). Файл <<change\_001.xml>> будет содержать список всех изменённых объектов с полным описанием их параметров в XML. Но он будет содержать только список изменённых объектов, - остальные объекты не будут в него скопированы.

Наконец, в тот момент, когда необходимо передать некоторое текущее состояние сцены рендеру, пользователь вызывает операцию $Commit$. Эта операция создаёт файл <<state\_002.xml>>, в котором изменённые копии из <<change\_001.xml>> замещают свои оригиналы из <<state\_001.xml>>. Важно пояснить, что во время выполнения операции $Commit$ рендеру будут переданы только новые, изменённые объекты и их XML ноды для того чтобы он обновил состояния изменённых объектов внутри себя. Таким образом, состояние сцены внутри рендера будет соответствовать файлу <<state\_002.xml>>, хотя при этом сам файл <<state\_002.xml>> не анализируется. 

\paragraph{Упорядоченная передача изменений.}

Необходимо отметить, что наш интеграционный слой (API) передаёт в рендер все изменения всегда в одном и том же, строго определённом порядке, - независимо от того в каком порядке они были сделаны пользователем до операции $Commit$. Благодаря этому, непосредственная реализация рендера в значительной мере упрощается, т. к. она может полагаться на известную и заранее предопределённую последовательность вызовов от верхнего уровня (интеграционного слоя) независимо от того, в каком порядке <<дёргаются>> вызовы API в прикладном приложении (упрощённая иллюстрация данного процесса изображена на рис. \ref{calls}). 

\begin{figure}[h]
	\centering{\includegraphics[width=1.0\linewidth]{calls.png}}
	\caption{Пример переупорядочивания вызовов промежуточным слоем. Обратите внимание на 2 момента: (1) объект №1 передаётся в рендер раньше чем объект №2, несмотря на то, что объект №2 был изменён пользоватем первым; (2) До вызова функции $GetImage$ объект №3 не был передан в рендер, т.к. после обновления объекта №3 не была вызвана операция $Commit$. В результате итоговое изображение не будет содержать изменений третьего объекта, но именно это и позволяет нам не блокировать редактор. }
	\label{calls}
\end{figure}

Таким образом, для <<подключения>> конкретной реализации рендера к интеграционному слою, рендеру необходимо определить свою реализацию определенного в API интерфейса. Методы интерфейса, называемого в API <<рендер-драйвером>>, как было уже сказано, имеют четко определенную последовательность вызовов. Список методов включает в себя: загрузку и обновления компонентов библиотеки сцены (меши, материалы, текстуры, источники света, камера), обновление настроек рендера, инстанцирование мешей и источников света, отрисовку сцены, передачу рендером на верхний уровень картинки, а также <<подготовительные>> методы, вызываемые непосредственно перед и после инстанцирования и обновления библиотеки. При этом рендер может определить только те методы, которые отвечают поддерживаемым им возможностям.

Подобный подход к дает определенный вклад в облегчение механизмов отладки и тестирования. Разработчиком рендер-системы могут быть относительно легко реализованы различные отладочные рендер-драйверы, переключение на использование которых не потребует внесения каких-либо изменений в сами сцены.

\paragraph{Виртуальный буфер.}\label{virtualbuffer}

Для работы с большими данными (геометрия и текстуры) предлагается использовать концепцию Append-буфера с бесконечным размером. Для такого буфера существует только одна операция - это $Append$. Буфер позволяет добавлять линейные блоки данных в конец себя. При этом в оперативной памяти храняться лишь предопределённые $N$ мегабайт с конца буфера. Остальная часть буфера хранится на диске в виде файлов-чанков в папке $data$ (рис. \ref{svn2}). 

Важно отметить, что любые новые или изменённые данные \textit{всегда} помещаются в конец буфера. Это происходит из-за принятой нами стратегии отсутствия перезаписи (no-overwrite). Если нужно изменить текстуру, данные которой лежат в файле <<chunk\_036.bin>>, придётся создать новую копию данных для неё - <<chunk\_037.bin>>. В XML описании, при этом поменяется ссылка с 36-ого чанка на 37-ой, но сами чанки будут существовать в буфере <<до конца времён>>. 

Благодаря такой стратегии, мы можем быть уверены в том, что объекты с которыми работает пользователь почти всегда будут находиться в оперативной памяти. Старые состояния геометрии и текстур, (сохранённые как часть буфера на диск [в зелёном прямоугольнике на рис. \ref{svn2}]) либо уже были переданы в рендер раньше, либо уже не нужны (об этом случае ниже). 

\paragraph{Многопоточный экспорт.}

Следует отметить что предложенная нами концепция легко позволяет сделать процесс экспорта контента из 3D редактора многопоточным. Для этого:

\begin{enumerate}
  
  \item при создании объекта методом $Create$ необходимо использовать операцию атомарного инкремента $atomic\_add(pCounter,1)$ чтобы получить идентификатор нового объекта;
  
  \item на каждый объект необходимо завести уникальный мьютекс или спин-блокировку (что в ощем случае не ограничивает производительность системы [ССЫЛКА]);
  
  \item при вызове метода $Open$ мьютекс блокирует доступ к тому-же самому объекту из других потоков;

  \item при вызове метода $Close$ блокировка мьютекса освобождается;

  \item при добавлении объекта в виртуальный буфер для вычисления адреса в буфере необходимо использовать операцию атомарного сложения $atomic\_add(pAddr,sizeof(obj))$;

  \item при выделении памяти для динамических структур данных (например тех, что использует pugixml) необходимо использовать аналогичный предыдущему пункту механизм.

\end{enumerate}

\paragraph{Сеть и стратегия no-overwrite.}

Причина по которой мы выбрали стратию отсутствия перезаписи заключается в необходимости поддержки сетевого рендеринга. Если разрешить перезапись любого файла, тогда существует возможность, при которой на одной машине этот файл будет иметь старое состояние, а на другой - новое. Стратия отсутствия перезаписи гарантирует, что такого не может произойти никогда. Если файл с текстурой есть, то он существует только в единственно возможном состоянии. Если же его по какой-то причине нет, это означает что либо он ещё не был передан на данную машину (и тогда рендер ожидает передачи этого файла), либо уже не будет передан, поскольку в системе существует новое состояние для той же самой текстуры. В последнем случае рендер должен перейти к следующему состоянию системы и ожидать нужные этому состоянию файлы текстур и геометрии. 

\section{Выводы и результаты}

Разработанное API опробовано на свободно распространяемой рендер-системе Hydra Renderer, интегрированной в настоящий момент в два различных 3D редактора - 3ds Max и Fabric Engine. Прелагаемая концепция позвояет выполнить основные требования, о которых говорилось в начале статьи, хотя имеются и некоторые недостатки.

Среди недостатков предложенного подхода можно отметить явный перерасход дисковой памяти, вызванный необходимостью хранить полные копии различных версий одного и того же объекта. Аналогично, эффективная передача таких копий по сети хотя и возможна (например при помощи стратегии Copy On Write и разбиения большого буфера на страницы \cite{cow}), но требует отдельной проработки, и в данной работе не рассматривается.

Следует отметить, что в предложенном подходе <<откат>> к некоторому предыдущему состоянию системы равносилен загрузке этого состояния <<с нуля>>, - полный анализ некоторого файла <<state\_N.xml>> и загрузка большинства данных для геометрии и текстур с диска. Наконец, в данной работе мы не рассматривали операцию <<merge>>, которая может потребоваться при одновременной работе нескольких людей в одном окружении, оставив её для будущего исследования.


\section{ Благодарности }

Работа поддержана грантами РФФИ 16-31-60048 ``мол\_а\_дк'', 16-01-00552.


\begin{thebibliography}{99}

\small

\bibitem{hpg}
{\em High Performance Graphics.} //  The international forum for performance-oriented graphics systems research. 2017. 

\bibitem{outofcore} Ingo Wald Andreas Dietrich and Phlipp Slusallek.
An Interactive Out-of-Core Rendering Framework for Visualizing Massively Complex Models. // Eurographics Symposium on Rendering (2004).

\bibitem{mrhair} Marsel Khadiyev. Ornatrix mentalRay shaders. // third party plugin for mental ray for hairs. {URL = https://ephere.com/plugins/autodesk/max/ornatrix/docs/1286.html} -- 

\bibitem{vr_app2}
{Danny Rollings}
{\em The Future of 3D Modelling} // https://garagefarm.net/en/the-future-of-3d-modelling/   

\bibitem{obj_format} Wavefront obj file format.

\bibitem{adsk_fbx}
{\em Autodesk FBX format} 
{URL = https://www.autodesk.com/products/fbx/overview}  

\bibitem{opencollada}
{\em OpenCollada} A project to join efforts using COLLADA within various DCC tools. 
{URL = http://www.opencollada.org}  

\bibitem{barladian1}
{Барладян Б.Х., Волобой А.Г., Шапиро Л.З.}
{\em Построение реалистичных изображений в системах автоматизированного проектирования} // Труды 23-й Международной Конференции по Компьютерной Графике и Зрению, Институт автоматики и процессов управления ДВО РАН, 16-20 сентября 2013 года, с.148-151. URL = http://multi-verse.io/  

\bibitem{sdb}
Дерябин Н.Б., Денисов Е.Ю. 
{\em Объектно-ориентированная инфраструктура систем компьютерной графики } // Graphi'Con 2007,  Россия, МГУ июнь 23-27, 2007, с. 289-292. 

\bibitem{bunsen_gtc}
{Adam Glick, George Matos}
{\em Scalable Enterprise Visualization, GTC (GPU Technology Conference) 2017, March 26-29, Silicon Valley, presentation ID S7474} 	

\bibitem{holodeck_gtc}
{Jensen Huang}
{\em Keynote, GTC (GPU Technology Conference) 2017, March 26-29, Silicon Valley, presentation ID S7820} 

\bibitem{holodeck_gtcdc}
{David Weinstein}
{\em Nvidia Holodeck, GTC (GPU Technology Conference) DC 2017, November 1-2, Washington, D.C.} 


\bibitem{holodeck_website}
{\em Nvidia Holodeck} 
{URL = https://www.nvidia.com/en-us/design-visualization/technologies/holodeck}  


\bibitem{sigg2011_abc}
{\em Siggraph 2011, Alembic talk}
{URL = http://www.siggraph.org/s2011/content/practical-integration-alembic} 

\bibitem{abc}
{\em Alembic}
{URL = http://www.alembic.io/}  

\bibitem{usd}
{\em Pixar USD}
{URL = https://graphics.pixar.com/usd/docs/index.html}  

\bibitem{multiverse}
{\em Multiverse}
{URL = http://multi-verse.io/}           
     

\bibitem{pugixml} Arseny Kapoulkine. A light-weight C++ XML processing library. {URL = http://pugixml.org}        

\bibitem{cow} Bovet, Daniel Pierre; Cesati, Marco. Understanding the Linux Kernel. // O'Reilly Media, Inc. p. 295. ISBN 9780596002138. 2002.    


\end{thebibliography}

\label{lastpage}
\end{document}






